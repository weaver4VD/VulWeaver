agents:
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n   \
    \  ExceptionInfo *exception)\n{\n  char\n    page_geometry[MagickPathExtent];\n\
    \n  Image\n    *image;\n\n  MagickBooleanType\n    logging;\n\n  volatile int\n\
    \    first_mng_object,\n    object_id,\n    term_chunk_found,\n    skip_to_iend;\n\
    \n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n    status;\n\
    \n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n    fb,\n    previous_fb;\n\
    \n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n    mng_background_color;\n#endif\n\
    \n  register unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n\
    \    count;\n\n  ssize_t\n    loop_level;\n\n  volatile short\n    skipping_loop;\n\
    \n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n    mandatory_back=0;\n#endif\n\
    \n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n    mng_background_object=0,\n\
    #endif\n    mng_type=0;   /* 0: PNG or JNG; 1: MNG; 2: MNG-LC; 3: MNG-VLC */\n\
    \n  size_t\n    default_frame_timeout,\n    frame_timeout,\n#if defined(MNG_INSERT_LAYERS)\n\
    \    image_height,\n    image_width,\n#endif\n    length;\n\n  /* These delays\
    \ are all measured in image ticks_per_second,\n   * not in MNG ticks_per_second\n\
    \   */\n  volatile size_t\n    default_frame_delay,\n    final_delay,\n    final_image_delay,\n\
    \    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n    insert_layers,\n#endif\n\
    \    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n    subframe_width=0;\n\
    \n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n  previous_fb.right=0;\n\
    \  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n  default_fb.right=0;\n\
    \n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneMNGImage()\"\
    );\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"MNG\"\
    ) == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n      /*\
    \ Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned char\
    \ *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\n\"\
    ,8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n\
    \      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t)\
    \ PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n\
    \      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n\
    \  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n\
    \  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n\
    #endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n\
    \  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n\
    \  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n\
    \  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n\
    #endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n\
    #endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n\
    \  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n\
    \          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void)\
    \ ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n\
    \        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if\
    \ (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n          \
    \ type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n\
    \          {\n            status=MagickFalse;\n            break;\n          }\n\
    \n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n\
    \        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n\
    \              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\"\
    );\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n       \
    \      MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned\
    \ char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n      \
    \        int\n                c;\n\n              c=ReadBlobByte(image);\n   \
    \           if (c == EOF)\n                break;\n              chunk[i]=(unsigned\
    \ char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void)\
    \ ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n\
    \        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\
    \n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4)\
    \ == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n        \
    \    if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\
    \n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skip to IEND.\");\n\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length\
    \ != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n \
    \             }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1]\
    \ << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n   \
    \         if (logging != MagickFalse)\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width:\
    \ %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n \
    \             }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t)\
    \ mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n     \
    \         default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n\
    \                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n\
    \            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t)\
    \ mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n          \
    \  if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2;\
    \ /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n\
    \              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n     \
    \       if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n\
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \      {\n                /* Allocate next image structure.  */\n            \
    \    AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                  return((Image *) NULL);\n\n          \
    \      image=SyncNextImageInList(image);\n                mng_info->image=image;\n\
    \              }\n\n            if ((mng_info->mng_width > 65535L) ||\n      \
    \          (mng_info->mng_height > 65535L))\n              {\n               \
    \ chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"\
    WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n\
    \              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n   \
    \           mng_info->mng_height);\n\n            mng_info->frame.left=0;\n  \
    \          mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n\
    \            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n        \
    \    mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for\
    \ (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n  \
    \        {\n            int\n              repeat=0;\n\n            if (length\
    \ != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n        \
    \      {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n   \
    \             mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n          \
    \      if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\
    \n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n\
    \              }\n\n            if (logging != MagickFalse)\n              {\n\
    \                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \
    \           \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n      \
    \            repeat,(double) final_delay, (double) image->iterations);\n     \
    \         }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n\
    \          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (length < 2)\n        \
    \      {\n                if (chunk)\n                  chunk=(unsigned char *)\
    \ RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\
    \n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n\
    \              {\n                /*\n                  Instead of using a warning\
    \ we should allocate a larger\n                  MngInfo structure and continue.\n\
    \                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n\
    \                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if\
    \ (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n\
    \                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                  (void) ThrowMagickException(exception,\n                  \
    \  GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a\
    \ frozen MNG object\",\"`%s'\",\n                    image->filename);\n     \
    \             continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\
    \n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\
    \n            /*\n              Extract object offset info.\n            */\n\
    \            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t)\
    \ ((p[4] << 24) |\n                    (p[5] << 16) | (p[6] << 8) | p[7]);\n\n\
    \                mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n      \
    \              (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                if (logging\
    \ != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n          \
    \            object_id,(double) mng_info->x_off[object_id],\n                \
    \      object_id,(double) mng_info->y_off[object_id]);\n                  }\n\
    \              }\n\n            /*\n              Extract object clipping info.\n\
    \            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n\
    \                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n\
    \          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n        \
    \    if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\
    \n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned\
    \ short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\
    \n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n     \
    \     {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n       \
    \       mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\
    \n            if (mandatory_back && length > 5)\n              {\n           \
    \     mng_background_color.red=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n\
    \                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\
    \n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n\
    \              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n \
    \             mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n     \
    \       /* Read global PLTE.  */\n\n            if (length && (length < 769))\n\
    \              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n\
    \                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n\
    \                    sizeof(*mng_info->global_plte));\n\n                for (i=0;\
    \ i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n\
    \                  mng_info->global_plte[i].green=p[3*i+1];\n                \
    \  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n            \
    \    mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n\
    #ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n         \
    \     mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n\
    \              mng_info->global_plte[i].blue=i;\n            }\n\n           \
    \ if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n\
    \            else\n              mng_info->global_plte_length=0;\n\n         \
    \   chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n     \
    \       /* read global tRNS */\n\n            if (length > 0 && length < 257)\n\
    \              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\
    \n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n\
    #endif\n            mng_info->global_trns_length=(unsigned int) length;\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n       \
    \     if (length == 4)\n              {\n                ssize_t\n           \
    \       igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float)\
    \ igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n \
    \             }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n  \
    \        {\n            /* Read global cHRM */\n\n            if (length == 32)\n\
    \              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n\
    \                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n\
    \                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n\
    \                mng_info->global_chrm.red_primary.y=0.00001*\n              \
    \    mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n\
    \                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n\
    \                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n\
    \                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n\
    \                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n\
    \              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n  \
    \        {\n            /*\n              Read global sRGB.\n            */\n\
    \            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n\
    \                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n  \
    \              mng_info->have_global_srgb=MagickTrue;\n              }\n     \
    \       else\n              mng_info->have_global_srgb=MagickFalse;\n\n      \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n     \
    \       /* To do: */\n\n            /*\n              Read global iCCP.\n    \
    \        */\n            if (length != 0)\n              chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n\
    \        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type\
    \ == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if ((mng_info->framing_mode\
    \ == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\
    \n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n\
    \            fb=default_fb;\n\n            if (length != 0)\n              if\
    \ (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n        \
    \    if (length > 6)\n              {\n                /* Note the delay and frame\
    \ clipping boundaries.  */\n\n                p++; /* framing mode */\n\n    \
    \            while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;\
    \  /* frame name */\n\n                p++;  /* frame name terminator */\n\n \
    \               if ((p-chunk) < (ssize_t) (length-4))\n                  {\n \
    \                   int\n                      change_delay,\n               \
    \       change_timeout,\n                      change_clipping;\n\n          \
    \          change_delay=(*p++);\n                    change_timeout=(*p++);\n\
    \                    change_clipping=(*p++);\n                    p++; /* change_sync\
    \ */\n\n                    if (change_delay)\n                      {\n     \
    \                   frame_delay=1UL*image->ticks_per_second*\n               \
    \           mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n\
    \                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\
    \n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\
    \n                        p+=4;\n\n                        if (logging != MagickFalse)\n\
    \                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                            \"    Framing_delay=%.20g\",(double) frame_delay);\n\
    \                      }\n\n                    if (change_timeout)\n        \
    \              {\n                        frame_timeout=1UL*image->ticks_per_second*\n\
    \                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\
    \n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\
    \n                        if (change_timeout == 2)\n                         \
    \ default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n  \
    \                      if (logging != MagickFalse)\n                         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \
    \      \"    Framing_timeout=%.20g\",(double) frame_timeout);\n              \
    \        }\n\n                    if (change_clipping)\n                     \
    \ {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n\
    \                        p+=17;\n                        previous_fb=fb;\n\n \
    \                       if (logging != MagickFalse)\n                        \
    \  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \
    \       \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n               \
    \             (double) fb.left,(double) fb.right,(double) fb.top,\n          \
    \                  (double) fb.bottom);\n\n                        if (change_clipping\
    \ == 2)\n                          default_fb=fb;\n                      }\n \
    \                 }\n              }\n            mng_info->clip=fb;\n       \
    \     mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t)\
    \ (mng_info->clip.right\n               -mng_info->clip.left);\n\n           \
    \ subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n\
    \            /*\n              Insert a background layer behind the frame if framing_mode\
    \ is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n\
    \                subframe_width,(double) subframe_height);\n\n            if (insert_layers\
    \ && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n\
    \              {\n                /* Allocate next image structure.  */\n    \
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \          {\n                    AcquireNextImage(image_info,image,exception);\n\
    \n                    if (GetNextImageInList(image) == (Image *) NULL)\n     \
    \                 return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n\
    \                  }\n\n                mng_info->image=image;\n\n           \
    \     if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n\
    \                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                image->columns=subframe_width;\n                image->rows=subframe_height;\n\
    \                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n\
    \                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n\
    \                image->background_color=mng_background_color;\n             \
    \   image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n\n        \
    \        if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                    (double) mng_info->clip.left,\n                    (double)\
    \ mng_info->clip.right,\n                    (double) mng_info->clip.top,\n  \
    \                  (double) mng_info->clip.bottom);\n              }\n#endif\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n   \
    \       {\n            unsigned int\n              first_object,\n           \
    \   last_object;\n\n            /*\n              Read CLIP.\n            */\n\
    \            if (length > 3)\n              {\n                first_object=(p[0]\
    \ << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n           \
    \     p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object;\
    \ i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n\
    \                    {\n                      MngBox\n                       \
    \ box;\n\n                      box=mng_info->object_clip[i];\n              \
    \        if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n\
    \                           mng_read_box(box,(char) p[0],&p[1]);\n           \
    \         }\n                }\n\n              }\n            chunk=(unsigned\
    \ char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1;\
    \ i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n        \
    \        {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n\
    \                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n               \
    \     mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n     \
    \       if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) ==\
    \ 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC\
    \ or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n\
    \              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n      \
    \            MngInfoDiscardObject(mng_info,i);\n              }\n\n          \
    \  else\n              {\n                register ssize_t\n                 \
    \ j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n              \
    \  {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n\
    \                }\n              }\n\n            if (length != 0)\n        \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n     \
    \       size_t\n              first_object,\n              last_object;\n\n  \
    \          /* read MOVE */\n\n            if (length > 3)\n            {\n   \
    \           first_object=(p[0] << 8) | p[1];\n              last_object=(p[2]\
    \ << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object;\
    \ i <= (ssize_t) last_object; i++)\n              {\n                if ((i <\
    \ 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n             \
    \   if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk)\
    \ < (ssize_t) (length-8))\n                  {\n                    MngPair\n\
    \                      new_pair;\n\n                    MngPair\n            \
    \          old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n \
    \                   old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int)\
    \ p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n         \
    \           mng_info->y_off[i]=new_pair.b;\n                  }\n            \
    \  }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) ==\
    \ 0)\n          {\n            ssize_t loop_iters=1;\n            if (length >\
    \ 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;\
    \  /* mark loop active */\n\n                /* Record starting point.  */\n \
    \               loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging\
    \ != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  LOOP level %.20g has %.20g iterations \",\n         \
    \           (double) loop_level, (double) loop_iters);\n\n                if (loop_iters\
    \ == 0)\n                  skipping_loop=loop_level;\n\n                else\n\
    \                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n\
    \                    mng_info->loop_count[loop_level]=loop_iters;\n          \
    \        }\n\n                mng_info->loop_iteration[loop_level]=0;\n      \
    \        }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) ==\
    \ 0)\n          {\n            if (length > 0)\n              {\n            \
    \    loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n        \
    \          {\n                    if (skipping_loop == loop_level)\n         \
    \             {\n                        /*\n                          Found end\
    \ of zero-iteration loop.\n                        */\n                      \
    \  skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n\
    \                      }\n                  }\n\n                else\n      \
    \            {\n                    if (mng_info->loop_active[loop_level] == 1)\n\
    \                      {\n                        mng_info->loop_count[loop_level]--;\n\
    \                        mng_info->loop_iteration[loop_level]++;\n\n         \
    \               if (logging != MagickFalse)\n                          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \" \
    \ ENDL: LOOP level %.20g has %.20g remaining iters\",\n                      \
    \      (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\
    \n                        if (mng_info->loop_count[loop_level] != 0)\n       \
    \                   {\n                            offset=\n                 \
    \             SeekBlob(image,mng_info->loop_jump[loop_level],\n              \
    \                SEEK_SET);\n\n                            if (offset < 0)\n \
    \                             {\n                                chunk=(unsigned\
    \ char *) RelinquishMagickMemory(\n                                  chunk);\n\
    \                                ThrowReaderException(CorruptImageError,\n   \
    \                               \"ImproperImageHeader\");\n                  \
    \            }\n                          }\n\n                        else\n\
    \                          {\n                            short\n            \
    \                  last_level;\n\n                            /*\n           \
    \                   Finished loop.\n                            */\n         \
    \                   mng_info->loop_active[loop_level]=0;\n                   \
    \         last_level=(-1);\n                            for (i=0; i < loop_level;\
    \ i++)\n                              if (mng_info->loop_active[i] == 1)\n   \
    \                             last_level=(short) i;\n                        \
    \    loop_level=last_level;\n                          }\n                   \
    \   }\n                  }\n              }\n\n            chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n  \
    \      if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->clon_warning++;\n      \
    \    }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n           \
    \ png_uint_16\n              magn_first,\n              magn_last,\n         \
    \     magn_mb,\n              magn_ml,\n              magn_mr,\n             \
    \ magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n\
    \              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0]\
    \ << 8) | p[1];\n\n            else\n              magn_first=0;\n\n         \
    \   if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n         \
    \   else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n  \
    \          if (magn_first || magn_last)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"MAGN\
    \ is not implemented yet for nonzero objects\",\n                     \"`%s'\"\
    ,image->filename);\n\n                   mng_info->magn_warning++;\n         \
    \       }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\
    \n            else\n              magn_methx=0;\n\n            if (length > 6)\n\
    \              magn_mx=(p[5] << 8) | p[6];\n\n            else\n             \
    \ magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n  \
    \          if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n    \
    \        else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n\
    \              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9]\
    \ << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n     \
    \       if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length\
    \ > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n   \
    \           magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\
    \n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n\
    \            else\n              magn_mt=magn_my;\n\n            if (magn_mt ==\
    \ 0)\n              magn_mt=1;\n\n            if (length > 16)\n             \
    \ magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\
    \n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length\
    \ > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\
    \n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"Unknown\
    \ MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\
    \n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n\
    \          /* Magnify existing objects in the range magn_first to magn_last */\n\
    #endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n\
    \                /* Save the magnification factors for object 0 */\n         \
    \       mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n\
    \                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n\
    \                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n\
    \                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n\
    \              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n \
    \         {\n            if (mng_info->past_warning == 0)\n              (void)\
    \ ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"\
    PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n\
    \            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4)\
    \ == 0)\n          {\n            if (mng_info->show_warning == 0)\n         \
    \     (void) ThrowMagickException(exception,GetMagickModule(),\n             \
    \   CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\
    \n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4)\
    \ == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\
    \n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n\
    \                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n\
    \                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n\
    \                mng_info->have_global_sbit=MagickTrue;\n             }\n    \
    \      }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n           \
    \ if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n\
    \                mng_info->have_global_phys=MagickTrue;\n              }\n\n \
    \           else\n              mng_info->have_global_phys=MagickFalse;\n    \
    \      }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n           \
    \ if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\
    \n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->basi_warning++;\n#ifdef\
    \ MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] << 24) | (p[1] <<\
    \ 16) |\n               (p[2] << 8) | p[3]);\n            basi_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n               (p[6] << 8) | p[7]);\n      \
    \      basi_color_type=p[8];\n            basi_compression_method=p[9];\n    \
    \        basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n \
    \           if (length > 11)\n              basi_red=(p[12] << 8) & p[13];\n\n\
    \            else\n              basi_red=0;\n\n            if (length > 13)\n\
    \              basi_green=(p[14] << 8) & p[15];\n\n            else\n        \
    \      basi_green=0;\n\n            if (length > 15)\n              basi_blue=(p[16]\
    \ << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n         \
    \   if (length > 17)\n              basi_alpha=(p[18] << 8) & p[19];\n\n     \
    \       else\n              {\n                if (basi_sample_depth == 16)\n\
    \                  basi_alpha=65535L;\n                else\n                \
    \  basi_alpha=255;\n              }\n\n            if (length > 19)\n        \
    \      basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\
    \n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if\
    \ defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n   \
    \         )\n          {\n            /* Not an IHDR or JHDR chunk */\n      \
    \      if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n/* Process IHDR */\n        if (logging\
    \ != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\
    \n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\
    \n        if (mng_info->invisible[object_id])\n          {\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length\
    \ < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\
    \          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t)\
    \ mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n        /*\n          Insert a transparent background layer behind the entire\
    \ animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n\
    \        if (insert_layers && mng_type && first_mng_object)\n          {\n   \
    \         if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n     \
    \           (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right\
    \ < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height)\
    \ ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n\
    \              {\n                if (GetAuthenticPixelQueue(image) != (Quantum\
    \ *) NULL)\n                  {\n                    /*\n                    \
    \  Allocate next image structure.\n                    */\n                  \
    \  AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                      return(DestroyImageList(image));\n\
    \n                    image=SyncNextImageInList(image);\n                  }\n\
    \                mng_info->image=image;\n\n                if (term_chunk_found)\n\
    \                  {\n                    image->start_loop=MagickTrue;\n    \
    \                image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                /* Make a background rectangle.  */\n\n                image->delay=0;\n\
    \                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n\
    \                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        image->background_color=mng_background_color;\n                (void)\
    \ SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"  Inserted transparent background layer, W=%.20g, H=%.20g\"\
    ,\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n\
    \              }\n          }\n        /*\n          Insert a background layer\
    \ behind the upcoming image if\n          framing_mode is 3, and we haven't already\
    \ inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode\
    \ == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity\
    \ == 0 ||\n                (simplicity & 0x08)))\n          {\n            if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n       \
    \       /*\n                Allocate next image structure.\n              */\n\
    \              AcquireNextImage(image_info,image,exception);\n\n             \
    \ if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\
    \n              image=SyncNextImageInList(image);\n            }\n\n         \
    \   mng_info->image=image;\n\n            if (term_chunk_found)\n            \
    \  {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n\
    \                term_chunk_found=MagickFalse;\n              }\n\n          \
    \  else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n\
    \            image->columns=subframe_width;\n            image->rows=subframe_height;\n\
    \            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n\
    \            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n\
    \            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n\
    \            (void) SetImageBackgroundColor(image,exception);\n\n            if\
    \ (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n\
    \                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n\
    \          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\
    \n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n\
    \            /*\n              Allocate next image structure.\n            */\n\
    \            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n              return(DestroyImageList(image));\n\n     \
    \       image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\
    \n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n\
    \            term_chunk_found=MagickFalse;\n          }\n\n        else\n    \
    \        image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode\
    \ == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n\
    \            frame_delay=default_frame_delay;\n          }\n\n        else\n \
    \         image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n\
    \        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n\
    \        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\
    \n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's\
    \ length field.\n        */\n\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking\
    \ back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\
    \n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if\
    \ (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n\
    \    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n\
    \      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n\
    \    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\
    \n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n\
    \          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"\
    exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\
    \n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n\
    \        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\
    \n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if\
    \ (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n\
    \               magnified_height,\n               magnified_width;\n\n       \
    \     if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx\
    \ == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\
    \n                if (image->columns > 1)\n                   magnified_width\
    \ += mng_info->magn_mr;\n\n                if (image->columns > 2)\n         \
    \          magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n\
    \              }\n\n            else\n              {\n                magnified_width=(png_uint_32)\
    \ image->columns;\n\n                if (image->columns > 1)\n               \
    \    magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns\
    \ > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n       \
    \         if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n\
    \                      ((image->columns-3)*(mng_info->magn_mx-1));\n         \
    \     }\n\n            if (mng_info->magn_methy == 1)\n              {\n     \
    \           magnified_height=mng_info->magn_mt;\n\n                if (image->rows\
    \ > 1)\n                   magnified_height += mng_info->magn_mb;\n\n        \
    \        if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n\
    \                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\
    \n            else\n              {\n                magnified_height=(png_uint_32)\
    \ image->rows;\n\n                if (image->rows > 1)\n                   magnified_height\
    \ += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n          \
    \         magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows\
    \ > 3)\n                   magnified_height += (png_uint_32)\n               \
    \       ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n        \
    \    if (magnified_height > image->rows ||\n                magnified_width >\
    \ image->columns)\n              {\n                Image\n                  *large_image;\n\
    \n                int\n                  yy;\n\n                Quantum\n    \
    \              *next,\n                  *prev;\n\n                png_uint_16\n\
    \                  magn_methx,\n                  magn_methy;\n\n            \
    \    ssize_t\n                  m,\n                  y;\n\n                register\
    \ Quantum\n                  *n,\n                  *q;\n\n                register\
    \ ssize_t\n                  x;\n\n                /* Allocate next image structure.\
    \  */\n\n                if (logging != MagickFalse)\n                  (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate\
    \ magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\
    \n                if (GetNextImageInList(image) == (Image *) NULL)\n         \
    \         return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\
    \n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\
    \n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\
    \n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n           \
    \     if (magn_methx != 1 || magn_methy != 1)\n                  {\n         \
    \         /*\n                     Scale pixels to unsigned shorts to prevent\n\
    \                     overflow of intermediate values of interpolations\n    \
    \              */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                          exception);\n\n                       for (x=(ssize_t)\
    \ image->columns-1; x >= 0; x--)\n                       {\n                 \
    \         SetPixelRed(image,ScaleQuantumToShort(\n                           \
    \ GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n\
    \                            GetPixelGreen(image,q)),q);\n                   \
    \       SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n\
    \                          SetPixelAlpha(image,ScaleQuantumToShort(\n        \
    \                    GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n\
    \                       }\n\n                       if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                         break;\n                     }\n \
    \                 }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait\
    \ != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\
    \n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n\
    \                    (void) SetImageBackgroundColor(large_image,exception);\n\n\
    \                    if (magn_methx == 4)\n                      magn_methx=2;\n\
    \n                    if (magn_methx == 5)\n                      magn_methx=3;\n\
    \n                    if (magn_methy == 4)\n                      magn_methy=2;\n\
    \n                    if (magn_methy == 5)\n                      magn_methy=3;\n\
    \                  }\n\n                /* magnify the rows into the right side\
    \ of the large image */\n\n                if (logging != MagickFalse)\n     \
    \             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \
    \          \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n\
    \                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n     \
    \           length=(size_t) GetPixelChannels(image)*image->columns;\n        \
    \        next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n      \
    \          prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n  \
    \              if ((prev == (Quantum *) NULL) ||\n                    (next ==\
    \ (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n\
    \                     ThrowReaderException(ResourceLimitError,\n             \
    \          \"MemoryAllocationFailed\");\n                  }\n\n             \
    \   n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n            \
    \    (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y <\
    \ (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n\
    \                    m=(ssize_t) mng_info->magn_mt;\n\n                  else\
    \ if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t)\
    \ mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t)\
    \ image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n     \
    \             else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n     \
    \               m=1;\n\n                  else\n                    m=(ssize_t)\
    \ mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n\
    \                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n\
    \                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n\
    \                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n\
    \                    }\n\n                  for (i=0; i < m; i++, yy++)\n    \
    \              {\n                    register Quantum\n                     \
    \ *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n\
    \                    pixels=prev;\n                    n=next;\n             \
    \       q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n        \
    \              1,exception);\n                    q+=(large_image->columns-image->columns)*\n\
    \                      GetPixelChannels(large_image);\n\n                    for\
    \ (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n       \
    \               /* To do: get color as function of indexes[x] */\n           \
    \           /*\n                      if (image->storage_class == PseudoClass)\n\
    \                        {\n                        }\n                      */\n\
    \n                      if (magn_methy <= 1)\n                        {\n    \
    \                      /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(large_image,GetPixelGreen(image,\n  \
    \                           pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                             pixels),q);\n                        }\n\n     \
    \                 else if (magn_methy == 2 || magn_methy == 4)\n             \
    \           {\n                          if (i == 0)\n                       \
    \     {\n                              SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n\
    \                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                 pixels),q);\n                            }\n\
    \n                          else\n                            {\n            \
    \                  /* Interpolate */\n                              SetPixelRed(large_image,((QM)\
    \ (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n \
    \                                -GetPixelRed(image,pixels)+m))/\n           \
    \                      ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n\
    \                              SetPixelGreen(large_image,((QM) (((ssize_t)\n \
    \                                (2*i*(GetPixelGreen(image,n)\n              \
    \                   -GetPixelGreen(image,pixels)+m))/\n                      \
    \           ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n\
    \                              SetPixelBlue(large_image,((QM) (((ssize_t)\n  \
    \                               (2*i*(GetPixelBlue(image,n)\n                \
    \                 -GetPixelBlue(image,pixels)+m))/\n                         \
    \        ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\
    \n                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n\
    \                                    (2*i*(GetPixelAlpha(image,n)\n          \
    \                          -GetPixelAlpha(image,pixels)+m))\n                \
    \                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n\
    \                            }\n\n                          if (magn_methy ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                        SetPixelAlpha(large_image,GetPixelAlpha(image,\n    \
    \                                pixels),q);\n                              else\n\
    \                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                    n),q);\n                            }\n \
    \                       }\n\n                      else /* if (magn_methy == 3\
    \ || magn_methy == 5) */\n                        {\n                        \
    \  /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n\
    \                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelGreen(large_image,GetPixelGreen(image,\n                          \
    \          pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelAlpha(large_image,GetPixelAlpha(image,\n                          \
    \          pixels),q);\n                          }\n\n                      \
    \    else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n\
    \                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n\
    \                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n\
    \                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n\
    \                                    q);\n                          }\n\n    \
    \                      if (magn_methy == 5)\n                            {\n \
    \                             SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n\
    \                                 (GetPixelAlpha(image,n)\n                  \
    \               -GetPixelAlpha(image,pixels))\n                              \
    \   +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n                        }\n                  \
    \    n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n\
    \                      pixels+=GetPixelChannels(image);\n                    }\
    \ /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception)\
    \ == 0)\n                      break;\n\n                  } /* i */\n       \
    \         } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n\
    \                next=(Quantum *) RelinquishMagickMemory(next);\n\n          \
    \      length=image->columns;\n\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\
    \n                image=large_image;\n\n                mng_info->image=image;\n\
    \n                /* magnify the columns */\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Magnify the columns to %.20g\",\n                    (double)\
    \ image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                {\n                  register Quantum\n                    *pixels;\n\
    \n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n\
    \                  n=pixels+GetPixelChannels(image);\n\n                  for\
    \ (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns;\
    \ x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel()\
    \ */\n\n                    if (x == (ssize_t) (image->columns-length))\n    \
    \                  m=(ssize_t) mng_info->magn_ml;\n\n                    else\
    \ if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                   \
    \   m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ <= 1 &&\n                        x == (ssize_t) image->columns-1)\n        \
    \              m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n    \
    \                else\n                      m=(ssize_t) mng_info->magn_mx;\n\n\
    \                    for (i=0; i < m; i++)\n                    {\n          \
    \            if (magn_methx <= 1)\n                        {\n               \
    \           /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                        }\n\n                      else if (magn_methx == 2 ||\
    \ magn_methx == 4)\n                        {\n                          if (i\
    \ == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                          }\n\n                          /* To do: Rewrite using\
    \ Get/Set***PixelChannel() */\n                          else\n              \
    \              {\n                              /* Interpolate */\n          \
    \                    SetPixelRed(image,(QM) ((2*i*(\n                        \
    \         GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n\
    \                                 /((ssize_t) (m*2))+\n                      \
    \           GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM)\
    \ ((2*i*(\n                                 GetPixelGreen(image,n)\n         \
    \                        -GetPixelGreen(image,pixels))+m)\n                  \
    \               /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\
    \n                              SetPixelBlue(image,(QM) ((2*i*(\n            \
    \                     GetPixelBlue(image,n)\n                                \
    \ -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t)\
    \ (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n\
    \                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(image,(QM) ((2*i*(\n         \
    \                          GetPixelAlpha(image,n)\n                          \
    \         -GetPixelAlpha(image,pixels))+m)\n                                 \
    \  /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n\n                          if (magn_methx ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                     {\n                                 SetPixelAlpha(image,\n\
    \                                   GetPixelAlpha(image,pixels)+0,q);\n      \
    \                        }\n                              else\n             \
    \                 {\n                                 SetPixelAlpha(image,\n \
    \                                  GetPixelAlpha(image,n)+0,q);\n            \
    \                  }\n                            }\n                        }\n\
    \n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n \
    \                       {\n                          /* Replicate nearest */\n\
    \                          if (i <= ((m+1) << 1))\n                          {\n\
    \                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                             SetPixelGreen(image,GetPixelGreen(image,\n     \
    \                            pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                             SetPixelAlpha(image,GetPixelAlpha(image,\n     \
    \                            pixels),q);\n                          }\n\n    \
    \                      else\n                          {\n                   \
    \          SetPixelRed(image,GetPixelRed(image,n),q);\n                      \
    \       SetPixelGreen(image,GetPixelGreen(image,n),q);\n                     \
    \        SetPixelBlue(image,GetPixelBlue(image,n),q);\n                      \
    \       SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                     \
    \     }\n\n                          if (magn_methx == 5)\n                  \
    \          {\n                              /* Interpolate */\n              \
    \                SetPixelAlpha(image,\n                                 (QM) ((2*i*(\
    \ GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n\
    \                                 ((ssize_t) (m*2))\n                        \
    \         +GetPixelAlpha(image,pixels)),q);\n                            }\n \
    \                       }\n                      q+=GetPixelChannels(image);\n\
    \                    }\n                    n+=GetPixelChannels(image);\n    \
    \              }\n\n                  if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n             \
    \   {\n                /*\n                   Rescale pixels to Quantum\n    \
    \            */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                       exception);\n\n                     for (x=(ssize_t) image->columns-1;\
    \ x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n\
    \                          GetPixelRed(image,q)),q);\n                       \
    \ SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n\
    \                        SetPixelBlue(image,ScaleShortToQuantum(\n           \
    \               GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n\
    \                          GetPixelAlpha(image,q)),q);\n                     \
    \   q+=GetPixelChannels(image);\n                     }\n\n                  \
    \   if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               \
    \        break;\n                   }\n                }\n#endif\n           \
    \     if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Finished MAGN processing\");\n              }\n     \
    \     }\n\n        /*\n          Crop_box is with respect to the upper left corner\
    \ of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n\
    \        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n\
    \        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n  \
    \      crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n\
    \        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id]))\
    \ ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n          \
    \  +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n\
    \              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \
    \       \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right)\
    \ &&\n                (crop_box.top < crop_box.bottom))\n              {\n   \
    \             Image\n                  *im;\n\n                RectangleInfo\n\
    \                  crop_info;\n\n                /*\n                  Crop_info\
    \ is with respect to the upper left corner of\n                  the image.\n\
    \                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n\
    \                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n    \
    \            crop_info.width=(size_t) (crop_box.right-crop_box.left);\n      \
    \          crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n       \
    \         image->page.width=image->columns;\n                image->page.height=image->rows;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        im=CropImage(image,&crop_info,exception);\n\n                if (im !=\
    \ (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n\
    \                    image->rows=im->rows;\n                    im=DestroyImage(im);\n\
    \                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n\
    \                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n\
    \                  }\n              }\n\n            else\n              {\n \
    \               /*\n                  No pixels in crop area.  The MNG spec still\
    \ requires\n                  a layer, though, so make a single transparent pixel\
    \ in\n                  the top left corner.\n                */\n           \
    \     image->columns=1;\n                image->rows=1;\n                image->colors=2;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n          \
    \      image->page.width=1;\n                image->page.height=1;\n         \
    \       image->page.x=0;\n                image->page.y=0;\n              }\n\
    \          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n\
    #endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not\
    \ handle depths greater than 16 so reduce it even\n       * if lossy.\n      \
    \ */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte\
    \ properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception)\
    \ != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes\
    \ != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t)\
    \ (image_info->first_scene+image_info->number_scenes))\n            break;\n \
    \       }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"\
    MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n\
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading\
    \ all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers\
    \ && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n\
    \    {\n      /*\n        Insert a background layer if nothing else was found.\n\
    \      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No images found.  Inserting a background layer.\");\n\n      if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n\
    \            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n\
    \          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n \
    \             if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Allocation failed, returning NULL.\");\n\n            \
    \  return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n\
    \        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n\
    \      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n\
    \      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n\
    \      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping ==\
    \ MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n \
    \     mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\
    \n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image)\
    \ != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n\
    \      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \          CoderError,\"Linked list is corrupted, beginning of list not found\"\
    ,\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n\
    \      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n\
    \        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"\
    Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n\
    \      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1\
    \ &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n\
    \      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"image->next for first image is NULL but shouldn't be.\"\
    ,\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found\
    \ == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\
    \n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n\
    \    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\
    \n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay\
    \ */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *)\
    \ NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\
    \n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n\
    \    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging\
    \ != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n\
    \        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n    \
    \  int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image)\
    \ != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n    \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n \
    \     }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n\
    \  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\
    \n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\"\
    );\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\
    \n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\
    \n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n \
    \        next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n\
    \         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n\
    \         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image\
    \ *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n\
    \             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n\
    \             if (GetPreviousImageInList(next) == (Image *) NULL)\n          \
    \     image=next_image;\n             else\n               next->previous->next=next_image;\n\
    \             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\
    \n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\
    \n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n\
    \      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n  \
    \      (double) image->dispose);\n\n      while (GetNextImageInList(image) !=\
    \ (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n     \
    \   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double)\
    \ image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\"\
    );\n\n  return(image);\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nstatic Image *ReadOneMNGImage(MngInfo*\
    \ mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n\
    \  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n\
    \    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n\
    \    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n\
    \    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n\
    \    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n  \
    \  mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register\
    \ ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile\
    \ short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n\
    \    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n\
    \    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1:\
    \ MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n\
    #if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n\
    \    length;\n\n  /* These delays are all measured in image ticks_per_second,\n\
    \   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n\
    \    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n\
    \    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n\
    \    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n\
    \  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n\
    \  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n \
    \     /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned\
    \ char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\\
    n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n\
    \      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t)\
    \ PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n\
    \      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n\
    \  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n\
    \  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n\
    #endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n\
    \  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n\
    \  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n\
    \  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n\
    #endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n\
    #endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n\
    \  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n\
    \          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void)\
    \ ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n\
    \        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if\
    \ (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n          \
    \ type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n\
    \          {\n            status=MagickFalse;\n            break;\n          }\n\
    \n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n\
    \        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n\
    \              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\"\
    );\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n       \
    \      MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned\
    \ char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n      \
    \        int\n                c;\n\n              c=ReadBlobByte(image);\n   \
    \           if (c == EOF)\n                break;\n              chunk[i]=(unsigned\
    \ char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void)\
    \ ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n\
    \        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\
    \n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4)\
    \ == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n        \
    \    if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\
    \n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skip to IEND.\");\n\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length\
    \ != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n \
    \             }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1]\
    \ << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n   \
    \         if (logging != MagickFalse)\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width:\
    \ %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n \
    \             }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t)\
    \ mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n     \
    \         default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n\
    \                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n\
    \            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t)\
    \ mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n          \
    \  if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2;\
    \ /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n\
    \              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n     \
    \       if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n\
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \      {\n                /* Allocate next image structure.  */\n            \
    \    AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                  return((Image *) NULL);\n\n          \
    \      image=SyncNextImageInList(image);\n                mng_info->image=image;\n\
    \              }\n\n            if ((mng_info->mng_width > 65535L) ||\n      \
    \          (mng_info->mng_height > 65535L))\n              {\n               \
    \ chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"\
    WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n\
    \              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n   \
    \           mng_info->mng_height);\n\n            mng_info->frame.left=0;\n  \
    \          mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n\
    \            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n        \
    \    mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for\
    \ (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n  \
    \        {\n            int\n              repeat=0;\n\n            if (length\
    \ != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n        \
    \      {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n   \
    \             mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n          \
    \      if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\
    \n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n\
    \              }\n\n            if (logging != MagickFalse)\n              {\n\
    \                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \
    \           \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n      \
    \            repeat,(double) final_delay, (double) image->iterations);\n     \
    \         }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n\
    \          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (length < 2)\n        \
    \      {\n                if (chunk)\n                  chunk=(unsigned char *)\
    \ RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\
    \n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n\
    \              {\n                /*\n                  Instead of using a warning\
    \ we should allocate a larger\n                  MngInfo structure and continue.\n\
    \                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n\
    \                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if\
    \ (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n\
    \                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                  (void) ThrowMagickException(exception,\n                  \
    \  GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a\
    \ frozen MNG object\",\"`%s'\",\n                    image->filename);\n     \
    \             continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\
    \n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\
    \n            /*\n              Extract object offset info.\n            */\n\
    \            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t)\
    \ ((p[4] << 24) |\n                    (p[5] << 16) | (p[6] << 8) | p[7]);\n\n\
    \                mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n      \
    \              (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                if (logging\
    \ != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n          \
    \            object_id,(double) mng_info->x_off[object_id],\n                \
    \      object_id,(double) mng_info->y_off[object_id]);\n                  }\n\
    \              }\n\n            /*\n              Extract object clipping info.\n\
    \            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n\
    \                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n\
    \          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n        \
    \    if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\
    \n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned\
    \ short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\
    \n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n     \
    \     {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n       \
    \       mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\
    \n            if (mandatory_back && length > 5)\n              {\n           \
    \     mng_background_color.red=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n\
    \                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\
    \n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n\
    \              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n \
    \             mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n     \
    \       /* Read global PLTE.  */\n\n            if (length && (length < 769))\n\
    \              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n\
    \                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n\
    \                    sizeof(*mng_info->global_plte));\n\n                for (i=0;\
    \ i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n\
    \                  mng_info->global_plte[i].green=p[3*i+1];\n                \
    \  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n            \
    \    mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n\
    #ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n         \
    \     mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n\
    \              mng_info->global_plte[i].blue=i;\n            }\n\n           \
    \ if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n\
    \            else\n              mng_info->global_plte_length=0;\n\n         \
    \   chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n     \
    \       /* read global tRNS */\n\n            if (length > 0 && length < 257)\n\
    \              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\
    \n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n\
    #endif\n            mng_info->global_trns_length=(unsigned int) length;\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n       \
    \     if (length == 4)\n              {\n                ssize_t\n           \
    \       igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float)\
    \ igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n \
    \             }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n  \
    \        {\n            /* Read global cHRM */\n\n            if (length == 32)\n\
    \              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n\
    \                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n\
    \                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n\
    \                mng_info->global_chrm.red_primary.y=0.00001*\n              \
    \    mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n\
    \                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n\
    \                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n\
    \                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n\
    \                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n\
    \              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n  \
    \        {\n            /*\n              Read global sRGB.\n            */\n\
    \            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n\
    \                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n  \
    \              mng_info->have_global_srgb=MagickTrue;\n              }\n     \
    \       else\n              mng_info->have_global_srgb=MagickFalse;\n\n      \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n     \
    \       /* To do: */\n\n            /*\n              Read global iCCP.\n    \
    \        */\n            if (length != 0)\n              chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n\
    \        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type\
    \ == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if ((mng_info->framing_mode\
    \ == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\
    \n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n\
    \            fb=default_fb;\n\n            if (length != 0)\n              if\
    \ (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n        \
    \    if (length > 6)\n              {\n                /* Note the delay and frame\
    \ clipping boundaries.  */\n\n                p++; /* framing mode */\n\n    \
    \            while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;\
    \  /* frame name */\n\n                p++;  /* frame name terminator */\n\n \
    \               if ((p-chunk) < (ssize_t) (length-4))\n                  {\n \
    \                   int\n                      change_delay,\n               \
    \       change_timeout,\n                      change_clipping;\n\n          \
    \          change_delay=(*p++);\n                    change_timeout=(*p++);\n\
    \                    change_clipping=(*p++);\n                    p++; /* change_sync\
    \ */\n\n                    if (change_delay)\n                      {\n     \
    \                   frame_delay=1UL*image->ticks_per_second*\n               \
    \           mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n\
    \                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\
    \n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\
    \n                        p+=4;\n\n                        if (logging != MagickFalse)\n\
    \                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                            \"    Framing_delay=%.20g\",(double) frame_delay);\n\
    \                      }\n\n                    if (change_timeout)\n        \
    \              {\n                        frame_timeout=1UL*image->ticks_per_second*\n\
    \                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\
    \n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\
    \n                        if (change_timeout == 2)\n                         \
    \ default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n  \
    \                      if (logging != MagickFalse)\n                         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \
    \      \"    Framing_timeout=%.20g\",(double) frame_timeout);\n              \
    \        }\n\n                    if (change_clipping)\n                     \
    \ {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n\
    \                        p+=17;\n                        previous_fb=fb;\n\n \
    \                       if (logging != MagickFalse)\n                        \
    \  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \
    \       \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n               \
    \             (double) fb.left,(double) fb.right,(double) fb.top,\n          \
    \                  (double) fb.bottom);\n\n                        if (change_clipping\
    \ == 2)\n                          default_fb=fb;\n                      }\n \
    \                 }\n              }\n            mng_info->clip=fb;\n       \
    \     mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t)\
    \ (mng_info->clip.right\n               -mng_info->clip.left);\n\n           \
    \ subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n\
    \            /*\n              Insert a background layer behind the frame if framing_mode\
    \ is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n\
    \                subframe_width,(double) subframe_height);\n\n            if (insert_layers\
    \ && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n\
    \              {\n                /* Allocate next image structure.  */\n    \
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \          {\n                    AcquireNextImage(image_info,image,exception);\n\
    \n                    if (GetNextImageInList(image) == (Image *) NULL)\n     \
    \                 return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n\
    \                  }\n\n                mng_info->image=image;\n\n           \
    \     if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n\
    \                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                image->columns=subframe_width;\n                image->rows=subframe_height;\n\
    \                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n\
    \                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n\
    \                image->background_color=mng_background_color;\n             \
    \   image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n\n        \
    \        if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                    (double) mng_info->clip.left,\n                    (double)\
    \ mng_info->clip.right,\n                    (double) mng_info->clip.top,\n  \
    \                  (double) mng_info->clip.bottom);\n              }\n#endif\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n   \
    \       {\n            unsigned int\n              first_object,\n           \
    \   last_object;\n\n            /*\n              Read CLIP.\n            */\n\
    \            if (length > 3)\n              {\n                first_object=(p[0]\
    \ << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n           \
    \     p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object;\
    \ i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n\
    \                    {\n                      MngBox\n                       \
    \ box;\n\n                      box=mng_info->object_clip[i];\n              \
    \        if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n\
    \                           mng_read_box(box,(char) p[0],&p[1]);\n           \
    \         }\n                }\n\n              }\n            chunk=(unsigned\
    \ char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1;\
    \ i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n        \
    \        {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n\
    \                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n               \
    \     mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n     \
    \       if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) ==\
    \ 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC\
    \ or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n\
    \              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n      \
    \            MngInfoDiscardObject(mng_info,i);\n              }\n\n          \
    \  else\n              {\n                register ssize_t\n                 \
    \ j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n              \
    \  {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n\
    \                }\n              }\n\n            if (length != 0)\n        \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n     \
    \       size_t\n              first_object,\n              last_object;\n\n  \
    \          /* read MOVE */\n\n            if (length > 3)\n            {\n   \
    \           first_object=(p[0] << 8) | p[1];\n              last_object=(p[2]\
    \ << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object;\
    \ i <= (ssize_t) last_object; i++)\n              {\n                if ((i <\
    \ 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n             \
    \   if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk)\
    \ < (ssize_t) (length-8))\n                  {\n                    MngPair\n\
    \                      new_pair;\n\n                    MngPair\n            \
    \          old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n \
    \                   old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int)\
    \ p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n         \
    \           mng_info->y_off[i]=new_pair.b;\n                  }\n            \
    \  }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) ==\
    \ 0)\n          {\n            ssize_t loop_iters=1;\n            if (length >\
    \ 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;\
    \  /* mark loop active */\n\n                /* Record starting point.  */\n \
    \               loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging\
    \ != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  LOOP level %.20g has %.20g iterations \",\n         \
    \           (double) loop_level, (double) loop_iters);\n\n                if (loop_iters\
    \ == 0)\n                  skipping_loop=loop_level;\n\n                else\n\
    \                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n\
    \                    mng_info->loop_count[loop_level]=loop_iters;\n          \
    \        }\n\n                mng_info->loop_iteration[loop_level]=0;\n      \
    \        }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) ==\
    \ 0)\n          {\n            if (length > 0)\n              {\n            \
    \    loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n        \
    \          {\n                    if (skipping_loop == loop_level)\n         \
    \             {\n                        /*\n                          Found end\
    \ of zero-iteration loop.\n                        */\n                      \
    \  skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n\
    \                      }\n                  }\n\n                else\n      \
    \            {\n                    if (mng_info->loop_active[loop_level] == 1)\n\
    \                      {\n                        mng_info->loop_count[loop_level]--;\n\
    \                        mng_info->loop_iteration[loop_level]++;\n\n         \
    \               if (logging != MagickFalse)\n                          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \" \
    \ ENDL: LOOP level %.20g has %.20g remaining iters\",\n                      \
    \      (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\
    \n                        if (mng_info->loop_count[loop_level] != 0)\n       \
    \                   {\n                            offset=\n                 \
    \             SeekBlob(image,mng_info->loop_jump[loop_level],\n              \
    \                SEEK_SET);\n\n                            if (offset < 0)\n \
    \                             {\n                                chunk=(unsigned\
    \ char *) RelinquishMagickMemory(\n                                  chunk);\n\
    \                                ThrowReaderException(CorruptImageError,\n   \
    \                               \"ImproperImageHeader\");\n                  \
    \            }\n                          }\n\n                        else\n\
    \                          {\n                            short\n            \
    \                  last_level;\n\n                            /*\n           \
    \                   Finished loop.\n                            */\n         \
    \                   mng_info->loop_active[loop_level]=0;\n                   \
    \         last_level=(-1);\n                            for (i=0; i < loop_level;\
    \ i++)\n                              if (mng_info->loop_active[i] == 1)\n   \
    \                             last_level=(short) i;\n                        \
    \    loop_level=last_level;\n                          }\n                   \
    \   }\n                  }\n              }\n\n            chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n  \
    \      if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->clon_warning++;\n      \
    \    }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n           \
    \ png_uint_16\n              magn_first,\n              magn_last,\n         \
    \     magn_mb,\n              magn_ml,\n              magn_mr,\n             \
    \ magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n\
    \              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0]\
    \ << 8) | p[1];\n\n            else\n              magn_first=0;\n\n         \
    \   if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n         \
    \   else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n  \
    \          if (magn_first || magn_last)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"MAGN\
    \ is not implemented yet for nonzero objects\",\n                     \"`%s'\"\
    ,image->filename);\n\n                   mng_info->magn_warning++;\n         \
    \       }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\
    \n            else\n              magn_methx=0;\n\n            if (length > 6)\n\
    \              magn_mx=(p[5] << 8) | p[6];\n\n            else\n             \
    \ magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n  \
    \          if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n    \
    \        else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n\
    \              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9]\
    \ << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n     \
    \       if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length\
    \ > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n   \
    \           magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\
    \n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n\
    \            else\n              magn_mt=magn_my;\n\n            if (magn_mt ==\
    \ 0)\n              magn_mt=1;\n\n            if (length > 16)\n             \
    \ magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\
    \n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length\
    \ > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\
    \n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"Unknown\
    \ MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\
    \n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n\
    \          /* Magnify existing objects in the range magn_first to magn_last */\n\
    #endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n\
    \                /* Save the magnification factors for object 0 */\n         \
    \       mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n\
    \                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n\
    \                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n\
    \                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n\
    \              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n \
    \         {\n            if (mng_info->past_warning == 0)\n              (void)\
    \ ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"\
    PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n\
    \            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4)\
    \ == 0)\n          {\n            if (mng_info->show_warning == 0)\n         \
    \     (void) ThrowMagickException(exception,GetMagickModule(),\n             \
    \   CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\
    \n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4)\
    \ == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\
    \n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n\
    \                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n\
    \                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n\
    \                mng_info->have_global_sbit=MagickTrue;\n             }\n    \
    \      }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n           \
    \ if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n\
    \                mng_info->have_global_phys=MagickTrue;\n              }\n\n \
    \           else\n              mng_info->have_global_phys=MagickFalse;\n    \
    \      }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n           \
    \ if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\
    \n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->basi_warning++;\n#ifdef\
    \ MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] << 24) | (p[1] <<\
    \ 16) |\n               (p[2] << 8) | p[3]);\n            basi_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n               (p[6] << 8) | p[7]);\n      \
    \      basi_color_type=p[8];\n            basi_compression_method=p[9];\n    \
    \        basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n \
    \           if (length > 11)\n              basi_red=(p[12] << 8) & p[13];\n\n\
    \            else\n              basi_red=0;\n\n            if (length > 13)\n\
    \              basi_green=(p[14] << 8) & p[15];\n\n            else\n        \
    \      basi_green=0;\n\n            if (length > 15)\n              basi_blue=(p[16]\
    \ << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n         \
    \   if (length > 17)\n              basi_alpha=(p[18] << 8) & p[19];\n\n     \
    \       else\n              {\n                if (basi_sample_depth == 16)\n\
    \                  basi_alpha=65535L;\n                else\n                \
    \  basi_alpha=255;\n              }\n\n            if (length > 19)\n        \
    \      basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\
    \n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if\
    \ defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n   \
    \         )\n          {\n            /* Not an IHDR or JHDR chunk */\n      \
    \      if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n/* Process IHDR */\n        if (logging\
    \ != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\
    \n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\
    \n        if (mng_info->invisible[object_id])\n          {\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length\
    \ < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\
    \          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t)\
    \ mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n        /*\n          Insert a transparent background layer behind the entire\
    \ animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n\
    \        if (insert_layers && mng_type && first_mng_object)\n          {\n   \
    \         if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n     \
    \           (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right\
    \ < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height)\
    \ ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n\
    \              {\n                if (GetAuthenticPixelQueue(image) != (Quantum\
    \ *) NULL)\n                  {\n                    /*\n                    \
    \  Allocate next image structure.\n                    */\n                  \
    \  AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                      return(DestroyImageList(image));\n\
    \n                    image=SyncNextImageInList(image);\n                  }\n\
    \                mng_info->image=image;\n\n                if (term_chunk_found)\n\
    \                  {\n                    image->start_loop=MagickTrue;\n    \
    \                image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                /* Make a background rectangle.  */\n\n                image->delay=0;\n\
    \                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n\
    \                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        image->background_color=mng_background_color;\n                (void)\
    \ SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"  Inserted transparent background layer, W=%.20g, H=%.20g\"\
    ,\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n\
    \              }\n          }\n        /*\n          Insert a background layer\
    \ behind the upcoming image if\n          framing_mode is 3, and we haven't already\
    \ inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode\
    \ == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity\
    \ == 0 ||\n                (simplicity & 0x08)))\n          {\n            if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n       \
    \       /*\n                Allocate next image structure.\n              */\n\
    \              AcquireNextImage(image_info,image,exception);\n\n             \
    \ if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\
    \n              image=SyncNextImageInList(image);\n            }\n\n         \
    \   mng_info->image=image;\n\n            if (term_chunk_found)\n            \
    \  {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n\
    \                term_chunk_found=MagickFalse;\n              }\n\n          \
    \  else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n\
    \            image->columns=subframe_width;\n            image->rows=subframe_height;\n\
    \            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n\
    \            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n\
    \            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n\
    \            (void) SetImageBackgroundColor(image,exception);\n\n            if\
    \ (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n\
    \                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n\
    \          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\
    \n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n\
    \            /*\n              Allocate next image structure.\n            */\n\
    \            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n              return(DestroyImageList(image));\n\n     \
    \       image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\
    \n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n\
    \            term_chunk_found=MagickFalse;\n          }\n\n        else\n    \
    \        image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode\
    \ == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n\
    \            frame_delay=default_frame_delay;\n          }\n\n        else\n \
    \         image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n\
    \        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n\
    \        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\
    \n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's\
    \ length field.\n        */\n\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking\
    \ back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\
    \n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if\
    \ (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n\
    \    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n\
    \      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n\
    \    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\
    \n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n\
    \          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"\
    exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\
    \n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n\
    \        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\
    \n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if\
    \ (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n\
    \               magnified_height,\n               magnified_width;\n\n       \
    \     if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx\
    \ == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\
    \n                if (image->columns > 1)\n                   magnified_width\
    \ += mng_info->magn_mr;\n\n                if (image->columns > 2)\n         \
    \          magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n\
    \              }\n\n            else\n              {\n                magnified_width=(png_uint_32)\
    \ image->columns;\n\n                if (image->columns > 1)\n               \
    \    magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns\
    \ > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n       \
    \         if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n\
    \                      ((image->columns-3)*(mng_info->magn_mx-1));\n         \
    \     }\n\n            if (mng_info->magn_methy == 1)\n              {\n     \
    \           magnified_height=mng_info->magn_mt;\n\n                if (image->rows\
    \ > 1)\n                   magnified_height += mng_info->magn_mb;\n\n        \
    \        if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n\
    \                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\
    \n            else\n              {\n                magnified_height=(png_uint_32)\
    \ image->rows;\n\n                if (image->rows > 1)\n                   magnified_height\
    \ += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n          \
    \         magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows\
    \ > 3)\n                   magnified_height += (png_uint_32)\n               \
    \       ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n        \
    \    if (magnified_height > image->rows ||\n                magnified_width >\
    \ image->columns)\n              {\n                Image\n                  *large_image;\n\
    \n                int\n                  yy;\n\n                Quantum\n    \
    \              *next,\n                  *prev;\n\n                png_uint_16\n\
    \                  magn_methx,\n                  magn_methy;\n\n            \
    \    ssize_t\n                  m,\n                  y;\n\n                register\
    \ Quantum\n                  *n,\n                  *q;\n\n                register\
    \ ssize_t\n                  x;\n\n                /* Allocate next image structure.\
    \  */\n\n                if (logging != MagickFalse)\n                  (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate\
    \ magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\
    \n                if (GetNextImageInList(image) == (Image *) NULL)\n         \
    \         return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\
    \n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\
    \n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\
    \n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n           \
    \     if (magn_methx != 1 || magn_methy != 1)\n                  {\n         \
    \         /*\n                     Scale pixels to unsigned shorts to prevent\n\
    \                     overflow of intermediate values of interpolations\n    \
    \              */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                          exception);\n\n                       for (x=(ssize_t)\
    \ image->columns-1; x >= 0; x--)\n                       {\n                 \
    \         SetPixelRed(image,ScaleQuantumToShort(\n                           \
    \ GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n\
    \                            GetPixelGreen(image,q)),q);\n                   \
    \       SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n\
    \                          SetPixelAlpha(image,ScaleQuantumToShort(\n        \
    \                    GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n\
    \                       }\n\n                       if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                         break;\n                     }\n \
    \                 }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait\
    \ != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\
    \n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n\
    \                    (void) SetImageBackgroundColor(large_image,exception);\n\n\
    \                    if (magn_methx == 4)\n                      magn_methx=2;\n\
    \n                    if (magn_methx == 5)\n                      magn_methx=3;\n\
    \n                    if (magn_methy == 4)\n                      magn_methy=2;\n\
    \n                    if (magn_methy == 5)\n                      magn_methy=3;\n\
    \                  }\n\n                /* magnify the rows into the right side\
    \ of the large image */\n\n                if (logging != MagickFalse)\n     \
    \             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \
    \          \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n\
    \                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n     \
    \           length=(size_t) GetPixelChannels(image)*image->columns;\n        \
    \        next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n      \
    \          prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n  \
    \              if ((prev == (Quantum *) NULL) ||\n                    (next ==\
    \ (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n\
    \                     ThrowReaderException(ResourceLimitError,\n             \
    \          \"MemoryAllocationFailed\");\n                  }\n\n             \
    \   n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n            \
    \    (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y <\
    \ (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n\
    \                    m=(ssize_t) mng_info->magn_mt;\n\n                  else\
    \ if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t)\
    \ mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t)\
    \ image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n     \
    \             else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n     \
    \               m=1;\n\n                  else\n                    m=(ssize_t)\
    \ mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n\
    \                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n\
    \                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n\
    \                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n\
    \                    }\n\n                  for (i=0; i < m; i++, yy++)\n    \
    \              {\n                    register Quantum\n                     \
    \ *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n\
    \                    pixels=prev;\n                    n=next;\n             \
    \       q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n        \
    \              1,exception);\n                    q+=(large_image->columns-image->columns)*\n\
    \                      GetPixelChannels(large_image);\n\n                    for\
    \ (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n       \
    \               /* To do: get color as function of indexes[x] */\n           \
    \           /*\n                      if (image->storage_class == PseudoClass)\n\
    \                        {\n                        }\n                      */\n\
    \n                      if (magn_methy <= 1)\n                        {\n    \
    \                      /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(large_image,GetPixelGreen(image,\n  \
    \                           pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                             pixels),q);\n                        }\n\n     \
    \                 else if (magn_methy == 2 || magn_methy == 4)\n             \
    \           {\n                          if (i == 0)\n                       \
    \     {\n                              SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n\
    \                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                 pixels),q);\n                            }\n\
    \n                          else\n                            {\n            \
    \                  /* Interpolate */\n                              SetPixelRed(large_image,((QM)\
    \ (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n \
    \                                -GetPixelRed(image,pixels)+m))/\n           \
    \                      ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n\
    \                              SetPixelGreen(large_image,((QM) (((ssize_t)\n \
    \                                (2*i*(GetPixelGreen(image,n)\n              \
    \                   -GetPixelGreen(image,pixels)+m))/\n                      \
    \           ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n\
    \                              SetPixelBlue(large_image,((QM) (((ssize_t)\n  \
    \                               (2*i*(GetPixelBlue(image,n)\n                \
    \                 -GetPixelBlue(image,pixels)+m))/\n                         \
    \        ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\
    \n                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n\
    \                                    (2*i*(GetPixelAlpha(image,n)\n          \
    \                          -GetPixelAlpha(image,pixels)+m))\n                \
    \                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n\
    \                            }\n\n                          if (magn_methy ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                        SetPixelAlpha(large_image,GetPixelAlpha(image,\n    \
    \                                pixels),q);\n                              else\n\
    \                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                    n),q);\n                            }\n \
    \                       }\n\n                      else /* if (magn_methy == 3\
    \ || magn_methy == 5) */\n                        {\n                        \
    \  /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n\
    \                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelGreen(large_image,GetPixelGreen(image,\n                          \
    \          pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelAlpha(large_image,GetPixelAlpha(image,\n                          \
    \          pixels),q);\n                          }\n\n                      \
    \    else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n\
    \                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n\
    \                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n\
    \                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n\
    \                                    q);\n                          }\n\n    \
    \                      if (magn_methy == 5)\n                            {\n \
    \                             SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n\
    \                                 (GetPixelAlpha(image,n)\n                  \
    \               -GetPixelAlpha(image,pixels))\n                              \
    \   +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n                        }\n                  \
    \    n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n\
    \                      pixels+=GetPixelChannels(image);\n                    }\
    \ /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception)\
    \ == 0)\n                      break;\n\n                  } /* i */\n       \
    \         } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n\
    \                next=(Quantum *) RelinquishMagickMemory(next);\n\n          \
    \      length=image->columns;\n\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\
    \n                image=large_image;\n\n                mng_info->image=image;\n\
    \n                /* magnify the columns */\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Magnify the columns to %.20g\",\n                    (double)\
    \ image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                {\n                  register Quantum\n                    *pixels;\n\
    \n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n\
    \                  n=pixels+GetPixelChannels(image);\n\n                  for\
    \ (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns;\
    \ x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel()\
    \ */\n\n                    if (x == (ssize_t) (image->columns-length))\n    \
    \                  m=(ssize_t) mng_info->magn_ml;\n\n                    else\
    \ if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                   \
    \   m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ <= 1 &&\n                        x == (ssize_t) image->columns-1)\n        \
    \              m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n    \
    \                else\n                      m=(ssize_t) mng_info->magn_mx;\n\n\
    \                    for (i=0; i < m; i++)\n                    {\n          \
    \            if (magn_methx <= 1)\n                        {\n               \
    \           /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                        }\n\n                      else if (magn_methx == 2 ||\
    \ magn_methx == 4)\n                        {\n                          if (i\
    \ == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                          }\n\n                          /* To do: Rewrite using\
    \ Get/Set***PixelChannel() */\n                          else\n              \
    \              {\n                              /* Interpolate */\n          \
    \                    SetPixelRed(image,(QM) ((2*i*(\n                        \
    \         GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n\
    \                                 /((ssize_t) (m*2))+\n                      \
    \           GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM)\
    \ ((2*i*(\n                                 GetPixelGreen(image,n)\n         \
    \                        -GetPixelGreen(image,pixels))+m)\n                  \
    \               /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\
    \n                              SetPixelBlue(image,(QM) ((2*i*(\n            \
    \                     GetPixelBlue(image,n)\n                                \
    \ -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t)\
    \ (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n\
    \                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(image,(QM) ((2*i*(\n         \
    \                          GetPixelAlpha(image,n)\n                          \
    \         -GetPixelAlpha(image,pixels))+m)\n                                 \
    \  /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n\n                          if (magn_methx ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                     {\n                                 SetPixelAlpha(image,\n\
    \                                   GetPixelAlpha(image,pixels)+0,q);\n      \
    \                        }\n                              else\n             \
    \                 {\n                                 SetPixelAlpha(image,\n \
    \                                  GetPixelAlpha(image,n)+0,q);\n            \
    \                  }\n                            }\n                        }\n\
    \n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n \
    \                       {\n                          /* Replicate nearest */\n\
    \                          if (i <= ((m+1) << 1))\n                          {\n\
    \                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                             SetPixelGreen(image,GetPixelGreen(image,\n     \
    \                            pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                             SetPixelAlpha(image,GetPixelAlpha(image,\n     \
    \                            pixels),q);\n                          }\n\n    \
    \                      else\n                          {\n                   \
    \          SetPixelRed(image,GetPixelRed(image,n),q);\n                      \
    \       SetPixelGreen(image,GetPixelGreen(image,n),q);\n                     \
    \        SetPixelBlue(image,GetPixelBlue(image,n),q);\n                      \
    \       SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                     \
    \     }\n\n                          if (magn_methx == 5)\n                  \
    \          {\n                              /* Interpolate */\n              \
    \                SetPixelAlpha(image,\n                                 (QM) ((2*i*(\
    \ GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n\
    \                                 ((ssize_t) (m*2))\n                        \
    \         +GetPixelAlpha(image,pixels)),q);\n                            }\n \
    \                       }\n                      q+=GetPixelChannels(image);\n\
    \                    }\n                    n+=GetPixelChannels(image);\n    \
    \              }\n\n                  if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n             \
    \   {\n                /*\n                   Rescale pixels to Quantum\n    \
    \            */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                       exception);\n\n                     for (x=(ssize_t) image->columns-1;\
    \ x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n\
    \                          GetPixelRed(image,q)),q);\n                       \
    \ SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n\
    \                        SetPixelBlue(image,ScaleShortToQuantum(\n           \
    \               GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n\
    \                          GetPixelAlpha(image,q)),q);\n                     \
    \   q+=GetPixelChannels(image);\n                     }\n\n                  \
    \   if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               \
    \        break;\n                   }\n                }\n#endif\n           \
    \     if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Finished MAGN processing\");\n              }\n     \
    \     }\n\n        /*\n          Crop_box is with respect to the upper left corner\
    \ of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n\
    \        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n\
    \        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n  \
    \      crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n\
    \        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id]))\
    \ ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n          \
    \  +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n\
    \              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \
    \       \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right)\
    \ &&\n                (crop_box.top < crop_box.bottom))\n              {\n   \
    \             Image\n                  *im;\n\n                RectangleInfo\n\
    \                  crop_info;\n\n                /*\n                  Crop_info\
    \ is with respect to the upper left corner of\n                  the image.\n\
    \                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n\
    \                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n    \
    \            crop_info.width=(size_t) (crop_box.right-crop_box.left);\n      \
    \          crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n       \
    \         image->page.width=image->columns;\n                image->page.height=image->rows;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        im=CropImage(image,&crop_info,exception);\n\n                if (im !=\
    \ (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n\
    \                    image->rows=im->rows;\n                    im=DestroyImage(im);\n\
    \                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n\
    \                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n\
    \                  }\n              }\n\n            else\n              {\n \
    \               /*\n                  No pixels in crop area.  The MNG spec still\
    \ requires\n                  a layer, though, so make a single transparent pixel\
    \ in\n                  the top left corner.\n                */\n           \
    \     image->columns=1;\n                image->rows=1;\n                image->colors=2;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n          \
    \      image->page.width=1;\n                image->page.height=1;\n         \
    \       image->page.x=0;\n                image->page.y=0;\n              }\n\
    \          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n\
    #endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not\
    \ handle depths greater than 16 so reduce it even\n       * if lossy.\n      \
    \ */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte\
    \ properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception)\
    \ != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes\
    \ != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t)\
    \ (image_info->first_scene+image_info->number_scenes))\n            break;\n \
    \       }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"\
    MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n\
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading\
    \ all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers\
    \ && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n\
    \    {\n      /*\n        Insert a background layer if nothing else was found.\n\
    \      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No images found.  Inserting a background layer.\");\n\n      if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n\
    \            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n\
    \          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n \
    \             if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Allocation failed, returning NULL.\");\n\n            \
    \  return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n\
    \        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n\
    \      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n\
    \      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n\
    \      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping ==\
    \ MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n \
    \     mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\
    \n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image)\
    \ != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n\
    \      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \          CoderError,\"Linked list is corrupted, beginning of list not found\"\
    ,\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n\
    \      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n\
    \        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"\
    Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n\
    \      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1\
    \ &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n\
    \      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"image->next for first image is NULL but shouldn't be.\"\
    ,\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found\
    \ == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\
    \n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n\
    \    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\
    \n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay\
    \ */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *)\
    \ NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\
    \n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n\
    \    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging\
    \ != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n\
    \        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n    \
    \  int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image)\
    \ != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n    \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n \
    \     }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n\
    \  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\
    \n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\"\
    );\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\
    \n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\
    \n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n \
    \        next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n\
    \         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n\
    \         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image\
    \ *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n\
    \             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n\
    \             if (GetPreviousImageInList(next) == (Image *) NULL)\n          \
    \     image=next_image;\n             else\n               next->previous->next=next_image;\n\
    \             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\
    \n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\
    \n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n\
    \      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n  \
    \      (double) image->dispose);\n\n      while (GetNextImageInList(image) !=\
    \ (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n     \
    \   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double)\
    \ image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\"\
    );\n\n  return(image);\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nstatic Image *ReadOneMNGImage(MngInfo*\
    \ mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n\
    \  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n\
    \    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n\
    \    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n\
    \    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n\
    \    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n  \
    \  mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register\
    \ ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile\
    \ short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n\
    \    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n\
    \    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1:\
    \ MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n\
    #if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n\
    \    length;\n\n  /* These delays are all measured in image ticks_per_second,\n\
    \   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n\
    \    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n\
    \    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n\
    \    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n\
    \  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n\
    \  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n \
    \     /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned\
    \ char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\\
    n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n\
    \      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t)\
    \ PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n\
    \      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n\
    \  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n\
    \  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n\
    #endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n\
    \  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n\
    \  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n\
    \  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n\
    #endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n\
    #endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n\
    \  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n\
    \          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void)\
    \ ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n\
    \        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if\
    \ (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n          \
    \ type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n\
    \          {\n            status=MagickFalse;\n            break;\n          }\n\
    \n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n\
    \        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n\
    \              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\"\
    );\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n       \
    \      MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned\
    \ char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n      \
    \        int\n                c;\n\n              c=ReadBlobByte(image);\n   \
    \           if (c == EOF)\n                break;\n              chunk[i]=(unsigned\
    \ char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void)\
    \ ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n\
    \        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\
    \n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4)\
    \ == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n        \
    \    if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\
    \n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skip to IEND.\");\n\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length\
    \ != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n \
    \             }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1]\
    \ << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n   \
    \         if (logging != MagickFalse)\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width:\
    \ %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n \
    \             }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t)\
    \ mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n     \
    \         default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n\
    \                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n\
    \            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t)\
    \ mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n          \
    \  if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2;\
    \ /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n\
    \              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n     \
    \       if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n\
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \      {\n                /* Allocate next image structure.  */\n            \
    \    AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                  return((Image *) NULL);\n\n          \
    \      image=SyncNextImageInList(image);\n                mng_info->image=image;\n\
    \              }\n\n            if ((mng_info->mng_width > 65535L) ||\n      \
    \          (mng_info->mng_height > 65535L))\n              {\n               \
    \ chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"\
    WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n\
    \              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n   \
    \           mng_info->mng_height);\n\n            mng_info->frame.left=0;\n  \
    \          mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n\
    \            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n        \
    \    mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for\
    \ (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n  \
    \        {\n            int\n              repeat=0;\n\n            if (length\
    \ != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n        \
    \      {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n   \
    \             mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n          \
    \      if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\
    \n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n\
    \              }\n\n            if (logging != MagickFalse)\n              {\n\
    \                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \
    \           \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n      \
    \            repeat,(double) final_delay, (double) image->iterations);\n     \
    \         }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n\
    \          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (length < 2)\n        \
    \      {\n                if (chunk)\n                  chunk=(unsigned char *)\
    \ RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\
    \n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n\
    \              {\n                /*\n                  Instead of using a warning\
    \ we should allocate a larger\n                  MngInfo structure and continue.\n\
    \                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n\
    \                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if\
    \ (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n\
    \                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                  (void) ThrowMagickException(exception,\n                  \
    \  GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a\
    \ frozen MNG object\",\"`%s'\",\n                    image->filename);\n     \
    \             continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\
    \n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\
    \n            /*\n              Extract object offset info.\n            */\n\
    \            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t)\
    \ ((p[4] << 24) |\n                    (p[5] << 16) | (p[6] << 8) | p[7]);\n\n\
    \                mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n      \
    \              (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                if (logging\
    \ != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n          \
    \            object_id,(double) mng_info->x_off[object_id],\n                \
    \      object_id,(double) mng_info->y_off[object_id]);\n                  }\n\
    \              }\n\n            /*\n              Extract object clipping info.\n\
    \            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n\
    \                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n\
    \          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n        \
    \    if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\
    \n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned\
    \ short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\
    \n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n     \
    \     {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n       \
    \       mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\
    \n            if (mandatory_back && length > 5)\n              {\n           \
    \     mng_background_color.red=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n\
    \                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\
    \n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n\
    \              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n \
    \             mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n     \
    \       /* Read global PLTE.  */\n\n            if (length && (length < 769))\n\
    \              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n\
    \                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n\
    \                    sizeof(*mng_info->global_plte));\n\n                for (i=0;\
    \ i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n\
    \                  mng_info->global_plte[i].green=p[3*i+1];\n                \
    \  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n            \
    \    mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n\
    #ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n         \
    \     mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n\
    \              mng_info->global_plte[i].blue=i;\n            }\n\n           \
    \ if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n\
    \            else\n              mng_info->global_plte_length=0;\n\n         \
    \   chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n     \
    \       /* read global tRNS */\n\n            if (length > 0 && length < 257)\n\
    \              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\
    \n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n\
    #endif\n            mng_info->global_trns_length=(unsigned int) length;\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n       \
    \     if (length == 4)\n              {\n                ssize_t\n           \
    \       igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float)\
    \ igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n \
    \             }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n  \
    \        {\n            /* Read global cHRM */\n\n            if (length == 32)\n\
    \              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n\
    \                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n\
    \                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n\
    \                mng_info->global_chrm.red_primary.y=0.00001*\n              \
    \    mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n\
    \                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n\
    \                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n\
    \                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n\
    \                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n\
    \              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n  \
    \        {\n            /*\n              Read global sRGB.\n            */\n\
    \            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n\
    \                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n  \
    \              mng_info->have_global_srgb=MagickTrue;\n              }\n     \
    \       else\n              mng_info->have_global_srgb=MagickFalse;\n\n      \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n     \
    \       /* To do: */\n\n            /*\n              Read global iCCP.\n    \
    \        */\n            if (length != 0)\n              chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n\
    \        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type\
    \ == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if ((mng_info->framing_mode\
    \ == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\
    \n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n\
    \            fb=default_fb;\n\n            if (length != 0)\n              if\
    \ (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n        \
    \    if (length > 6)\n              {\n                /* Note the delay and frame\
    \ clipping boundaries.  */\n\n                p++; /* framing mode */\n\n    \
    \            while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;\
    \  /* frame name */\n\n                p++;  /* frame name terminator */\n\n \
    \               if ((p-chunk) < (ssize_t) (length-4))\n                  {\n \
    \                   int\n                      change_delay,\n               \
    \       change_timeout,\n                      change_clipping;\n\n          \
    \          change_delay=(*p++);\n                    change_timeout=(*p++);\n\
    \                    change_clipping=(*p++);\n                    p++; /* change_sync\
    \ */\n\n                    if (change_delay)\n                      {\n     \
    \                   frame_delay=1UL*image->ticks_per_second*\n               \
    \           mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n\
    \                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\
    \n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\
    \n                        p+=4;\n\n                        if (logging != MagickFalse)\n\
    \                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                            \"    Framing_delay=%.20g\",(double) frame_delay);\n\
    \                      }\n\n                    if (change_timeout)\n        \
    \              {\n                        frame_timeout=1UL*image->ticks_per_second*\n\
    \                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\
    \n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\
    \n                        if (change_timeout == 2)\n                         \
    \ default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n  \
    \                      if (logging != MagickFalse)\n                         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \
    \      \"    Framing_timeout=%.20g\",(double) frame_timeout);\n              \
    \        }\n\n                    if (change_clipping)\n                     \
    \ {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n\
    \                        p+=17;\n                        previous_fb=fb;\n\n \
    \                       if (logging != MagickFalse)\n                        \
    \  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \
    \       \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n               \
    \             (double) fb.left,(double) fb.right,(double) fb.top,\n          \
    \                  (double) fb.bottom);\n\n                        if (change_clipping\
    \ == 2)\n                          default_fb=fb;\n                      }\n \
    \                 }\n              }\n            mng_info->clip=fb;\n       \
    \     mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t)\
    \ (mng_info->clip.right\n               -mng_info->clip.left);\n\n           \
    \ subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n\
    \            /*\n              Insert a background layer behind the frame if framing_mode\
    \ is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n\
    \                subframe_width,(double) subframe_height);\n\n            if (insert_layers\
    \ && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n\
    \              {\n                /* Allocate next image structure.  */\n    \
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \          {\n                    AcquireNextImage(image_info,image,exception);\n\
    \n                    if (GetNextImageInList(image) == (Image *) NULL)\n     \
    \                 return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n\
    \                  }\n\n                mng_info->image=image;\n\n           \
    \     if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n\
    \                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                image->columns=subframe_width;\n                image->rows=subframe_height;\n\
    \                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n\
    \                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n\
    \                image->background_color=mng_background_color;\n             \
    \   image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n\n        \
    \        if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                    (double) mng_info->clip.left,\n                    (double)\
    \ mng_info->clip.right,\n                    (double) mng_info->clip.top,\n  \
    \                  (double) mng_info->clip.bottom);\n              }\n#endif\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n   \
    \       {\n            unsigned int\n              first_object,\n           \
    \   last_object;\n\n            /*\n              Read CLIP.\n            */\n\
    \            if (length > 3)\n              {\n                first_object=(p[0]\
    \ << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n           \
    \     p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object;\
    \ i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n\
    \                    {\n                      MngBox\n                       \
    \ box;\n\n                      box=mng_info->object_clip[i];\n              \
    \        if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n\
    \                           mng_read_box(box,(char) p[0],&p[1]);\n           \
    \         }\n                }\n\n              }\n            chunk=(unsigned\
    \ char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1;\
    \ i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n        \
    \        {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n\
    \                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n               \
    \     mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n     \
    \       if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) ==\
    \ 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC\
    \ or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n\
    \              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n      \
    \            MngInfoDiscardObject(mng_info,i);\n              }\n\n          \
    \  else\n              {\n                register ssize_t\n                 \
    \ j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n              \
    \  {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n\
    \                }\n              }\n\n            if (length != 0)\n        \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n     \
    \       size_t\n              first_object,\n              last_object;\n\n  \
    \          /* read MOVE */\n\n            if (length > 3)\n            {\n   \
    \           first_object=(p[0] << 8) | p[1];\n              last_object=(p[2]\
    \ << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object;\
    \ i <= (ssize_t) last_object; i++)\n              {\n                if ((i <\
    \ 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n             \
    \   if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk)\
    \ < (ssize_t) (length-8))\n                  {\n                    MngPair\n\
    \                      new_pair;\n\n                    MngPair\n            \
    \          old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n \
    \                   old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int)\
    \ p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n         \
    \           mng_info->y_off[i]=new_pair.b;\n                  }\n            \
    \  }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) ==\
    \ 0)\n          {\n            ssize_t loop_iters=1;\n            if (length >\
    \ 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;\
    \  /* mark loop active */\n\n                /* Record starting point.  */\n \
    \               loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging\
    \ != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  LOOP level %.20g has %.20g iterations \",\n         \
    \           (double) loop_level, (double) loop_iters);\n\n                if (loop_iters\
    \ == 0)\n                  skipping_loop=loop_level;\n\n                else\n\
    \                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n\
    \                    mng_info->loop_count[loop_level]=loop_iters;\n          \
    \        }\n\n                mng_info->loop_iteration[loop_level]=0;\n      \
    \        }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) ==\
    \ 0)\n          {\n            if (length > 0)\n              {\n            \
    \    loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n        \
    \          {\n                    if (skipping_loop == loop_level)\n         \
    \             {\n                        /*\n                          Found end\
    \ of zero-iteration loop.\n                        */\n                      \
    \  skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n\
    \                      }\n                  }\n\n                else\n      \
    \            {\n                    if (mng_info->loop_active[loop_level] == 1)\n\
    \                      {\n                        mng_info->loop_count[loop_level]--;\n\
    \                        mng_info->loop_iteration[loop_level]++;\n\n         \
    \               if (logging != MagickFalse)\n                          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \" \
    \ ENDL: LOOP level %.20g has %.20g remaining iters\",\n                      \
    \      (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\
    \n                        if (mng_info->loop_count[loop_level] != 0)\n       \
    \                   {\n                            offset=\n                 \
    \             SeekBlob(image,mng_info->loop_jump[loop_level],\n              \
    \                SEEK_SET);\n\n                            if (offset < 0)\n \
    \                             {\n                                chunk=(unsigned\
    \ char *) RelinquishMagickMemory(\n                                  chunk);\n\
    \                                ThrowReaderException(CorruptImageError,\n   \
    \                               \"ImproperImageHeader\");\n                  \
    \            }\n                          }\n\n                        else\n\
    \                          {\n                            short\n            \
    \                  last_level;\n\n                            /*\n           \
    \                   Finished loop.\n                            */\n         \
    \                   mng_info->loop_active[loop_level]=0;\n                   \
    \         last_level=(-1);\n                            for (i=0; i < loop_level;\
    \ i++)\n                              if (mng_info->loop_active[i] == 1)\n   \
    \                             last_level=(short) i;\n                        \
    \    loop_level=last_level;\n                          }\n                   \
    \   }\n                  }\n              }\n\n            chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n  \
    \      if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->clon_warning++;\n      \
    \    }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n           \
    \ png_uint_16\n              magn_first,\n              magn_last,\n         \
    \     magn_mb,\n              magn_ml,\n              magn_mr,\n             \
    \ magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n\
    \              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0]\
    \ << 8) | p[1];\n\n            else\n              magn_first=0;\n\n         \
    \   if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n         \
    \   else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n  \
    \          if (magn_first || magn_last)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"MAGN\
    \ is not implemented yet for nonzero objects\",\n                     \"`%s'\"\
    ,image->filename);\n\n                   mng_info->magn_warning++;\n         \
    \       }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\
    \n            else\n              magn_methx=0;\n\n            if (length > 6)\n\
    \              magn_mx=(p[5] << 8) | p[6];\n\n            else\n             \
    \ magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n  \
    \          if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n    \
    \        else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n\
    \              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9]\
    \ << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n     \
    \       if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length\
    \ > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n   \
    \           magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\
    \n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n\
    \            else\n              magn_mt=magn_my;\n\n            if (magn_mt ==\
    \ 0)\n              magn_mt=1;\n\n            if (length > 16)\n             \
    \ magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\
    \n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length\
    \ > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\
    \n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"Unknown\
    \ MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\
    \n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n\
    \          /* Magnify existing objects in the range magn_first to magn_last */\n\
    #endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n\
    \                /* Save the magnification factors for object 0 */\n         \
    \       mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n\
    \                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n\
    \                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n\
    \                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n\
    \              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n \
    \         {\n            if (mng_info->past_warning == 0)\n              (void)\
    \ ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"\
    PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n\
    \            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4)\
    \ == 0)\n          {\n            if (mng_info->show_warning == 0)\n         \
    \     (void) ThrowMagickException(exception,GetMagickModule(),\n             \
    \   CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\
    \n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4)\
    \ == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\
    \n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n\
    \                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n\
    \                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n\
    \                mng_info->have_global_sbit=MagickTrue;\n             }\n    \
    \      }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n           \
    \ if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n\
    \                mng_info->have_global_phys=MagickTrue;\n              }\n\n \
    \           else\n              mng_info->have_global_phys=MagickFalse;\n    \
    \      }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n           \
    \ if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\
    \n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->basi_warning++;\n#ifdef\
    \ MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] << 24) | (p[1] <<\
    \ 16) |\n               (p[2] << 8) | p[3]);\n            basi_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n               (p[6] << 8) | p[7]);\n      \
    \      basi_color_type=p[8];\n            basi_compression_method=p[9];\n    \
    \        basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n \
    \           if (length > 11)\n              basi_red=(p[12] << 8) & p[13];\n\n\
    \            else\n              basi_red=0;\n\n            if (length > 13)\n\
    \              basi_green=(p[14] << 8) & p[15];\n\n            else\n        \
    \      basi_green=0;\n\n            if (length > 15)\n              basi_blue=(p[16]\
    \ << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n         \
    \   if (length > 17)\n              basi_alpha=(p[18] << 8) & p[19];\n\n     \
    \       else\n              {\n                if (basi_sample_depth == 16)\n\
    \                  basi_alpha=65535L;\n                else\n                \
    \  basi_alpha=255;\n              }\n\n            if (length > 19)\n        \
    \      basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\
    \n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if\
    \ defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n   \
    \         )\n          {\n            /* Not an IHDR or JHDR chunk */\n      \
    \      if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n/* Process IHDR */\n        if (logging\
    \ != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\
    \n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\
    \n        if (mng_info->invisible[object_id])\n          {\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length\
    \ < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\
    \          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t)\
    \ mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n        /*\n          Insert a transparent background layer behind the entire\
    \ animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n\
    \        if (insert_layers && mng_type && first_mng_object)\n          {\n   \
    \         if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n     \
    \           (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right\
    \ < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height)\
    \ ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n\
    \              {\n                if (GetAuthenticPixelQueue(image) != (Quantum\
    \ *) NULL)\n                  {\n                    /*\n                    \
    \  Allocate next image structure.\n                    */\n                  \
    \  AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                      return(DestroyImageList(image));\n\
    \n                    image=SyncNextImageInList(image);\n                  }\n\
    \                mng_info->image=image;\n\n                if (term_chunk_found)\n\
    \                  {\n                    image->start_loop=MagickTrue;\n    \
    \                image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                /* Make a background rectangle.  */\n\n                image->delay=0;\n\
    \                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n\
    \                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        image->background_color=mng_background_color;\n                (void)\
    \ SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"  Inserted transparent background layer, W=%.20g, H=%.20g\"\
    ,\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n\
    \              }\n          }\n        /*\n          Insert a background layer\
    \ behind the upcoming image if\n          framing_mode is 3, and we haven't already\
    \ inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode\
    \ == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity\
    \ == 0 ||\n                (simplicity & 0x08)))\n          {\n            if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n       \
    \       /*\n                Allocate next image structure.\n              */\n\
    \              AcquireNextImage(image_info,image,exception);\n\n             \
    \ if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\
    \n              image=SyncNextImageInList(image);\n            }\n\n         \
    \   mng_info->image=image;\n\n            if (term_chunk_found)\n            \
    \  {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n\
    \                term_chunk_found=MagickFalse;\n              }\n\n          \
    \  else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n\
    \            image->columns=subframe_width;\n            image->rows=subframe_height;\n\
    \            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n\
    \            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n\
    \            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n\
    \            (void) SetImageBackgroundColor(image,exception);\n\n            if\
    \ (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n\
    \                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n\
    \          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\
    \n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n\
    \            /*\n              Allocate next image structure.\n            */\n\
    \            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n              return(DestroyImageList(image));\n\n     \
    \       image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\
    \n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n\
    \            term_chunk_found=MagickFalse;\n          }\n\n        else\n    \
    \        image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode\
    \ == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n\
    \            frame_delay=default_frame_delay;\n          }\n\n        else\n \
    \         image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n\
    \        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n\
    \        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\
    \n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's\
    \ length field.\n        */\n\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking\
    \ back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\
    \n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if\
    \ (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n\
    \    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n\
    \      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n\
    \    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\
    \n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n\
    \          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"\
    exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\
    \n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n\
    \        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\
    \n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if\
    \ (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n\
    \               magnified_height,\n               magnified_width;\n\n       \
    \     if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx\
    \ == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\
    \n                if (image->columns > 1)\n                   magnified_width\
    \ += mng_info->magn_mr;\n\n                if (image->columns > 2)\n         \
    \          magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n\
    \              }\n\n            else\n              {\n                magnified_width=(png_uint_32)\
    \ image->columns;\n\n                if (image->columns > 1)\n               \
    \    magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns\
    \ > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n       \
    \         if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n\
    \                      ((image->columns-3)*(mng_info->magn_mx-1));\n         \
    \     }\n\n            if (mng_info->magn_methy == 1)\n              {\n     \
    \           magnified_height=mng_info->magn_mt;\n\n                if (image->rows\
    \ > 1)\n                   magnified_height += mng_info->magn_mb;\n\n        \
    \        if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n\
    \                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\
    \n            else\n              {\n                magnified_height=(png_uint_32)\
    \ image->rows;\n\n                if (image->rows > 1)\n                   magnified_height\
    \ += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n          \
    \         magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows\
    \ > 3)\n                   magnified_height += (png_uint_32)\n               \
    \       ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n        \
    \    if (magnified_height > image->rows ||\n                magnified_width >\
    \ image->columns)\n              {\n                Image\n                  *large_image;\n\
    \n                int\n                  yy;\n\n                Quantum\n    \
    \              *next,\n                  *prev;\n\n                png_uint_16\n\
    \                  magn_methx,\n                  magn_methy;\n\n            \
    \    ssize_t\n                  m,\n                  y;\n\n                register\
    \ Quantum\n                  *n,\n                  *q;\n\n                register\
    \ ssize_t\n                  x;\n\n                /* Allocate next image structure.\
    \  */\n\n                if (logging != MagickFalse)\n                  (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate\
    \ magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\
    \n                if (GetNextImageInList(image) == (Image *) NULL)\n         \
    \         return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\
    \n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\
    \n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\
    \n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n           \
    \     if (magn_methx != 1 || magn_methy != 1)\n                  {\n         \
    \         /*\n                     Scale pixels to unsigned shorts to prevent\n\
    \                     overflow of intermediate values of interpolations\n    \
    \              */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                          exception);\n\n                       for (x=(ssize_t)\
    \ image->columns-1; x >= 0; x--)\n                       {\n                 \
    \         SetPixelRed(image,ScaleQuantumToShort(\n                           \
    \ GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n\
    \                            GetPixelGreen(image,q)),q);\n                   \
    \       SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n\
    \                          SetPixelAlpha(image,ScaleQuantumToShort(\n        \
    \                    GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n\
    \                       }\n\n                       if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                         break;\n                     }\n \
    \                 }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait\
    \ != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\
    \n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n\
    \                    (void) SetImageBackgroundColor(large_image,exception);\n\n\
    \                    if (magn_methx == 4)\n                      magn_methx=2;\n\
    \n                    if (magn_methx == 5)\n                      magn_methx=3;\n\
    \n                    if (magn_methy == 4)\n                      magn_methy=2;\n\
    \n                    if (magn_methy == 5)\n                      magn_methy=3;\n\
    \                  }\n\n                /* magnify the rows into the right side\
    \ of the large image */\n\n                if (logging != MagickFalse)\n     \
    \             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \
    \          \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n\
    \                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n     \
    \           length=(size_t) GetPixelChannels(image)*image->columns;\n        \
    \        next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n      \
    \          prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n  \
    \              if ((prev == (Quantum *) NULL) ||\n                    (next ==\
    \ (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n\
    \                     ThrowReaderException(ResourceLimitError,\n             \
    \          \"MemoryAllocationFailed\");\n                  }\n\n             \
    \   n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n            \
    \    (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y <\
    \ (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n\
    \                    m=(ssize_t) mng_info->magn_mt;\n\n                  else\
    \ if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t)\
    \ mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t)\
    \ image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n     \
    \             else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n     \
    \               m=1;\n\n                  else\n                    m=(ssize_t)\
    \ mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n\
    \                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n\
    \                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n\
    \                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n\
    \                    }\n\n                  for (i=0; i < m; i++, yy++)\n    \
    \              {\n                    register Quantum\n                     \
    \ *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n\
    \                    pixels=prev;\n                    n=next;\n             \
    \       q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n        \
    \              1,exception);\n                    q+=(large_image->columns-image->columns)*\n\
    \                      GetPixelChannels(large_image);\n\n                    for\
    \ (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n       \
    \               /* To do: get color as function of indexes[x] */\n           \
    \           /*\n                      if (image->storage_class == PseudoClass)\n\
    \                        {\n                        }\n                      */\n\
    \n                      if (magn_methy <= 1)\n                        {\n    \
    \                      /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(large_image,GetPixelGreen(image,\n  \
    \                           pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                             pixels),q);\n                        }\n\n     \
    \                 else if (magn_methy == 2 || magn_methy == 4)\n             \
    \           {\n                          if (i == 0)\n                       \
    \     {\n                              SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n\
    \                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                 pixels),q);\n                            }\n\
    \n                          else\n                            {\n            \
    \                  /* Interpolate */\n                              SetPixelRed(large_image,((QM)\
    \ (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n \
    \                                -GetPixelRed(image,pixels)+m))/\n           \
    \                      ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n\
    \                              SetPixelGreen(large_image,((QM) (((ssize_t)\n \
    \                                (2*i*(GetPixelGreen(image,n)\n              \
    \                   -GetPixelGreen(image,pixels)+m))/\n                      \
    \           ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n\
    \                              SetPixelBlue(large_image,((QM) (((ssize_t)\n  \
    \                               (2*i*(GetPixelBlue(image,n)\n                \
    \                 -GetPixelBlue(image,pixels)+m))/\n                         \
    \        ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\
    \n                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n\
    \                                    (2*i*(GetPixelAlpha(image,n)\n          \
    \                          -GetPixelAlpha(image,pixels)+m))\n                \
    \                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n\
    \                            }\n\n                          if (magn_methy ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                        SetPixelAlpha(large_image,GetPixelAlpha(image,\n    \
    \                                pixels),q);\n                              else\n\
    \                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                    n),q);\n                            }\n \
    \                       }\n\n                      else /* if (magn_methy == 3\
    \ || magn_methy == 5) */\n                        {\n                        \
    \  /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n\
    \                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelGreen(large_image,GetPixelGreen(image,\n                          \
    \          pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelAlpha(large_image,GetPixelAlpha(image,\n                          \
    \          pixels),q);\n                          }\n\n                      \
    \    else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n\
    \                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n\
    \                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n\
    \                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n\
    \                                    q);\n                          }\n\n    \
    \                      if (magn_methy == 5)\n                            {\n \
    \                             SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n\
    \                                 (GetPixelAlpha(image,n)\n                  \
    \               -GetPixelAlpha(image,pixels))\n                              \
    \   +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n                        }\n                  \
    \    n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n\
    \                      pixels+=GetPixelChannels(image);\n                    }\
    \ /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception)\
    \ == 0)\n                      break;\n\n                  } /* i */\n       \
    \         } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n\
    \                next=(Quantum *) RelinquishMagickMemory(next);\n\n          \
    \      length=image->columns;\n\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\
    \n                image=large_image;\n\n                mng_info->image=image;\n\
    \n                /* magnify the columns */\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Magnify the columns to %.20g\",\n                    (double)\
    \ image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                {\n                  register Quantum\n                    *pixels;\n\
    \n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n\
    \                  n=pixels+GetPixelChannels(image);\n\n                  for\
    \ (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns;\
    \ x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel()\
    \ */\n\n                    if (x == (ssize_t) (image->columns-length))\n    \
    \                  m=(ssize_t) mng_info->magn_ml;\n\n                    else\
    \ if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                   \
    \   m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ <= 1 &&\n                        x == (ssize_t) image->columns-1)\n        \
    \              m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n    \
    \                else\n                      m=(ssize_t) mng_info->magn_mx;\n\n\
    \                    for (i=0; i < m; i++)\n                    {\n          \
    \            if (magn_methx <= 1)\n                        {\n               \
    \           /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                        }\n\n                      else if (magn_methx == 2 ||\
    \ magn_methx == 4)\n                        {\n                          if (i\
    \ == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                          }\n\n                          /* To do: Rewrite using\
    \ Get/Set***PixelChannel() */\n                          else\n              \
    \              {\n                              /* Interpolate */\n          \
    \                    SetPixelRed(image,(QM) ((2*i*(\n                        \
    \         GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n\
    \                                 /((ssize_t) (m*2))+\n                      \
    \           GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM)\
    \ ((2*i*(\n                                 GetPixelGreen(image,n)\n         \
    \                        -GetPixelGreen(image,pixels))+m)\n                  \
    \               /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\
    \n                              SetPixelBlue(image,(QM) ((2*i*(\n            \
    \                     GetPixelBlue(image,n)\n                                \
    \ -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t)\
    \ (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n\
    \                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(image,(QM) ((2*i*(\n         \
    \                          GetPixelAlpha(image,n)\n                          \
    \         -GetPixelAlpha(image,pixels))+m)\n                                 \
    \  /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n\n                          if (magn_methx ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                     {\n                                 SetPixelAlpha(image,\n\
    \                                   GetPixelAlpha(image,pixels)+0,q);\n      \
    \                        }\n                              else\n             \
    \                 {\n                                 SetPixelAlpha(image,\n \
    \                                  GetPixelAlpha(image,n)+0,q);\n            \
    \                  }\n                            }\n                        }\n\
    \n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n \
    \                       {\n                          /* Replicate nearest */\n\
    \                          if (i <= ((m+1) << 1))\n                          {\n\
    \                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                             SetPixelGreen(image,GetPixelGreen(image,\n     \
    \                            pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                             SetPixelAlpha(image,GetPixelAlpha(image,\n     \
    \                            pixels),q);\n                          }\n\n    \
    \                      else\n                          {\n                   \
    \          SetPixelRed(image,GetPixelRed(image,n),q);\n                      \
    \       SetPixelGreen(image,GetPixelGreen(image,n),q);\n                     \
    \        SetPixelBlue(image,GetPixelBlue(image,n),q);\n                      \
    \       SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                     \
    \     }\n\n                          if (magn_methx == 5)\n                  \
    \          {\n                              /* Interpolate */\n              \
    \                SetPixelAlpha(image,\n                                 (QM) ((2*i*(\
    \ GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n\
    \                                 ((ssize_t) (m*2))\n                        \
    \         +GetPixelAlpha(image,pixels)),q);\n                            }\n \
    \                       }\n                      q+=GetPixelChannels(image);\n\
    \                    }\n                    n+=GetPixelChannels(image);\n    \
    \              }\n\n                  if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n             \
    \   {\n                /*\n                   Rescale pixels to Quantum\n    \
    \            */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                       exception);\n\n                     for (x=(ssize_t) image->columns-1;\
    \ x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n\
    \                          GetPixelRed(image,q)),q);\n                       \
    \ SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n\
    \                        SetPixelBlue(image,ScaleShortToQuantum(\n           \
    \               GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n\
    \                          GetPixelAlpha(image,q)),q);\n                     \
    \   q+=GetPixelChannels(image);\n                     }\n\n                  \
    \   if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               \
    \        break;\n                   }\n                }\n#endif\n           \
    \     if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Finished MAGN processing\");\n              }\n     \
    \     }\n\n        /*\n          Crop_box is with respect to the upper left corner\
    \ of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n\
    \        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n\
    \        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n  \
    \      crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n\
    \        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id]))\
    \ ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n          \
    \  +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n\
    \              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \
    \       \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right)\
    \ &&\n                (crop_box.top < crop_box.bottom))\n              {\n   \
    \             Image\n                  *im;\n\n                RectangleInfo\n\
    \                  crop_info;\n\n                /*\n                  Crop_info\
    \ is with respect to the upper left corner of\n                  the image.\n\
    \                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n\
    \                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n    \
    \            crop_info.width=(size_t) (crop_box.right-crop_box.left);\n      \
    \          crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n       \
    \         image->page.width=image->columns;\n                image->page.height=image->rows;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        im=CropImage(image,&crop_info,exception);\n\n                if (im !=\
    \ (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n\
    \                    image->rows=im->rows;\n                    im=DestroyImage(im);\n\
    \                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n\
    \                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n\
    \                  }\n              }\n\n            else\n              {\n \
    \               /*\n                  No pixels in crop area.  The MNG spec still\
    \ requires\n                  a layer, though, so make a single transparent pixel\
    \ in\n                  the top left corner.\n                */\n           \
    \     image->columns=1;\n                image->rows=1;\n                image->colors=2;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n          \
    \      image->page.width=1;\n                image->page.height=1;\n         \
    \       image->page.x=0;\n                image->page.y=0;\n              }\n\
    \          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n\
    #endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not\
    \ handle depths greater than 16 so reduce it even\n       * if lossy.\n      \
    \ */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte\
    \ properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception)\
    \ != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes\
    \ != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t)\
    \ (image_info->first_scene+image_info->number_scenes))\n            break;\n \
    \       }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"\
    MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n\
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading\
    \ all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers\
    \ && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n\
    \    {\n      /*\n        Insert a background layer if nothing else was found.\n\
    \      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No images found.  Inserting a background layer.\");\n\n      if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n\
    \            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n\
    \          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n \
    \             if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Allocation failed, returning NULL.\");\n\n            \
    \  return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n\
    \        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n\
    \      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n\
    \      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n\
    \      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping ==\
    \ MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n \
    \     mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\
    \n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image)\
    \ != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n\
    \      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \          CoderError,\"Linked list is corrupted, beginning of list not found\"\
    ,\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n\
    \      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n\
    \        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"\
    Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n\
    \      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1\
    \ &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n\
    \      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"image->next for first image is NULL but shouldn't be.\"\
    ,\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found\
    \ == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\
    \n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n\
    \    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\
    \n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay\
    \ */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *)\
    \ NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\
    \n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n\
    \    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging\
    \ != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n\
    \        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n    \
    \  int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image)\
    \ != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n    \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n \
    \     }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n\
    \  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\
    \n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\"\
    );\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\
    \n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\
    \n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n \
    \        next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n\
    \         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n\
    \         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image\
    \ *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n\
    \             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n\
    \             if (GetPreviousImageInList(next) == (Image *) NULL)\n          \
    \     image=next_image;\n             else\n               next->previous->next=next_image;\n\
    \             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\
    \n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\
    \n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n\
    \      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n  \
    \      (double) image->dispose);\n\n      while (GetNextImageInList(image) !=\
    \ (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n     \
    \   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double)\
    \ image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\"\
    );\n\n  return(image);\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nstatic Image *ReadOneMNGImage(MngInfo*\
    \ mng_info, const ImageInfo *image_info,\n     ExceptionInfo *exception)\n{\n\
    \  char\n    page_geometry[MagickPathExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n\
    \    logging;\n\n  volatile int\n    first_mng_object,\n    object_id,\n    term_chunk_found,\n\
    \    skip_to_iend;\n\n  volatile ssize_t\n    image_count=0;\n\n  MagickBooleanType\n\
    \    status;\n\n  MagickOffsetType\n    offset;\n\n  MngBox\n    default_fb,\n\
    \    fb,\n    previous_fb;\n\n#if defined(MNG_INSERT_LAYERS)\n  PixelInfo\n  \
    \  mng_background_color;\n#endif\n\n  register unsigned char\n    *p;\n\n  register\
    \ ssize_t\n    i;\n\n  size_t\n    count;\n\n  ssize_t\n    loop_level;\n\n  volatile\
    \ short\n    skipping_loop;\n\n#if defined(MNG_INSERT_LAYERS)\n  unsigned int\n\
    \    mandatory_back=0;\n#endif\n\n  volatile unsigned int\n#ifdef MNG_OBJECT_BUFFERS\n\
    \    mng_background_object=0,\n#endif\n    mng_type=0;   /* 0: PNG or JNG; 1:\
    \ MNG; 2: MNG-LC; 3: MNG-VLC */\n\n  size_t\n    default_frame_timeout,\n    frame_timeout,\n\
    #if defined(MNG_INSERT_LAYERS)\n    image_height,\n    image_width,\n#endif\n\
    \    length;\n\n  /* These delays are all measured in image ticks_per_second,\n\
    \   * not in MNG ticks_per_second\n   */\n  volatile size_t\n    default_frame_delay,\n\
    \    final_delay,\n    final_image_delay,\n    frame_delay,\n#if defined(MNG_INSERT_LAYERS)\n\
    \    insert_layers,\n#endif\n    mng_iterations=1,\n    simplicity=0,\n    subframe_height=0,\n\
    \    subframe_width=0;\n\n  previous_fb.top=0;\n  previous_fb.bottom=0;\n  previous_fb.left=0;\n\
    \  previous_fb.right=0;\n  default_fb.top=0;\n  default_fb.bottom=0;\n  default_fb.left=0;\n\
    \  default_fb.right=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \    \"  Enter ReadOneMNGImage()\");\n\n  image=mng_info->image;\n\n  if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n    {\n      char\n        magic_number[MagickPathExtent];\n\n \
    \     /* Verify MNG signature.  */\n      count=(size_t) ReadBlob(image,8,(unsigned\
    \ char *) magic_number);\n      if (memcmp(magic_number,\"\\212MNG\\r\\n\\032\\\
    n\",8) != 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n\n      /* Initialize some nonzero members of the MngInfo structure.  */\n\
    \      for (i=0; i < MNG_MAX_OBJECTS; i++)\n      {\n        mng_info->object_clip[i].right=(ssize_t)\
    \ PNG_UINT_31_MAX;\n        mng_info->object_clip[i].bottom=(ssize_t) PNG_UINT_31_MAX;\n\
    \      }\n      mng_info->exists[0]=MagickTrue;\n    }\n\n  skipping_loop=(-1);\n\
    \  first_mng_object=MagickTrue;\n  mng_type=0;\n#if defined(MNG_INSERT_LAYERS)\n\
    \  insert_layers=MagickFalse; /* should be False during convert or mogrify */\n\
    #endif\n  default_frame_delay=0;\n  default_frame_timeout=0;\n  frame_delay=0;\n\
    \  final_delay=1;\n  mng_info->ticks_per_second=1UL*image->ticks_per_second;\n\
    \  object_id=0;\n  skip_to_iend=MagickFalse;\n  term_chunk_found=MagickFalse;\n\
    \  mng_info->framing_mode=1;\n#if defined(MNG_INSERT_LAYERS)\n  mandatory_back=MagickFalse;\n\
    #endif\n#if defined(MNG_INSERT_LAYERS)\n  mng_background_color=image->background_color;\n\
    #endif\n  default_fb=mng_info->frame;\n  previous_fb=mng_info->frame;\n  do\n\
    \  {\n    char\n      type[MagickPathExtent];\n\n    if (LocaleCompare(image_info->magick,\"\
    MNG\") == 0)\n      {\n        unsigned char\n          *chunk;\n\n        /*\n\
    \          Read a new chunk.\n        */\n        type[0]='\\0';\n        (void)\
    \ ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n        length=ReadBlobMSBLong(image);\n\
    \        count=(size_t) ReadBlob(image,4,(unsigned char *) type);\n\n        if\
    \ (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \           \"  Reading MNG chunk type %c%c%c%c, length: %.20g\",\n          \
    \ type[0],type[1],type[2],type[3],(double) length);\n\n        if (length > PNG_UINT_31_MAX)\n\
    \          {\n            status=MagickFalse;\n            break;\n          }\n\
    \n        if (count == 0)\n          ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n\n        p=NULL;\n        chunk=(unsigned char *) NULL;\n\n\
    \        if (length != 0)\n          {\n            if (length > GetBlobSize(image))\n\
    \              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\"\
    );\n            chunk=(unsigned char *) AcquireQuantumMemory(length+\n       \
    \      MagickPathExtent,sizeof(*chunk));\n\n            if (chunk == (unsigned\
    \ char *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n\n            for (i=0; i < (ssize_t) length; i++)\n            {\n      \
    \        int\n                c;\n\n              c=ReadBlobByte(image);\n   \
    \           if (c == EOF)\n                break;\n              chunk[i]=(unsigned\
    \ char) c;\n            }\n\n            p=chunk;\n          }\n\n        (void)\
    \ ReadBlobMSBLong(image);  /* read crc word */\n\n#if !defined(JNG_SUPPORTED)\n\
    \        if (memcmp(type,mng_JHDR,4) == 0)\n          {\n            skip_to_iend=MagickTrue;\n\
    \n            if (mng_info->jhdr_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"JNGCompressNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->jhdr_warning++;\n          }\n#endif\n        if (memcmp(type,mng_DHDR,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->dhdr_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DeltaPNGNotSupported\",\"`%s'\",image->filename);\n\
    \n            mng_info->dhdr_warning++;\n          }\n        if (memcmp(type,mng_MEND,4)\
    \ == 0)\n          break;\n\n        if (skip_to_iend)\n          {\n        \
    \    if (memcmp(type,mng_IEND,4) == 0)\n              skip_to_iend=MagickFalse;\n\
    \n            if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skip to IEND.\");\n\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_MHDR,4) == 0)\n          {\n            if (length\
    \ != 28)\n              {\n                chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n \
    \             }\n\n            mng_info->mng_width=(size_t) ((p[0] << 24) | (p[1]\
    \ << 16) |\n                (p[2] << 8) | p[3]);\n\n            mng_info->mng_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n                (p[6] << 8) | p[7]);\n\n   \
    \         if (logging != MagickFalse)\n              {\n                (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  MNG width:\
    \ %.20g\",(double) mng_info->mng_width);\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  MNG height: %.20g\",(double) mng_info->mng_height);\n \
    \             }\n\n            p+=8;\n            mng_info->ticks_per_second=(size_t)\
    \ mng_get_long(p);\n\n            if (mng_info->ticks_per_second == 0)\n     \
    \         default_frame_delay=0;\n\n            else\n              default_frame_delay=1UL*image->ticks_per_second/\n\
    \                mng_info->ticks_per_second;\n\n            frame_delay=default_frame_delay;\n\
    \            simplicity=0;\n\n            p+=16;\n            simplicity=(size_t)\
    \ mng_get_long(p);\n\n            mng_type=1;    /* Full MNG */\n\n          \
    \  if ((simplicity != 0) && ((simplicity | 11) == 11))\n              mng_type=2;\
    \ /* LC */\n\n            if ((simplicity != 0) && ((simplicity | 9) == 9))\n\
    \              mng_type=3; /* VLC */\n\n#if defined(MNG_INSERT_LAYERS)\n     \
    \       if (mng_type != 3)\n              insert_layers=MagickTrue;\n#endif\n\
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \      {\n                /* Allocate next image structure.  */\n            \
    \    AcquireNextImage(image_info,image,exception);\n\n                if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                  return((Image *) NULL);\n\n          \
    \      image=SyncNextImageInList(image);\n                mng_info->image=image;\n\
    \              }\n\n            if ((mng_info->mng_width > 65535L) ||\n      \
    \          (mng_info->mng_height > 65535L))\n              {\n               \
    \ chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n                ThrowReaderException(ImageError,\"\
    WidthOrHeightExceedsLimit\");\n              }\n\n            (void) FormatLocaleString(page_geometry,MagickPathExtent,\n\
    \              \"%.20gx%.20g+0+0\",(double) mng_info->mng_width,(double)\n   \
    \           mng_info->mng_height);\n\n            mng_info->frame.left=0;\n  \
    \          mng_info->frame.right=(ssize_t) mng_info->mng_width;\n            mng_info->frame.top=0;\n\
    \            mng_info->frame.bottom=(ssize_t) mng_info->mng_height;\n        \
    \    mng_info->clip=default_fb=previous_fb=mng_info->frame;\n\n            for\
    \ (i=0; i < MNG_MAX_OBJECTS; i++)\n              mng_info->object_clip[i]=mng_info->frame;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_TERM,4) == 0)\n  \
    \        {\n            int\n              repeat=0;\n\n            if (length\
    \ != 0)\n              repeat=p[0];\n\n            if (repeat == 3)\n        \
    \      {\n                final_delay=(png_uint_32) mng_get_long(&p[2]);\n   \
    \             mng_iterations=(png_uint_32) mng_get_long(&p[6]);\n\n          \
    \      if (mng_iterations == PNG_UINT_31_MAX)\n                  mng_iterations=0;\n\
    \n                image->iterations=mng_iterations;\n                term_chunk_found=MagickTrue;\n\
    \              }\n\n            if (logging != MagickFalse)\n              {\n\
    \                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \
    \           \"    repeat=%d,  final_delay=%.20g,  iterations=%.20g\",\n      \
    \            repeat,(double) final_delay, (double) image->iterations);\n     \
    \         }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_DEFI,4) == 0)\n\
    \          {\n            if (mng_type == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"DEFI chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (length < 2)\n        \
    \      {\n                if (chunk)\n                  chunk=(unsigned char *)\
    \ RelinquishMagickMemory(chunk);\n                ThrowReaderException(CorruptImageError,\"\
    CorruptImage\");\n              }\n\n            object_id=(p[0] << 8) | p[1];\n\
    \n            if (mng_type == 2 && object_id != 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"Nonzero object_id in MNG-LC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if (object_id > MNG_MAX_OBJECTS)\n\
    \              {\n                /*\n                  Instead of using a warning\
    \ we should allocate a larger\n                  MngInfo structure and continue.\n\
    \                */\n                (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                  CoderError,\"object id too large\",\"`%s'\",image->filename);\n\
    \                object_id=MNG_MAX_OBJECTS;\n              }\n\n            if\
    \ (mng_info->exists[object_id])\n              if (mng_info->frozen[object_id])\n\
    \                {\n                  chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \                  (void) ThrowMagickException(exception,\n                  \
    \  GetMagickModule(),CoderError,\n                    \"DEFI cannot redefine a\
    \ frozen MNG object\",\"`%s'\",\n                    image->filename);\n     \
    \             continue;\n                }\n\n            mng_info->exists[object_id]=MagickTrue;\n\
    \n            if (length > 2)\n              mng_info->invisible[object_id]=p[2];\n\
    \n            /*\n              Extract object offset info.\n            */\n\
    \            if (length > 11)\n              {\n                mng_info->x_off[object_id]=(ssize_t)\
    \ ((p[4] << 24) |\n                    (p[5] << 16) | (p[6] << 8) | p[7]);\n\n\
    \                mng_info->y_off[object_id]=(ssize_t) ((p[8] << 24) |\n      \
    \              (p[9] << 16) | (p[10] << 8) | p[11]);\n\n                if (logging\
    \ != MagickFalse)\n                  {\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                      \"  x_off[%d]: %.20g,  y_off[%d]: %.20g\",\n          \
    \            object_id,(double) mng_info->x_off[object_id],\n                \
    \      object_id,(double) mng_info->y_off[object_id]);\n                  }\n\
    \              }\n\n            /*\n              Extract object clipping info.\n\
    \            */\n            if (length > 27)\n              mng_info->object_clip[object_id]=mng_read_box(mng_info->frame,0,\n\
    \                &p[12]);\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n        if (memcmp(type,mng_bKGD,4) == 0)\n\
    \          {\n            mng_info->have_global_bkgd=MagickFalse;\n\n        \
    \    if (length > 5)\n              {\n                mng_info->mng_global_bkgd.red=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[0] << 8) | p[1]));\n\
    \n                mng_info->mng_global_bkgd.green=\n                  ScaleShortToQuantum((unsigned\
    \ short) ((p[2] << 8) | p[3]));\n\n                mng_info->mng_global_bkgd.blue=\n\
    \                  ScaleShortToQuantum((unsigned short) ((p[4] << 8) | p[5]));\n\
    \n                mng_info->have_global_bkgd=MagickTrue;\n              }\n\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n        if (memcmp(type,mng_BACK,4) == 0)\n     \
    \     {\n#if defined(MNG_INSERT_LAYERS)\n            if (length > 6)\n       \
    \       mandatory_back=p[6];\n\n            else\n              mandatory_back=0;\n\
    \n            if (mandatory_back && length > 5)\n              {\n           \
    \     mng_background_color.red=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[0] << 8) | p[1]));\n\n                mng_background_color.green=\n\
    \                    ScaleShortToQuantum((unsigned short) ((p[2] << 8) | p[3]));\n\
    \n                mng_background_color.blue=\n                    ScaleShortToQuantum((unsigned\
    \ short) ((p[4] << 8) | p[5]));\n\n                mng_background_color.alpha=OpaqueAlpha;\n\
    \              }\n\n#ifdef MNG_OBJECT_BUFFERS\n            if (length > 8)\n \
    \             mng_background_object=(p[7] << 8) | p[8];\n#endif\n#endif\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_PLTE,4) == 0)\n          {\n     \
    \       /* Read global PLTE.  */\n\n            if (length && (length < 769))\n\
    \              {\n                if (mng_info->global_plte == (png_colorp) NULL)\n\
    \                  mng_info->global_plte=(png_colorp) AcquireQuantumMemory(256,\n\
    \                    sizeof(*mng_info->global_plte));\n\n                for (i=0;\
    \ i < (ssize_t) (length/3); i++)\n                {\n                  mng_info->global_plte[i].red=p[3*i];\n\
    \                  mng_info->global_plte[i].green=p[3*i+1];\n                \
    \  mng_info->global_plte[i].blue=p[3*i+2];\n                }\n\n            \
    \    mng_info->global_plte_length=(unsigned int) (length/3);\n              }\n\
    #ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n            {\n         \
    \     mng_info->global_plte[i].red=i;\n              mng_info->global_plte[i].green=i;\n\
    \              mng_info->global_plte[i].blue=i;\n            }\n\n           \
    \ if (length != 0)\n              mng_info->global_plte_length=256;\n#endif\n\
    \            else\n              mng_info->global_plte_length=0;\n\n         \
    \   chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_tRNS,4) == 0)\n          {\n     \
    \       /* read global tRNS */\n\n            if (length > 0 && length < 257)\n\
    \              for (i=0; i < (ssize_t) length; i++)\n                mng_info->global_trns[i]=p[i];\n\
    \n#ifdef MNG_LOOSE\n            for ( ; i < 256; i++)\n              mng_info->global_trns[i]=255;\n\
    #endif\n            mng_info->global_trns_length=(unsigned int) length;\n    \
    \        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n        if (memcmp(type,mng_gAMA,4) == 0)\n          {\n       \
    \     if (length == 4)\n              {\n                ssize_t\n           \
    \       igamma;\n\n                igamma=mng_get_long(p);\n                mng_info->global_gamma=((float)\
    \ igamma)*0.00001;\n                mng_info->have_global_gama=MagickTrue;\n \
    \             }\n\n            else\n              mng_info->have_global_gama=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_cHRM,4) == 0)\n  \
    \        {\n            /* Read global cHRM */\n\n            if (length == 32)\n\
    \              {\n                mng_info->global_chrm.white_point.x=0.00001*mng_get_long(p);\n\
    \                mng_info->global_chrm.white_point.y=0.00001*mng_get_long(&p[4]);\n\
    \                mng_info->global_chrm.red_primary.x=0.00001*mng_get_long(&p[8]);\n\
    \                mng_info->global_chrm.red_primary.y=0.00001*\n              \
    \    mng_get_long(&p[12]);\n                mng_info->global_chrm.green_primary.x=0.00001*\n\
    \                  mng_get_long(&p[16]);\n                mng_info->global_chrm.green_primary.y=0.00001*\n\
    \                  mng_get_long(&p[20]);\n                mng_info->global_chrm.blue_primary.x=0.00001*\n\
    \                  mng_get_long(&p[24]);\n                mng_info->global_chrm.blue_primary.y=0.00001*\n\
    \                  mng_get_long(&p[28]);\n                mng_info->have_global_chrm=MagickTrue;\n\
    \              }\n            else\n              mng_info->have_global_chrm=MagickFalse;\n\
    \n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n       \
    \     continue;\n          }\n\n        if (memcmp(type,mng_sRGB,4) == 0)\n  \
    \        {\n            /*\n              Read global sRGB.\n            */\n\
    \            if (length != 0)\n              {\n                mng_info->global_srgb_intent=\n\
    \                  Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n  \
    \              mng_info->have_global_srgb=MagickTrue;\n              }\n     \
    \       else\n              mng_info->have_global_srgb=MagickFalse;\n\n      \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_iCCP,4) == 0)\n          {\n     \
    \       /* To do: */\n\n            /*\n              Read global iCCP.\n    \
    \        */\n            if (length != 0)\n              chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n\n            continue;\n          }\n\n\
    \        if (memcmp(type,mng_FRAM,4) == 0)\n          {\n            if (mng_type\
    \ == 3)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"FRAM chunk found in MNG-VLC datastream\",\"`%s'\"\
    ,\n                image->filename);\n\n            if ((mng_info->framing_mode\
    \ == 2) || (mng_info->framing_mode == 4))\n              image->delay=frame_delay;\n\
    \n            frame_delay=default_frame_delay;\n            frame_timeout=default_frame_timeout;\n\
    \            fb=default_fb;\n\n            if (length != 0)\n              if\
    \ (p[0])\n                mng_info->framing_mode=p[0];\n\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"    Framing_mode=%d\",mng_info->framing_mode);\n\n        \
    \    if (length > 6)\n              {\n                /* Note the delay and frame\
    \ clipping boundaries.  */\n\n                p++; /* framing mode */\n\n    \
    \            while (*p && ((p-chunk) < (ssize_t) length))\n                  p++;\
    \  /* frame name */\n\n                p++;  /* frame name terminator */\n\n \
    \               if ((p-chunk) < (ssize_t) (length-4))\n                  {\n \
    \                   int\n                      change_delay,\n               \
    \       change_timeout,\n                      change_clipping;\n\n          \
    \          change_delay=(*p++);\n                    change_timeout=(*p++);\n\
    \                    change_clipping=(*p++);\n                    p++; /* change_sync\
    \ */\n\n                    if (change_delay)\n                      {\n     \
    \                   frame_delay=1UL*image->ticks_per_second*\n               \
    \           mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_delay/=mng_info->ticks_per_second;\n\n\
    \                        else\n                          frame_delay=PNG_UINT_31_MAX;\n\
    \n                        if (change_delay == 2)\n                          default_frame_delay=frame_delay;\n\
    \n                        p+=4;\n\n                        if (logging != MagickFalse)\n\
    \                          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                            \"    Framing_delay=%.20g\",(double) frame_delay);\n\
    \                      }\n\n                    if (change_timeout)\n        \
    \              {\n                        frame_timeout=1UL*image->ticks_per_second*\n\
    \                          mng_get_long(p);\n\n                        if (mng_info->ticks_per_second\
    \ != 0)\n                          frame_timeout/=mng_info->ticks_per_second;\n\
    \n                        else\n                          frame_timeout=PNG_UINT_31_MAX;\n\
    \n                        if (change_timeout == 2)\n                         \
    \ default_frame_timeout=frame_timeout;\n\n                        p+=4;\n\n  \
    \                      if (logging != MagickFalse)\n                         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \
    \      \"    Framing_timeout=%.20g\",(double) frame_timeout);\n              \
    \        }\n\n                    if (change_clipping)\n                     \
    \ {\n                        fb=mng_read_box(previous_fb,(char) p[0],&p[1]);\n\
    \                        p+=17;\n                        previous_fb=fb;\n\n \
    \                       if (logging != MagickFalse)\n                        \
    \  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \
    \       \"    Frame_clip: L=%.20g R=%.20g T=%.20g B=%.20g\",\n               \
    \             (double) fb.left,(double) fb.right,(double) fb.top,\n          \
    \                  (double) fb.bottom);\n\n                        if (change_clipping\
    \ == 2)\n                          default_fb=fb;\n                      }\n \
    \                 }\n              }\n            mng_info->clip=fb;\n       \
    \     mng_info->clip=mng_minimum_box(fb,mng_info->frame);\n\n            subframe_width=(size_t)\
    \ (mng_info->clip.right\n               -mng_info->clip.left);\n\n           \
    \ subframe_height=(size_t) (mng_info->clip.bottom\n               -mng_info->clip.top);\n\
    \            /*\n              Insert a background layer behind the frame if framing_mode\
    \ is 4.\n            */\n#if defined(MNG_INSERT_LAYERS)\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"   subframe_width=%.20g, subframe_height=%.20g\",(double)\n\
    \                subframe_width,(double) subframe_height);\n\n            if (insert_layers\
    \ && (mng_info->framing_mode == 4) &&\n                (subframe_width) && (subframe_height))\n\
    \              {\n                /* Allocate next image structure.  */\n    \
    \            if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        \
    \          {\n                    AcquireNextImage(image_info,image,exception);\n\
    \n                    if (GetNextImageInList(image) == (Image *) NULL)\n     \
    \                 return(DestroyImageList(image));\n\n                    image=SyncNextImageInList(image);\n\
    \                  }\n\n                mng_info->image=image;\n\n           \
    \     if (term_chunk_found)\n                  {\n                    image->start_loop=MagickTrue;\n\
    \                    image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                image->columns=subframe_width;\n                image->rows=subframe_height;\n\
    \                image->page.width=subframe_width;\n                image->page.height=subframe_height;\n\
    \                image->page.x=mng_info->clip.left;\n                image->page.y=mng_info->clip.top;\n\
    \                image->background_color=mng_background_color;\n             \
    \   image->alpha_trait=UndefinedPixelTrait;\n                image->delay=0;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n\n        \
    \        if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Insert backgd layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                    (double) mng_info->clip.left,\n                    (double)\
    \ mng_info->clip.right,\n                    (double) mng_info->clip.top,\n  \
    \                  (double) mng_info->clip.bottom);\n              }\n#endif\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n\n        if (memcmp(type,mng_CLIP,4) == 0)\n   \
    \       {\n            unsigned int\n              first_object,\n           \
    \   last_object;\n\n            /*\n              Read CLIP.\n            */\n\
    \            if (length > 3)\n              {\n                first_object=(p[0]\
    \ << 8) | p[1];\n                last_object=(p[2] << 8) | p[3];\n           \
    \     p+=4;\n\n                for (i=(int) first_object; i <= (int) last_object;\
    \ i++)\n                {\n                  if (mng_info->exists[i] && !mng_info->frozen[i])\n\
    \                    {\n                      MngBox\n                       \
    \ box;\n\n                      box=mng_info->object_clip[i];\n              \
    \        if ((p-chunk) < (ssize_t) (length-17))\n                        mng_info->object_clip[i]=\n\
    \                           mng_read_box(box,(char) p[0],&p[1]);\n           \
    \         }\n                }\n\n              }\n            chunk=(unsigned\
    \ char *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\
    \n        if (memcmp(type,mng_SAVE,4) == 0)\n          {\n            for (i=1;\
    \ i < MNG_MAX_OBJECTS; i++)\n              if (mng_info->exists[i])\n        \
    \        {\n                 mng_info->frozen[i]=MagickTrue;\n#ifdef MNG_OBJECT_BUFFERS\n\
    \                 if (mng_info->ob[i] != (MngBuffer *) NULL)\n               \
    \     mng_info->ob[i]->frozen=MagickTrue;\n#endif\n                }\n\n     \
    \       if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n\n        if ((memcmp(type,mng_DISC,4) ==\
    \ 0) || (memcmp(type,mng_SEEK,4) == 0))\n          {\n            /* Read DISC\
    \ or SEEK.  */\n\n            if ((length == 0) || !memcmp(type,mng_SEEK,4))\n\
    \              {\n                for (i=1; i < MNG_MAX_OBJECTS; i++)\n      \
    \            MngInfoDiscardObject(mng_info,i);\n              }\n\n          \
    \  else\n              {\n                register ssize_t\n                 \
    \ j;\n\n                for (j=1; j < (ssize_t) length; j+=2)\n              \
    \  {\n                  i=p[j-1] << 8 | p[j];\n                  MngInfoDiscardObject(mng_info,i);\n\
    \                }\n              }\n\n            if (length != 0)\n        \
    \      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n            continue;\n\
    \          }\n\n        if (memcmp(type,mng_MOVE,4) == 0)\n          {\n     \
    \       size_t\n              first_object,\n              last_object;\n\n  \
    \          /* read MOVE */\n\n            if (length > 3)\n            {\n   \
    \           first_object=(p[0] << 8) | p[1];\n              last_object=(p[2]\
    \ << 8) | p[3];\n              p+=4;\n\n              for (i=(ssize_t) first_object;\
    \ i <= (ssize_t) last_object; i++)\n              {\n                if ((i <\
    \ 0) || (i >= MNG_MAX_OBJECTS))\n                  continue;\n\n             \
    \   if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                    (p-chunk)\
    \ < (ssize_t) (length-8))\n                  {\n                    MngPair\n\
    \                      new_pair;\n\n                    MngPair\n            \
    \          old_pair;\n\n                    old_pair.a=mng_info->x_off[i];\n \
    \                   old_pair.b=mng_info->y_off[i];\n                    new_pair=mng_read_pair(old_pair,(int)\
    \ p[0],&p[1]);\n                    mng_info->x_off[i]=new_pair.a;\n         \
    \           mng_info->y_off[i]=new_pair.b;\n                  }\n            \
    \  }\n            }\n\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_LOOP,4) ==\
    \ 0)\n          {\n            ssize_t loop_iters=1;\n            if (length >\
    \ 4)\n              {\n                loop_level=chunk[0];\n                mng_info->loop_active[loop_level]=1;\
    \  /* mark loop active */\n\n                /* Record starting point.  */\n \
    \               loop_iters=mng_get_long(&chunk[1]);\n\n                if (logging\
    \ != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  LOOP level %.20g has %.20g iterations \",\n         \
    \           (double) loop_level, (double) loop_iters);\n\n                if (loop_iters\
    \ == 0)\n                  skipping_loop=loop_level;\n\n                else\n\
    \                  {\n                    mng_info->loop_jump[loop_level]=TellBlob(image);\n\
    \                    mng_info->loop_count[loop_level]=loop_iters;\n          \
    \        }\n\n                mng_info->loop_iteration[loop_level]=0;\n      \
    \        }\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_ENDL,4) ==\
    \ 0)\n          {\n            if (length > 0)\n              {\n            \
    \    loop_level=chunk[0];\n\n                if (skipping_loop > 0)\n        \
    \          {\n                    if (skipping_loop == loop_level)\n         \
    \             {\n                        /*\n                          Found end\
    \ of zero-iteration loop.\n                        */\n                      \
    \  skipping_loop=(-1);\n                        mng_info->loop_active[loop_level]=0;\n\
    \                      }\n                  }\n\n                else\n      \
    \            {\n                    if (mng_info->loop_active[loop_level] == 1)\n\
    \                      {\n                        mng_info->loop_count[loop_level]--;\n\
    \                        mng_info->loop_iteration[loop_level]++;\n\n         \
    \               if (logging != MagickFalse)\n                          (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \" \
    \ ENDL: LOOP level %.20g has %.20g remaining iters\",\n                      \
    \      (double) loop_level,(double)\n                            mng_info->loop_count[loop_level]);\n\
    \n                        if (mng_info->loop_count[loop_level] != 0)\n       \
    \                   {\n                            offset=\n                 \
    \             SeekBlob(image,mng_info->loop_jump[loop_level],\n              \
    \                SEEK_SET);\n\n                            if (offset < 0)\n \
    \                             {\n                                chunk=(unsigned\
    \ char *) RelinquishMagickMemory(\n                                  chunk);\n\
    \                                ThrowReaderException(CorruptImageError,\n   \
    \                               \"ImproperImageHeader\");\n                  \
    \            }\n                          }\n\n                        else\n\
    \                          {\n                            short\n            \
    \                  last_level;\n\n                            /*\n           \
    \                   Finished loop.\n                            */\n         \
    \                   mng_info->loop_active[loop_level]=0;\n                   \
    \         last_level=(-1);\n                            for (i=0; i < loop_level;\
    \ i++)\n                              if (mng_info->loop_active[i] == 1)\n   \
    \                             last_level=(short) i;\n                        \
    \    loop_level=last_level;\n                          }\n                   \
    \   }\n                  }\n              }\n\n            chunk=(unsigned char\
    \ *) RelinquishMagickMemory(chunk);\n            continue;\n          }\n\n  \
    \      if (memcmp(type,mng_CLON,4) == 0)\n          {\n            if (mng_info->clon_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"CLON is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->clon_warning++;\n      \
    \    }\n\n        if (memcmp(type,mng_MAGN,4) == 0)\n          {\n           \
    \ png_uint_16\n              magn_first,\n              magn_last,\n         \
    \     magn_mb,\n              magn_ml,\n              magn_mr,\n             \
    \ magn_mt,\n              magn_mx,\n              magn_my,\n              magn_methx,\n\
    \              magn_methy;\n\n            if (length > 1)\n              magn_first=(p[0]\
    \ << 8) | p[1];\n\n            else\n              magn_first=0;\n\n         \
    \   if (length > 3)\n              magn_last=(p[2] << 8) | p[3];\n\n         \
    \   else\n              magn_last=magn_first;\n#ifndef MNG_OBJECT_BUFFERS\n  \
    \          if (magn_first || magn_last)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"MAGN\
    \ is not implemented yet for nonzero objects\",\n                     \"`%s'\"\
    ,image->filename);\n\n                   mng_info->magn_warning++;\n         \
    \       }\n#endif\n            if (length > 4)\n              magn_methx=p[4];\n\
    \n            else\n              magn_methx=0;\n\n            if (length > 6)\n\
    \              magn_mx=(p[5] << 8) | p[6];\n\n            else\n             \
    \ magn_mx=1;\n\n            if (magn_mx == 0)\n              magn_mx=1;\n\n  \
    \          if (length > 8)\n              magn_my=(p[7] << 8) | p[8];\n\n    \
    \        else\n              magn_my=magn_mx;\n\n            if (magn_my == 0)\n\
    \              magn_my=1;\n\n            if (length > 10)\n              magn_ml=(p[9]\
    \ << 8) | p[10];\n\n            else\n              magn_ml=magn_mx;\n\n     \
    \       if (magn_ml == 0)\n              magn_ml=1;\n\n            if (length\
    \ > 12)\n              magn_mr=(p[11] << 8) | p[12];\n\n            else\n   \
    \           magn_mr=magn_mx;\n\n            if (magn_mr == 0)\n              magn_mr=1;\n\
    \n            if (length > 14)\n              magn_mt=(p[13] << 8) | p[14];\n\n\
    \            else\n              magn_mt=magn_my;\n\n            if (magn_mt ==\
    \ 0)\n              magn_mt=1;\n\n            if (length > 16)\n             \
    \ magn_mb=(p[15] << 8) | p[16];\n\n            else\n              magn_mb=magn_my;\n\
    \n            if (magn_mb == 0)\n              magn_mb=1;\n\n            if (length\
    \ > 17)\n              magn_methy=p[17];\n\n            else\n              magn_methy=magn_methx;\n\
    \n\n            if (magn_methx > 5 || magn_methy > 5)\n              if (mng_info->magn_warning\
    \ == 0)\n                {\n                  (void) ThrowMagickException(exception,\n\
    \                     GetMagickModule(),CoderError,\n                     \"Unknown\
    \ MAGN method in MNG datastream\",\"`%s'\",\n                     image->filename);\n\
    \n                   mng_info->magn_warning++;\n                }\n#ifdef MNG_OBJECT_BUFFERS\n\
    \          /* Magnify existing objects in the range magn_first to magn_last */\n\
    #endif\n            if (magn_first == 0 || magn_last == 0)\n              {\n\
    \                /* Save the magnification factors for object 0 */\n         \
    \       mng_info->magn_mb=magn_mb;\n                mng_info->magn_ml=magn_ml;\n\
    \                mng_info->magn_mr=magn_mr;\n                mng_info->magn_mt=magn_mt;\n\
    \                mng_info->magn_mx=magn_mx;\n                mng_info->magn_my=magn_my;\n\
    \                mng_info->magn_methx=magn_methx;\n                mng_info->magn_methy=magn_methy;\n\
    \              }\n          }\n\n        if (memcmp(type,mng_PAST,4) == 0)\n \
    \         {\n            if (mng_info->past_warning == 0)\n              (void)\
    \ ThrowMagickException(exception,GetMagickModule(),\n                CoderError,\"\
    PAST is not implemented yet\",\"`%s'\",\n                image->filename);\n\n\
    \            mng_info->past_warning++;\n          }\n\n        if (memcmp(type,mng_SHOW,4)\
    \ == 0)\n          {\n            if (mng_info->show_warning == 0)\n         \
    \     (void) ThrowMagickException(exception,GetMagickModule(),\n             \
    \   CoderError,\"SHOW is not implemented yet\",\"`%s'\",\n                image->filename);\n\
    \n            mng_info->show_warning++;\n          }\n\n        if (memcmp(type,mng_sBIT,4)\
    \ == 0)\n          {\n            if (length < 4)\n              mng_info->have_global_sbit=MagickFalse;\n\
    \n            else\n              {\n                mng_info->global_sbit.gray=p[0];\n\
    \                mng_info->global_sbit.red=p[0];\n                mng_info->global_sbit.green=p[1];\n\
    \                mng_info->global_sbit.blue=p[2];\n                mng_info->global_sbit.alpha=p[3];\n\
    \                mng_info->have_global_sbit=MagickTrue;\n             }\n    \
    \      }\n        if (memcmp(type,mng_pHYs,4) == 0)\n          {\n           \
    \ if (length > 8)\n              {\n                mng_info->global_x_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(p);\n                mng_info->global_y_pixels_per_unit=\n\
    \                    (size_t) mng_get_long(&p[4]);\n                mng_info->global_phys_unit_type=p[8];\n\
    \                mng_info->have_global_phys=MagickTrue;\n              }\n\n \
    \           else\n              mng_info->have_global_phys=MagickFalse;\n    \
    \      }\n        if (memcmp(type,mng_pHYg,4) == 0)\n          {\n           \
    \ if (mng_info->phyg_warning == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"pHYg is not implemented.\",\"`%s'\",image->filename);\n\
    \n            mng_info->phyg_warning++;\n          }\n        if (memcmp(type,mng_BASI,4)\
    \ == 0)\n          {\n            skip_to_iend=MagickTrue;\n\n            if (mng_info->basi_warning\
    \ == 0)\n              (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \                CoderError,\"BASI is not implemented yet\",\"`%s'\",\n      \
    \          image->filename);\n\n            mng_info->basi_warning++;\n#ifdef\
    \ MNG_BASI_SUPPORTED\n            basi_width=(size_t) ((p[0] << 24) | (p[1] <<\
    \ 16) |\n               (p[2] << 8) | p[3]);\n            basi_height=(size_t)\
    \ ((p[4] << 24) | (p[5] << 16) |\n               (p[6] << 8) | p[7]);\n      \
    \      basi_color_type=p[8];\n            basi_compression_method=p[9];\n    \
    \        basi_filter_type=p[10];\n            basi_interlace_method=p[11];\n \
    \           if (length > 11)\n              basi_red=(p[12] << 8) & p[13];\n\n\
    \            else\n              basi_red=0;\n\n            if (length > 13)\n\
    \              basi_green=(p[14] << 8) & p[15];\n\n            else\n        \
    \      basi_green=0;\n\n            if (length > 15)\n              basi_blue=(p[16]\
    \ << 8) & p[17];\n\n            else\n              basi_blue=0;\n\n         \
    \   if (length > 17)\n              basi_alpha=(p[18] << 8) & p[19];\n\n     \
    \       else\n              {\n                if (basi_sample_depth == 16)\n\
    \                  basi_alpha=65535L;\n                else\n                \
    \  basi_alpha=255;\n              }\n\n            if (length > 19)\n        \
    \      basi_viewable=p[20];\n\n            else\n              basi_viewable=0;\n\
    \n#endif\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            continue;\n          }\n\n        if (memcmp(type,mng_IHDR,4)\n#if\
    \ defined(JNG_SUPPORTED)\n            && memcmp(type,mng_JHDR,4)\n#endif\n   \
    \         )\n          {\n            /* Not an IHDR or JHDR chunk */\n      \
    \      if (length != 0)\n              chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n            continue;\n          }\n/* Process IHDR */\n        if (logging\
    \ != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  Processing %c%c%c%c chunk\",type[0],type[1],type[2],type[3]);\n\
    \n        mng_info->exists[object_id]=MagickTrue;\n        mng_info->viewable[object_id]=MagickTrue;\n\
    \n        if (mng_info->invisible[object_id])\n          {\n            if (logging\
    \ != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Skipping invisible object\");\n\n            skip_to_iend=MagickTrue;\n\
    \            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        \
    \    continue;\n          }\n#if defined(MNG_INSERT_LAYERS)\n        if (length\
    \ < 8)\n          {\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\
    \          }\n\n        image_width=(size_t) mng_get_long(p);\n        image_height=(size_t)\
    \ mng_get_long(&p[4]);\n#endif\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\
    \n        /*\n          Insert a transparent background layer behind the entire\
    \ animation\n          if it is not full screen.\n        */\n#if defined(MNG_INSERT_LAYERS)\n\
    \        if (insert_layers && mng_type && first_mng_object)\n          {\n   \
    \         if ((mng_info->clip.left > 0) || (mng_info->clip.top > 0) ||\n     \
    \           (image_width < mng_info->mng_width) ||\n                (mng_info->clip.right\
    \ < (ssize_t) mng_info->mng_width) ||\n                (image_height < mng_info->mng_height)\
    \ ||\n                (mng_info->clip.bottom < (ssize_t) mng_info->mng_height))\n\
    \              {\n                if (GetAuthenticPixelQueue(image) != (Quantum\
    \ *) NULL)\n                  {\n                    /*\n                    \
    \  Allocate next image structure.\n                    */\n                  \
    \  AcquireNextImage(image_info,image,exception);\n\n                    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n                      return(DestroyImageList(image));\n\
    \n                    image=SyncNextImageInList(image);\n                  }\n\
    \                mng_info->image=image;\n\n                if (term_chunk_found)\n\
    \                  {\n                    image->start_loop=MagickTrue;\n    \
    \                image->iterations=mng_iterations;\n                    term_chunk_found=MagickFalse;\n\
    \                  }\n\n                else\n                    image->start_loop=MagickFalse;\n\
    \n                /* Make a background rectangle.  */\n\n                image->delay=0;\n\
    \                image->columns=mng_info->mng_width;\n                image->rows=mng_info->mng_height;\n\
    \                image->page.width=mng_info->mng_width;\n                image->page.height=mng_info->mng_height;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        image->background_color=mng_background_color;\n                (void)\
    \ SetImageBackgroundColor(image,exception);\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"  Inserted transparent background layer, W=%.20g, H=%.20g\"\
    ,\n                    (double) mng_info->mng_width,(double) mng_info->mng_height);\n\
    \              }\n          }\n        /*\n          Insert a background layer\
    \ behind the upcoming image if\n          framing_mode is 3, and we haven't already\
    \ inserted one.\n        */\n        if (insert_layers && (mng_info->framing_mode\
    \ == 3) &&\n                (subframe_width) && (subframe_height) && (simplicity\
    \ == 0 ||\n                (simplicity & 0x08)))\n          {\n            if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n            {\n       \
    \       /*\n                Allocate next image structure.\n              */\n\
    \              AcquireNextImage(image_info,image,exception);\n\n             \
    \ if (GetNextImageInList(image) == (Image *) NULL)\n                return(DestroyImageList(image));\n\
    \n              image=SyncNextImageInList(image);\n            }\n\n         \
    \   mng_info->image=image;\n\n            if (term_chunk_found)\n            \
    \  {\n                image->start_loop=MagickTrue;\n                image->iterations=mng_iterations;\n\
    \                term_chunk_found=MagickFalse;\n              }\n\n          \
    \  else\n                image->start_loop=MagickFalse;\n\n            image->delay=0;\n\
    \            image->columns=subframe_width;\n            image->rows=subframe_height;\n\
    \            image->page.width=subframe_width;\n            image->page.height=subframe_height;\n\
    \            image->page.x=mng_info->clip.left;\n            image->page.y=mng_info->clip.top;\n\
    \            image->background_color=mng_background_color;\n            image->alpha_trait=UndefinedPixelTrait;\n\
    \            (void) SetImageBackgroundColor(image,exception);\n\n            if\
    \ (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Insert background layer, L=%.20g, R=%.20g T=%.20g, B=%.20g\"\
    ,\n                (double) mng_info->clip.left,(double) mng_info->clip.right,\n\
    \                (double) mng_info->clip.top,(double) mng_info->clip.bottom);\n\
    \          }\n#endif /* MNG_INSERT_LAYERS */\n        first_mng_object=MagickFalse;\n\
    \n        if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n          {\n\
    \            /*\n              Allocate next image structure.\n            */\n\
    \            AcquireNextImage(image_info,image,exception);\n\n            if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n              return(DestroyImageList(image));\n\n     \
    \       image=SyncNextImageInList(image);\n          }\n        mng_info->image=image;\n\
    \        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      \
    \    GetBlobSize(image));\n\n        if (status == MagickFalse)\n          break;\n\
    \n        if (term_chunk_found)\n          {\n            image->start_loop=MagickTrue;\n\
    \            term_chunk_found=MagickFalse;\n          }\n\n        else\n    \
    \        image->start_loop=MagickFalse;\n\n        if (mng_info->framing_mode\
    \ == 1 || mng_info->framing_mode == 3)\n          {\n            image->delay=frame_delay;\n\
    \            frame_delay=default_frame_delay;\n          }\n\n        else\n \
    \         image->delay=0;\n\n        image->page.width=mng_info->mng_width;\n\
    \        image->page.height=mng_info->mng_height;\n        image->page.x=mng_info->x_off[object_id];\n\
    \        image->page.y=mng_info->y_off[object_id];\n        image->iterations=mng_iterations;\n\
    \n        /*\n          Seek back to the beginning of the IHDR or JHDR chunk's\
    \ length field.\n        */\n\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Seeking\
    \ back to beginning of %c%c%c%c chunk\",type[0],type[1],\n            type[2],type[3]);\n\
    \n        offset=SeekBlob(image,-((ssize_t) length+12),SEEK_CUR);\n\n        if\
    \ (offset < 0)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"\
    );\n      }\n\n    mng_info->image=image;\n    mng_info->mng_type=mng_type;\n\
    \    mng_info->object_id=object_id;\n\n    if (memcmp(type,mng_IHDR,4) == 0)\n\
    \      image=ReadOnePNGImage(mng_info,image_info,exception);\n\n#if defined(JNG_SUPPORTED)\n\
    \    else\n      image=ReadOneJNGImage(mng_info,image_info,exception);\n#endif\n\
    \n    if (image == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n\
    \          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"\
    exit ReadJNGImage() with error\");\n\n        return((Image *) NULL);\n      }\n\
    \n    if (image->columns == 0 || image->rows == 0)\n      {\n        (void) CloseBlob(image);\n\
    \        return(DestroyImageList(image));\n      }\n\n    mng_info->image=image;\n\
    \n    if (mng_type)\n      {\n        MngBox\n          crop_box;\n\n        if\
    \ (mng_info->magn_methx || mng_info->magn_methy)\n          {\n            png_uint_32\n\
    \               magnified_height,\n               magnified_width;\n\n       \
    \     if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                \"  Processing MNG MAGN chunk\");\n\n            if (mng_info->magn_methx\
    \ == 1)\n              {\n                magnified_width=mng_info->magn_ml;\n\
    \n                if (image->columns > 1)\n                   magnified_width\
    \ += mng_info->magn_mr;\n\n                if (image->columns > 2)\n         \
    \          magnified_width += (png_uint_32)\n                      ((image->columns-2)*(mng_info->magn_mx));\n\
    \              }\n\n            else\n              {\n                magnified_width=(png_uint_32)\
    \ image->columns;\n\n                if (image->columns > 1)\n               \
    \    magnified_width += mng_info->magn_ml-1;\n\n                if (image->columns\
    \ > 2)\n                   magnified_width += mng_info->magn_mr-1;\n\n       \
    \         if (image->columns > 3)\n                   magnified_width += (png_uint_32)\n\
    \                      ((image->columns-3)*(mng_info->magn_mx-1));\n         \
    \     }\n\n            if (mng_info->magn_methy == 1)\n              {\n     \
    \           magnified_height=mng_info->magn_mt;\n\n                if (image->rows\
    \ > 1)\n                   magnified_height += mng_info->magn_mb;\n\n        \
    \        if (image->rows > 2)\n                   magnified_height += (png_uint_32)\n\
    \                      ((image->rows-2)*(mng_info->magn_my));\n              }\n\
    \n            else\n              {\n                magnified_height=(png_uint_32)\
    \ image->rows;\n\n                if (image->rows > 1)\n                   magnified_height\
    \ += mng_info->magn_mt-1;\n\n                if (image->rows > 2)\n          \
    \         magnified_height += mng_info->magn_mb-1;\n\n                if (image->rows\
    \ > 3)\n                   magnified_height += (png_uint_32)\n               \
    \       ((image->rows-3)*(mng_info->magn_my-1));\n              }\n\n        \
    \    if (magnified_height > image->rows ||\n                magnified_width >\
    \ image->columns)\n              {\n                Image\n                  *large_image;\n\
    \n                int\n                  yy;\n\n                Quantum\n    \
    \              *next,\n                  *prev;\n\n                png_uint_16\n\
    \                  magn_methx,\n                  magn_methy;\n\n            \
    \    ssize_t\n                  m,\n                  y;\n\n                register\
    \ Quantum\n                  *n,\n                  *q;\n\n                register\
    \ ssize_t\n                  x;\n\n                /* Allocate next image structure.\
    \  */\n\n                if (logging != MagickFalse)\n                  (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Allocate\
    \ magnified image\");\n\n                AcquireNextImage(image_info,image,exception);\n\
    \n                if (GetNextImageInList(image) == (Image *) NULL)\n         \
    \         return(DestroyImageList(image));\n\n                large_image=SyncNextImageInList(image);\n\
    \n                large_image->columns=magnified_width;\n                large_image->rows=magnified_height;\n\
    \n                magn_methx=mng_info->magn_methx;\n                magn_methy=mng_info->magn_methy;\n\
    \n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n#define QM unsigned short\n           \
    \     if (magn_methx != 1 || magn_methy != 1)\n                  {\n         \
    \         /*\n                     Scale pixels to unsigned shorts to prevent\n\
    \                     overflow of intermediate values of interpolations\n    \
    \              */\n                     for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                     {\n                       q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                          exception);\n\n                       for (x=(ssize_t)\
    \ image->columns-1; x >= 0; x--)\n                       {\n                 \
    \         SetPixelRed(image,ScaleQuantumToShort(\n                           \
    \ GetPixelRed(image,q)),q);\n                          SetPixelGreen(image,ScaleQuantumToShort(\n\
    \                            GetPixelGreen(image,q)),q);\n                   \
    \       SetPixelBlue(image,ScaleQuantumToShort(\n                            GetPixelBlue(image,q)),q);\n\
    \                          SetPixelAlpha(image,ScaleQuantumToShort(\n        \
    \                    GetPixelAlpha(image,q)),q);\n                          q+=GetPixelChannels(image);\n\
    \                       }\n\n                       if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                         break;\n                     }\n \
    \                 }\n#else\n#define QM Quantum\n#endif\n\n                if (image->alpha_trait\
    \ != UndefinedPixelTrait)\n                   (void) SetImageBackgroundColor(large_image,exception);\n\
    \n                else\n                  {\n                    large_image->background_color.alpha=OpaqueAlpha;\n\
    \                    (void) SetImageBackgroundColor(large_image,exception);\n\n\
    \                    if (magn_methx == 4)\n                      magn_methx=2;\n\
    \n                    if (magn_methx == 5)\n                      magn_methx=3;\n\
    \n                    if (magn_methy == 4)\n                      magn_methy=2;\n\
    \n                    if (magn_methy == 5)\n                      magn_methy=3;\n\
    \                  }\n\n                /* magnify the rows into the right side\
    \ of the large image */\n\n                if (logging != MagickFalse)\n     \
    \             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \
    \          \"    Magnify the rows to %.20g\",\n                    (double) large_image->rows);\n\
    \                m=(ssize_t) mng_info->magn_mt;\n                yy=0;\n     \
    \           length=(size_t) GetPixelChannels(image)*image->columns;\n        \
    \        next=(Quantum *) AcquireQuantumMemory(length,sizeof(*next));\n      \
    \          prev=(Quantum *) AcquireQuantumMemory(length,sizeof(*prev));\n\n  \
    \              if ((prev == (Quantum *) NULL) ||\n                    (next ==\
    \ (Quantum *) NULL))\n                  {\n                     image=DestroyImageList(image);\n\
    \                     ThrowReaderException(ResourceLimitError,\n             \
    \          \"MemoryAllocationFailed\");\n                  }\n\n             \
    \   n=GetAuthenticPixels(image,0,0,image->columns,1,exception);\n            \
    \    (void) CopyMagickMemory(next,n,length);\n\n                for (y=0; y <\
    \ (ssize_t) image->rows; y++)\n                {\n                  if (y == 0)\n\
    \                    m=(ssize_t) mng_info->magn_mt;\n\n                  else\
    \ if (magn_methy > 1 && y == (ssize_t) image->rows-2)\n                    m=(ssize_t)\
    \ mng_info->magn_mb;\n\n                  else if (magn_methy <= 1 && y == (ssize_t)\
    \ image->rows-1)\n                    m=(ssize_t) mng_info->magn_mb;\n\n     \
    \             else if (magn_methy > 1 && y == (ssize_t) image->rows-1)\n     \
    \               m=1;\n\n                  else\n                    m=(ssize_t)\
    \ mng_info->magn_my;\n\n                  n=prev;\n                  prev=next;\n\
    \                  next=n;\n\n                  if (y < (ssize_t) image->rows-1)\n\
    \                    {\n                      n=GetAuthenticPixels(image,0,y+1,image->columns,1,\n\
    \                          exception);\n                      (void) CopyMagickMemory(next,n,length);\n\
    \                    }\n\n                  for (i=0; i < m; i++, yy++)\n    \
    \              {\n                    register Quantum\n                     \
    \ *pixels;\n\n                    assert(yy < (ssize_t) large_image->rows);\n\
    \                    pixels=prev;\n                    n=next;\n             \
    \       q=GetAuthenticPixels(large_image,0,yy,large_image->columns,\n        \
    \              1,exception);\n                    q+=(large_image->columns-image->columns)*\n\
    \                      GetPixelChannels(large_image);\n\n                    for\
    \ (x=(ssize_t) image->columns-1; x >= 0; x--)\n                    {\n       \
    \               /* To do: get color as function of indexes[x] */\n           \
    \           /*\n                      if (image->storage_class == PseudoClass)\n\
    \                        {\n                        }\n                      */\n\
    \n                      if (magn_methy <= 1)\n                        {\n    \
    \                      /* replicate previous */\n                          SetPixelRed(large_image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(large_image,GetPixelGreen(image,\n  \
    \                           pixels),q);\n                          SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                             pixels),q);\n                          SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                             pixels),q);\n                        }\n\n     \
    \                 else if (magn_methy == 2 || magn_methy == 4)\n             \
    \           {\n                          if (i == 0)\n                       \
    \     {\n                              SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                 pixels),q);\n                              SetPixelGreen(large_image,GetPixelGreen(image,\n\
    \                                 pixels),q);\n                              SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                 pixels),q);\n                              SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                 pixels),q);\n                            }\n\
    \n                          else\n                            {\n            \
    \                  /* Interpolate */\n                              SetPixelRed(large_image,((QM)\
    \ (((ssize_t)\n                                 (2*i*(GetPixelRed(image,n)\n \
    \                                -GetPixelRed(image,pixels)+m))/\n           \
    \                      ((ssize_t) (m*2))\n                                 +GetPixelRed(image,pixels)))),q);\n\
    \                              SetPixelGreen(large_image,((QM) (((ssize_t)\n \
    \                                (2*i*(GetPixelGreen(image,n)\n              \
    \                   -GetPixelGreen(image,pixels)+m))/\n                      \
    \           ((ssize_t) (m*2))\n                                 +GetPixelGreen(image,pixels)))),q);\n\
    \                              SetPixelBlue(large_image,((QM) (((ssize_t)\n  \
    \                               (2*i*(GetPixelBlue(image,n)\n                \
    \                 -GetPixelBlue(image,pixels)+m))/\n                         \
    \        ((ssize_t) (m*2))\n                                 +GetPixelBlue(image,pixels)))),q);\n\
    \n                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(large_image, ((QM) (((ssize_t)\n\
    \                                    (2*i*(GetPixelAlpha(image,n)\n          \
    \                          -GetPixelAlpha(image,pixels)+m))\n                \
    \                    /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)))),q);\n\
    \                            }\n\n                          if (magn_methy ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                        SetPixelAlpha(large_image,GetPixelAlpha(image,\n    \
    \                                pixels),q);\n                              else\n\
    \                                 SetPixelAlpha(large_image,GetPixelAlpha(image,\n\
    \                                    n),q);\n                            }\n \
    \                       }\n\n                      else /* if (magn_methy == 3\
    \ || magn_methy == 5) */\n                        {\n                        \
    \  /* Replicate nearest */\n                          if (i <= ((m+1) << 1))\n\
    \                          {\n                             SetPixelRed(large_image,GetPixelRed(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelGreen(large_image,GetPixelGreen(image,\n                          \
    \          pixels),q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,\n\
    \                                    pixels),q);\n                           \
    \  SetPixelAlpha(large_image,GetPixelAlpha(image,\n                          \
    \          pixels),q);\n                          }\n\n                      \
    \    else\n                          {\n                             SetPixelRed(large_image,GetPixelRed(image,n),q);\n\
    \                             SetPixelGreen(large_image,GetPixelGreen(image,n),\n\
    \                                    q);\n                             SetPixelBlue(large_image,GetPixelBlue(image,n),\n\
    \                                    q);\n                             SetPixelAlpha(large_image,GetPixelAlpha(image,n),\n\
    \                                    q);\n                          }\n\n    \
    \                      if (magn_methy == 5)\n                            {\n \
    \                             SetPixelAlpha(large_image,(QM) (((ssize_t) (2*i*\n\
    \                                 (GetPixelAlpha(image,n)\n                  \
    \               -GetPixelAlpha(image,pixels))\n                              \
    \   +m))/((ssize_t) (m*2))\n                                 +GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n                        }\n                  \
    \    n+=GetPixelChannels(image);\n                      q+=GetPixelChannels(large_image);\n\
    \                      pixels+=GetPixelChannels(image);\n                    }\
    \ /* x */\n\n                    if (SyncAuthenticPixels(large_image,exception)\
    \ == 0)\n                      break;\n\n                  } /* i */\n       \
    \         } /* y */\n\n                prev=(Quantum *) RelinquishMagickMemory(prev);\n\
    \                next=(Quantum *) RelinquishMagickMemory(next);\n\n          \
    \      length=image->columns;\n\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Delete original image\");\n\n                DeleteImageFromList(&image);\n\
    \n                image=large_image;\n\n                mng_info->image=image;\n\
    \n                /* magnify the columns */\n                if (logging != MagickFalse)\n\
    \                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \
    \               \"    Magnify the columns to %.20g\",\n                    (double)\
    \ image->columns);\n\n                for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                {\n                  register Quantum\n                    *pixels;\n\
    \n                  q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \                  pixels=q+(image->columns-length)*GetPixelChannels(image);\n\
    \                  n=pixels+GetPixelChannels(image);\n\n                  for\
    \ (x=(ssize_t) (image->columns-length);\n                    x < (ssize_t) image->columns;\
    \ x++)\n                  {\n                    /* To do: Rewrite using Get/Set***PixelChannel()\
    \ */\n\n                    if (x == (ssize_t) (image->columns-length))\n    \
    \                  m=(ssize_t) mng_info->magn_ml;\n\n                    else\
    \ if (magn_methx > 1 && x == (ssize_t) image->columns-2)\n                   \
    \   m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ <= 1 &&\n                        x == (ssize_t) image->columns-1)\n        \
    \              m=(ssize_t) mng_info->magn_mr;\n\n                    else if (magn_methx\
    \ > 1 && x == (ssize_t) image->columns-1)\n                      m=1;\n\n    \
    \                else\n                      m=(ssize_t) mng_info->magn_mx;\n\n\
    \                    for (i=0; i < m; i++)\n                    {\n          \
    \            if (magn_methx <= 1)\n                        {\n               \
    \           /* replicate previous */\n                          SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                          SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                          SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                          SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                        }\n\n                      else if (magn_methx == 2 ||\
    \ magn_methx == 4)\n                        {\n                          if (i\
    \ == 0)\n                          {\n                            SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                            SetPixelGreen(image,GetPixelGreen(image,pixels),q);\n\
    \                            SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                            SetPixelAlpha(image,GetPixelAlpha(image,pixels),q);\n\
    \                          }\n\n                          /* To do: Rewrite using\
    \ Get/Set***PixelChannel() */\n                          else\n              \
    \              {\n                              /* Interpolate */\n          \
    \                    SetPixelRed(image,(QM) ((2*i*(\n                        \
    \         GetPixelRed(image,n)\n                                 -GetPixelRed(image,pixels))+m)\n\
    \                                 /((ssize_t) (m*2))+\n                      \
    \           GetPixelRed(image,pixels)),q);\n\n                              SetPixelGreen(image,(QM)\
    \ ((2*i*(\n                                 GetPixelGreen(image,n)\n         \
    \                        -GetPixelGreen(image,pixels))+m)\n                  \
    \               /((ssize_t) (m*2))+\n                                 GetPixelGreen(image,pixels)),q);\n\
    \n                              SetPixelBlue(image,(QM) ((2*i*(\n            \
    \                     GetPixelBlue(image,n)\n                                \
    \ -GetPixelBlue(image,pixels))+m)\n                                 /((ssize_t)\
    \ (m*2))+\n                                 GetPixelBlue(image,pixels)),q);\n\
    \                              if (image->alpha_trait != UndefinedPixelTrait)\n\
    \                                 SetPixelAlpha(image,(QM) ((2*i*(\n         \
    \                          GetPixelAlpha(image,n)\n                          \
    \         -GetPixelAlpha(image,pixels))+m)\n                                 \
    \  /((ssize_t) (m*2))+\n                                   GetPixelAlpha(image,pixels)),q);\n\
    \                            }\n\n                          if (magn_methx ==\
    \ 4)\n                            {\n                              /* Replicate\
    \ nearest */\n                              if (i <= ((m+1) << 1))\n         \
    \                     {\n                                 SetPixelAlpha(image,\n\
    \                                   GetPixelAlpha(image,pixels)+0,q);\n      \
    \                        }\n                              else\n             \
    \                 {\n                                 SetPixelAlpha(image,\n \
    \                                  GetPixelAlpha(image,n)+0,q);\n            \
    \                  }\n                            }\n                        }\n\
    \n                      else /* if (magn_methx == 3 || magn_methx == 5) */\n \
    \                       {\n                          /* Replicate nearest */\n\
    \                          if (i <= ((m+1) << 1))\n                          {\n\
    \                             SetPixelRed(image,GetPixelRed(image,pixels),q);\n\
    \                             SetPixelGreen(image,GetPixelGreen(image,\n     \
    \                            pixels),q);\n                             SetPixelBlue(image,GetPixelBlue(image,pixels),q);\n\
    \                             SetPixelAlpha(image,GetPixelAlpha(image,\n     \
    \                            pixels),q);\n                          }\n\n    \
    \                      else\n                          {\n                   \
    \          SetPixelRed(image,GetPixelRed(image,n),q);\n                      \
    \       SetPixelGreen(image,GetPixelGreen(image,n),q);\n                     \
    \        SetPixelBlue(image,GetPixelBlue(image,n),q);\n                      \
    \       SetPixelAlpha(image,GetPixelAlpha(image,n),q);\n                     \
    \     }\n\n                          if (magn_methx == 5)\n                  \
    \          {\n                              /* Interpolate */\n              \
    \                SetPixelAlpha(image,\n                                 (QM) ((2*i*(\
    \ GetPixelAlpha(image,n)\n                                 -GetPixelAlpha(image,pixels))+m)/\n\
    \                                 ((ssize_t) (m*2))\n                        \
    \         +GetPixelAlpha(image,pixels)),q);\n                            }\n \
    \                       }\n                      q+=GetPixelChannels(image);\n\
    \                    }\n                    n+=GetPixelChannels(image);\n    \
    \              }\n\n                  if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                    break;\n                }\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 16)\n              if (magn_methx != 1 || magn_methy != 1)\n             \
    \   {\n                /*\n                   Rescale pixels to Quantum\n    \
    \            */\n                   for (y=0; y < (ssize_t) image->rows; y++)\n\
    \                   {\n                     q=GetAuthenticPixels(image,0,y,image->columns,1,\n\
    \                       exception);\n\n                     for (x=(ssize_t) image->columns-1;\
    \ x >= 0; x--)\n                     {\n                        SetPixelRed(image,ScaleShortToQuantum(\n\
    \                          GetPixelRed(image,q)),q);\n                       \
    \ SetPixelGreen(image,ScaleShortToQuantum(\n                          GetPixelGreen(image,q)),q);\n\
    \                        SetPixelBlue(image,ScaleShortToQuantum(\n           \
    \               GetPixelBlue(image,q)),q);\n                        SetPixelAlpha(image,ScaleShortToQuantum(\n\
    \                          GetPixelAlpha(image,q)),q);\n                     \
    \   q+=GetPixelChannels(image);\n                     }\n\n                  \
    \   if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               \
    \        break;\n                   }\n                }\n#endif\n           \
    \     if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                    \"  Finished MAGN processing\");\n              }\n     \
    \     }\n\n        /*\n          Crop_box is with respect to the upper left corner\
    \ of the MNG.\n        */\n        crop_box.left=mng_info->image_box.left+mng_info->x_off[object_id];\n\
    \        crop_box.right=mng_info->image_box.right+mng_info->x_off[object_id];\n\
    \        crop_box.top=mng_info->image_box.top+mng_info->y_off[object_id];\n  \
    \      crop_box.bottom=mng_info->image_box.bottom+mng_info->y_off[object_id];\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->clip);\n        crop_box=mng_minimum_box(crop_box,mng_info->frame);\n\
    \        crop_box=mng_minimum_box(crop_box,mng_info->object_clip[object_id]);\n\
    \        if ((crop_box.left != (mng_info->image_box.left\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.right != (mng_info->image_box.right\n            +mng_info->x_off[object_id]))\
    \ ||\n            (crop_box.top != (mng_info->image_box.top\n            +mng_info->y_off[object_id]))\
    \ ||\n            (crop_box.bottom != (mng_info->image_box.bottom\n          \
    \  +mng_info->y_off[object_id])))\n          {\n            if (logging != MagickFalse)\n\
    \              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n         \
    \       \"  Crop the PNG image\");\n\n            if ((crop_box.left < crop_box.right)\
    \ &&\n                (crop_box.top < crop_box.bottom))\n              {\n   \
    \             Image\n                  *im;\n\n                RectangleInfo\n\
    \                  crop_info;\n\n                /*\n                  Crop_info\
    \ is with respect to the upper left corner of\n                  the image.\n\
    \                */\n                crop_info.x=(crop_box.left-mng_info->x_off[object_id]);\n\
    \                crop_info.y=(crop_box.top-mng_info->y_off[object_id]);\n    \
    \            crop_info.width=(size_t) (crop_box.right-crop_box.left);\n      \
    \          crop_info.height=(size_t) (crop_box.bottom-crop_box.top);\n       \
    \         image->page.width=image->columns;\n                image->page.height=image->rows;\n\
    \                image->page.x=0;\n                image->page.y=0;\n        \
    \        im=CropImage(image,&crop_info,exception);\n\n                if (im !=\
    \ (Image *) NULL)\n                  {\n                    image->columns=im->columns;\n\
    \                    image->rows=im->rows;\n                    im=DestroyImage(im);\n\
    \                    image->page.width=image->columns;\n                    image->page.height=image->rows;\n\
    \                    image->page.x=crop_box.left;\n                    image->page.y=crop_box.top;\n\
    \                  }\n              }\n\n            else\n              {\n \
    \               /*\n                  No pixels in crop area.  The MNG spec still\
    \ requires\n                  a layer, though, so make a single transparent pixel\
    \ in\n                  the top left corner.\n                */\n           \
    \     image->columns=1;\n                image->rows=1;\n                image->colors=2;\n\
    \                (void) SetImageBackgroundColor(image,exception);\n          \
    \      image->page.width=1;\n                image->page.height=1;\n         \
    \       image->page.x=0;\n                image->page.y=0;\n              }\n\
    \          }\n#ifndef PNG_READ_EMPTY_PLTE_SUPPORTED\n        image=mng_info->image;\n\
    #endif\n      }\n\n#if (MAGICKCORE_QUANTUM_DEPTH > 16)\n      /* PNG does not\
    \ handle depths greater than 16 so reduce it even\n       * if lossy.\n      \
    \ */\n      if (image->depth > 16)\n         image->depth=16;\n#endif\n\n#if (MAGICKCORE_QUANTUM_DEPTH\
    \ > 8)\n      if (image->depth > 8)\n        {\n          /* To do: fill low byte\
    \ properly */\n          image->depth=16;\n        }\n\n      if (LosslessReduceDepthOK(image,exception)\
    \ != MagickFalse)\n         image->depth = 8;\n#endif\n\n      if (image_info->number_scenes\
    \ != 0)\n        {\n          if (mng_info->scenes_found >\n             (ssize_t)\
    \ (image_info->first_scene+image_info->number_scenes))\n            break;\n \
    \       }\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  Finished reading image datastream.\");\n\n  } while (LocaleCompare(image_info->magick,\"\
    MNG\") == 0);\n\n  (void) CloseBlob(image);\n\n  if (logging != MagickFalse)\n\
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Finished reading\
    \ all image datastreams.\");\n\n#if defined(MNG_INSERT_LAYERS)\n  if (insert_layers\
    \ && !mng_info->image_found && (mng_info->mng_width) &&\n       (mng_info->mng_height))\n\
    \    {\n      /*\n        Insert a background layer if nothing else was found.\n\
    \      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No images found.  Inserting a background layer.\");\n\n      if\
    \ (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n        {\n          /*\n\
    \            Allocate next image structure.\n          */\n          AcquireNextImage(image_info,image,exception);\n\
    \          if (GetNextImageInList(image) == (Image *) NULL)\n            {\n \
    \             if (logging != MagickFalse)\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \                  \"  Allocation failed, returning NULL.\");\n\n            \
    \  return(DestroyImageList(image));;\n            }\n          image=SyncNextImageInList(image);\n\
    \        }\n      image->columns=mng_info->mng_width;\n      image->rows=mng_info->mng_height;\n\
    \      image->page.width=mng_info->mng_width;\n      image->page.height=mng_info->mng_height;\n\
    \      image->page.x=0;\n      image->page.y=0;\n      image->background_color=mng_background_color;\n\
    \      image->alpha_trait=UndefinedPixelTrait;\n\n      if (image_info->ping ==\
    \ MagickFalse)\n        (void) SetImageBackgroundColor(image,exception);\n\n \
    \     mng_info->image_found++;\n    }\n#endif\n  image->iterations=mng_iterations;\n\
    \n  if (mng_iterations == 1)\n    image->start_loop=MagickTrue;\n\n  while (GetPreviousImageInList(image)\
    \ != (Image *) NULL)\n  {\n    image_count++;\n    if (image_count > 10*mng_info->image_found)\n\
    \      {\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    \  No beginning\");\n\n        (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \          CoderError,\"Linked list is corrupted, beginning of list not found\"\
    ,\n          \"`%s'\",image_info->filename);\n\n        return(DestroyImageList(image));\n\
    \      }\n\n    image=GetPreviousImageInList(image);\n\n    if (GetNextImageInList(image)\
    \ == (Image *) NULL)\n      {\n        if (logging != MagickFalse)\n         \
    \ (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Corrupt list\");\n\n\
    \        (void) ThrowMagickException(exception,GetMagickModule(),\n          CoderError,\"\
    Linked list is corrupted; next_image is NULL\",\"`%s'\",\n          image_info->filename);\n\
    \      }\n  }\n\n  if (mng_info->ticks_per_second && mng_info->image_found > 1\
    \ &&\n             GetNextImageInList(image) ==\n     (Image *) NULL)\n    {\n\
    \      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \            \"  First image null\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"image->next for first image is NULL but shouldn't be.\"\
    ,\n        \"`%s'\",image_info->filename);\n    }\n\n  if (mng_info->image_found\
    \ == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"  No visible images found.\");\n\n      (void) ThrowMagickException(exception,GetMagickModule(),\n\
    \        CoderError,\"No visible images in file\",\"`%s'\",image_info->filename);\n\
    \n      return(DestroyImageList(image));\n    }\n\n  if (mng_info->ticks_per_second)\n\
    \    final_delay=1UL*MagickMax(image->ticks_per_second,1L)*\n            final_delay/mng_info->ticks_per_second;\n\
    \n  else\n    image->start_loop=MagickTrue;\n\n  /* Find final nonzero image delay\
    \ */\n  final_image_delay=0;\n\n  while (GetNextImageInList(image) != (Image *)\
    \ NULL)\n    {\n      if (image->delay)\n        final_image_delay=image->delay;\n\
    \n      image=GetNextImageInList(image);\n    }\n\n  if (final_delay < final_image_delay)\n\
    \    final_delay=final_image_delay;\n\n  image->delay=final_delay;\n\n  if (logging\
    \ != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"  image->delay=%.20g, final_delay=%.20g\",(double) image->delay,\n\
    \        (double) final_delay);\n\n  if (logging != MagickFalse)\n    {\n    \
    \  int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Before\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g\",(double) image->delay);\n\n      while (GetNextImageInList(image)\
    \ != (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n    \
    \    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g\",(double) scene++,\n          (double) image->delay);\n \
    \     }\n    }\n\n  image=GetFirstImageInList(image);\n#ifdef MNG_COALESCE_LAYERS\n\
    \  if (insert_layers)\n    {\n      Image\n        *next_image,\n        *next;\n\
    \n      size_t\n        scene;\n\n      if (logging != MagickFalse)\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Coalesce Images\"\
    );\n\n      scene=image->scene;\n      next_image=CoalesceImages(image,exception);\n\
    \n      if (next_image == (Image *) NULL)\n        ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n\n      image=DestroyImageList(image);\n      image=next_image;\n\
    \n      for (next=image; next != (Image *) NULL; next=next_image)\n      {\n \
    \        next->page.width=mng_info->mng_width;\n         next->page.height=mng_info->mng_height;\n\
    \         next->page.x=0;\n         next->page.y=0;\n         next->scene=scene++;\n\
    \         next_image=GetNextImageInList(next);\n\n         if (next_image == (Image\
    \ *) NULL)\n           break;\n\n         if (next->delay == 0)\n           {\n\
    \             scene--;\n             next_image->previous=GetPreviousImageInList(next);\n\
    \             if (GetPreviousImageInList(next) == (Image *) NULL)\n          \
    \     image=next_image;\n             else\n               next->previous->next=next_image;\n\
    \             next=DestroyImage(next);\n           }\n      }\n    }\n#endif\n\
    \n  while (GetNextImageInList(image) != (Image *) NULL)\n      image=GetNextImageInList(image);\n\
    \n  image->dispose=BackgroundDispose;\n\n  if (logging != MagickFalse)\n    {\n\
    \      int\n        scene;\n\n      scene=0;\n      image=GetFirstImageInList(image);\n\
    \n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  After\
    \ coalesce:\");\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \        \"    scene 0 delay=%.20g dispose=%.20g\",(double) image->delay,\n  \
    \      (double) image->dispose);\n\n      while (GetNextImageInList(image) !=\
    \ (Image *) NULL)\n      {\n        image=GetNextImageInList(image);\n\n     \
    \   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    scene\
    \ %.20g delay=%.20g dispose=%.20g\",(double) scene++,\n          (double) image->delay,(double)\
    \ image->dispose);\n      }\n   }\n\n  if (logging != MagickFalse)\n    (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneMNGImage();\"\
    );\n\n  return(image);\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 195909
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
