agents:
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nbool st_select_lex::optimize_unflattened_subqueries(bool\
    \ const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT\
    \ *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n\
    \  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\
    \n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n\
    \      {\n\t/*\n\t This subquery was excluded as part of some expression so it\
    \ is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\
    \tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n \
    \     if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n\
    \        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n\
    \        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if\
    \ (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip\
    \ non-constant subqueries if the caller asked so. */\n        continue;\n    \
    \  }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n\
    \      bool first= true;\n      bool union_plan_saved= false;\n      /*\n    \
    \    If the subquery is a UNION, optimize all the subqueries in the UNION. If\n\
    \        there is no UNION, then the loop will execute once for the subquery.\n\
    \      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n\
    \      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first=\
    \ false;\n        else\n        {\n          if (!union_plan_saved)\n        \
    \  {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n\
    \              return true; /* Failure */\n          }\n        }\n        if\
    \ (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n\
    \        ulonglong save_options;\n        int res;\n        /* We need only 1\
    \ row to determine existence */\n        un->set_limit(un->global_parameters());\n\
    \        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n\
    \        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the\
    \ subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n\
    \          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|=\
    \ SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n  \
    \        return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n\
    \        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n\
    \        inner_join->select_options= save_options;\n        un->thd->lex->current_select=\
    \ save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n\
    \        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n\
    \          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type=\
    \ sl->type;\n          }\n        }\n\n        if (empty_union_result)\n     \
    \   {\n          /*\n            If at least one subquery in a union is non-empty,\
    \ the UNION result\n            is non-empty. If there is no UNION, the only subquery\
    \ is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n\
    \        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n\
    \        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n\
    \      {\n        /*\n          Some parts of UNION are not correlated. This means\
    \ we will need to\n          re-execute the whole UNION every time. Mark all parts\
    \ of the UNION\n          as correlated so that they are prepared to be executed\
    \ multiple\n          times (if we don't do that, some part of the UNION may free\
    \ its\n          execution data at the end of first execution and crash on the\
    \ second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select();\
    \ sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n\
    \      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n    \
    \  subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return\
    \ FALSE;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nbool st_select_lex::optimize_unflattened_subqueries(bool\
    \ const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT\
    \ *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n\
    \  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\
    \n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n\
    \      {\n\t/*\n\t This subquery was excluded as part of some expression so it\
    \ is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\
    \tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n \
    \     if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n\
    \        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n\
    \        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if\
    \ (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip\
    \ non-constant subqueries if the caller asked so. */\n        continue;\n    \
    \  }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n\
    \      bool first= true;\n      bool union_plan_saved= false;\n      /*\n    \
    \    If the subquery is a UNION, optimize all the subqueries in the UNION. If\n\
    \        there is no UNION, then the loop will execute once for the subquery.\n\
    \      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n\
    \      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first=\
    \ false;\n        else\n        {\n          if (!union_plan_saved)\n        \
    \  {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n\
    \              return true; /* Failure */\n          }\n        }\n        if\
    \ (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n\
    \        ulonglong save_options;\n        int res;\n        /* We need only 1\
    \ row to determine existence */\n        un->set_limit(un->global_parameters());\n\
    \        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n\
    \        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the\
    \ subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n\
    \          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|=\
    \ SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n  \
    \        return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n\
    \        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n\
    \        inner_join->select_options= save_options;\n        un->thd->lex->current_select=\
    \ save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n\
    \        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n\
    \          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type=\
    \ sl->type;\n          }\n        }\n\n        if (empty_union_result)\n     \
    \   {\n          /*\n            If at least one subquery in a union is non-empty,\
    \ the UNION result\n            is non-empty. If there is no UNION, the only subquery\
    \ is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n\
    \        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n\
    \        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n\
    \      {\n        /*\n          Some parts of UNION are not correlated. This means\
    \ we will need to\n          re-execute the whole UNION every time. Mark all parts\
    \ of the UNION\n          as correlated so that they are prepared to be executed\
    \ multiple\n          times (if we don't do that, some part of the UNION may free\
    \ its\n          execution data at the end of first execution and crash on the\
    \ second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select();\
    \ sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n\
    \      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n    \
    \  subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return\
    \ FALSE;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nbool st_select_lex::optimize_unflattened_subqueries(bool\
    \ const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT\
    \ *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n\
    \  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\
    \n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n\
    \      {\n\t/*\n\t This subquery was excluded as part of some expression so it\
    \ is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\
    \tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n \
    \     if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n\
    \        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n\
    \        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if\
    \ (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip\
    \ non-constant subqueries if the caller asked so. */\n        continue;\n    \
    \  }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n\
    \      bool first= true;\n      bool union_plan_saved= false;\n      /*\n    \
    \    If the subquery is a UNION, optimize all the subqueries in the UNION. If\n\
    \        there is no UNION, then the loop will execute once for the subquery.\n\
    \      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n\
    \      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first=\
    \ false;\n        else\n        {\n          if (!union_plan_saved)\n        \
    \  {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n\
    \              return true; /* Failure */\n          }\n        }\n        if\
    \ (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n\
    \        ulonglong save_options;\n        int res;\n        /* We need only 1\
    \ row to determine existence */\n        un->set_limit(un->global_parameters());\n\
    \        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n\
    \        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the\
    \ subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n\
    \          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|=\
    \ SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n  \
    \        return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n\
    \        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n\
    \        inner_join->select_options= save_options;\n        un->thd->lex->current_select=\
    \ save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n\
    \        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n\
    \          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type=\
    \ sl->type;\n          }\n        }\n\n        if (empty_union_result)\n     \
    \   {\n          /*\n            If at least one subquery in a union is non-empty,\
    \ the UNION result\n            is non-empty. If there is no UNION, the only subquery\
    \ is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n\
    \        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n\
    \        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n\
    \      {\n        /*\n          Some parts of UNION are not correlated. This means\
    \ we will need to\n          re-execute the whole UNION every time. Mark all parts\
    \ of the UNION\n          as correlated so that they are prepared to be executed\
    \ multiple\n          times (if we don't do that, some part of the UNION may free\
    \ its\n          execution data at the end of first execution and crash on the\
    \ second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select();\
    \ sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n\
    \      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n    \
    \  subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return\
    \ FALSE;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nbool st_select_lex::optimize_unflattened_subqueries(bool\
    \ const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT\
    \ *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n\
    \  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n\
    \n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n\
    \      {\n\t/*\n\t This subquery was excluded as part of some expression so it\
    \ is\n\t invisible from all prepared expression.\n       */\n\tnext_unit= un->next_unit();\n\
    \tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n \
    \     if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n\
    \        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n\
    \        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n\n      if\
    \ (const_only && !subquery_predicate->const_item())\n      {\n        /* Skip\
    \ non-constant subqueries if the caller asked so. */\n        continue;\n    \
    \  }\n\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n\
    \      bool first= true;\n      bool union_plan_saved= false;\n      /*\n    \
    \    If the subquery is a UNION, optimize all the subqueries in the UNION. If\n\
    \        there is no UNION, then the loop will execute once for the subquery.\n\
    \      */\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n\
    \      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first=\
    \ false;\n        else\n        {\n          if (!union_plan_saved)\n        \
    \  {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n\
    \              return true; /* Failure */\n          }\n        }\n        if\
    \ (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n\
    \        ulonglong save_options;\n        int res;\n        /* We need only 1\
    \ row to determine existence */\n        un->set_limit(un->global_parameters());\n\
    \        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n\
    \        if (options & SELECT_DESCRIBE)\n        {\n          /* Optimize the\
    \ subquery in the context of EXPLAIN. */\n          sl->set_explain_type(FALSE);\n\
    \          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|=\
    \ SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n  \
    \        return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n\
    \        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n\
    \        inner_join->select_options= save_options;\n        un->thd->lex->current_select=\
    \ save_select;\n\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n\
    \        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n\
    \          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type=\
    \ sl->type;\n          }\n        }\n\n        if (empty_union_result)\n     \
    \   {\n          /*\n            If at least one subquery in a union is non-empty,\
    \ the UNION result\n            is non-empty. If there is no UNION, the only subquery\
    \ is non-empy.\n          */\n          empty_union_result= inner_join->empty_result();\n\
    \        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n\
    \        subquery_predicate->no_rows_in_result();\n\n      if (is_correlated_unit)\n\
    \      {\n        /*\n          Some parts of UNION are not correlated. This means\
    \ we will need to\n          re-execute the whole UNION every time. Mark all parts\
    \ of the UNION\n          as correlated so that they are prepared to be executed\
    \ multiple\n          times (if we don't do that, some part of the UNION may free\
    \ its\n          execution data at the end of first execution and crash on the\
    \ second\n          execution)\n        */\n        for (SELECT_LEX *sl= un->first_select();\
    \ sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n\
    \      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n    \
    \  subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return\
    \ FALSE;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 508874
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
