agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nStatus\
    \ DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,\n             \
    \          CodecInOut* io) {\n  Reader r;\n  unsigned int id, i, j, w, h, w0,\
    \ h0, x0, y0;\n  unsigned int delay_num, delay_den, dop, bop, rowbytes, imagesize;\n\
    \  unsigned char sig[8];\n  png_structp png_ptr;\n  png_infop info_ptr;\n  CHUNK\
    \ chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK> chunksInfo;\n  bool isAnimated\
    \ = false;\n  bool skipFirst = false;\n  bool hasInfo = false;\n  bool all_dispose_bg\
    \ = true;\n  APNGFrame frameRaw = {};\n\n  r = {bytes.data(), bytes.data() + bytes.size()};\n\
    \  // Not an aPNG => not an error\n  unsigned char png_signature[8] = {137, 80,\
    \ 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig, 8) || memcmp(sig, png_signature,\
    \ 8) != 0) {\n    return false;\n  }\n  id = read_chunk(&r, &chunkIHDR);\n\n \
    \ io->frames.clear();\n  io->dec_pixels = 0;\n  io->metadata.m.SetUintSamples(8);\n\
    \  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding =\n      ColorEncoding::SRGB();\
    \  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n     \
    \ [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"\
    APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\
    \n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n\
    \    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p\
    \ + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n\
    \    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n\
    \    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\
    \n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h\
    \ * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p\
    \ + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw,\
    \ hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none\
    \ = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n  \
    \      if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if\
    \ (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n\
    \          skipFirst = true;\n          io->metadata.m.have_animation = true;\n\
    \          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id\
    \ == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated)))\
    \ {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr))\
    \ {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration\
    \ = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n    \
    \          bundle.origin.y0 = y0;\n              // TODO(veluca): this could in\
    \ principle be implemented.\n              if (last_base_was_none && !all_dispose_bg\
    \ &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0))\
    \ {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0\
    \ is not supported for non-full or \"\n                    \"blended frames\"\
    );\n              }\n              switch (dop) {\n                case 0:\n \
    \                 bundle.use_for_next_frame = true;\n                  last_base_was_none\
    \ = false;\n                  all_dispose_bg = false;\n                  break;\n\
    \                case 2:\n                  bundle.use_for_next_frame = false;\n\
    \                  all_dispose_bg = false;\n                  break;\n       \
    \         default:\n                  bundle.use_for_next_frame = false;\n   \
    \               last_base_was_none = true;\n              }\n              bundle.blend\
    \ = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F\
    \ sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n        \
    \      for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT\
    \ row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT\
    \ row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT\
    \ row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT\
    \ row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n\
    \                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4\
    \ * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                  \
    \  row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x]\
    \ = 0;\n                    continue;\n                  }\n                 \
    \ row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x\
    \ + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n\
    \                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n              \
    \  }\n              }\n              bundle.SetFromImage(std::move(sub_frame),\
    \ ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n\
    \                              /*alpha_is_premultiplied=*/false);\n          \
    \    io->frames.push_back(std::move(bundle));\n            } else {\n        \
    \      delete[] chunk.p;\n              break;\n            }\n          }\n\n\
    \          if (id == kId_IEND) {\n            errorstate = false;\n          \
    \  break;\n          }\n          // At this point the old frame is done. Let's\
    \ start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0\
    \ = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n\
    \          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p\
    \ + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop\
    \ = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (w0 > cMaxPNGSize\
    \ || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize ||\
    \ x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n       \
    \     delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo)\
    \ {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr,\
    \ info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR,\
    \ chunksInfo)) {\n              delete[] chunk.p;\n              break;\n    \
    \        }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size()\
    \ == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop\
    \ = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo =\
    \ true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size))\
    \ {\n            delete[] chunk.p;\n            break;\n          }\n        }\
    \ else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p\
    \ + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n      \
    \    if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n\
    \            delete[] chunk.p;\n            break;\n          }\n        } else\
    \ if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6])\
    \ || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n  \
    \      } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr,\
    \ chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n\
    \          }\n          chunksInfo.push_back(chunk);\n          continue;\n  \
    \      }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n\
    \    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[]\
    \ chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate)\
    \ return false;\n  SetIntensityTarget(io);\n  return true;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nStatus DecodeImageAPNG(Span<const\
    \ uint8_t> bytes, ThreadPool* pool,\n                       CodecInOut* io) {\n\
    \  Reader r;\n  unsigned int id, i, j, w, h, w0, h0, x0, y0;\n  unsigned int delay_num,\
    \ delay_den, dop, bop, rowbytes, imagesize;\n  unsigned char sig[8];\n  png_structp\
    \ png_ptr;\n  png_infop info_ptr;\n  CHUNK chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK>\
    \ chunksInfo;\n  bool isAnimated = false;\n  bool skipFirst = false;\n  bool hasInfo\
    \ = false;\n  bool all_dispose_bg = true;\n  APNGFrame frameRaw = {};\n\n  r =\
    \ {bytes.data(), bytes.data() + bytes.size()};\n  // Not an aPNG => not an error\n\
    \  unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig,\
    \ 8) || memcmp(sig, png_signature, 8) != 0) {\n    return false;\n  }\n  id =\
    \ read_chunk(&r, &chunkIHDR);\n\n  io->frames.clear();\n  io->dec_pixels = 0;\n\
    \  io->metadata.m.SetUintSamples(8);\n  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding\
    \ =\n      ColorEncoding::SRGB();  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n\
    \      [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"\
    APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\
    \n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n\
    \    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p\
    \ + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n\
    \    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n\
    \    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\
    \n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h\
    \ * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p\
    \ + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw,\
    \ hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none\
    \ = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n  \
    \      if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if\
    \ (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n\
    \          skipFirst = true;\n          io->metadata.m.have_animation = true;\n\
    \          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id\
    \ == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated)))\
    \ {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr))\
    \ {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration\
    \ = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n    \
    \          bundle.origin.y0 = y0;\n              // TODO(veluca): this could in\
    \ principle be implemented.\n              if (last_base_was_none && !all_dispose_bg\
    \ &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0))\
    \ {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0\
    \ is not supported for non-full or \"\n                    \"blended frames\"\
    );\n              }\n              switch (dop) {\n                case 0:\n \
    \                 bundle.use_for_next_frame = true;\n                  last_base_was_none\
    \ = false;\n                  all_dispose_bg = false;\n                  break;\n\
    \                case 2:\n                  bundle.use_for_next_frame = false;\n\
    \                  all_dispose_bg = false;\n                  break;\n       \
    \         default:\n                  bundle.use_for_next_frame = false;\n   \
    \               last_base_was_none = true;\n              }\n              bundle.blend\
    \ = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F\
    \ sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n        \
    \      for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT\
    \ row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT\
    \ row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT\
    \ row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT\
    \ row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n\
    \                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4\
    \ * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                  \
    \  row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x]\
    \ = 0;\n                    continue;\n                  }\n                 \
    \ row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x\
    \ + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n\
    \                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n              \
    \  }\n              }\n              bundle.SetFromImage(std::move(sub_frame),\
    \ ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n\
    \                              /*alpha_is_premultiplied=*/false);\n          \
    \    io->frames.push_back(std::move(bundle));\n            } else {\n        \
    \      delete[] chunk.p;\n              break;\n            }\n          }\n\n\
    \          if (id == kId_IEND) {\n            errorstate = false;\n          \
    \  break;\n          }\n          // At this point the old frame is done. Let's\
    \ start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0\
    \ = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n\
    \          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p\
    \ + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop\
    \ = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (w0 > cMaxPNGSize\
    \ || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize ||\
    \ x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n       \
    \     delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo)\
    \ {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr,\
    \ info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR,\
    \ chunksInfo)) {\n              delete[] chunk.p;\n              break;\n    \
    \        }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size()\
    \ == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop\
    \ = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo =\
    \ true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size))\
    \ {\n            delete[] chunk.p;\n            break;\n          }\n        }\
    \ else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p\
    \ + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n      \
    \    if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n\
    \            delete[] chunk.p;\n            break;\n          }\n        } else\
    \ if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6])\
    \ || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n  \
    \      } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr,\
    \ chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n\
    \          }\n          chunksInfo.push_back(chunk);\n          continue;\n  \
    \      }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n\
    \    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[]\
    \ chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate)\
    \ return false;\n  SetIntensityTarget(io);\n  return true;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nStatus DecodeImageAPNG(Span<const uint8_t> bytes, ThreadPool* pool,\n\
    \                       CodecInOut* io) {\n  Reader r;\n  unsigned int id, i,\
    \ j, w, h, w0, h0, x0, y0;\n  unsigned int delay_num, delay_den, dop, bop, rowbytes,\
    \ imagesize;\n  unsigned char sig[8];\n  png_structp png_ptr;\n  png_infop info_ptr;\n\
    \  CHUNK chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK> chunksInfo;\n  bool\
    \ isAnimated = false;\n  bool skipFirst = false;\n  bool hasInfo = false;\n  bool\
    \ all_dispose_bg = true;\n  APNGFrame frameRaw = {};\n\n  r = {bytes.data(), bytes.data()\
    \ + bytes.size()};\n  // Not an aPNG => not an error\n  unsigned char png_signature[8]\
    \ = {137, 80, 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig, 8) || memcmp(sig, png_signature,\
    \ 8) != 0) {\n    return false;\n  }\n  id = read_chunk(&r, &chunkIHDR);\n\n \
    \ io->frames.clear();\n  io->dec_pixels = 0;\n  io->metadata.m.SetUintSamples(8);\n\
    \  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding =\n      ColorEncoding::SRGB();\
    \  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n     \
    \ [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"\
    APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\
    \n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n\
    \    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p\
    \ + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n\
    \    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n\
    \    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\
    \n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h\
    \ * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p\
    \ + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw,\
    \ hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none\
    \ = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n  \
    \      if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if\
    \ (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n\
    \          skipFirst = true;\n          io->metadata.m.have_animation = true;\n\
    \          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id\
    \ == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated)))\
    \ {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr))\
    \ {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration\
    \ = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n    \
    \          bundle.origin.y0 = y0;\n              // TODO(veluca): this could in\
    \ principle be implemented.\n              if (last_base_was_none && !all_dispose_bg\
    \ &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0))\
    \ {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0\
    \ is not supported for non-full or \"\n                    \"blended frames\"\
    );\n              }\n              switch (dop) {\n                case 0:\n \
    \                 bundle.use_for_next_frame = true;\n                  last_base_was_none\
    \ = false;\n                  all_dispose_bg = false;\n                  break;\n\
    \                case 2:\n                  bundle.use_for_next_frame = false;\n\
    \                  all_dispose_bg = false;\n                  break;\n       \
    \         default:\n                  bundle.use_for_next_frame = false;\n   \
    \               last_base_was_none = true;\n              }\n              bundle.blend\
    \ = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F\
    \ sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n        \
    \      for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT\
    \ row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT\
    \ row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT\
    \ row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT\
    \ row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n\
    \                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4\
    \ * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                  \
    \  row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x]\
    \ = 0;\n                    continue;\n                  }\n                 \
    \ row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x\
    \ + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n\
    \                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n              \
    \  }\n              }\n              bundle.SetFromImage(std::move(sub_frame),\
    \ ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n\
    \                              /*alpha_is_premultiplied=*/false);\n          \
    \    io->frames.push_back(std::move(bundle));\n            } else {\n        \
    \      delete[] chunk.p;\n              break;\n            }\n          }\n\n\
    \          if (id == kId_IEND) {\n            errorstate = false;\n          \
    \  break;\n          }\n          // At this point the old frame is done. Let's\
    \ start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0\
    \ = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n\
    \          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p\
    \ + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop\
    \ = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (w0 > cMaxPNGSize\
    \ || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize ||\
    \ x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n       \
    \     delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo)\
    \ {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr,\
    \ info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR,\
    \ chunksInfo)) {\n              delete[] chunk.p;\n              break;\n    \
    \        }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size()\
    \ == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop\
    \ = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo =\
    \ true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size))\
    \ {\n            delete[] chunk.p;\n            break;\n          }\n        }\
    \ else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p\
    \ + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n      \
    \    if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n\
    \            delete[] chunk.p;\n            break;\n          }\n        } else\
    \ if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6])\
    \ || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n  \
    \      } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr,\
    \ chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n\
    \          }\n          chunksInfo.push_back(chunk);\n          continue;\n  \
    \      }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n\
    \    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[]\
    \ chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate)\
    \ return false;\n  SetIntensityTarget(io);\n  return true;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nStatus DecodeImageAPNG(Span<const uint8_t>\
    \ bytes, ThreadPool* pool,\n                       CodecInOut* io) {\n  Reader\
    \ r;\n  unsigned int id, i, j, w, h, w0, h0, x0, y0;\n  unsigned int delay_num,\
    \ delay_den, dop, bop, rowbytes, imagesize;\n  unsigned char sig[8];\n  png_structp\
    \ png_ptr;\n  png_infop info_ptr;\n  CHUNK chunk;\n  CHUNK chunkIHDR;\n  std::vector<CHUNK>\
    \ chunksInfo;\n  bool isAnimated = false;\n  bool skipFirst = false;\n  bool hasInfo\
    \ = false;\n  bool all_dispose_bg = true;\n  APNGFrame frameRaw = {};\n\n  r =\
    \ {bytes.data(), bytes.data() + bytes.size()};\n  // Not an aPNG => not an error\n\
    \  unsigned char png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};\n  if (r.Read(sig,\
    \ 8) || memcmp(sig, png_signature, 8) != 0) {\n    return false;\n  }\n  id =\
    \ read_chunk(&r, &chunkIHDR);\n\n  io->frames.clear();\n  io->dec_pixels = 0;\n\
    \  io->metadata.m.SetUintSamples(8);\n  io->metadata.m.SetAlphaBits(8);\n  io->metadata.m.color_encoding\
    \ =\n      ColorEncoding::SRGB();  // todo: get data from png metadata\n  (void)io->dec_hints.Foreach(\n\
    \      [](const std::string& key, const std::string& /*value*/) {\n        JXL_WARNING(\"\
    APNG decoder ignoring %s hint\", key.c_str());\n        return true;\n      });\n\
    \n  bool errorstate = true;\n  if (id == kId_IHDR && chunkIHDR.size == 25) {\n\
    \    w0 = w = png_get_uint_32(chunkIHDR.p + 8);\n    h0 = h = png_get_uint_32(chunkIHDR.p\
    \ + 12);\n\n    if (w > cMaxPNGSize || h > cMaxPNGSize) {\n      return false;\n\
    \    }\n\n    x0 = 0;\n    y0 = 0;\n    delay_num = 1;\n    delay_den = 10;\n\
    \    dop = 0;\n    bop = 0;\n    rowbytes = w * 4;\n    imagesize = h * rowbytes;\n\
    \n    frameRaw.p = new unsigned char[imagesize];\n    frameRaw.rows = new png_bytep[h\
    \ * sizeof(png_bytep)];\n    for (j = 0; j < h; j++) frameRaw.rows[j] = frameRaw.p\
    \ + j * rowbytes;\n\n    if (!processing_start(png_ptr, info_ptr, (void*)&frameRaw,\
    \ hasInfo,\n                          chunkIHDR, chunksInfo)) {\n      bool last_base_was_none\
    \ = true;\n      while (!r.Eof()) {\n        id = read_chunk(&r, &chunk);\n  \
    \      if (!id) break;\n        JXL_ASSERT(chunk.p != nullptr);\n\n        if\
    \ (id == kId_acTL && !hasInfo && !isAnimated) {\n          isAnimated = true;\n\
    \          skipFirst = true;\n          io->metadata.m.have_animation = true;\n\
    \          io->metadata.m.animation.tps_numerator = 1000;\n        } else if (id\
    \ == kId_IEND ||\n                   (id == kId_fcTL && (!hasInfo || isAnimated)))\
    \ {\n          if (hasInfo) {\n            if (!processing_finish(png_ptr, info_ptr))\
    \ {\n              ImageBundle bundle(&io->metadata.m);\n              bundle.duration\
    \ = delay_num * 1000 / delay_den;\n              bundle.origin.x0 = x0;\n    \
    \          bundle.origin.y0 = y0;\n              // TODO(veluca): this could in\
    \ principle be implemented.\n              if (last_base_was_none && !all_dispose_bg\
    \ &&\n                  (x0 != 0 || y0 != 0 || w0 != w || h0 != h || bop != 0))\
    \ {\n                return JXL_FAILURE(\n                    \"APNG with dispose-to-0\
    \ is not supported for non-full or \"\n                    \"blended frames\"\
    );\n              }\n              switch (dop) {\n                case 0:\n \
    \                 bundle.use_for_next_frame = true;\n                  last_base_was_none\
    \ = false;\n                  all_dispose_bg = false;\n                  break;\n\
    \                case 2:\n                  bundle.use_for_next_frame = false;\n\
    \                  all_dispose_bg = false;\n                  break;\n       \
    \         default:\n                  bundle.use_for_next_frame = false;\n   \
    \               last_base_was_none = true;\n              }\n              bundle.blend\
    \ = bop != 0;\n              io->dec_pixels += w0 * h0;\n\n              Image3F\
    \ sub_frame(w0, h0);\n              ImageF sub_frame_alpha(w0, h0);\n        \
    \      for (size_t y = 0; y < h0; ++y) {\n                float* const JXL_RESTRICT\
    \ row_r = sub_frame.PlaneRow(0, y);\n                float* const JXL_RESTRICT\
    \ row_g = sub_frame.PlaneRow(1, y);\n                float* const JXL_RESTRICT\
    \ row_b = sub_frame.PlaneRow(2, y);\n                float* const JXL_RESTRICT\
    \ row_alpha = sub_frame_alpha.Row(y);\n                uint8_t* const f = frameRaw.rows[y];\n\
    \                for (size_t x = 0; x < w0; ++x) {\n                  if (f[4\
    \ * x + 3] == 0) {\n                    row_alpha[x] = 0;\n                  \
    \  row_r[x] = 0;\n                    row_g[x] = 0;\n                    row_b[x]\
    \ = 0;\n                    continue;\n                  }\n                 \
    \ row_r[x] = f[4 * x + 0] * (1.f / 255);\n                  row_g[x] = f[4 * x\
    \ + 1] * (1.f / 255);\n                  row_b[x] = f[4 * x + 2] * (1.f / 255);\n\
    \                  row_alpha[x] = f[4 * x + 3] * (1.f / 255);\n              \
    \  }\n              }\n              bundle.SetFromImage(std::move(sub_frame),\
    \ ColorEncoding::SRGB());\n              bundle.SetAlpha(std::move(sub_frame_alpha),\n\
    \                              /*alpha_is_premultiplied=*/false);\n          \
    \    io->frames.push_back(std::move(bundle));\n            } else {\n        \
    \      delete[] chunk.p;\n              break;\n            }\n          }\n\n\
    \          if (id == kId_IEND) {\n            errorstate = false;\n          \
    \  break;\n          }\n          // At this point the old frame is done. Let's\
    \ start a new one.\n          w0 = png_get_uint_32(chunk.p + 12);\n          h0\
    \ = png_get_uint_32(chunk.p + 16);\n          x0 = png_get_uint_32(chunk.p + 20);\n\
    \          y0 = png_get_uint_32(chunk.p + 24);\n          delay_num = png_get_uint_16(chunk.p\
    \ + 28);\n          delay_den = png_get_uint_16(chunk.p + 30);\n          dop\
    \ = chunk.p[32];\n          bop = chunk.p[33];\n\n          if (w0 > cMaxPNGSize\
    \ || h0 > cMaxPNGSize || x0 > cMaxPNGSize ||\n              y0 > cMaxPNGSize ||\
    \ x0 + w0 > w || y0 + h0 > h || dop > 2 ||\n              bop > 1) {\n       \
    \     delete[] chunk.p;\n            break;\n          }\n\n          if (hasInfo)\
    \ {\n            memcpy(chunkIHDR.p + 8, chunk.p + 12, 8);\n            if (processing_start(png_ptr,\
    \ info_ptr, (void*)&frameRaw, hasInfo,\n                                 chunkIHDR,\
    \ chunksInfo)) {\n              delete[] chunk.p;\n              break;\n    \
    \        }\n          } else\n            skipFirst = false;\n\n          if (io->frames.size()\
    \ == (skipFirst ? 1 : 0)) {\n            bop = 0;\n            if (dop == 2) dop\
    \ = 1;\n          }\n        } else if (id == kId_IDAT) {\n          hasInfo =\
    \ true;\n          if (processing_data(png_ptr, info_ptr, chunk.p, chunk.size))\
    \ {\n            delete[] chunk.p;\n            break;\n          }\n        }\
    \ else if (id == kId_fdAT && isAnimated) {\n          png_save_uint_32(chunk.p\
    \ + 4, chunk.size - 16);\n          memcpy(chunk.p + 8, \"IDAT\", 4);\n      \
    \    if (processing_data(png_ptr, info_ptr, chunk.p + 4, chunk.size - 4)) {\n\
    \            delete[] chunk.p;\n            break;\n          }\n        } else\
    \ if (!isAbc(chunk.p[4]) || !isAbc(chunk.p[5]) ||\n                   !isAbc(chunk.p[6])\
    \ || !isAbc(chunk.p[7])) {\n          delete[] chunk.p;\n          break;\n  \
    \      } else if (!hasInfo) {\n          if (processing_data(png_ptr, info_ptr,\
    \ chunk.p, chunk.size)) {\n            delete[] chunk.p;\n            break;\n\
    \          }\n          chunksInfo.push_back(chunk);\n          continue;\n  \
    \      }\n        delete[] chunk.p;\n      }\n    }\n    delete[] frameRaw.rows;\n\
    \    delete[] frameRaw.p;\n  }\n\n  for (i = 0; i < chunksInfo.size(); i++) delete[]\
    \ chunksInfo[i].p;\n\n  chunksInfo.clear();\n  delete[] chunkIHDR.p;\n\n  if (errorstate)\
    \ return false;\n  SetIntensityTarget(io);\n  return true;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 196993
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
