agents:
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nex_substitute(exarg_T\
    \ *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n\
    \    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\
    \t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n\
    #endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\
    \tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL,\
    \ *sub = NULL;\t// init for GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n \
    \   int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n\
    \    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\t\
    first_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below\
    \ last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count\
    \ = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t\
    // number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy\
    \ of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when\
    \ done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef\
    \ FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n\
    \    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\
    \n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used\
    \ regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\
    \t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd !=\
    \ NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\
    \"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\
    \tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif\
    \ (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\
    \t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\
    \t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t\
    \ *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\
    \tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\"\
    , *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\
    \treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    //\
    \ use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\
    \t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\
    \t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last\
    \ used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\
    \t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd,\
    \ delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0]\
    \ == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace\
    \ it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end\
    \ of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\
    \t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd,\
    \ delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses\
    \ the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t &&\
    \ vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t\
    // there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\t\
    vim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n   \
    \ else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif\
    \ (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\
    \tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the\
    \ cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant\
    \ == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join\
    \ command, which is much\n    // more efficient.\n    // TODO: find a generic\
    \ solution to make line-joining operations more\n    // efficient, avoid allocating\
    \ a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\")\
    \ == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd\
    \ == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n  \
    \  {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\t\
    curwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\
    \telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\
    \t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number\
    \ of lines in the range plus\n\t// one.  One less when the last line is included.\n\
    \tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\
    \t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count,\
    \ FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t  \
    \  sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\
    \t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST,\
    \ pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH,\
    \ pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.\
    \  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n\
    \    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore\
    \ 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask\
    \ = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default\
    \ is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all =\
    \ FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\t\
    subflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count =\
    \ FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while\
    \ (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when\
    \ p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t   \
    \ subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask\
    \ = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\
    \telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse\
    \ if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\t\
    else if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\
    \t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\t\
    else if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list\
    \ = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic\
    \ = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic\
    \ = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\t\
    subflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask\
    \ = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n \
    \   cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\
    \tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\
    \t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2\
    \ > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\
    \    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd\
    \ = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line\
    \ or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t\
    {\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\
    \n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\
    \n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is\
    \ not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\
    \treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS,\
    \ &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\
    \treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n\
    \    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic\
    \ == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n\
    \     * ~ in the substitute pattern is replaced with the old pattern.\n     *\
    \ We do it here once to avoid it to be replaced over and over again.\n     * But\
    \ don't do it when it starts with \"\\=\", then it's an expression.\n     */\n\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n\tsub = regtilde(sub, magic_isset());\n\
    \n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n\
    \    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\
    \t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch,\
    \ curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\
    \t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol\
    \ = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len\
    \ = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\
    \t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of\
    \ lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining\
    \ lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t//\
    \ nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO\
    \ | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t\
    \     * The new text is build up step by step, to avoid too much\n\t     * copying.\
    \  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\
    \t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking\
    \ for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the\
    \ new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\
    \t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious\
    \ match or one further.\n\t     * prev_matchcol\tColumn just after the previous\
    \ match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\
    \t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\t\
    Where the pattern matched in the old text.\n\t     * new_start\tThe new text,\
    \ all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new\
    \ text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number\
    \ where we found the start of\n\t     *\t\t\tthe match.  Can be below the line\
    \ we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t    \
    \ *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where\
    \ to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t    \
    \ *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\
    \t     *\n\t     * Special situations:\n\t     * - When the substitute string\
    \ contains a line break, the part up\n\t     *   to the line break is inserted\
    \ in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\"\
    \ is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched\
    \ pattern contains a line break, the old line\n\t     *   is taken from the line\
    \ at the end of the pattern.  The lines\n\t     *   in the match are deleted later,\
    \ \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The\
    \ new text is built up in new_start[].  It has some extra\n\t     * room to avoid\
    \ using alloc()/free() too often.  new_start_len is\n\t     * the length of the\
    \ allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line,\
    \ so it won't be taken away when\n\t     * updating the screen or handling a multi-line\
    \ match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t\
    \    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    //\
    \ At first match, remember current cursor position.\n\t    if (!got_match)\n\t\
    \    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     *\
    \ Loop until nothing more to replace in this line.\n\t     * 1. Handle match with\
    \ empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     *\
    \ 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t\
    \     * 5. break if there isn't another match in this line\n\t     */\n\t    for\
    \ (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts. \
    \ The\n\t\t// match does not start in the first line when there is a line\n\t\t\
    // break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t   \
    \ lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\
    \t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\
    \t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\
    \t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\
    \t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline\
    \ = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\
    \t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\
    \t\t// Save the line number of the last change for the final\n\t\t// cursor position\
    \ (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\
    \t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t *\
    \ match.  This reproduces the strange vi behaviour.\n\t\t * This also catches\
    \ endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum\
    \ == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol]\
    \ == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t\
    // for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\
    \t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\
    \t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t\
    \    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue\
    \ searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol =\
    \ regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2.\
    \ If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask\
    \ for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For\
    \ a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line\
    \ and set nmatch to one, so that\n\t\t    // we continue looking for a match on\
    \ the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t\
    \    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\
    \t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless\
    \ an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t\
    }\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change\
    \ State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State\
    \ = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse\
    \ in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t   \
    \ if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions'\
    \ contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\
    \t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t   \
    \ /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\
    \t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\
    \t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\
    \t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin,\
    \ &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col\
    \ - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col\
    \ = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t\
    \    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number\
    \ || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\
    \t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\
    \t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t  \
    \  for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp =\
    \ getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\
    \t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\t\
    else\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change\
    \ = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int\
    \ save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\
    \t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\
    \t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t\
    \    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\
    \n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was\
    \ a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\
    \t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches. \
    \ Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\
    \t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\
    \t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t  \
    \   sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\t\
    VIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position\
    \ the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\
    \t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before\
    \ the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\
    \t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\
    \t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\
    \    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t\
    \  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\
    \t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t  \
    \  update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\
    \t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef\
    \ FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if\
    \ (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\
    \t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\
    \t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\
    \t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\
    \t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"\
    ), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t  \
    \  showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled\
    \ = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow\
    \ scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\
    \t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\
    \t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\
    \t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\
    \t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore\
    \ the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line,\
    \ FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\
    \t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\
    \t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\
    \t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif\
    \ (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t \
    \   // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t\
    \    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t\
    {\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed\
    \ == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\
    \t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\
    \t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t \
    \   if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol\
    \ at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\
    \t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that\
    \ \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing\
    \ 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if\
    \ (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of\
    \ the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col\
    \ = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t\
    \ */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\
    \t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t\
    \    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for\
    \ recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\
    \tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\
    \tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\
    \t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\
    \t\t// If getting the substitute string caused an error, don't do\n\t\t// the\
    \ replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags\
    \ = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma\
    \ = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\
    \t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it\
    \ may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count\
    \ - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum\
    \ + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result\
    \ so far in new_start (not for first sub in line)\n\t\t// - original text up to\
    \ match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\
    \t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\
    \t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\
    \t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen\
    \ - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\
    \n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first,\
    \ unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added\
    \ + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\
    \t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number\
    \ of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added\
    \ += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum\
    \ + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col\
    \ - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t    \
    \   - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t\
    {\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t\
    \     * substitution into (and some extra space to avoid\n\t\t     * too many\
    \ calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len +\
    \ 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\
    \t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\
    \t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     *\
    \ extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len\
    \ = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len\
    \ > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\
    \t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\
    \t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len\
    \ + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t \
    \   new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the\
    \ part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol,\
    \ (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\
    \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end,\
    \ TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t//\
    \ Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond\
    \ the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\
    \n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line\
    \ and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum\
    \ += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\
    \t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum\
    \ <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\
    \t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\
    \n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum\
    \ is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\
    \t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\
    \t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\
    \t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the\
    \ text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a\
    \ backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in\
    \ the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\t\
    for (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] !=\
    \ NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties\
    \ are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\
    \t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start),\
    \ -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t\
    }\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum)\
    \ == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1\
    \ - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\
    \t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum\
    \ + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum\
    \ - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\
    \t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t   \
    \ // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\
    \t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\
    \t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start,\
    \ p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if\
    \ (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4.\
    \ If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns\
    \ that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t\
    \ * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did\
    \ the last subst when we are at\n\t\t// the end of the line, except that a pattern\
    \ like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\
    \t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\
    \t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum\
    \ > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol]\
    \ == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\t\
    nmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This\
    \ is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl\
    \ is needed for when multi-line\n\t\t * matching must replace the lines before\
    \ trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t *\
    \ When the match starts below where we start searching also\n\t\t * need to replace\
    \ the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl\
    \ > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\t\
    curbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t||\
    \ regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t\
    \    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\
    \t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as\
    \ reference, because the substitute may\n\t\t\t * have changed the number of characters.\
    \  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline\
    \ + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\
    \t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\
    \n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start,\
    \ TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched\
    \ lines have now been substituted and are\n\t\t\t     * useless, delete them.\
    \  The part after the match\n\t\t\t     * has been appended to new_start, we don't\
    \ need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\
    \t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i\
    \ = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum,\
    \ lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t  \
    \  if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\
    \t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl =\
    \ 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\
    \t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum,\
    \ 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line\
    \ = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\
    \t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline\
    \ = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline)\
    \ - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\
    \t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch\
    \ == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\
    \t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5.\
    \ break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch\
    \ <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\
    \t\t// searching, do the next search in the line where we\n\t\t\t// found the\
    \ match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\
    \t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if\
    \ (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute\
    \ was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original\
    \ line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\
    \t// Need to subtract the number of added lines from \"last_line\" to get\n\t\
    // the line number before the change (same as adding the number of\n\t// deleted\
    \ lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line,\
    \ 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may\
    \ have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move\
    \ the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n\
    \    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS)\
    \ == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum\
    \ = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col\
    \ = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when\
    \ interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\
    \t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE\
    \ | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\
    \t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\
    \t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\
    \    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t\
    \    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but\
    \ nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing\
    \ found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n\
    #ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor\
    \ position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n\
    \n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all\
    \ = save_do_all;\n    subflags.do_ask = save_do_ask;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nex_substitute(exarg_T\
    \ *eap)\n{\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n\
    \    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\
    \t\t\t      FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n\
    #endif\n    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\
    \tsave_do_ask;\t\t// remember user specified 'c' flag\n    char_u\t*pat = NULL,\
    \ *sub = NULL;\t// init for GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n \
    \   int\t\tgot_quit = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n\
    \    int\t\twhich_pat;\n    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\t\
    first_line = 0;\t\t// first changed line\n    linenr_T\tlast_line= 0;\t\t// below\
    \ last changed line AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count\
    \ = curbuf->b_ml.ml_line_count;\n    linenr_T\tline2;\n    long\tnmatch;\t\t\t\
    // number of lines in match\n    char_u\t*sub_firstline;\t\t// allocated copy\
    \ of first sub line\n    int\t\tendcolumn = FALSE;\t// cursor in last column when\
    \ done\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef\
    \ FEAT_EVAL\n    int\t\tsave_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n\
    \    {\n\tsub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\
    \n    if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used\
    \ regexp\n    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\
    \t\t\t\t// new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd !=\
    \ NUL && !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\
    \"\", *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\
    \tif (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif\
    \ (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\
    \t\t      == FAIL)\n\t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\
    \t *  \"\\/sub/\" and \"\\?sub?\" use last used search pattern (almost like\n\t\
    \ *  //sub/r).  \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\
    \tif (*cmd == '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\"\
    , *cmd) == NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\
    \treturn;\n\t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    //\
    \ use last '/' pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\
    \t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\
    \t// find the end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last\
    \ used regexp\n\t    delimiter = *cmd++;\t\t    // remember delimiter character\n\
    \t    pat = cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd,\
    \ delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0]\
    \ == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace\
    \ it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end\
    \ of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\
    \t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd,\
    \ delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses\
    \ the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t &&\
    \ vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t\
    // there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\t\
    vim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n   \
    \ else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif\
    \ (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\
    \tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the\
    \ cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant\
    \ == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join\
    \ command, which is much\n    // more efficient.\n    // TODO: find a generic\
    \ solution to make line-joining operations more\n    // efficient, avoid allocating\
    \ a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\")\
    \ == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd\
    \ == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n  \
    \  {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\t\
    curwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\
    \telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\
    \t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number\
    \ of lines in the range plus\n\t// one.  One less when the last line is included.\n\
    \tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\
    \t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count,\
    \ FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t  \
    \  sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\
    \t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST,\
    \ pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH,\
    \ pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.\
    \  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n\
    \    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore\
    \ 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask\
    \ = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default\
    \ is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all =\
    \ FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\t\
    subflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count =\
    \ FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while\
    \ (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when\
    \ p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t   \
    \ subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask\
    \ = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\
    \telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse\
    \ if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\t\
    else if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\
    \t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\t\
    else if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list\
    \ = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic\
    \ = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic\
    \ = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\t\
    subflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask\
    \ = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n \
    \   cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\
    \tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\
    \t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2\
    \ > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\
    \    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd\
    \ = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line\
    \ or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t\
    {\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\
    \n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\
    \n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is\
    \ not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\
    \treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS,\
    \ &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\
    \treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n\
    \    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic\
    \ == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n\
    \     * ~ in the substitute pattern is replaced with the old pattern.\n     *\
    \ We do it here once to avoid it to be replaced over and over again.\n     * But\
    \ don't do it when it starts with \"\\=\", then it's an expression.\n     */\n\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n\tsub = regtilde(sub, magic_isset());\n\
    \n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n\
    \    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\
    \t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch,\
    \ curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\
    \t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol\
    \ = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len\
    \ = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\
    \t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of\
    \ lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining\
    \ lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t//\
    \ nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO\
    \ | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t\
    \     * The new text is build up step by step, to avoid too much\n\t     * copying.\
    \  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\
    \t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking\
    \ for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the\
    \ new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\
    \t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious\
    \ match or one further.\n\t     * prev_matchcol\tColumn just after the previous\
    \ match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\
    \t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\t\
    Where the pattern matched in the old text.\n\t     * new_start\tThe new text,\
    \ all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new\
    \ text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number\
    \ where we found the start of\n\t     *\t\t\tthe match.  Can be below the line\
    \ we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t    \
    \ *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where\
    \ to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t    \
    \ *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\
    \t     *\n\t     * Special situations:\n\t     * - When the substitute string\
    \ contains a line break, the part up\n\t     *   to the line break is inserted\
    \ in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\"\
    \ is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched\
    \ pattern contains a line break, the old line\n\t     *   is taken from the line\
    \ at the end of the pattern.  The lines\n\t     *   in the match are deleted later,\
    \ \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The\
    \ new text is built up in new_start[].  It has some extra\n\t     * room to avoid\
    \ using alloc()/free() too often.  new_start_len is\n\t     * the length of the\
    \ allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line,\
    \ so it won't be taken away when\n\t     * updating the screen or handling a multi-line\
    \ match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t\
    \    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    //\
    \ At first match, remember current cursor position.\n\t    if (!got_match)\n\t\
    \    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     *\
    \ Loop until nothing more to replace in this line.\n\t     * 1. Handle match with\
    \ empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     *\
    \ 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t\
    \     * 5. break if there isn't another match in this line\n\t     */\n\t    for\
    \ (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts. \
    \ The\n\t\t// match does not start in the first line when there is a line\n\t\t\
    // break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t   \
    \ lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\
    \t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\
    \t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\
    \t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\
    \t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline\
    \ = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\
    \t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\
    \t\t// Save the line number of the last change for the final\n\t\t// cursor position\
    \ (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\
    \t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t *\
    \ match.  This reproduces the strange vi behaviour.\n\t\t * This also catches\
    \ endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum\
    \ == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol]\
    \ == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t\
    // for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\
    \t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\
    \t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t\
    \    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue\
    \ searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol =\
    \ regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2.\
    \ If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask\
    \ for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For\
    \ a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line\
    \ and set nmatch to one, so that\n\t\t    // we continue looking for a match on\
    \ the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t\
    \    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\
    \t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless\
    \ an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t\
    }\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change\
    \ State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State\
    \ = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse\
    \ in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t   \
    \ if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions'\
    \ contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\
    \t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t   \
    \ /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\
    \t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\
    \t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\
    \t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin,\
    \ &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col\
    \ - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col\
    \ = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t\
    \    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number\
    \ || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\
    \t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\
    \t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t  \
    \  for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp =\
    \ getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\
    \t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\t\
    else\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change\
    \ = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int\
    \ save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\
    \t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\
    \t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t\
    \    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\
    \n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was\
    \ a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\
    \t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches. \
    \ Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\
    \t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\
    \t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t  \
    \   sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\t\
    VIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position\
    \ the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\
    \t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before\
    \ the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\
    \t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\
    \t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\
    \    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t\
    \  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\
    \t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t  \
    \  update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\
    \t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef\
    \ FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if\
    \ (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\
    \t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\
    \t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\
    \t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\
    \t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"\
    ), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t  \
    \  showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled\
    \ = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow\
    \ scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\
    \t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\
    \t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\
    \t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\
    \t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore\
    \ the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line,\
    \ FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\
    \t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\
    \t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\
    \t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif\
    \ (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t \
    \   // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t\
    \    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t\
    {\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed\
    \ == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\
    \t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\
    \t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t \
    \   if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol\
    \ at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\
    \t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that\
    \ \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing\
    \ 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if\
    \ (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of\
    \ the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col\
    \ = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t\
    \ */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\
    \t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t\
    \    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for\
    \ recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\
    \tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\
    \tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\
    \t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\
    \t\t// If getting the substitute string caused an error, don't do\n\t\t// the\
    \ replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags\
    \ = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma\
    \ = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\
    \t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it\
    \ may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count\
    \ - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum\
    \ + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result\
    \ so far in new_start (not for first sub in line)\n\t\t// - original text up to\
    \ match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\
    \t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\
    \t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\
    \t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen\
    \ - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\
    \n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first,\
    \ unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added\
    \ + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\
    \t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number\
    \ of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added\
    \ += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum\
    \ + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col\
    \ - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t    \
    \   - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t\
    {\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t\
    \     * substitution into (and some extra space to avoid\n\t\t     * too many\
    \ calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len +\
    \ 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\
    \t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\
    \t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     *\
    \ extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len\
    \ = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len\
    \ > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\
    \t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\
    \t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len\
    \ + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t \
    \   new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the\
    \ part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol,\
    \ (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\
    \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end,\
    \ TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t//\
    \ Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond\
    \ the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\
    \n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line\
    \ and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum\
    \ += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\
    \t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum\
    \ <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\
    \t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\
    \n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum\
    \ is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\
    \t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\
    \t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\
    \t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the\
    \ text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a\
    \ backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in\
    \ the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\t\
    for (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] !=\
    \ NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties\
    \ are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\
    \t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start),\
    \ -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t\
    }\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum)\
    \ == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1\
    \ - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\
    \t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum\
    \ + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum\
    \ - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\
    \t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t   \
    \ // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\
    \t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\
    \t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start,\
    \ p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if\
    \ (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4.\
    \ If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns\
    \ that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t\
    \ * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did\
    \ the last subst when we are at\n\t\t// the end of the line, except that a pattern\
    \ like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\
    \t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\
    \t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum\
    \ > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol]\
    \ == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\t\
    nmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This\
    \ is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl\
    \ is needed for when multi-line\n\t\t * matching must replace the lines before\
    \ trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t *\
    \ When the match starts below where we start searching also\n\t\t * need to replace\
    \ the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl\
    \ > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\t\
    curbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t||\
    \ regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t\
    \    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\
    \t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as\
    \ reference, because the substitute may\n\t\t\t * have changed the number of characters.\
    \  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline\
    \ + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\
    \t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\
    \n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start,\
    \ TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched\
    \ lines have now been substituted and are\n\t\t\t     * useless, delete them.\
    \  The part after the match\n\t\t\t     * has been appended to new_start, we don't\
    \ need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\
    \t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i\
    \ = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum,\
    \ lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t  \
    \  if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\
    \t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl =\
    \ 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\
    \t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum,\
    \ 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line\
    \ = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\
    \t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline\
    \ = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline)\
    \ - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\
    \t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch\
    \ == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\
    \t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5.\
    \ break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch\
    \ <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\
    \t\t// searching, do the next search in the line where we\n\t\t\t// found the\
    \ match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\
    \t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if\
    \ (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute\
    \ was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original\
    \ line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\
    \t// Need to subtract the number of added lines from \"last_line\" to get\n\t\
    // the line number before the change (same as adding the number of\n\t// deleted\
    \ lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line,\
    \ 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may\
    \ have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move\
    \ the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n\
    \    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS)\
    \ == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum\
    \ = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col\
    \ = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when\
    \ interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\
    \t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE\
    \ | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\
    \t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\
    \t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\
    \    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t\
    \    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but\
    \ nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing\
    \ found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n\
    #ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor\
    \ position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n\
    \n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all\
    \ = save_do_all;\n    subflags.do_ask = save_do_ask;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nex_substitute(exarg_T *eap)\n{\n    linenr_T\t\
    lnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static subflags_T subflags\
    \ = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t      FALSE, FALSE, 0};\n\
    #ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n    int\t\tsave_do_all;\t\
    \t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\t// remember\
    \ user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t// init for\
    \ GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit = FALSE;\n\
    \    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n    char_u\t\
    *cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t// first changed\
    \ line\n    linenr_T\tlast_line= 0;\t\t// below last changed line AFTER the\n\t\
    \t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n\
    \    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n  \
    \  char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\t\
    endcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor\
    \ = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\t\
    save_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\t\
    sub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n   \
    \ if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n\
    \    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t\
    // new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL &&\
    \ !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\",\
    \ *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\t\
    if (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script()\
    \ && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\
    \t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\"\
    \ and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r). \
    \ \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd ==\
    \ '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) ==\
    \ NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\
    \t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/'\
    \ pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter\
    \ = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the\
    \ end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\
    \t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat =\
    \ cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd,\
    \ delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0]\
    \ == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace\
    \ it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end\
    \ of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\
    \t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd,\
    \ delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses\
    \ the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t &&\
    \ vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t\
    // there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\t\
    vim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n   \
    \ else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif\
    \ (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\
    \tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the\
    \ cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant\
    \ == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join\
    \ command, which is much\n    // more efficient.\n    // TODO: find a generic\
    \ solution to make line-joining operations more\n    // efficient, avoid allocating\
    \ a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\")\
    \ == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd\
    \ == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n  \
    \  {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\t\
    curwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\
    \telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\
    \t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number\
    \ of lines in the range plus\n\t// one.  One less when the last line is included.\n\
    \tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\
    \t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count,\
    \ FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t  \
    \  sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\
    \t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST,\
    \ pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH,\
    \ pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.\
    \  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n\
    \    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore\
    \ 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask\
    \ = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default\
    \ is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all =\
    \ FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\t\
    subflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count =\
    \ FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while\
    \ (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when\
    \ p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t   \
    \ subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask\
    \ = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\
    \telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse\
    \ if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\t\
    else if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\
    \t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\t\
    else if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list\
    \ = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic\
    \ = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic\
    \ = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\t\
    subflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask\
    \ = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n \
    \   cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\
    \tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\
    \t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2\
    \ > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\
    \    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd\
    \ = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line\
    \ or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t\
    {\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\
    \n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\
    \n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is\
    \ not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\
    \treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS,\
    \ &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\
    \treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n\
    \    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic\
    \ == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n\
    \     * ~ in the substitute pattern is replaced with the old pattern.\n     *\
    \ We do it here once to avoid it to be replaced over and over again.\n     * But\
    \ don't do it when it starts with \"\\=\", then it's an expression.\n     */\n\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n\tsub = regtilde(sub, magic_isset());\n\
    \n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n\
    \    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\
    \t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch,\
    \ curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\
    \t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol\
    \ = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len\
    \ = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\
    \t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of\
    \ lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining\
    \ lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t//\
    \ nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO\
    \ | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t\
    \     * The new text is build up step by step, to avoid too much\n\t     * copying.\
    \  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\
    \t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking\
    \ for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the\
    \ new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\
    \t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious\
    \ match or one further.\n\t     * prev_matchcol\tColumn just after the previous\
    \ match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\
    \t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\t\
    Where the pattern matched in the old text.\n\t     * new_start\tThe new text,\
    \ all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new\
    \ text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number\
    \ where we found the start of\n\t     *\t\t\tthe match.  Can be below the line\
    \ we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t    \
    \ *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where\
    \ to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t    \
    \ *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\
    \t     *\n\t     * Special situations:\n\t     * - When the substitute string\
    \ contains a line break, the part up\n\t     *   to the line break is inserted\
    \ in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\"\
    \ is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched\
    \ pattern contains a line break, the old line\n\t     *   is taken from the line\
    \ at the end of the pattern.  The lines\n\t     *   in the match are deleted later,\
    \ \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The\
    \ new text is built up in new_start[].  It has some extra\n\t     * room to avoid\
    \ using alloc()/free() too often.  new_start_len is\n\t     * the length of the\
    \ allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line,\
    \ so it won't be taken away when\n\t     * updating the screen or handling a multi-line\
    \ match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t\
    \    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    //\
    \ At first match, remember current cursor position.\n\t    if (!got_match)\n\t\
    \    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     *\
    \ Loop until nothing more to replace in this line.\n\t     * 1. Handle match with\
    \ empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     *\
    \ 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t\
    \     * 5. break if there isn't another match in this line\n\t     */\n\t    for\
    \ (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts. \
    \ The\n\t\t// match does not start in the first line when there is a line\n\t\t\
    // break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t   \
    \ lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\
    \t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\
    \t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\
    \t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\
    \t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline\
    \ = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\
    \t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\
    \t\t// Save the line number of the last change for the final\n\t\t// cursor position\
    \ (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\
    \t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t *\
    \ match.  This reproduces the strange vi behaviour.\n\t\t * This also catches\
    \ endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum\
    \ == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol]\
    \ == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t\
    // for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\
    \t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\
    \t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t\
    \    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue\
    \ searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol =\
    \ regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2.\
    \ If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask\
    \ for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For\
    \ a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line\
    \ and set nmatch to one, so that\n\t\t    // we continue looking for a match on\
    \ the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t\
    \    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\
    \t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless\
    \ an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t\
    }\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change\
    \ State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State\
    \ = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse\
    \ in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t   \
    \ if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions'\
    \ contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\
    \t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t   \
    \ /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\
    \t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\
    \t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\
    \t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin,\
    \ &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col\
    \ - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col\
    \ = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t\
    \    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number\
    \ || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\
    \t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\
    \t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t  \
    \  for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp =\
    \ getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\
    \t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\t\
    else\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change\
    \ = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int\
    \ save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\
    \t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\
    \t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t\
    \    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\
    \n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was\
    \ a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\
    \t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches. \
    \ Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\
    \t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\
    \t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t  \
    \   sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\t\
    VIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position\
    \ the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\
    \t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before\
    \ the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\
    \t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\
    \t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\
    \    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t\
    \  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\
    \t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t  \
    \  update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\
    \t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef\
    \ FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if\
    \ (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\
    \t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\
    \t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\
    \t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\
    \t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"\
    ), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t  \
    \  showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled\
    \ = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow\
    \ scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\
    \t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\
    \t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\
    \t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\
    \t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore\
    \ the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line,\
    \ FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\
    \t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\
    \t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\
    \t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif\
    \ (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t \
    \   // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t\
    \    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t\
    {\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed\
    \ == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\
    \t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\
    \t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t \
    \   if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol\
    \ at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\
    \t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that\
    \ \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing\
    \ 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if\
    \ (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of\
    \ the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col\
    \ = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t\
    \ */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\
    \t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t\
    \    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for\
    \ recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\
    \tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\
    \tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\
    \t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\
    \t\t// If getting the substitute string caused an error, don't do\n\t\t// the\
    \ replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags\
    \ = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma\
    \ = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\
    \t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it\
    \ may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count\
    \ - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum\
    \ + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result\
    \ so far in new_start (not for first sub in line)\n\t\t// - original text up to\
    \ match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\
    \t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\
    \t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\
    \t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen\
    \ - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\
    \n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first,\
    \ unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added\
    \ + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\
    \t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number\
    \ of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added\
    \ += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum\
    \ + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col\
    \ - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t    \
    \   - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t\
    {\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t\
    \     * substitution into (and some extra space to avoid\n\t\t     * too many\
    \ calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len +\
    \ 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\
    \t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\
    \t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     *\
    \ extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len\
    \ = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len\
    \ > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\
    \t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\
    \t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len\
    \ + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t \
    \   new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the\
    \ part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol,\
    \ (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\
    \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end,\
    \ TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t//\
    \ Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond\
    \ the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\
    \n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line\
    \ and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum\
    \ += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\
    \t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum\
    \ <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\
    \t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\
    \n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum\
    \ is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\
    \t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\
    \t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\
    \t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the\
    \ text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a\
    \ backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in\
    \ the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\t\
    for (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] !=\
    \ NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties\
    \ are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\
    \t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start),\
    \ -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t\
    }\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum)\
    \ == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1\
    \ - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\
    \t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum\
    \ + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum\
    \ - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\
    \t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t   \
    \ // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\
    \t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\
    \t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start,\
    \ p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if\
    \ (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4.\
    \ If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns\
    \ that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t\
    \ * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did\
    \ the last subst when we are at\n\t\t// the end of the line, except that a pattern\
    \ like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\
    \t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\
    \t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum\
    \ > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol]\
    \ == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\t\
    nmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This\
    \ is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl\
    \ is needed for when multi-line\n\t\t * matching must replace the lines before\
    \ trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t *\
    \ When the match starts below where we start searching also\n\t\t * need to replace\
    \ the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl\
    \ > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\t\
    curbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t||\
    \ regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t\
    \    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\
    \t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as\
    \ reference, because the substitute may\n\t\t\t * have changed the number of characters.\
    \  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline\
    \ + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\
    \t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\
    \n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start,\
    \ TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched\
    \ lines have now been substituted and are\n\t\t\t     * useless, delete them.\
    \  The part after the match\n\t\t\t     * has been appended to new_start, we don't\
    \ need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\
    \t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i\
    \ = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum,\
    \ lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t  \
    \  if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\
    \t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl =\
    \ 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\
    \t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum,\
    \ 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line\
    \ = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\
    \t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline\
    \ = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline)\
    \ - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\
    \t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch\
    \ == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\
    \t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5.\
    \ break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch\
    \ <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\
    \t\t// searching, do the next search in the line where we\n\t\t\t// found the\
    \ match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\
    \t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if\
    \ (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute\
    \ was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original\
    \ line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\
    \t// Need to subtract the number of added lines from \"last_line\" to get\n\t\
    // the line number before the change (same as adding the number of\n\t// deleted\
    \ lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line,\
    \ 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may\
    \ have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move\
    \ the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n\
    \    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS)\
    \ == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum\
    \ = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col\
    \ = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when\
    \ interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\
    \t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE\
    \ | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\
    \t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\
    \t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\
    \    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t\
    \    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but\
    \ nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing\
    \ found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n\
    #ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor\
    \ position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n\
    \n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all\
    \ = save_do_all;\n    subflags.do_ask = save_do_ask;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nex_substitute(exarg_T *eap)\n\
    {\n    linenr_T\tlnum;\n    long\ti = 0;\n    regmmatch_T regmatch;\n    static\
    \ subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,\n\t\t\t\t\t\t\t   \
    \   FALSE, FALSE, 0};\n#ifdef FEAT_EVAL\n    subflags_T\tsubflags_save;\n#endif\n\
    \    int\t\tsave_do_all;\t\t// remember user specified 'g' flag\n    int\t\tsave_do_ask;\t\
    \t// remember user specified 'c' flag\n    char_u\t*pat = NULL, *sub = NULL;\t\
    // init for GCC\n    int\t\tdelimiter;\n    int\t\tsublen;\n    int\t\tgot_quit\
    \ = FALSE;\n    int\t\tgot_match = FALSE;\n    int\t\ttemp;\n    int\t\twhich_pat;\n\
    \    char_u\t*cmd;\n    int\t\tsave_State;\n    linenr_T\tfirst_line = 0;\t\t\
    // first changed line\n    linenr_T\tlast_line= 0;\t\t// below last changed line\
    \ AFTER the\n\t\t\t\t\t// change\n    linenr_T\told_line_count = curbuf->b_ml.ml_line_count;\n\
    \    linenr_T\tline2;\n    long\tnmatch;\t\t\t// number of lines in match\n  \
    \  char_u\t*sub_firstline;\t\t// allocated copy of first sub line\n    int\t\t\
    endcolumn = FALSE;\t// cursor in last column when done\n    pos_T\told_cursor\
    \ = curwin->w_cursor;\n    int\t\tstart_nsubs;\n#ifdef FEAT_EVAL\n    int\t\t\
    save_ma = 0;\n#endif\n\n    cmd = eap->arg;\n    if (!global_busy)\n    {\n\t\
    sub_nsubs = 0;\n\tsub_nlines = 0;\n    }\n    start_nsubs = sub_nsubs;\n\n   \
    \ if (eap->cmdidx == CMD_tilde)\n\twhich_pat = RE_LAST;\t// use last used regexp\n\
    \    else\n\twhich_pat = RE_SUBST;\t// use last substitute regexp\n\n\t\t\t\t\
    // new pattern and substitution\n    if (eap->cmd[0] == 's' && *cmd != NUL &&\
    \ !VIM_ISWHITE(*cmd)\n\t\t&& vim_strchr((char_u *)\"0123456789cegriIp|\\\"\",\
    \ *cmd) == NULL)\n    {\n\t\t\t\t// don't accept alphanumeric for separator\n\t\
    if (check_regexp_delim(*cmd) == FAIL)\n\t    return;\n#ifdef FEAT_EVAL\n\tif (in_vim9script()\
    \ && check_global_and_subst(eap->cmd, eap->arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\
    \t    return;\n#endif\n\n\t/*\n\t * undocumented vi feature:\n\t *  \"\\/sub/\"\
    \ and \"\\?sub?\" use last used search pattern (almost like\n\t *  //sub/r). \
    \ \"\\&sub&\" use last substitute pattern (like //sub/).\n\t */\n\tif (*cmd ==\
    \ '\\\\')\n\t{\n\t    ++cmd;\n\t    if (vim_strchr((char_u *)\"/?&\", *cmd) ==\
    \ NULL)\n\t    {\n\t\temsg(_(e_backslash_should_be_followed_by));\n\t\treturn;\n\
    \t    }\n\t    if (*cmd != '&')\n\t\twhich_pat = RE_SEARCH;\t    // use last '/'\
    \ pattern\n\t    pat = (char_u *)\"\";\t\t    // empty search pattern\n\t    delimiter\
    \ = *cmd++;\t\t    // remember delimiter character\n\t}\n\telse\t\t// find the\
    \ end of the regexp\n\t{\n\t    which_pat = RE_LAST;\t    // use last used regexp\n\
    \t    delimiter = *cmd++;\t\t    // remember delimiter character\n\t    pat =\
    \ cmd;\t\t\t    // remember start of search pat\n\t    cmd = skip_regexp_ex(cmd,\
    \ delimiter, magic_isset(),\n\t\t\t\t\t\t\t&eap->arg, NULL, NULL);\n\t    if (cmd[0]\
    \ == delimiter)\t    // end delimiter found\n\t\t*cmd++ = NUL;\t\t    // replace\
    \ it with a NUL\n\t}\n\n\t/*\n\t * Small incompatibility: vi sees '\\n' as end\
    \ of the command, but in\n\t * Vim we want to use '\\n' to find/substitute a NUL.\n\
    \t */\n\tsub = cmd;\t    // remember the start of the substitution\n\tcmd = skip_substitute(cmd,\
    \ delimiter);\n\n\tif (!eap->skip)\n\t{\n\t    // In POSIX vi \":s/pat/%/\" uses\
    \ the previous subst. string.\n\t    if (STRCMP(sub, \"%\") == 0\n\t\t\t\t &&\
    \ vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)\n\t    {\n\t\tif (old_sub == NULL)\t\
    // there is no previous command\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t\t    return;\n\t\t}\n\t\tsub = old_sub;\n\t    }\n\t    else\n\t    {\n\t\t\
    vim_free(old_sub);\n\t\told_sub = vim_strsave(sub);\n\t    }\n\t}\n    }\n   \
    \ else if (!eap->skip)\t// use previous pattern and substitution\n    {\n\tif\
    \ (old_sub == NULL)\t// there is no previous command\n\t{\n\t    emsg(_(e_no_previous_substitute_regular_expression));\n\
    \t    return;\n\t}\n\tpat = NULL;\t\t// search_regcomp() will use previous pattern\n\
    \tsub = old_sub;\n\n\t// Vi compatibility quirk: repeating with \":s\" keeps the\
    \ cursor in the\n\t// last column after using \"$\".\n\tendcolumn = (curwin->w_curswant\
    \ == MAXCOL);\n    }\n\n    // Recognize \":%s/\\n//\" and turn it into a join\
    \ command, which is much\n    // more efficient.\n    // TODO: find a generic\
    \ solution to make line-joining operations more\n    // efficient, avoid allocating\
    \ a string that grows in size.\n    if (pat != NULL && STRCMP(pat, \"\\\\n\")\
    \ == 0\n\t    && *sub == NUL\n\t    && (*cmd == NUL || (cmd[1] == NUL && (*cmd\
    \ == 'g' || *cmd == 'l'\n\t\t\t\t\t     || *cmd == 'p' || *cmd == '#'))))\n  \
    \  {\n\tlinenr_T    joined_lines_count;\n\n\tif (eap->skip)\n\t    return;\n\t\
    curwin->w_cursor.lnum = eap->line1;\n\tif (*cmd == 'l')\n\t    eap->flags = EXFLAG_LIST;\n\
    \telse if (*cmd == '#')\n\t    eap->flags = EXFLAG_NR;\n\telse if (*cmd == 'p')\n\
    \t    eap->flags = EXFLAG_PRINT;\n\n\t// The number of lines joined is the number\
    \ of lines in the range plus\n\t// one.  One less when the last line is included.\n\
    \tjoined_lines_count = eap->line2 - eap->line1 + 1;\n\tif (eap->line2 < curbuf->b_ml.ml_line_count)\n\
    \t    ++joined_lines_count;\n\tif (joined_lines_count > 1)\n\t{\n\t    (void)do_join(joined_lines_count,\
    \ FALSE, TRUE, FALSE, TRUE);\n\t    sub_nsubs = joined_lines_count - 1;\n\t  \
    \  sub_nlines = 1;\n\t    (void)do_sub_msg(FALSE);\n\t    ex_may_print(eap);\n\
    \t}\n\n\tif ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n\t    save_re_pat(RE_SUBST,\
    \ pat, magic_isset());\n\t// put pattern in history\n\tadd_to_history(HIST_SEARCH,\
    \ pat, TRUE, NUL);\n\n\treturn;\n    }\n\n    /*\n     * Find trailing options.\
    \  When '&' is used, keep old options.\n     */\n    if (*cmd == '&')\n\t++cmd;\n\
    \    else\n    {\n#ifdef FEAT_EVAL\n\tif (in_vim9script())\n\t{\n\t    // ignore\
    \ 'gdefault' and 'edcompatible'\n\t    subflags.do_all = FALSE;\n\t    subflags.do_ask\
    \ = FALSE;\n\t}\n\telse\n#endif\n\tif (!p_ed)\n\t{\n\t    if (p_gd)\t\t// default\
    \ is global on\n\t\tsubflags.do_all = TRUE;\n\t    else\n\t\tsubflags.do_all =\
    \ FALSE;\n\t    subflags.do_ask = FALSE;\n\t}\n\tsubflags.do_error = TRUE;\n\t\
    subflags.do_print = FALSE;\n\tsubflags.do_list = FALSE;\n\tsubflags.do_count =\
    \ FALSE;\n\tsubflags.do_number = FALSE;\n\tsubflags.do_ic = 0;\n    }\n    while\
    \ (*cmd)\n    {\n\t/*\n\t * Note that 'g' and 'c' are always inverted, also when\
    \ p_ed is off.\n\t * 'r' is never inverted.\n\t */\n\tif (*cmd == 'g')\n\t   \
    \ subflags.do_all = !subflags.do_all;\n\telse if (*cmd == 'c')\n\t    subflags.do_ask\
    \ = !subflags.do_ask;\n\telse if (*cmd == 'n')\n\t    subflags.do_count = TRUE;\n\
    \telse if (*cmd == 'e')\n\t    subflags.do_error = !subflags.do_error;\n\telse\
    \ if (*cmd == 'r')\t    // use last used regexp\n\t    which_pat = RE_LAST;\n\t\
    else if (*cmd == 'p')\n\t    subflags.do_print = TRUE;\n\telse if (*cmd == '#')\n\
    \t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_number = TRUE;\n\t}\n\t\
    else if (*cmd == 'l')\n\t{\n\t    subflags.do_print = TRUE;\n\t    subflags.do_list\
    \ = TRUE;\n\t}\n\telse if (*cmd == 'i')\t    // ignore case\n\t    subflags.do_ic\
    \ = 'i';\n\telse if (*cmd == 'I')\t    // don't ignore case\n\t    subflags.do_ic\
    \ = 'I';\n\telse\n\t    break;\n\t++cmd;\n    }\n    if (subflags.do_count)\n\t\
    subflags.do_ask = FALSE;\n\n    save_do_all = subflags.do_all;\n    save_do_ask\
    \ = subflags.do_ask;\n\n    /*\n     * check for a trailing count\n     */\n \
    \   cmd = skipwhite(cmd);\n    if (VIM_ISDIGIT(*cmd))\n    {\n\ti = getdigits(&cmd);\n\
    \tif (i <= 0 && !eap->skip && subflags.do_error)\n\t{\n\t    emsg(_(e_positive_count_required));\n\
    \t    return;\n\t}\n\teap->line1 = eap->line2;\n\teap->line2 += i - 1;\n\tif (eap->line2\
    \ > curbuf->b_ml.ml_line_count)\n\t    eap->line2 = curbuf->b_ml.ml_line_count;\n\
    \    }\n\n    /*\n     * check for trailing command or garbage\n     */\n    cmd\
    \ = skipwhite(cmd);\n    if (*cmd && *cmd != '\"')\t    // if not end-of-line\
    \ or comment\n    {\n\tset_nextcmd(eap, cmd);\n\tif (eap->nextcmd == NULL)\n\t\
    {\n\t    semsg(_(e_trailing_characters_str), cmd);\n\t    return;\n\t}\n    }\n\
    \n    if (eap->skip)\t    // not executing commands, only parsing\n\treturn;\n\
    \n    if (!subflags.do_count && !curbuf->b_p_ma)\n    {\n\t// Substitution is\
    \ not allowed in non-'modifiable' buffer\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\
    \treturn;\n    }\n\n    if (search_regcomp(pat, RE_SUBST, which_pat, SEARCH_HIS,\
    \ &regmatch) == FAIL)\n    {\n\tif (subflags.do_error)\n\t    emsg(_(e_invalid_command));\n\
    \treturn;\n    }\n\n    // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'\n\
    \    if (subflags.do_ic == 'i')\n\tregmatch.rmm_ic = TRUE;\n    else if (subflags.do_ic\
    \ == 'I')\n\tregmatch.rmm_ic = FALSE;\n\n    sub_firstline = NULL;\n\n    /*\n\
    \     * ~ in the substitute pattern is replaced with the old pattern.\n     *\
    \ We do it here once to avoid it to be replaced over and over again.\n     * But\
    \ don't do it when it starts with \"\\=\", then it's an expression.\n     */\n\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n\tsub = regtilde(sub, magic_isset());\n\
    \n    /*\n     * Check for a match on each line.\n     */\n    line2 = eap->line2;\n\
    \    for (lnum = eap->line1; lnum <= line2 && !(got_quit\n#if defined(FEAT_EVAL)\n\
    \t\t|| aborting()\n#endif\n\t\t); ++lnum)\n    {\n\tnmatch = vim_regexec_multi(&regmatch,\
    \ curwin, curbuf, lnum,\n\t\t\t\t\t\t       (colnr_T)0, NULL, NULL);\n\tif (nmatch)\n\
    \t{\n\t    colnr_T\tcopycol;\n\t    colnr_T\tmatchcol;\n\t    colnr_T\tprev_matchcol\
    \ = MAXCOL;\n\t    char_u\t*new_end, *new_start = NULL;\n\t    unsigned\tnew_start_len\
    \ = 0;\n\t    char_u\t*p1;\n\t    int\t\tdid_sub = FALSE;\n\t    int\t\tlastone;\n\
    \t    int\t\tlen, copy_len, needed_len;\n\t    long\tnmatch_tl = 0;\t// nr of\
    \ lines matched below lnum\n\t    int\t\tdo_again;\t// do it again after joining\
    \ lines\n\t    int\t\tskip_match = FALSE;\n\t    linenr_T\tsub_firstlnum;\t//\
    \ nr of first sub line\n#ifdef FEAT_PROP_POPUP\n\t    int\t\tapc_flags = APC_SAVE_FOR_UNDO\
    \ | APC_SUBSTITUTE;\n\t    colnr_T\ttotal_added =  0;\n#endif\n\n\t    /*\n\t\
    \     * The new text is build up step by step, to avoid too much\n\t     * copying.\
    \  There are these pieces:\n\t     * sub_firstline\tThe old text, unmodified.\n\
    \t     * copycol\t\tColumn in the old text where we started\n\t     *\t\t\tlooking\
    \ for a match; from here old text still\n\t     *\t\t\tneeds to be copied to the\
    \ new text.\n\t     * matchcol\t\tColumn number of the old text where to look\n\
    \t     *\t\t\tfor the next match.  It's just after the\n\t     *\t\t\tprevious\
    \ match or one further.\n\t     * prev_matchcol\tColumn just after the previous\
    \ match (if any).\n\t     *\t\t\tMostly equal to matchcol, except for the first\n\
    \t     *\t\t\tmatch and after skipping an empty match.\n\t     * regmatch.*pos\t\
    Where the pattern matched in the old text.\n\t     * new_start\tThe new text,\
    \ all that has been produced so\n\t     *\t\t\tfar.\n\t     * new_end\t\tThe new\
    \ text, where to append new text.\n\t     *\n\t     * lnum\t\tThe line number\
    \ where we found the start of\n\t     *\t\t\tthe match.  Can be below the line\
    \ we searched\n\t     *\t\t\twhen there is a \\n before a \\zs in the\n\t    \
    \ *\t\t\tpattern.\n\t     * sub_firstlnum\tThe line number in the buffer where\
    \ to look\n\t     *\t\t\tfor a match.  Can be different from \"lnum\"\n\t    \
    \ *\t\t\twhen the pattern or substitute string contains\n\t     *\t\t\tline breaks.\n\
    \t     *\n\t     * Special situations:\n\t     * - When the substitute string\
    \ contains a line break, the part up\n\t     *   to the line break is inserted\
    \ in the text, but the copy of\n\t     *   the original line is kept.  \"sub_firstlnum\"\
    \ is adjusted for\n\t     *   the inserted lines.\n\t     * - When the matched\
    \ pattern contains a line break, the old line\n\t     *   is taken from the line\
    \ at the end of the pattern.  The lines\n\t     *   in the match are deleted later,\
    \ \"sub_firstlnum\" is adjusted\n\t     *   accordingly.\n\t     *\n\t     * The\
    \ new text is built up in new_start[].  It has some extra\n\t     * room to avoid\
    \ using alloc()/free() too often.  new_start_len is\n\t     * the length of the\
    \ allocated memory at new_start.\n\t     *\n\t     * Make a copy of the old line,\
    \ so it won't be taken away when\n\t     * updating the screen or handling a multi-line\
    \ match.  The \"old_\"\n\t     * pointers point into this copy.\n\t     */\n\t\
    \    sub_firstlnum = lnum;\n\t    copycol = 0;\n\t    matchcol = 0;\n\n\t    //\
    \ At first match, remember current cursor position.\n\t    if (!got_match)\n\t\
    \    {\n\t\tsetpcmark();\n\t\tgot_match = TRUE;\n\t    }\n\n\t    /*\n\t     *\
    \ Loop until nothing more to replace in this line.\n\t     * 1. Handle match with\
    \ empty string.\n\t     * 2. If do_ask is set, ask for confirmation.\n\t     *\
    \ 3. substitute the string.\n\t     * 4. if do_all is set, find next match\n\t\
    \     * 5. break if there isn't another match in this line\n\t     */\n\t    for\
    \ (;;)\n\t    {\n\t\t// Advance \"lnum\" to the line where the match starts. \
    \ The\n\t\t// match does not start in the first line when there is a line\n\t\t\
    // break before \\zs.\n\t\tif (regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t   \
    \ lnum += regmatch.startpos[0].lnum;\n\t\t    sub_firstlnum += regmatch.startpos[0].lnum;\n\
    \t\t    nmatch -= regmatch.startpos[0].lnum;\n\t\t    VIM_CLEAR(sub_firstline);\n\
    \t\t}\n\n\t\t// Match might be after the last line for \"\\n\\zs\" matching at\n\
    \t\t// the end of the last line.\n\t\tif (lnum > curbuf->b_ml.ml_line_count)\n\
    \t\t    break;\n\n\t\tif (sub_firstline == NULL)\n\t\t{\n\t\t    sub_firstline\
    \ = vim_strsave(ml_get(sub_firstlnum));\n\t\t    if (sub_firstline == NULL)\n\t\
    \t    {\n\t\t\tvim_free(new_start);\n\t\t\tgoto outofmem;\n\t\t    }\n\t\t}\n\n\
    \t\t// Save the line number of the last change for the final\n\t\t// cursor position\
    \ (just like Vi).\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tdo_again = FALSE;\n\n\
    \t\t/*\n\t\t * 1. Match empty string does not count, except for first\n\t\t *\
    \ match.  This reproduces the strange vi behaviour.\n\t\t * This also catches\
    \ endless loops.\n\t\t */\n\t\tif (matchcol == prev_matchcol\n\t\t\t&& regmatch.endpos[0].lnum\
    \ == 0\n\t\t\t&& matchcol == regmatch.endpos[0].col)\n\t\t{\n\t\t    if (sub_firstline[matchcol]\
    \ == NUL)\n\t\t\t// We already were at the end of the line.  Don't look\n\t\t\t\
    // for a match in this line again.\n\t\t\tskip_match = TRUE;\n\t\t    else\n\t\
    \t    {\n\t\t\t // search for a match at next column\n\t\t\tif (has_mbyte)\n\t\
    \t\t    matchcol += mb_ptr2len(sub_firstline + matchcol);\n\t\t\telse\n\t\t\t\
    \    ++matchcol;\n\t\t    }\n\t\t    goto skip;\n\t\t}\n\n\t\t// Normally we continue\
    \ searching for a match just after the\n\t\t// previous match.\n\t\tmatchcol =\
    \ regmatch.endpos[0].col;\n\t\tprev_matchcol = matchcol;\n\n\t\t/*\n\t\t * 2.\
    \ If do_count is set only increase the counter.\n\t\t *    If do_ask is set, ask\
    \ for confirmation.\n\t\t */\n\t\tif (subflags.do_count)\n\t\t{\n\t\t    // For\
    \ a multi-line match, put matchcol at the NUL at\n\t\t    // the end of the line\
    \ and set nmatch to one, so that\n\t\t    // we continue looking for a match on\
    \ the next line.\n\t\t    // Avoids that \":s/\\nB\\@=//gc\" get stuck.\n\t\t\
    \    if (nmatch > 1)\n\t\t    {\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\tnmatch = 1;\n\t\t\tskip_match = TRUE;\n\t\t    }\n\t\t    sub_nsubs++;\n\
    \t\t    did_sub = TRUE;\n#ifdef FEAT_EVAL\n\t\t    // Skip the substitution, unless\
    \ an expression is used,\n\t\t    // then it is evaluated in the sandbox.\n\t\t\
    \    if (!(sub[0] == '\\\\' && sub[1] == '='))\n#endif\n\t\t\tgoto skip;\n\t\t\
    }\n\n\t\tif (subflags.do_ask)\n\t\t{\n\t\t    int typed = 0;\n\n\t\t    // change\
    \ State to CONFIRM, so that the mouse works\n\t\t    // properly\n\t\t    save_State\
    \ = State;\n\t\t    State = CONFIRM;\n\t\t    setmouse();\t\t// disable mouse\
    \ in xterm\n\t\t    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t   \
    \ if (curwin->w_p_crb)\n\t\t\tdo_check_cursorbind();\n\n\t\t    // When 'cpoptions'\
    \ contains \"u\" don't sync undo when\n\t\t    // asking for confirmation.\n\t\
    \t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t++no_u_sync;\n\n\t\t   \
    \ /*\n\t\t     * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.\n\t\t     */\n\
    \t\t    while (subflags.do_ask)\n\t\t    {\n\t\t\tif (exmode_active)\n\t\t\t{\n\
    \t\t\t    char_u\t*resp;\n\t\t\t    colnr_T\tsc, ec;\n\n\t\t\t    print_line_no_prefix(lnum,\n\
    \t\t\t\t\t subflags.do_number, subflags.do_list);\n\n\t\t\t    getvcol(curwin,\
    \ &curwin->w_cursor, &sc, NULL, NULL);\n\t\t\t    curwin->w_cursor.col = regmatch.endpos[0].col\
    \ - 1;\n\t\t\t    if (curwin->w_cursor.col < 0)\n\t\t\t\tcurwin->w_cursor.col\
    \ = 0;\n\t\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);\n\t\t\t\
    \    curwin->w_cursor.col = regmatch.startpos[0].col;\n\t\t\t    if (subflags.do_number\
    \ || curwin->w_p_nu)\n\t\t\t    {\n\t\t\t\tint numw = number_width(curwin) + 1;\n\
    \t\t\t\tsc += numw;\n\t\t\t\tec += numw;\n\t\t\t    }\n\t\t\t    msg_start();\n\
    \t\t\t    for (i = 0; i < (long)sc; ++i)\n\t\t\t\tmsg_putchar(' ');\n\t\t\t  \
    \  for ( ; i <= (long)ec; ++i)\n\t\t\t\tmsg_putchar('^');\n\n\t\t\t    resp =\
    \ getexmodeline('?', NULL, 0, TRUE);\n\t\t\t    if (resp != NULL)\n\t\t\t    {\n\
    \t\t\t\ttyped = *resp;\n\t\t\t\tvim_free(resp);\n\t\t\t    }\n\t\t\t}\n\t\t\t\
    else\n\t\t\t{\n\t\t\t    char_u *orig_line = NULL;\n\t\t\t    int    len_change\
    \ = 0;\n\t\t\t    int\t   save_p_lz = p_lz;\n#ifdef FEAT_FOLDING\n\t\t\t    int\
    \ save_p_fen = curwin->w_p_fen;\n\n\t\t\t    curwin->w_p_fen = FALSE;\n#endif\n\
    \t\t\t    // Invert the matched string.\n\t\t\t    // Remove the inversion afterwards.\n\
    \t\t\t    temp = RedrawingDisabled;\n\t\t\t    RedrawingDisabled = 0;\n\n\t\t\t\
    \    // avoid calling update_screen() in vgetorpeek()\n\t\t\t    p_lz = FALSE;\n\
    \n\t\t\t    if (new_start != NULL)\n\t\t\t    {\n\t\t\t\t// There already was\
    \ a substitution, we would\n\t\t\t\t// like to show this to the user.  We cannot\n\
    \t\t\t\t// really update the line, it would change\n\t\t\t\t// what matches. \
    \ Temporarily replace the line\n\t\t\t\t// and change it back afterwards.\n\t\t\
    \t\torig_line = vim_strsave(ml_get(lnum));\n\t\t\t\tif (orig_line != NULL)\n\t\
    \t\t\t{\n\t\t\t\t    char_u *new_line = concat_str(new_start,\n\t\t\t\t\t\t  \
    \   sub_firstline + copycol);\n\n\t\t\t\t    if (new_line == NULL)\n\t\t\t\t\t\
    VIM_CLEAR(orig_line);\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t// Position\
    \ the cursor relative to the\n\t\t\t\t\t// end of the line, the previous\n\t\t\
    \t\t\t// substitute may have inserted or\n\t\t\t\t\t// deleted characters before\
    \ the\n\t\t\t\t\t// cursor.\n\t\t\t\t\tlen_change = (int)STRLEN(new_line)\n\t\t\
    \t\t\t\t     - (int)STRLEN(orig_line);\n\t\t\t\t\tcurwin->w_cursor.col += len_change;\n\
    \t\t\t\t\tml_replace(lnum, new_line, FALSE);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\
    \    }\n\n\t\t\t    search_match_lines = regmatch.endpos[0].lnum\n\t\t\t\t\t\t\
    \  - regmatch.startpos[0].lnum;\n\t\t\t    search_match_endcol = regmatch.endpos[0].col\n\
    \t\t\t\t\t\t\t\t + len_change;\n\t\t\t    highlight_match = TRUE;\n\n\t\t\t  \
    \  update_topline();\n\t\t\t    validate_cursor();\n\t\t\t    update_screen(SOME_VALID);\n\
    \t\t\t    highlight_match = FALSE;\n\t\t\t    redraw_later(SOME_VALID);\n\n#ifdef\
    \ FEAT_FOLDING\n\t\t\t    curwin->w_p_fen = save_p_fen;\n#endif\n\t\t\t    if\
    \ (msg_row == Rows - 1)\n\t\t\t\tmsg_didout = FALSE;\t// avoid a scroll-up\n\t\
    \t\t    msg_starthere();\n\t\t\t    i = msg_scroll;\n\t\t\t    msg_scroll = 0;\t\
    \t// truncate msg when\n\t\t\t\t\t\t\t// needed\n\t\t\t    msg_no_more = TRUE;\n\
    \t\t\t    // write message same highlighting as for\n\t\t\t    // wait_return\n\
    \t\t\t    smsg_attr(HL_ATTR(HLF_R),\n\t\t\t\t_(\"replace with %s (y/n/a/q/l/^E/^Y)?\"\
    ), sub);\n\t\t\t    msg_no_more = FALSE;\n\t\t\t    msg_scroll = i;\n\t\t\t  \
    \  showruler(TRUE);\n\t\t\t    windgoto(msg_row, msg_col);\n\t\t\t    RedrawingDisabled\
    \ = temp;\n\n#ifdef USE_ON_FLY_SCROLL\n\t\t\t    dont_scroll = FALSE; // allow\
    \ scrolling here\n#endif\n\t\t\t    ++no_mapping;\t// don't map this key\n\t\t\
    \t    ++allow_keys;\t// allow special keys\n\t\t\t    typed = plain_vgetc();\n\
    \t\t\t    --allow_keys;\n\t\t\t    --no_mapping;\n\n\t\t\t    // clear the question\n\
    \t\t\t    msg_didout = FALSE;\t// don't scroll up\n\t\t\t    msg_col = 0;\n\t\t\
    \t    gotocmdline(TRUE);\n\t\t\t    p_lz = save_p_lz;\n\n\t\t\t    // restore\
    \ the line\n\t\t\t    if (orig_line != NULL)\n\t\t\t\tml_replace(lnum, orig_line,\
    \ FALSE);\n\t\t\t}\n\n\t\t\tneed_wait_return = FALSE; // no hit-return prompt\n\
    \t\t\tif (typed == 'q' || typed == ESC || typed == Ctrl_C\n#ifdef UNIX\n\t\t\t\
    \t|| typed == intr_char\n#endif\n\t\t\t\t)\n\t\t\t{\n\t\t\t    got_quit = TRUE;\n\
    \t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'n')\n\t\t\t    break;\n\t\t\tif\
    \ (typed == 'y')\n\t\t\t    break;\n\t\t\tif (typed == 'l')\n\t\t\t{\n\t\t\t \
    \   // last: replace and then stop\n\t\t\t    subflags.do_all = FALSE;\n\t\t\t\
    \    line2 = lnum;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed == 'a')\n\t\t\t\
    {\n\t\t\t    subflags.do_ask = FALSE;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (typed\
    \ == Ctrl_E)\n\t\t\t    scrollup_clamp();\n\t\t\telse if (typed == Ctrl_Y)\n\t\
    \t\t    scrolldown_clamp();\n\t\t    }\n\t\t    State = save_State;\n\t\t    setmouse();\n\
    \t\t    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)\n\t\t\t--no_u_sync;\n\n\t\t \
    \   if (typed == 'n')\n\t\t    {\n\t\t\t// For a multi-line match, put matchcol\
    \ at the NUL at\n\t\t\t// the end of the line and set nmatch to one, so that\n\
    \t\t\t// we continue looking for a match on the next line.\n\t\t\t// Avoids that\
    \ \":%s/\\nB\\@=//gc\" and \":%s/\\n/,\\r/gc\"\n\t\t\t// get stuck when pressing\
    \ 'n'.\n\t\t\tif (nmatch > 1)\n\t\t\t{\n\t\t\t    matchcol = (colnr_T)STRLEN(sub_firstline);\n\
    \t\t\t    skip_match = TRUE;\n\t\t\t}\n\t\t\tgoto skip;\n\t\t    }\n\t\t    if\
    \ (got_quit)\n\t\t\tgoto skip;\n\t\t}\n\n\t\t// Move the cursor to the start of\
    \ the match, so that we can\n\t\t// use \"\\=col(\".\").\n\t\tcurwin->w_cursor.col\
    \ = regmatch.startpos[0].col;\n\n\t\t/*\n\t\t * 3. substitute the string.\n\t\t\
    \ */\n#ifdef FEAT_EVAL\n\t\tsave_ma = curbuf->b_p_ma;\n\t\tif (subflags.do_count)\n\
    \t\t{\n\t\t    // prevent accidentally changing the buffer by a function\n\t\t\
    \    curbuf->b_p_ma = FALSE;\n\t\t    sandbox++;\n\t\t}\n\t\t// Save flags for\
    \ recursion.  They can change for e.g.\n\t\t// :s/^/\\=execute(\"s#^##gn\")\n\t\
    \tsubflags_save = subflags;\n#endif\n\t\t// get length of substitution part\n\t\
    \tsublen = vim_regsub_multi(&regmatch,\n\t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\
    \t\t\t       sub, sub_firstline, FALSE, magic_isset(), TRUE);\n#ifdef FEAT_EVAL\n\
    \t\t// If getting the substitute string caused an error, don't do\n\t\t// the\
    \ replacement.\n\t\t// Don't keep flags set by a recursive call.\n\t\tsubflags\
    \ = subflags_save;\n\t\tif (aborting() || subflags.do_count)\n\t\t{\n\t\t    curbuf->b_p_ma\
    \ = save_ma;\n\t\t    if (sandbox > 0)\n\t\t\tsandbox--;\n\t\t    goto skip;\n\
    \t\t}\n#endif\n\n\t\t// When the match included the \"$\" of the last line it\
    \ may\n\t\t// go beyond the last line of the buffer.\n\t\tif (nmatch > curbuf->b_ml.ml_line_count\
    \ - sub_firstlnum + 1)\n\t\t{\n\t\t    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum\
    \ + 1;\n\t\t    skip_match = TRUE;\n\t\t}\n\n\t\t// Need room for:\n\t\t// - result\
    \ so far in new_start (not for first sub in line)\n\t\t// - original text up to\
    \ match\n\t\t// - length of substituted part\n\t\t// - original text after match\n\
    \t\t// Adjust text properties here, since we have all information\n\t\t// needed.\n\
    \t\tif (nmatch == 1)\n\t\t{\n\t\t    p1 = sub_firstline;\n#ifdef FEAT_PROP_POPUP\n\
    \t\t    if (curbuf->b_has_textprop)\n\t\t    {\n\t\t\tint bytes_added = sublen\
    \ - 1 - (regmatch.endpos[0].col\n\t\t\t\t\t\t   - regmatch.startpos[0].col);\n\
    \n\t\t\t// When text properties are changed, need to save for\n\t\t\t// undo first,\
    \ unless done already.\n\t\t\tif (adjust_prop_columns(lnum,\n\t\t\t\t\ttotal_added\
    \ + regmatch.startpos[0].col,\n\t\t\t\t\t\t       bytes_added, apc_flags))\n\t\
    \t\t    apc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t// Offset for column byte number\
    \ of the text property\n\t\t\t// in the resulting buffer afterwards.\n\t\t\ttotal_added\
    \ += bytes_added;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    p1 = ml_get(sub_firstlnum\
    \ + nmatch - 1);\n\t\t    nmatch_tl += nmatch - 1;\n\t\t}\n\t\tcopy_len = regmatch.startpos[0].col\
    \ - copycol;\n\t\tneeded_len = copy_len + ((unsigned)STRLEN(p1)\n\t\t\t\t    \
    \   - regmatch.endpos[0].col) + sublen + 1;\n\t\tif (new_start == NULL)\n\t\t\
    {\n\t\t    /*\n\t\t     * Get some space for a temporary buffer to do the\n\t\t\
    \     * substitution into (and some extra space to avoid\n\t\t     * too many\
    \ calls to alloc()/free()).\n\t\t     */\n\t\t    new_start_len = needed_len +\
    \ 50;\n\t\t    if ((new_start = alloc(new_start_len)) == NULL)\n\t\t\tgoto outofmem;\n\
    \t\t    *new_start = NUL;\n\t\t    new_end = new_start;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    /*\n\t\t     * Check if the temporary buffer is long enough to do the\n\
    \t\t     * substitution into.  If not, make it larger (with a bit\n\t\t     *\
    \ extra to avoid too many calls to alloc()/free()).\n\t\t     */\n\t\t    len\
    \ = (unsigned)STRLEN(new_start);\n\t\t    needed_len += len;\n\t\t    if (needed_len\
    \ > (int)new_start_len)\n\t\t    {\n\t\t\tnew_start_len = needed_len + 50;\n\t\
    \t\tif ((p1 = alloc(new_start_len)) == NULL)\n\t\t\t{\n\t\t\t    vim_free(new_start);\n\
    \t\t\t    goto outofmem;\n\t\t\t}\n\t\t\tmch_memmove(p1, new_start, (size_t)(len\
    \ + 1));\n\t\t\tvim_free(new_start);\n\t\t\tnew_start = p1;\n\t\t    }\n\t\t \
    \   new_end = new_start + len;\n\t\t}\n\n\t\t/*\n\t\t * copy the text up to the\
    \ part that matched\n\t\t */\n\t\tmch_memmove(new_end, sub_firstline + copycol,\
    \ (size_t)copy_len);\n\t\tnew_end += copy_len;\n\n\t\t(void)vim_regsub_multi(&regmatch,\n\
    \t\t\t\t    sub_firstlnum - regmatch.startpos[0].lnum,\n\t\t\t\t      sub, new_end,\
    \ TRUE, magic_isset(), TRUE);\n\t\tsub_nsubs++;\n\t\tdid_sub = TRUE;\n\n\t\t//\
    \ Move the cursor to the start of the line, to avoid that it\n\t\t// is beyond\
    \ the end of the line after the substitution.\n\t\tcurwin->w_cursor.col = 0;\n\
    \n\t\t// For a multi-line match, make a copy of the last matched\n\t\t// line\
    \ and continue in that one.\n\t\tif (nmatch > 1)\n\t\t{\n\t\t    sub_firstlnum\
    \ += nmatch - 1;\n\t\t    vim_free(sub_firstline);\n\t\t    sub_firstline = vim_strsave(ml_get(sub_firstlnum));\n\
    \t\t    // When going beyond the last line, stop substituting.\n\t\t    if (sub_firstlnum\
    \ <= line2)\n\t\t\tdo_again = TRUE;\n\t\t    else\n\t\t\tsubflags.do_all = FALSE;\n\
    \t\t}\n\n\t\t// Remember next character to be copied.\n\t\tcopycol = regmatch.endpos[0].col;\n\
    \n\t\tif (skip_match)\n\t\t{\n\t\t    // Already hit end of the buffer, sub_firstlnum\
    \ is one\n\t\t    // less than what it ought to be.\n\t\t    vim_free(sub_firstline);\n\
    \t\t    sub_firstline = vim_strsave((char_u *)\"\");\n\t\t    copycol = 0;\n\t\
    \t}\n\n\t\t/*\n\t\t * Now the trick is to replace CTRL-M chars with a real line\n\
    \t\t * break.  This would make it impossible to insert a CTRL-M in\n\t\t * the\
    \ text.  The line break can be avoided by preceding the\n\t\t * CTRL-M with a\
    \ backslash.  To be able to insert a backslash,\n\t\t * they must be doubled in\
    \ the string and are halved here.\n\t\t * That is Vi compatible.\n\t\t */\n\t\t\
    for (p1 = new_end; *p1; ++p1)\n\t\t{\n\t\t    if (p1[0] == '\\\\' && p1[1] !=\
    \ NUL)  // remove backslash\n\t\t    {\n\t\t\tSTRMOVE(p1, p1 + 1);\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\tif (curbuf->b_has_textprop)\n\t\t\t{\n\t\t\t    // When text properties\
    \ are changed, need to save\n\t\t\t    // for undo first, unless done already.\n\
    \t\t\t    if (adjust_prop_columns(lnum,\n\t\t\t\t\t(colnr_T)(p1 - new_start),\
    \ -1,\n\t\t\t\t\tapc_flags))\n\t\t\t\tapc_flags &= ~APC_SAVE_FOR_UNDO;\n\t\t\t\
    }\n#endif\n\t\t    }\n\t\t    else if (*p1 == CAR)\n\t\t    {\n\t\t\tif (u_inssub(lnum)\
    \ == OK)   // prepare for undo\n\t\t\t{\n\t\t\t    colnr_T\tplen = (colnr_T)(p1\
    \ - new_start + 1);\n\n\t\t\t    *p1 = NUL;\t\t    // truncate up to the CR\n\t\
    \t\t    ml_append(lnum - 1, new_start, plen, FALSE);\n\t\t\t    mark_adjust(lnum\
    \ + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\t\t\t    if (subflags.do_ask)\n\t\t\t\tappended_lines(lnum\
    \ - 1, 1L);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (first_line == 0)\n\t\t\t\
    \t    first_line = lnum;\n\t\t\t\tlast_line = lnum + 1;\n\t\t\t    }\n#ifdef FEAT_PROP_POPUP\n\
    \t\t\t    adjust_props_for_split(lnum + 1, lnum, plen, 1);\n#endif\n\t\t\t   \
    \ // all line numbers increase\n\t\t\t    ++sub_firstlnum;\n\t\t\t    ++lnum;\n\
    \t\t\t    ++line2;\n\t\t\t    // move the cursor to the new line, like Vi\n\t\t\
    \t    ++curwin->w_cursor.lnum;\n\t\t\t    // copy the rest\n\t\t\t    STRMOVE(new_start,\
    \ p1 + 1);\n\t\t\t    p1 = new_start - 1;\n\t\t\t}\n\t\t    }\n\t\t    else if\
    \ (has_mbyte)\n\t\t\tp1 += (*mb_ptr2len)(p1) - 1;\n\t\t}\n\n\t\t/*\n\t\t * 4.\
    \ If do_all is set, find next match.\n\t\t * Prevent endless loop with patterns\
    \ that match empty\n\t\t * strings, e.g. :s/$/pat/g or :s/[a-z]* /(&)/g.\n\t\t\
    \ * But \":s/\\n/#/\" is OK.\n\t\t */\nskip:\n\t\t// We already know that we did\
    \ the last subst when we are at\n\t\t// the end of the line, except that a pattern\
    \ like\n\t\t// \"bar\\|\\nfoo\" may match at the NUL.  \"lnum\" can be below\n\
    \t\t// \"line2\" when there is a \\zs in the pattern after a line\n\t\t// break.\n\
    \t\tlastone = (skip_match\n\t\t\t|| got_int\n\t\t\t|| got_quit\n\t\t\t|| lnum\
    \ > line2\n\t\t\t|| !(subflags.do_all || do_again)\n\t\t\t|| (sub_firstline[matchcol]\
    \ == NUL && nmatch <= 1\n\t\t\t\t\t && !re_multiline(regmatch.regprog)));\n\t\t\
    nmatch = -1;\n\n\t\t/*\n\t\t * Replace the line in the buffer when needed.  This\
    \ is\n\t\t * skipped when there are more matches.\n\t\t * The check for nmatch_tl\
    \ is needed for when multi-line\n\t\t * matching must replace the lines before\
    \ trying to do another\n\t\t * match, otherwise \"\\@<=\" won't work.\n\t\t *\
    \ When the match starts below where we start searching also\n\t\t * need to replace\
    \ the line first (using \\zs after \\n).\n\t\t */\n\t\tif (lastone\n\t\t\t|| nmatch_tl\
    \ > 0\n\t\t\t|| (nmatch = vim_regexec_multi(&regmatch, curwin,\n\t\t\t\t\t\t\t\
    curbuf, sub_firstlnum,\n\t\t\t\t\t\t    matchcol, NULL, NULL)) == 0\n\t\t\t||\
    \ regmatch.startpos[0].lnum > 0)\n\t\t{\n\t\t    if (new_start != NULL)\n\t\t\
    \    {\n\t\t\t/*\n\t\t\t * Copy the rest of the line, that didn't match.\n\t\t\
    \t * \"matchcol\" has to be adjusted, we use the end of\n\t\t\t * the line as\
    \ reference, because the substitute may\n\t\t\t * have changed the number of characters.\
    \  Same for\n\t\t\t * \"prev_matchcol\".\n\t\t\t */\n\t\t\tSTRCAT(new_start, sub_firstline\
    \ + copycol);\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;\n\t\
    \t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\t\t      - prev_matchcol;\n\
    \n\t\t\tif (u_savesub(lnum) != OK)\n\t\t\t    break;\n\t\t\tml_replace(lnum, new_start,\
    \ TRUE);\n\n\t\t\tif (nmatch_tl > 0)\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Matched\
    \ lines have now been substituted and are\n\t\t\t     * useless, delete them.\
    \  The part after the match\n\t\t\t     * has been appended to new_start, we don't\
    \ need\n\t\t\t     * it in the buffer.\n\t\t\t     */\n\t\t\t    ++lnum;\n\t\t\
    \t    if (u_savedel(lnum, nmatch_tl) != OK)\n\t\t\t\tbreak;\n\t\t\t    for (i\
    \ = 0; i < nmatch_tl; ++i)\n\t\t\t\tml_delete(lnum);\n\t\t\t    mark_adjust(lnum,\
    \ lnum + nmatch_tl - 1,\n\t\t\t\t\t\t   (long)MAXLNUM, -nmatch_tl);\n\t\t\t  \
    \  if (subflags.do_ask)\n\t\t\t\tdeleted_lines(lnum, nmatch_tl);\n\t\t\t    --lnum;\n\
    \t\t\t    line2 -= nmatch_tl; // nr of lines decreases\n\t\t\t    nmatch_tl =\
    \ 0;\n\t\t\t}\n\n\t\t\t// When asking, undo is saved each time, must also set\n\
    \t\t\t// changed flag each time.\n\t\t\tif (subflags.do_ask)\n\t\t\t    changed_bytes(lnum,\
    \ 0);\n\t\t\telse\n\t\t\t{\n\t\t\t    if (first_line == 0)\n\t\t\t\tfirst_line\
    \ = lnum;\n\t\t\t    last_line = lnum + 1;\n\t\t\t}\n\n\t\t\tsub_firstlnum = lnum;\n\
    \t\t\tvim_free(sub_firstline);    // free the temp buffer\n\t\t\tsub_firstline\
    \ = new_start;\n\t\t\tnew_start = NULL;\n\t\t\tmatchcol = (colnr_T)STRLEN(sub_firstline)\
    \ - matchcol;\n\t\t\tprev_matchcol = (colnr_T)STRLEN(sub_firstline)\n\t\t\t\t\t\
    \t\t      - prev_matchcol;\n\t\t\tcopycol = 0;\n\t\t    }\n\t\t    if (nmatch\
    \ == -1 && !lastone)\n\t\t\tnmatch = vim_regexec_multi(&regmatch, curwin, curbuf,\n\
    \t\t\t\t\t  sub_firstlnum, matchcol, NULL, NULL);\n\n\t\t    /*\n\t\t     * 5.\
    \ break if there isn't another match in this line\n\t\t     */\n\t\t    if (nmatch\
    \ <= 0)\n\t\t    {\n\t\t\t// If the match found didn't start where we were\n\t\
    \t\t// searching, do the next search in the line where we\n\t\t\t// found the\
    \ match.\n\t\t\tif (nmatch == -1)\n\t\t\t    lnum -= regmatch.startpos[0].lnum;\n\
    \t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tline_breakcheck();\n\t    }\n\n\t    if\
    \ (did_sub)\n\t\t++sub_nlines;\n\t    vim_free(new_start);\t// for when substitute\
    \ was cancelled\n\t    VIM_CLEAR(sub_firstline);\t// free the copy of the original\
    \ line\n\t}\n\n\tline_breakcheck();\n    }\n\n    if (first_line != 0)\n    {\n\
    \t// Need to subtract the number of added lines from \"last_line\" to get\n\t\
    // the line number before the change (same as adding the number of\n\t// deleted\
    \ lines).\n\ti = curbuf->b_ml.ml_line_count - old_line_count;\n\tchanged_lines(first_line,\
    \ 0, last_line - i, i);\n    }\n\noutofmem:\n    vim_free(sub_firstline); // may\
    \ have to free allocated copy of the line\n\n    // \":s/pat//n\" doesn't move\
    \ the cursor\n    if (subflags.do_count)\n\tcurwin->w_cursor = old_cursor;\n\n\
    \    if (sub_nsubs > start_nsubs)\n    {\n\tif ((cmdmod.cmod_flags & CMOD_LOCKMARKS)\
    \ == 0)\n\t{\n\t    // Set the '[ and '] marks.\n\t    curbuf->b_op_start.lnum\
    \ = eap->line1;\n\t    curbuf->b_op_end.lnum = line2;\n\t    curbuf->b_op_start.col\
    \ = curbuf->b_op_end.col = 0;\n\t}\n\n\tif (!global_busy)\n\t{\n\t    // when\
    \ interactive leave cursor on the match\n\t    if (!subflags.do_ask)\n\t    {\n\
    \t\tif (endcolumn)\n\t\t    coladvance((colnr_T)MAXCOL);\n\t\telse\n\t\t    beginline(BL_WHITE\
    \ | BL_FIX);\n\t    }\n\t    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)\n\
    \t\tmsg(\"\");\n\t}\n\telse\n\t    global_need_beginline = TRUE;\n\tif (subflags.do_print)\n\
    \t    print_line(curwin->w_cursor.lnum,\n\t\t\t\t\t subflags.do_number, subflags.do_list);\n\
    \    }\n    else if (!global_busy)\n    {\n\tif (got_int)\t\t// interrupted\n\t\
    \    emsg(_(e_interrupted));\n\telse if (got_match)\t// did find something but\
    \ nothing substituted\n\t    msg(\"\");\n\telse if (subflags.do_error)\t// nothing\
    \ found\n\t    semsg(_(e_pattern_not_found_str), get_search_pat());\n    }\n\n\
    #ifdef FEAT_FOLDING\n    if (subflags.do_ask && hasAnyFolding(curwin))\n\t// Cursor\
    \ position may require updating\n\tchanged_window_setting();\n#endif\n\n    vim_regfree(regmatch.regprog);\n\
    \n    // Restore the flag values, they can be used for \":&&\".\n    subflags.do_all\
    \ = save_do_all;\n    subflags.do_ask = save_do_ask;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 199984
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
