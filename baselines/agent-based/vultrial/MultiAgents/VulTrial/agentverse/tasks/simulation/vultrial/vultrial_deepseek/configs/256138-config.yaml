agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\n  void\
    \ Compute(OpKernelContext* ctx) override {\n    const Tensor& a = ctx->input(0);\n\
    \    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n\
    \                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx,\
    \ TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"\
    b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n\
    \    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int\
    \ n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_\
    \ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n        \
    \        errors::InvalidArgument(\n                    \"Matrix size incompatible:\
    \ a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n\
    \    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n\
    \                    \"Matrix dimensions cannot be negative: a: \",\n        \
    \            a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n\
    \    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0,\
    \ TensorShape({m, n}), &output));\n\n    // Return early if at least one of the\
    \ output dimension size is 0.\n    if (m == 0 || n == 0) {\n      return;\n  \
    \  }\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication\
    \ is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice,\
    \ float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n\
    \      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor>\
    \ a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_)\
    \ {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread\
    \ the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value)\
    \ {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n\
    \                        a_float->flat<float>().data(), a.NumElements());\n  \
    \      left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value)\
    \ {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n\
    \                        b_float->flat<float>().data(), b.NumElements());\n  \
    \      right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>,\
    \ 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second\
    \ = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>())\
    \ =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n\
    \      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output\
    \ = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n\
    \    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the\
    \ identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n  \
    \    std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n\
    \      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n\
    \    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n    \
    \  // TODO(agarwal): avoid transposing the matrix here and directly handle\n \
    \     // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0)\
    \ != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's\
    \ shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n             \
    \     errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n\
    \          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1),\
    \ right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output)\
    \ {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>())\
    \ =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template\
    \ eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n\
    \      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n\
    \      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n     \
    \                           right->matrix<TL>(), transpose_a,\n              \
    \                  ctx->device()->tensorflow_cpu_worker_threads(),\n         \
    \                       transpose_output, &out);\n    } else {\n      DoMatMul<TL,\
    \ TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                       \
    \         right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n\
    \                                transpose_output, &out);\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\n  void Compute(OpKernelContext*\
    \ ctx) override {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b =\
    \ ctx->input(1);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n\
    \                errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx,\
    \ TensorShapeUtils::IsMatrix(b.shape()),\n                errors::InvalidArgument(\"\
    b is not a matrix\"));\n\n    const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n\
    \    const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);\n    const int\
    \ n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);\n    const int k2 = transpose_b_\
    \ ? b.dim_size(1) : b.dim_size(0);\n\n    OP_REQUIRES(ctx, k == k2,\n        \
    \        errors::InvalidArgument(\n                    \"Matrix size incompatible:\
    \ a: \", a.shape().DebugString(),\n                    \", b: \", b.shape().DebugString()));\n\
    \    OP_REQUIRES(ctx, m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n\
    \                    \"Matrix dimensions cannot be negative: a: \",\n        \
    \            a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n\
    \    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0,\
    \ TensorShape({m, n}), &output));\n\n    // Return early if at least one of the\
    \ output dimension size is 0.\n    if (m == 0 || n == 0) {\n      return;\n  \
    \  }\n\n    if (k == 0) {\n      // If the inner dimension k in the matrix multiplication\
    \ is zero, we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice,\
    \ float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n\
    \      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor>\
    \ a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_)\
    \ {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread\
    \ the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value)\
    \ {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n\
    \                        a_float->flat<float>().data(), a.NumElements());\n  \
    \      left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value)\
    \ {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n\
    \                        b_float->flat<float>().data(), b.NumElements());\n  \
    \      right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>,\
    \ 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second\
    \ = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>())\
    \ =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n\
    \      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output\
    \ = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n\
    \    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the\
    \ identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n  \
    \    std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n\
    \      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n\
    \    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n    \
    \  // TODO(agarwal): avoid transposing the matrix here and directly handle\n \
    \     // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0)\
    \ != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's\
    \ shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n             \
    \     errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n\
    \          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1),\
    \ right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output)\
    \ {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>())\
    \ =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template\
    \ eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n\
    \      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n\
    \      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n     \
    \                           right->matrix<TL>(), transpose_a,\n              \
    \                  ctx->device()->tensorflow_cpu_worker_threads(),\n         \
    \                       transpose_output, &out);\n    } else {\n      DoMatMul<TL,\
    \ TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                       \
    \         right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n\
    \                                transpose_output, &out);\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\n  void Compute(OpKernelContext* ctx) override {\n    const Tensor&\
    \ a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n    OP_REQUIRES(ctx,\
    \ TensorShapeUtils::IsMatrix(a.shape()),\n                errors::InvalidArgument(\"\
    a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n\
    \                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const\
    \ int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_\
    \ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0)\
    \ : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\
    \n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n  \
    \                  \"Matrix size incompatible: a: \", a.shape().DebugString(),\n\
    \                    \", b: \", b.shape().DebugString()));\n    OP_REQUIRES(ctx,\
    \ m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n    \
    \                \"Matrix dimensions cannot be negative: a: \",\n            \
    \        a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n    Tensor*\
    \ output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m,\
    \ n}), &output));\n\n    // Return early if at least one of the output dimension\
    \ size is 0.\n    if (m == 0 || n == 0) {\n      return;\n    }\n\n    if (k ==\
    \ 0) {\n      // If the inner dimension k in the matrix multiplication is zero,\
    \ we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice,\
    \ float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n\
    \      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor>\
    \ a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_)\
    \ {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread\
    \ the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value)\
    \ {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n\
    \                        a_float->flat<float>().data(), a.NumElements());\n  \
    \      left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value)\
    \ {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n\
    \                        b_float->flat<float>().data(), b.NumElements());\n  \
    \      right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>,\
    \ 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second\
    \ = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>())\
    \ =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n\
    \      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output\
    \ = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n\
    \    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the\
    \ identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n  \
    \    std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n\
    \      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n\
    \    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n    \
    \  // TODO(agarwal): avoid transposing the matrix here and directly handle\n \
    \     // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0)\
    \ != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's\
    \ shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n             \
    \     errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n\
    \          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1),\
    \ right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output)\
    \ {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>())\
    \ =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template\
    \ eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n\
    \      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n\
    \      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n     \
    \                           right->matrix<TL>(), transpose_a,\n              \
    \                  ctx->device()->tensorflow_cpu_worker_threads(),\n         \
    \                       transpose_output, &out);\n    } else {\n      DoMatMul<TL,\
    \ TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                       \
    \         right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n\
    \                                transpose_output, &out);\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\n  void Compute(OpKernelContext* ctx) override\
    \ {\n    const Tensor& a = ctx->input(0);\n    const Tensor& b = ctx->input(1);\n\
    \    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),\n               \
    \ errors::InvalidArgument(\"a is not a matrix\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),\n\
    \                errors::InvalidArgument(\"b is not a matrix\"));\n\n    const\
    \ int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);\n    const int k = transpose_a_\
    \ ? a.dim_size(0) : a.dim_size(1);\n    const int n = transpose_b_ ? b.dim_size(0)\
    \ : b.dim_size(1);\n    const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);\n\
    \n    OP_REQUIRES(ctx, k == k2,\n                errors::InvalidArgument(\n  \
    \                  \"Matrix size incompatible: a: \", a.shape().DebugString(),\n\
    \                    \", b: \", b.shape().DebugString()));\n    OP_REQUIRES(ctx,\
    \ m >= 0 && n >= 0 && k >= 0,\n                errors::InvalidArgument(\n    \
    \                \"Matrix dimensions cannot be negative: a: \",\n            \
    \        a.shape().DebugString(), \", b: \", b.shape().DebugString()));\n    Tensor*\
    \ output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m,\
    \ n}), &output));\n\n    // Return early if at least one of the output dimension\
    \ size is 0.\n    if (m == 0 || n == 0) {\n      return;\n    }\n\n    if (k ==\
    \ 0) {\n      // If the inner dimension k in the matrix multiplication is zero,\
    \ we fill\n      // the output with zeros.\n      functor::SetZeroFunctor<CPUDevice,\
    \ float> f;\n      f(ctx->eigen_device<CPUDevice>(), output->flat<float>());\n\
    \      return;\n    }\n\n    auto out = output->matrix<float>();\n\n    std::unique_ptr<Tensor>\
    \ a_float;\n    std::unique_ptr<Tensor> b_float;\n    if (!a_is_sparse_ && !b_is_sparse_)\
    \ {\n      auto left = &a;\n      auto right = &b;\n      // TODO(agarwal): multi-thread\
    \ the conversions from bfloat16 to float.\n      if (std::is_same<TL, bfloat16>::value)\
    \ {\n        a_float.reset(new Tensor(DT_FLOAT, a.shape()));\n        BFloat16ToFloat(a.flat<bfloat16>().data(),\n\
    \                        a_float->flat<float>().data(), a.NumElements());\n  \
    \      left = a_float.get();\n      }\n      if (std::is_same<TR, bfloat16>::value)\
    \ {\n        b_float.reset(new Tensor(DT_FLOAT, b.shape()));\n        BFloat16ToFloat(b.flat<bfloat16>().data(),\n\
    \                        b_float->flat<float>().data(), b.NumElements());\n  \
    \      right = b_float.get();\n      }\n      Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>,\
    \ 1> dim_pair;\n      dim_pair[0].first = transpose_a_ ? 0 : 1;\n      dim_pair[0].second\
    \ = transpose_b_ ? 1 : 0;\n\n      out.device(ctx->template eigen_device<CPUDevice>())\
    \ =\n          left->matrix<float>().contract(right->matrix<float>(), dim_pair);\n\
    \      return;\n    }\n\n    auto left = &a;\n    auto right = &b;\n    bool transpose_output\
    \ = false;\n    bool transpose_a = transpose_a_;\n    bool transpose_b = transpose_b_;\n\
    \    if (!a_is_sparse_) {\n      // Swap the order of multiplications using the\
    \ identity:\n      // A * B = (B' *  A')'.\n      std::swap(left, right);\n  \
    \    std::swap(transpose_a, transpose_b);\n      transpose_a = !transpose_a;\n\
    \      transpose_b = !transpose_b;\n      transpose_output = !transpose_output;\n\
    \    }\n\n    std::unique_ptr<Tensor> right_tr;\n    if (transpose_b) {\n    \
    \  // TODO(agarwal): avoid transposing the matrix here and directly handle\n \
    \     // transpose in CreateDenseSlices.\n      OP_REQUIRES(ctx, right->dim_size(0)\
    \ != 0,\n                  errors::InvalidArgument(\"b has an entry 0 in it's\
    \ shape.\"));\n      OP_REQUIRES(ctx, right->dim_size(1) != 0,\n             \
    \     errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));\n      right_tr.reset(\n\
    \          new Tensor(right->dtype(),\n                     TensorShape({right->dim_size(1),\
    \ right->dim_size(0)})));\n\n      const auto perm = dsizes_10();\n      if (transpose_output)\
    \ {\n        right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>())\
    \ =\n            right->matrix<TL>().shuffle(perm);\n      } else {\n        right_tr->matrix<TR>().device(ctx->template\
    \ eigen_device<CPUDevice>()) =\n            right->matrix<TR>().shuffle(perm);\n\
    \      }\n      right = right_tr.get();\n    }\n\n    if (transpose_output) {\n\
    \      DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),\n     \
    \                           right->matrix<TL>(), transpose_a,\n              \
    \                  ctx->device()->tensorflow_cpu_worker_threads(),\n         \
    \                       transpose_output, &out);\n    } else {\n      DoMatMul<TL,\
    \ TR>::Compute(&this->cache_nt_, left->matrix<TL>(),\n                       \
    \         right->matrix<TR>(), transpose_a,\n                                ctx->device()->tensorflow_cpu_worker_threads(),\n\
    \                                transpose_output, &out);\n    }\n  }"
  verbose: true
environment:
  env_type: judge
  id_save: 256138
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
