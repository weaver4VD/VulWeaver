agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\ngst_flxdec_chain\
    \ (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n \
    \ guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n\n  GstFlxDec *flxdec;\n \
    \ FlxHeader *flxh;\n\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n\
    \  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n\
    \n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available\
    \ (flxdec->adapter);\n\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n   \
    \ if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter,\
    \ FlxHeaderSize);\n      GstCaps *templ;\n\n      memcpy ((gchar *) & flxdec->hdr,\
    \ data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n    \
    \  gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter,\
    \ FlxHeaderSize);\n\n      flxh = &flxdec->hdr;\n\n      /* check header */\n\
    \      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC\
    \ && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n\n      GST_LOG\
    \ (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n\
    \      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height  \
    \  :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n\
    \      GST_LOG (\"speed     :  %d\", flxh->speed);\n\n      flxdec->next_time\
    \ = 0;\n\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time\
    \ = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time\
    \ = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed\
    \ * GST_MSECOND;\n      }\n\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n\
    \      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS\
    \ (flxdec->duration));\n\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n\
    \      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple\
    \ (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\"\
    , G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint)\
    \ GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n\n      gst_pad_set_caps\
    \ (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n\n      if (flxh->depth\
    \ <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new\
    \ (flxh->width, flxh->height);\n\n      if (flxh->type == FLX_MAGICHDR_FLC ||\
    \ flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\"\
    , flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n\
    \        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG\
    \ (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n\n      flxdec->size\
    \ = ((guint) flxh->width * (guint) flxh->height);\n\n      /* create delta and\
    \ output frame */\n      flxdec->frame_data = g_malloc (flxdec->size);\n     \
    \ flxdec->delta_data = g_malloc (flxdec->size);\n\n      flxdec->state = GST_FLXDEC_PLAYING;\n\
    \    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n\
    \n    /* while we have enough data in the adapter */\n    while (avail >= FlxFrameChunkSize\
    \ && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n\
    \      const guint8 *data;\n      GstMapInfo map;\n\n      chunk = NULL;\n   \
    \   data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy\
    \ (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n\
    \      gst_adapter_unmap (flxdec->adapter);\n\n      switch (flxfh.id) {\n   \
    \     case FLX_FRAME_TYPE:\n          /* check if we have the complete frame */\n\
    \          if (avail < flxfh.size)\n            goto need_more_data;\n\n     \
    \     /* flush header */\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n\
    \n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size\
    \ - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType\
    \ *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n         \
    \   break;\n\n          /* create 32 bits output frame */\n//          res = gst_pad_alloc_buffer_and_set_caps\
    \ (flxdec->srcpad,\n//              GST_BUFFER_OFFSET_NONE,\n//              flxdec->size\
    \ * 4, GST_PAD_CAPS (flxdec->srcpad), &out);\n//          if (res != GST_FLOW_OK)\n\
    //            break;\n\n          out = gst_buffer_new_and_alloc (flxdec->size\
    \ * 4);\n\n          /* decode chunks */\n          if (!flx_decode_chunks (flxdec,\n\
    \                  ((FlxFrameType *) chunk)->chunks,\n                  chunk\
    \ + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec,\
    \ STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n\
    \            return GST_FLOW_ERROR;\n          }\n\n          /* save copy of\
    \ the current frame for possible delta. */\n          memcpy (flxdec->delta_data,\
    \ flxdec->frame_data, flxdec->size);\n\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n\
    \          /* convert current frame. */\n          flx_colorspace_convert (flxdec->converter,\
    \ flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out,\
    \ &map);\n\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n      \
    \    flxdec->next_time += flxdec->frame_time;\n\n          res = gst_pad_push\
    \ (flxdec->srcpad, out);\n          break;\n        default:\n          /* check\
    \ if we have the complete frame */\n          if (avail < flxfh.size)\n      \
    \      goto need_more_data;\n\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n\
    \          break;\n      }\n\n      g_free (chunk);\n\n      avail = gst_adapter_available\
    \ (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\n\n  /* ERRORS\
    \ */\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n\
    \        (\"not a flx file (type %x)\", flxh->type));\n    gst_object_unref (flxdec);\n\
    \    return GST_FLOW_ERROR;\n  }\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\ngst_flxdec_chain (GstPad * pad,\
    \ GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n\
    \  GstFlowReturn res = GST_FLOW_OK;\n\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n\
    \n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec\
    \ *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n\n  gst_adapter_push\
    \ (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n\
    \n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize)\
    \ {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n\
    \      GstCaps *templ;\n\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n\
    \      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n\
    \      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n\n      flxh = &flxdec->hdr;\n\
    \n      /* check header */\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n    \
    \      flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n   \
    \     goto wrong_type;\n\n      GST_LOG (\"size      :  %d\", flxh->size);\n \
    \     GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width   \
    \  :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n\
    \      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed   \
    \  :  %d\", flxh->speed);\n\n      flxdec->next_time = 0;\n\n      if (flxh->type\
    \ == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n\
    \      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND\
    \ / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n\
    \      }\n\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n    \
    \  GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n\
    \n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps =\
    \ gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple\
    \ (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\"\
    , G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint)\
    \ GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n\n      gst_pad_set_caps\
    \ (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n\n      if (flxh->depth\
    \ <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new\
    \ (flxh->width, flxh->height);\n\n      if (flxh->type == FLX_MAGICHDR_FLC ||\
    \ flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\"\
    , flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n\
    \        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG\
    \ (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n\n      flxdec->size\
    \ = ((guint) flxh->width * (guint) flxh->height);\n\n      /* create delta and\
    \ output frame */\n      flxdec->frame_data = g_malloc (flxdec->size);\n     \
    \ flxdec->delta_data = g_malloc (flxdec->size);\n\n      flxdec->state = GST_FLXDEC_PLAYING;\n\
    \    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n\
    \n    /* while we have enough data in the adapter */\n    while (avail >= FlxFrameChunkSize\
    \ && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n\
    \      const guint8 *data;\n      GstMapInfo map;\n\n      chunk = NULL;\n   \
    \   data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy\
    \ (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n\
    \      gst_adapter_unmap (flxdec->adapter);\n\n      switch (flxfh.id) {\n   \
    \     case FLX_FRAME_TYPE:\n          /* check if we have the complete frame */\n\
    \          if (avail < flxfh.size)\n            goto need_more_data;\n\n     \
    \     /* flush header */\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n\
    \n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size\
    \ - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType\
    \ *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n         \
    \   break;\n\n          /* create 32 bits output frame */\n//          res = gst_pad_alloc_buffer_and_set_caps\
    \ (flxdec->srcpad,\n//              GST_BUFFER_OFFSET_NONE,\n//              flxdec->size\
    \ * 4, GST_PAD_CAPS (flxdec->srcpad), &out);\n//          if (res != GST_FLOW_OK)\n\
    //            break;\n\n          out = gst_buffer_new_and_alloc (flxdec->size\
    \ * 4);\n\n          /* decode chunks */\n          if (!flx_decode_chunks (flxdec,\n\
    \                  ((FlxFrameType *) chunk)->chunks,\n                  chunk\
    \ + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec,\
    \ STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n\
    \            return GST_FLOW_ERROR;\n          }\n\n          /* save copy of\
    \ the current frame for possible delta. */\n          memcpy (flxdec->delta_data,\
    \ flxdec->frame_data, flxdec->size);\n\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n\
    \          /* convert current frame. */\n          flx_colorspace_convert (flxdec->converter,\
    \ flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out,\
    \ &map);\n\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n      \
    \    flxdec->next_time += flxdec->frame_time;\n\n          res = gst_pad_push\
    \ (flxdec->srcpad, out);\n          break;\n        default:\n          /* check\
    \ if we have the complete frame */\n          if (avail < flxfh.size)\n      \
    \      goto need_more_data;\n\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n\
    \          break;\n      }\n\n      g_free (chunk);\n\n      avail = gst_adapter_available\
    \ (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\n\n  /* ERRORS\
    \ */\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n\
    \        (\"not a flx file (type %x)\", flxh->type));\n    gst_object_unref (flxdec);\n\
    \    return GST_FLOW_ERROR;\n  }\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\ngst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n\
    {\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n\n  GstFlxDec\
    \ *flxdec;\n  FlxHeader *flxh;\n\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n\
    \  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n\
    \n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available\
    \ (flxdec->adapter);\n\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n   \
    \ if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter,\
    \ FlxHeaderSize);\n      GstCaps *templ;\n\n      memcpy ((gchar *) & flxdec->hdr,\
    \ data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n    \
    \  gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter,\
    \ FlxHeaderSize);\n\n      flxh = &flxdec->hdr;\n\n      /* check header */\n\
    \      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC\
    \ && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n\n      GST_LOG\
    \ (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n\
    \      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height  \
    \  :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n\
    \      GST_LOG (\"speed     :  %d\", flxh->speed);\n\n      flxdec->next_time\
    \ = 0;\n\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time\
    \ = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time\
    \ = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed\
    \ * GST_MSECOND;\n      }\n\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n\
    \      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS\
    \ (flxdec->duration));\n\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n\
    \      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple\
    \ (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\"\
    , G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint)\
    \ GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n\n      gst_pad_set_caps\
    \ (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n\n      if (flxh->depth\
    \ <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new\
    \ (flxh->width, flxh->height);\n\n      if (flxh->type == FLX_MAGICHDR_FLC ||\
    \ flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\"\
    , flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n\
    \        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG\
    \ (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n\n      flxdec->size\
    \ = ((guint) flxh->width * (guint) flxh->height);\n\n      /* create delta and\
    \ output frame */\n      flxdec->frame_data = g_malloc (flxdec->size);\n     \
    \ flxdec->delta_data = g_malloc (flxdec->size);\n\n      flxdec->state = GST_FLXDEC_PLAYING;\n\
    \    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n\
    \n    /* while we have enough data in the adapter */\n    while (avail >= FlxFrameChunkSize\
    \ && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n\
    \      const guint8 *data;\n      GstMapInfo map;\n\n      chunk = NULL;\n   \
    \   data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy\
    \ (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n\
    \      gst_adapter_unmap (flxdec->adapter);\n\n      switch (flxfh.id) {\n   \
    \     case FLX_FRAME_TYPE:\n          /* check if we have the complete frame */\n\
    \          if (avail < flxfh.size)\n            goto need_more_data;\n\n     \
    \     /* flush header */\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n\
    \n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size\
    \ - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType\
    \ *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n         \
    \   break;\n\n          /* create 32 bits output frame */\n//          res = gst_pad_alloc_buffer_and_set_caps\
    \ (flxdec->srcpad,\n//              GST_BUFFER_OFFSET_NONE,\n//              flxdec->size\
    \ * 4, GST_PAD_CAPS (flxdec->srcpad), &out);\n//          if (res != GST_FLOW_OK)\n\
    //            break;\n\n          out = gst_buffer_new_and_alloc (flxdec->size\
    \ * 4);\n\n          /* decode chunks */\n          if (!flx_decode_chunks (flxdec,\n\
    \                  ((FlxFrameType *) chunk)->chunks,\n                  chunk\
    \ + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec,\
    \ STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n\
    \            return GST_FLOW_ERROR;\n          }\n\n          /* save copy of\
    \ the current frame for possible delta. */\n          memcpy (flxdec->delta_data,\
    \ flxdec->frame_data, flxdec->size);\n\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n\
    \          /* convert current frame. */\n          flx_colorspace_convert (flxdec->converter,\
    \ flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out,\
    \ &map);\n\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n      \
    \    flxdec->next_time += flxdec->frame_time;\n\n          res = gst_pad_push\
    \ (flxdec->srcpad, out);\n          break;\n        default:\n          /* check\
    \ if we have the complete frame */\n          if (avail < flxfh.size)\n      \
    \      goto need_more_data;\n\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n\
    \          break;\n      }\n\n      g_free (chunk);\n\n      avail = gst_adapter_available\
    \ (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\n\n  /* ERRORS\
    \ */\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n\
    \        (\"not a flx file (type %x)\", flxh->type));\n    gst_object_unref (flxdec);\n\
    \    return GST_FLOW_ERROR;\n  }\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\ngst_flxdec_chain (GstPad * pad, GstObject\
    \ * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn\
    \ res = GST_FLOW_OK;\n\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n\n  g_return_val_if_fail\
    \ (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail\
    \ (flxdec != NULL, GST_FLOW_ERROR);\n\n  gst_adapter_push (flxdec->adapter, buf);\n\
    \  avail = gst_adapter_available (flxdec->adapter);\n\n  if (flxdec->state ==\
    \ GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8\
    \ *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n\
    \n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS\
    \ (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush\
    \ (flxdec->adapter, FlxHeaderSize);\n\n      flxh = &flxdec->hdr;\n\n      /*\
    \ check header */\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type\
    \ != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n\
    \n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames  \
    \  :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n\
    \      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth  \
    \   :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n\
    \n      flxdec->next_time = 0;\n\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n\
    \        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed\
    \ == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n   \
    \     flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n\n      flxdec->duration\
    \ = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n\
    \          GST_TIME_ARGS (flxdec->duration));\n\n      templ = gst_pad_get_pad_template_caps\
    \ (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref\
    \ (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT,\
    \ flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"\
    framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time\
    \ / 1000, NULL);\n\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref\
    \ (caps);\n\n      if (flxh->depth <= 8)\n        flxdec->converter =\n      \
    \      flx_colorspace_converter_new (flxh->width, flxh->height);\n\n      if (flxh->type\
    \ == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"\
    (FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy\
    \ :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\",\
    \ flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n\
    \      }\n\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n\
    \n      /* create delta and output frame */\n      flxdec->frame_data = g_malloc\
    \ (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n\n   \
    \   flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state ==\
    \ GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n\n    /* while we have enough data\
    \ in the adapter */\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK)\
    \ {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n\
    \      GstMapInfo map;\n\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter,\
    \ FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n     \
    \ FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n\
    \n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          /* check\
    \ if we have the complete frame */\n          if (avail < flxfh.size)\n      \
    \      goto need_more_data;\n\n          /* flush header */\n          gst_adapter_flush\
    \ (flxdec->adapter, FlxFrameChunkSize);\n\n          chunk = gst_adapter_take\
    \ (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n        \
    \  FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType\
    \ *) chunk)->chunks == 0)\n            break;\n\n          /* create 32 bits output\
    \ frame */\n//          res = gst_pad_alloc_buffer_and_set_caps (flxdec->srcpad,\n\
    //              GST_BUFFER_OFFSET_NONE,\n//              flxdec->size * 4, GST_PAD_CAPS\
    \ (flxdec->srcpad), &out);\n//          if (res != GST_FLOW_OK)\n//          \
    \  break;\n\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n\n\
    \          /* decode chunks */\n          if (!flx_decode_chunks (flxdec,\n  \
    \                ((FlxFrameType *) chunk)->chunks,\n                  chunk +\
    \ FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec,\
    \ STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n\
    \            return GST_FLOW_ERROR;\n          }\n\n          /* save copy of\
    \ the current frame for possible delta. */\n          memcpy (flxdec->delta_data,\
    \ flxdec->frame_data, flxdec->size);\n\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n\
    \          /* convert current frame. */\n          flx_colorspace_convert (flxdec->converter,\
    \ flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out,\
    \ &map);\n\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n      \
    \    flxdec->next_time += flxdec->frame_time;\n\n          res = gst_pad_push\
    \ (flxdec->srcpad, out);\n          break;\n        default:\n          /* check\
    \ if we have the complete frame */\n          if (avail < flxfh.size)\n      \
    \      goto need_more_data;\n\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n\
    \          break;\n      }\n\n      g_free (chunk);\n\n      avail = gst_adapter_available\
    \ (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\n\n  /* ERRORS\
    \ */\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n\
    \        (\"not a flx file (type %x)\", flxh->type));\n    gst_object_unref (flxdec);\n\
    \    return GST_FLOW_ERROR;\n  }\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 215038
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
