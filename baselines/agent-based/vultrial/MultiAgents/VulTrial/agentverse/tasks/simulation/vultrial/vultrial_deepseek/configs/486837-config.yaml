agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nSTATIC\
    \ SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode **scanp,\n \
    \                       SSize_t *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\
    \t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\
    \t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags, U32 depth, bool was_mutate_ok)\n\
    \t\t\t/* scanp: Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen\
    \ here. */\n\t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data\
    \ about the pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/*\
    \ recursed: which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid\
    \ if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least\
    \ this number of characters to match */\n    SSize_t min = 0;\n    I32 pars =\
    \ 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int\
    \ is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal\
    \ = 0;\t\t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN\
    \ ? ARG(scan) : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n\
    \    regnode *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n   \
    \ scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n\
    \    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if\
    \ ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n\
    \            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n\
    \    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n\
    \    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu\
    \ depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n\
    \            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned\
    \ long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n\
    \        if (recursed_depth) {\n            U32 i;\n            U32 j;\n     \
    \       for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i =\
    \ 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n       \
    \                 PAREN_TEST(RExC_study_chunk_recursed +\n                   \
    \                ( j * RExC_study_chunk_recursed_bytes), i )\n               \
    \         && (\n                            !j ||\n                          \
    \  !PAREN_TEST(RExC_study_chunk_recursed +\n                                 \
    \  (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                       \
    \ )\n                    ) {\n                        Perl_re_printf( aTHX_ \"\
    \ %d\",(int)i);\n                        break;\n                    }\n     \
    \           }\n                if ( j + 1 < recursed_depth ) {\n             \
    \       Perl_re_printf( aTHX_  \",\");\n                }\n            }\n   \
    \     }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan\
    \ && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How\
    \ mmany chars to subtract from the minimum\n                                 \
    \  node length to get a real minimum (because\n                              \
    \     the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\
    \        /* avoid mutating ops if we are anywhere within the recursed or\n   \
    \      * enframed handling for a GOSUB: the outermost level will handle it.\n\
    \         */\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n\
    \t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n\
    \        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason\
    \ we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/\
    \ which cant be dealt with by the normal EXACT\n         * parsing code, as each\
    \ (?:..) is handled by a different invocation of\n         * reg() -- Yves\n \
    \        */\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract,\
    \ &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current\
    \ node and optimize\n           away all the NOTHINGs from it.\n         */\n\
    \        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot\
    \ be a switch, since we\n\t   look into several different things.  */\n      \
    \  if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n           \
    \ SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n         \
    \   I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan)\
    \ == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\
    \n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n\
    \            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n\
    \            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"\
    next\", next, depth, flags);\n\n            /* we suppose the run is continuous,\
    \ last=next...\n             * NOTE we dont use the return here! */\n        \
    \    /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state,\
    \ &scan, &minlen,\n                              &deltanext, next, &data_fake,\
    \ stopparen,\n                              recursed_depth, NULL, f, depth+1,\
    \ mutate_ok);\n\n            scan = next;\n        } else\n        if (\n    \
    \        OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n        \
    \    OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code\
    \ = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n\
    \             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\
    \n             * IFTHEN is special as it might not appear in pairs.\n        \
    \     * Not sure whether BRANCH-BRANCHJ is possible, regardless\n            \
    \ * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN)\
    \ {\n                /* NOTE - There is similar code to this block below for\n\
    \                 * handling TRIE nodes on a re-study.  If you change stuff here\n\
    \                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX,\
    \ num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n\
    \                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge\
    \ strings after this. */\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\
    \t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\
    \t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc\
    \ this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\
    \n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\
    \t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\
    \tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t\
    \    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything\
    \ */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\
    \t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\t\
    ssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\
    \t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\
    \t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous,\
    \ last=next...*/\n                    /* recurse study_chunk() for each BRANCH\
    \ in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n\
    \                                      &deltanext, next, &data_fake, stopparen,\n\
    \                                      recursed_depth, NULL, f, depth+1,\n   \
    \                                   mutate_ok);\n\n\t\t    if (min1 > minnext)\n\
    \t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf =\
    \ is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext\
    \ + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t\
    \    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t        \
    \    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin\
    \ > minnext)\n\t                    stopmin = min + min1;\n\t                flags\
    \ &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags\
    \ |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags\
    \ & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c\
    \ = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\t\
    ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code\
    \ == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta\
    \ >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\
    \t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 !=\
    \ min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\
    \t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\
    \t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif\
    \ (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class,\
    \ (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1)\
    \ {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\
    \t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\
    \t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n      \
    \              && OP(startbranch) == BRANCH\n                    && mutate_ok\n\
    \                ) {\n\t\t/* demq.\n\n                   Assuming this was/is\
    \ a branch we are dealing with: 'scan'\n                   now points at the item\
    \ that follows the branch sequence,\n                   whatever it is. We now\
    \ start at the beginning of the\n                   sequence and look for subsequences\
    \ of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n  \
    \                 which would be constructed from a pattern like\n           \
    \        /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need\
    \ to turn the first\n\t\t   element into a trie and then add the subsequent branch\
    \ exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n         \
    \            1. patterns where the whole set of branches can be\n            \
    \            converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\
    \n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for\
    \ the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\
    \t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE;\
    \ BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\
    \t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding\
    \ the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not\
    \ we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\
    \t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested\
    \ if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t  \
    \  if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME,\
    \ 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff,\
    \ RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0\
    \  ) {\n                        regnode *cur;\n                        regnode\
    \ *first = (regnode *)NULL;\n                        regnode *last = (regnode\
    \ *)NULL;\n                        regnode *tail = scan;\n                   \
    \     U8 trietype = 0;\n                        U32 count=0;\n\n             \
    \           /* var tail is used because there may be a TAIL\n                \
    \           regop in the way. Ie, the exacts will point to the\n             \
    \              thing following the TAIL, but the last branch will\n          \
    \                 point at the TAIL. So we advance tail. If we\n             \
    \              have nested (?:) we may have to move through several\n        \
    \                   tails.\n                         */\n\n                  \
    \      while ( OP( tail ) == TAIL ) {\n                            /* this is\
    \ the TAIL generated by (?:) */\n                            tail = regnext( tail\
    \ );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n\
    \                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n\
    \                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\"\
    ,\n                              depth+1,\n                              \"Looking\
    \ for TRIE'able sequences. Tail node is \",\n                              (UV)\
    \ REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv\
    \ )\n                            );\n                        });\n\n         \
    \               /*\n\n                            Step through the branches\n\
    \                                cur represents each branch,\n               \
    \                 noper is the first thing to be matched as part\n           \
    \                           of that branch\n                                noper_next\
    \ is the regnext() of that node.\n\n                            We normally handle\
    \ a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump\
    \ trie\" but we also\n                            support building with NOJUMPTRIE,\
    \ which restricts\n                            the trie logic to structures like\
    \ /FOO|BAR/.\n\n                            If noper is a trieable nodetype then\
    \ the branch is\n                            a possible optimization target. If\
    \ we are building\n                            under NOJUMPTRIE then we require\
    \ that noper_next is\n                            the same as scan (our current\
    \ position in the regex\n                            program).\n\n           \
    \                 Once we have two or more consecutive such branches\n       \
    \                     we can create a trie of the EXACT's contents and\n     \
    \                       stitch it in place into the program.\n\n             \
    \               If the sequence represents all of the branches in\n          \
    \                  the alternation we replace the entire thing with a\n      \
    \                      single TRIE node.\n\n                            Otherwise\
    \ when it is a subsequence we need to\n                            stitch it in\
    \ place and replace only the relevant\n                            branches. This\
    \ means the first branch has to remain\n                            as it is used\
    \ by the alternation logic, and its\n                            next pointer,\
    \ and needs to be repointed at the item\n                            on the branch\
    \ chain following the last branch we\n                            have optimized\
    \ away.\n\n                            This could be either a BRANCH, in which\
    \ case the\n                            subsequence is internal, or it could be\
    \ the item\n                            following the branch sequence in which\
    \ case the\n                            subsequence is at the end (which does\
    \ not\n                            necessarily mean the first node is the start\
    \ of the\n                            alternation).\n\n                      \
    \      TRIE_TYPE(X) is a define which maps the optype to a\n                 \
    \           trietype.\n\n                                optype          |  trietype\n\
    \                                ----------------+-----------\n              \
    \                  NOTHING         | NOTHING\n                               \
    \ EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n\
    \                                EXACTFU         | EXACTFU\n                 \
    \               EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP\
    \        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n\
    \                                EXACTL          | EXACTL\n                  \
    \              EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define\
    \ TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n   \
    \                    ? NOTHING                                            \\\n\
    \                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\
    \n                         ? EXACT                                           \
    \ \\\n                         : (     EXACTFU == (X)                        \
    \     \\\n                              || EXACTFU_ONLY8 == (X)              \
    \         \\\n                              || EXACTFUP == (X) )             \
    \             \\\n                           ? EXACTFU                       \
    \                 \\\n                           : ( EXACTFAA == (X) )       \
    \                     \\\n                             ? EXACTFAA            \
    \                         \\\n                             : ( EXACTL == (X) )\
    \                            \\\n                               ? EXACTL     \
    \                                \\\n                               : ( EXACTFLU8\
    \ == (X) )                       \\\n                                 ? EXACTFLU8\
    \                                \\\n                                 : 0 )\n\n\
    \                        /* dont use tail as the end marker for this traverse\
    \ */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext(\
    \ cur ) ) {\n                            regnode * const noper = NEXTOPER( cur\
    \ );\n                            U8 noper_type = OP( noper );\n             \
    \               U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING)\
    \ || defined(NOJUMPTRIE)\n                            regnode * const noper_next\
    \ = regnext( noper );\n                            U8 noper_next_type = (noper_next\
    \ && noper_next < tail) ? OP(noper_next) : 0;\n                            U8\
    \ noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type\
    \ ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n      \
    \                          regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n\
    \                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n \
    \                                  depth+1,\n                                \
    \   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n\
    \                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n\
    \                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n     \
    \                               REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\
    \n                                if ( noper_next ) {\n                      \
    \            regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n   \
    \                               Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n  \
    \                                  REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n\
    \                                }\n                                Perl_re_printf(\
    \ aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n      \
    \                             REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\
    \t\t\t\t);\n                            });\n\n                            /*\
    \ Is noper a trieable nodetype that can be merged\n                          \
    \   * with the current trie (if there is one)? */\n                          \
    \  if ( noper_trietype\n                                  &&\n               \
    \                   (\n                                        ( noper_trietype\
    \ == NOTHING )\n                                        || ( trietype == NOTHING\
    \ )\n                                        || ( trietype == noper_trietype )\n\
    \                                  )\n#ifdef NOJUMPTRIE\n                    \
    \              && noper_next >= tail\n#endif\n                               \
    \   && count < U16_MAX)\n                            {\n                     \
    \           /* Handle mergable triable node Either we are\n                  \
    \               * the first node in a new trieable sequence,\n               \
    \                  * in which case we do some bookkeeping,\n                 \
    \                * otherwise we update the end pointer. */\n                 \
    \               if ( !first ) {\n                                    first = cur;\n\
    \t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\
    \t\t\t\t\tregnode * const noper_next = regnext( noper );\n                   \
    \                     U8 noper_next_type = (noper_next && noper_next < tail) ?\
    \ OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE(\
    \ noper_next_type ) :0;\n#endif\n\n                                        if\
    \ ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n \
    \                                       } else if (noper_next_type)  {\n     \
    \                                       /* a NOTHING regop is 1 regop wide.\n\
    \                                             * We need at least two for a trie\n\
    \                                             * so we can't merge this in */\n\
    \                                            first = NULL;\n                 \
    \                       }\n                                    } else {\n    \
    \                                    trietype = noper_trietype;\n            \
    \                        }\n                                } else {\n       \
    \                             if ( trietype == NOTHING )\n                   \
    \                     trietype = noper_trietype;\n                           \
    \         last = cur;\n                                }\n\t\t\t\tif (first)\n\
    \t\t\t\t    count++;\n                            } /* end handle mergable triable\
    \ node */\n                            else {\n                              \
    \  /* handle unmergable node -\n                                 * noper may either\
    \ be a triable node which can\n                                 * not be tried\
    \ together with the current trie,\n                                 * or a non\
    \ triable node */\n                                if ( last ) {\n           \
    \                         /* If last is set and trietype is not\n            \
    \                         * NOTHING then we have found at least two\n        \
    \                             * triable branch sequences in a row of a\n     \
    \                                * similar trietype so we can turn them\n    \
    \                                 * into a trie. If/when we allow NOTHING to\n\
    \                                     * start a trie sequence this condition\n\
    \                                     * will be required, and it isn't expensive\n\
    \                                     * so we leave it in for now. */\n      \
    \                              if ( trietype && trietype != NOTHING )\n      \
    \                                  make_trie( pRExC_state,\n                 \
    \                               startbranch, first, cur, tail,\n             \
    \                                   count, trietype, depth+1 );\n            \
    \                        last = NULL; /* note: we clear/update\n             \
    \                                       first, trietype etc below,\n         \
    \                                           so we dont do it here */\n       \
    \                         }\n                                if ( noper_trietype\n\
    #ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n\
    #endif\n                                ){\n                                 \
    \   /* noper is triable, so we can start a new\n                             \
    \        * trie sequence */\n                                    count = 1;\n\
    \                                    first = cur;\n                          \
    \          trietype = noper_trietype;\n                                } else\
    \ if (first) {\n                                    /* if we already saw a first\
    \ but the\n                                     * current node is not triable\
    \ then we have\n                                     * to reset the first information.\
    \ */\n                                    count = 0;\n                       \
    \             first = NULL;\n                                    trietype = 0;\n\
    \                                }\n                            } /* end handle\
    \ unmergable node */\n                        } /* loop over branches */\n   \
    \                     DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx,\
    \ RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf(\
    \ aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1,\
    \ SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                       \
    \     Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n\
    \                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \                               PL_reg_name[trietype]\n                      \
    \      );\n\n                        });\n                        if ( last &&\
    \ trietype ) {\n                            if ( trietype != NOTHING ) {\n   \
    \                             /* the last branch of the sequence was part of\n\
    \                                 * a trie, so we have to construct it here\n\
    \                                 * outside of the loop */\n                 \
    \               made= make_trie( pRExC_state, startbranch,\n                 \
    \                                first, scan, tail, count,\n                 \
    \                                trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n\
    \                                if ( ((made == MADE_EXACT_TRIE &&\n         \
    \                            startbranch == first)\n                         \
    \            || ( first_non_open == first )) &&\n                            \
    \         depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n\
    \                                    if ( startbranch == first\n             \
    \                            && scan >= tail )\n                             \
    \       {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n\
    \                                    }\n                                }\n#endif\n\
    \                            } else {\n                                /* at this\
    \ point we know whatever we have is a\n                                 * NOTHING\
    \ sequence/branch AND if 'startbranch'\n                                 * is\
    \ 'first' then we can turn the whole thing\n                                 *\
    \ into a NOTHING\n                                 */\n                      \
    \          if ( startbranch == first ) {\n                                   \
    \ regnode *opt;\n                                    /* the entire thing is a\
    \ NOTHING sequence,\n                                     * something like this:\
    \ (?:|) So we can\n                                     * turn it into a plain\
    \ NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n\
    \                                        regprop(RExC_rx, RExC_mysv, cur, NULL,\
    \ pRExC_state);\n                                        Perl_re_indentf( aTHX_\
    \  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                             \
    \             depth+1,\n                                          SvPV_nolen_const(\
    \ RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n\
    \                                    OP(startbranch)= NOTHING;\n             \
    \                       NEXT_OFF(startbranch)= tail - startbranch;\n         \
    \                           for ( opt= startbranch + 1; opt < tail ; opt++ )\n\
    \                                        OP(opt)= OPTIMIZED;\n               \
    \                 }\n                            }\n                        }\
    \ /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n\
    \                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ )\
    \ {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\
    \t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\
    \t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB)\
    \ {\n            I32 paren = 0;\n            regnode *start = NULL;\n        \
    \    regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\
    \n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup,\
    \ note this code has side effects beyond\n                 * the rest of this\
    \ block. Specifically setting\n                 * RExC_recurse[] must happen at\
    \ least once during\n                 * study_chunk(). */\n                paren\
    \ = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n          \
    \      start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\
    \n                /* NOTE we MUST always execute the above code, even\n      \
    \           * if we do nothing with a GOSUB */\n                if (\n       \
    \             ( flags & SCF_IN_DEFINE )\n                    ||\n            \
    \        (\n                        (is_inf_internal || is_inf || (data && data->flags\
    \ & SF_IS_INF))\n                        &&\n                        ( (flags\
    \ & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n        \
    \        ) {\n                    /* no need to do anything here if we are in\
    \ a define. */\n                    /* or we are after some kind of infinite construct\n\
    \                     * so we can skip recursing into this item.\n           \
    \          * Since it is infinite we will not change the maxlen\n            \
    \         * or delta, and if we miss something that might raise\n            \
    \         * the minlen it will merely pessimise a little.\n                  \
    \   *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n   \
    \                  * might result in a minlen of 1 and not of 4,\n           \
    \          * but this doesn't make us mismatch, just try a bit\n             \
    \        * harder than we should.\n                     * */\n               \
    \     scan= regnext(scan);\n                    continue;\n                }\n\
    \n                if (\n                    !recursed_depth\n                \
    \    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1)\
    \ * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n          \
    \          /* it is quite possible that there are more efficient ways\n      \
    \               * to do this. We maintain a bitmap per level of recursion\n  \
    \                   * of which patterns we have entered so we can detect if a\n\
    \                     * pattern creates a possible infinite loop. When we\n  \
    \                   * recurse down a level we copy the previous levels bitmap\n\
    \                     * down. When we are at recursion level 0 we zero the top\n\
    \                     * level bitmap. It would be nice to implement a different\n\
    \                     * more efficient way of doing this. In particular the top\n\
    \                     * level bitmap may be unnecessary.\n                   \
    \  */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed,\
    \ RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n      \
    \                  Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed_bytes, U8);\n        \
    \            }\n                    /* we havent recursed into this paren yet,\
    \ so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data,\
    \ depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth\
    \ * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth=\
    \ recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"\
    gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite\
    \ recursion, assume infinite length\n                     * */\n             \
    \       if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n\
    \                    }\n                    is_inf = is_inf_internal = 1;\n  \
    \                  if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n   \
    \                     ssc_anything(data->start_class);\n                    flags\
    \ &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we\
    \ dont recurse later on. */\n\t        }\n            } else {\n\t        paren\
    \ = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\
    \t    }\n            if (start) {\n                scan_frame *newframe;\n   \
    \             assert(end);\n                if (!RExC_frame_last) {\n        \
    \            Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames,\
    \ newframe);\n                    RExC_frame_head= newframe;\n               \
    \     RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame)\
    \ {\n                    Newxz(newframe, 1, scan_frame);\n                   \
    \ RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame=\
    \ RExC_frame_last;\n                    RExC_frame_count++;\n                }\
    \ else {\n                    newframe= RExC_frame_last->next_frame;\n       \
    \         }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode\
    \ = regnext(scan);\n                newframe->last_regnode = last;\n         \
    \       newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth\
    \ = recursed_depth;\n                newframe->this_prev_frame= frame;\n     \
    \           newframe->in_gosub = (\n                    (frame && frame->in_gosub)\
    \ || OP(scan) == GOSUB\n                );\n\n                DEBUG_STUDYDATA(\"\
    frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan,\
    \ depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t\
    \        stopparen = paren;\n\t        last = end;\n                depth = depth\
    \ + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\
    \t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) ==\
    \ EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t\
    \ l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\
    \t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s +\
    \ l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\
    \t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest\
    \ substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset,\
    \ later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update\
    \ the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t   \
    \ data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\
    \t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\
    \t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\
    \t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8)\
    \ : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n\
    \                                              (U8*)STRING(scan)+STR_LEN(scan));\n\
    \t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As\
    \ in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n    \
    \        /* ANDing the code point leaves at most it, and not in locale, and\n\
    \             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND)\
    \ {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class)\
    \ &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\
    \t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class,\
    \ uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)]\
    \ == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t\
    \ l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /*\
    \ Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\
    \t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\
    \t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n    \
    \        delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min\
    \ += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min\
    \ = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\
    \tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\
    \t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist\
    \ = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n\
    \                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan)\
    \ != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n\
    \                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                    ANYOF_POSIXL_ZERO(data->start_class);\n                 \
    \   ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n            \
    \    }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class,\
    \ EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a\
    \ */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n                flags &= ~SCF_DO_STCLASS;\n              \
    \  SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan)))\
    \ {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t\
    \    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc\
    \ this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\
    \n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)*\
    \ . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif\
    \ (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\
    \t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n\
    \                        || OP(next) == EXACTL\n                        || (flags\
    \ & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount\
    \ = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\
    \tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\
    \t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\
    \n                /* This temporary node can now be turned into EXACTFU, and\n\
    \                 * must, as regexec.c doesn't handle it */\n                if\
    \ (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n                    OP(next) =\
    \ EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n\
    \                    &&   isALPHA_A(* STRING(next))\n                    && (\
    \         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n\
    \                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n\
    \                    &&   mutate_ok\n                ) {\n                   \
    \ /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\
    \n                    assert(isALPHA_A(* STRING(next)));\n\n                 \
    \   /* Then replace it by an ANYOFM node, with\n                    * the mask\
    \ set to the complement of the\n                    * bit that differs between\
    \ upper and lower\n                    * case, and the lowest code point of the\n\
    \                    * pair (which the '&' forces) */\n                    OP(next)\
    \ = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n      \
    \              FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\
    \t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t   \
    \ data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal\
    \ = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\
    \t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\
    \t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\
    \t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount\
    \ = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX)\
    \ {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags\
    \ = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan)\
    \ + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\
    \t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n   \
    \                     scan_commit(pRExC_state, data, minlenp, is_inf);\n     \
    \               /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\
    \t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\
    \t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\
    \t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\
    \t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear\
    \ cache processing any {n,m}\n\t\t   regops for which the combination of input\
    \ pos and regex\n\t\t   pos is not enough information to determine if a match\n\
    \t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/\
    \ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\
    \t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats\
    \ into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount >\
    \ 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t\
    /* This will finish on WHILEM, setting scan, or on NULL: */\n                /*\
    \ recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state,\
    \ &scan, minlenp, &deltanext,\n                                  last, data, stopparen,\
    \ recursed_depth, NULL,\n                                  (mincount == 0\n  \
    \                                 ? (f & ~SCF_DO_SUBSTR)\n                   \
    \                : f)\n                                  , depth+1, mutate_ok);\n\
    \n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif\
    \ (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\
    \t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |=\
    \ SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\
    \t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan =\
    \ next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\
    \t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval\
    \ || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext\
    \ == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n        \
    \            && maxcount <= REG_INFTY/3) /* Complement check for big\n       \
    \                                            count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end,\
    \ packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n\
    \                            \"Quantifier unexpected on zero-length expression\
    \ \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF,\
    \ RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n             \
    \   }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext\
    \ )\n                    || min >= SSize_t_MAX - minnext * mincount )\n      \
    \          {\n                    FAIL(\"Regexp out of space\");\n           \
    \     }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext ==\
    \ SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext +\
    \ deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf)\
    \ {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta +=\
    \ (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n\
    \                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\t\
    if (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t\
    \      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext ==\
    \ 1\n                      && mutate_ok\n                ) {\n\t\t    /* Try to\
    \ optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\
    \t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n\
    #endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\
    \t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\
    \t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\
    \t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens)\
    \ {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n     \
    \                   RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\
    \t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags\
    \ = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t\
    /* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was\
    \ count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t\
    \    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count.\
    \ */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t\
    }\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan)\
    \ == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags\
    \ & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t   \
    \   && minnext != 0\t/* CURLYM can't handle zero width */\n                  \
    \       /* Nor characters whose fold at run-time may be\n                    \
    \      * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\
    \                      && mutate_ok\n\t\t) {\n\t\t    /* XXXX How to optimize\
    \ if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode\
    \ *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\
    \n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over\
    \ embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t\
    \    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away\
    \ parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\
    \t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) +\
    \ EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif\
    \ (RExC_open_parens) {\n                             /*open->CURLYM*/\n      \
    \                      RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n\
    \                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(nxt2)\n                                                   \
    \      + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED;\
    \ /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1\
    \ + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just\
    \ for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM))\
    \ {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\
    \t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\
    \t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\
    \t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t  \
    \  }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n \
    \                       /* recurse study_chunk() on optimised CURLYX => CURLYM\
    \ */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n      \
    \                              NULL, stopparen, recursed_depth, NULL, 0,\n   \
    \                                 depth+1, mutate_ok);\n\t\t    }\n\t\t    else\n\
    \t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t &&\
    \ (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression\
    \ above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we\
    \ care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\
    \t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair.\
    \ */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan\
    \ + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\
    \t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n           \
    \         if (nxt->flags & 0xf) {\n                        /* we've already set\
    \ whilem count on this node */\n                    } else if (++data->whilem_c\
    \ < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n\
    \                        nxt->flags = (U8)(data->whilem_c\n                  \
    \          | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\
    \t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN\
    \ last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                   \
    \ if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                \
    \                                                  string. */\n\t\t\tSSize_t b\
    \ = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\
    \t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\
    \t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old\
    \ >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n  \
    \                                             (U8 *) SvEND(data->last_found))\n\
    \                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the\
    \ added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n      \
    \                  last_chrs = UTF ? utf8_length((U8*)(s + old),\n           \
    \                                 (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext\
    \ == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string\
    \ */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l)\
    \ + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str),\
    \ l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str,\
    \ SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\t\
    SvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\
    \tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\
    \t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv,\
    \ PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\t\
    mg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                         \
    \       last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\
    \t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last\
    \ copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t\
    \    data->last_start_max =\n                              is_inf\n          \
    \                     ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n \
    \                                (maxcount - 1) * (minnext + data->pos_delta);\n\
    \t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min\
    \ += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\"\
    \ UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\"\
    \ UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf\
    \ \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX,\
    \ (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\n\
    Perl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted\
    \ * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount),\
    \ (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n\
    \                        || -counted * deltanext + (minnext + deltanext) * maxcount\
    \ - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta\
    \ = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext\
    \ +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if\
    \ (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\
    \t\t\t    the group.  */\n                        scan_commit(pRExC_state, data,\
    \ minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv\
    \ = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv)\
    \ ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\
    \tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end\
    \ = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\
    \t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min\
    \ + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /*\
    \ float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data &&\
    \ (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\
    \t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n\
    \                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\"\
    ,\n                                                                    OP(scan));\n\
    #endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR)\
    \ {\n                    /* Cannot expect anything... */\n                   \
    \ scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags &\
    \ SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n       \
    \                 /* Actually is any start char, but very few code points\n  \
    \                       * aren't start characters */\n                       \
    \ ssc_match_all_cp(data->start_class);\n                    }\n              \
    \      else {\n                        ssc_anything(data->start_class);\n    \
    \                }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\
    \t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS)\
    \ {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n\
    \                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n\
    \                    ssc_clear_locale(data->start_class);\n                  \
    \  ANYOF_FLAGS(data->start_class)\n                                          \
    \      &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else\
    \ if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n\
    \                              PL_XPosix_ptrs[_CC_VERTSPACE],\n              \
    \                FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n\n                    /* See commit msg for\n              \
    \       * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n\
    \                                                &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n\
    \            if (delta != SSize_t_MAX)\n                delta++;    /* Because\
    \ of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n  \
    \              /* Cannot expect anything... */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n               \
    \ if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta +=\
    \ 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t  \
    \  }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\
    \t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool\
    \ invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will\
    \ only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef\
    \ DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx\
    \ opcode %d\",\n                                                             \
    \        OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t   \
    \ break;\n\n\t\tcase REG_ANY:\n                    {\n                       \
    \ SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist\
    \ = add_cp_to_invlist(REG_ANY_invlist,\n                                     \
    \                       '\\n');\n                        if (flags & SCF_DO_STCLASS_OR)\
    \ {\n                            ssc_union(data->start_class,\n              \
    \                        REG_ANY_invlist,\n                                  \
    \    TRUE /* TRUE => invert, hence all but \\n\n                             \
    \               */\n                                      );\n               \
    \         }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n\
    \                            ssc_intersection(data->start_class,\n           \
    \                                  REG_ANY_invlist,\n                        \
    \                     TRUE  /* TRUE => invert */\n                           \
    \                  );\n                            ssc_clear_locale(data->start_class);\n\
    \                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\
    \t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case\
    \ ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n \
    \               case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class,\n                                (regnode_charclass *) scan);\n\
    \t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                 \
    \                                         (regnode_charclass *) scan);\n\t\t \
    \   break;\n\n                case NANYOFM:\n                case ANYOFM:\n  \
    \                {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\
    \n                    if (flags & SCF_DO_STCLASS_OR) {\n                     \
    \   ssc_union(data->start_class, cp_list, invert);\n                    }\n  \
    \                  else if (flags & SCF_DO_STCLASS_AND) {\n                  \
    \      ssc_intersection(data->start_class, cp_list, invert);\n               \
    \     }\n\n                    SvREFCNT_dec_NN(cp_list);\n                   \
    \ break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n          \
    \          namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n      \
    \              if (flags & SCF_DO_STCLASS_AND) {\n                        bool\
    \ was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n\
    \                                                                 namedclass));\n\
    \                        ANYOF_POSIXL_ZERO(data->start_class);\n             \
    \           if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class,\
    \ namedclass);\n                        }\n                        /* No individual\
    \ code points can now match */\n                        data->start_class->invlist\n\
    \                                                = sv_2mortal(_new_invlist(0));\n\
    \                    }\n                    else {\n                        int\
    \ complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this\
    \ class was already there,\n                         * the result is that they\
    \ match all code points,\n                         * (\\d + \\D == everything).\
    \  Remove the classes from\n                         * future consideration. \
    \ Locale is not relevant in\n                         * this case */\n       \
    \                 if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n  \
    \                          ssc_match_all_cp(data->start_class);\n            \
    \                ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n        \
    \                    ANYOF_POSIXL_CLEAR(data->start_class, complement);\n    \
    \                    }\n                        else {  /* The usual case; just\
    \ add this class to the\n                                   existing set */\n\
    \                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n\
    \                        }\n                    }\n                    break;\n\
    \n                case NPOSIXA:   /* For these, we always know the exact set of\n\
    \                                   what's matched */\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n            \
    \        my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n     \
    \               goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n\
    \                    invert = 1;\n                    /* FALLTHROUGH */\n\t\t\
    case POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)],\
    \ NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points\
    \ unless the\n                     * target string being matched is UTF-8, which\
    \ is\n                     * unknowable until match time.  Since we are going\
    \ to\n                     * invert, we want to get rid of all of them so that\
    \ the\n                     * inversion will match all */\n                  \
    \  if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist,\
    \ PL_UpperLatin1,\n                                          &my_invlist);\n \
    \                   }\n\n                  join_posix_and_ascii:\n\n         \
    \           if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class,\
    \ my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n\
    \                    }\n                    else {\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class,\
    \ my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\
    \t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t\
    }\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags\
    \ |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n\
    \            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if\
    \ (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate\
    \ parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\
    \t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n         \
    \   if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) ==\
    \ UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n\
    \                   In this case we can't do fixed string optimisation.\n    \
    \            */\n\n                SSize_t deltanext, minnext, fake = 0;\n   \
    \             regnode *nscan;\n                regnode_ssc intrnl;\n         \
    \       int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n                if (data) {\n                    data_fake.whilem_c\
    \ = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\
    \t\t}\n                else\n                    data_fake.last_closep = &fake;\n\
    \t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS\
    \ && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead\
    \ */\n                    ssc_init(pRExC_state, &intrnl);\n                  \
    \  data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\
    \t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                 \
    \   f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n    \
    \            nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk()\
    \ for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan,\
    \ minlenp, &deltanext,\n                                      last, &data_fake,\
    \ stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n\
    \                                      mutate_ok);\n                if (scan->flags)\
    \ {\n                    if (   deltanext < 0\n                        || deltanext\
    \ > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n         \
    \               || minnext + deltanext > (I32)U8_MAX)\n                    {\n\
    \t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n        \
    \                      (UV)U8_MAX);\n                    }\n\n               \
    \     /* The 'next_off' field has been repurposed to count the\n             \
    \        * additional starting positions to try beyond the initial\n         \
    \            * one.  (This leaves it at 0 for non-variable length\n          \
    \           * matches to avoid breakage for those not using this\n           \
    \          * extension) */\n                    if (deltanext) {\n           \
    \             scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n\
    \                            WARN_EXPERIMENTAL__VLB,\n                       \
    \     \"Variable length lookbehind is experimental\");\n                    }\n\
    \                    scan->flags = (U8)minnext + deltanext;\n                }\n\
    \                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\
    \                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND)\
    \ {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after:\
    \ ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by\
    \ study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t\
    \ * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl\
    \ #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t \
    \   }  else {\n                        /* AND before and after: combine and continue.\
    \  These\n                         * assertions are zero-length, so can match\
    \ an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                   |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n\
    \            else {\n                /* Positive Lookahead/lookbehind\n      \
    \             In this case we can do fixed string optimisation,\n            \
    \       but we must be careful about it. Note in the case of\n               \
    \    lookbehind the positions will be offset by the minimum\n                \
    \   length of the pattern, something we won't know about\n                   until\
    \ after the recurse.\n                */\n                SSize_t deltanext, fake\
    \ = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n\
    \                int f = 0;\n                /* We use SAVEFREEPV so that when\
    \ the full compile\n                    is finished perl will clean up the allocated\n\
    \                    minlens when it's all done. This way we don't\n         \
    \           have to worry about freeing them when we know\n                  \
    \  they wont be used, which would be a pain.\n                 */\n          \
    \      SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n   \
    \             SAVEFREEPV(minnextp);\n\n                if (data) {\n         \
    \           StructCopy(data, &data_fake, scan_data_t);\n                    if\
    \ ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |=\
    \ SCF_DO_SUBSTR;\n                        if (scan->flags)\n                 \
    \           scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n         \
    \               data_fake.last_found=newSVsv(data->last_found);\n            \
    \        }\n                }\n                else\n                    data_fake.last_closep\
    \ = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags\
    \ = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta\
    \ = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n\
    \                if ( flags & SCF_DO_STCLASS && !scan->flags\n               \
    \      && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state,\
    \ &intrnl);\n                    data_fake.start_class = &intrnl;\n          \
    \          f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags\
    \ & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n\
    \                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\
    \n                /* positive lookahead study_chunk() recursion */\n         \
    \       *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n             \
    \                           &deltanext, last, &data_fake,\n                  \
    \                      stopparen, recursed_depth, NULL,\n                    \
    \                    f, depth+1, mutate_ok);\n                if (scan->flags)\
    \ {\n                    assert(0);  /* This code has never been tested since\
    \ this\n                                   is normally not compiled */\n     \
    \               if (   deltanext < 0\n                        || deltanext > (I32)\
    \ U8_MAX\n                        || *minnextp > (I32)U8_MAX\n               \
    \         || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\
    \tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n            \
    \                  (UV)U8_MAX);\n                    }\n\n                   \
    \ if (deltanext) {\n                        scan->next_off = deltanext;\n    \
    \                }\n                    scan->flags = (U8)*minnextp + deltanext;\n\
    \                }\n\n                *minnextp += min;\n\n                if\
    \ (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class)\
    \ |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n\
    \                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n         \
    \               pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found)\
    \ {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n\
    \                            RExC_rx->minlen=*minnextp;\n                    \
    \    scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n               \
    \         SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for\
    \ (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp\
    \ != minlenp) {\n                                data->substrs[i].min_offset =\n\
    \                                            data_fake.substrs[i].min_offset;\n\
    \                                data->substrs[i].max_offset =\n             \
    \                               data_fake.substrs[i].max_offset;\n           \
    \                     data->substrs[i].minlenp =\n                           \
    \                 data_fake.substrs[i].minlenp;\n                            \
    \    data->substrs[i].lookbehind += scan->flags;\n                           \
    \ }\n                        }\n                    }\n                }\n\t \
    \   }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\
    \t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen ==\
    \ (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par)\
    \ {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next\
    \ < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if\
    \ (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL)\
    \ {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)]\
    \ == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data\
    \ && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t      \
    \  if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan)\
    \ == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf\
    \ = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything\
    \ */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT)\
    \ &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n  \
    \              if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n\
    \                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs\
    \ < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n       \
    \         RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs\
    \ = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n  \
    \      else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is\
    \ similar code to this block above for handling\n               BRANCH nodes on\
    \ the initial study.  If you change stuff here\n               check there too.\
    \ */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n\
    \            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan)\
    \ ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc\
    \ accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n\
    \                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n\
    \                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump)\
    \ {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n\
    \            } else {\n                const regnode *nextbranch= NULL;\n    \
    \            U32 word;\n\n                for ( word=1 ; word <= trie->wordcount\
    \ ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0,\
    \ f = 0, fake;\n                    regnode_ssc this_class;\n\n              \
    \      StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n               \
    \     if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n\
    \                        data_fake.last_closep = data->last_closep;\n        \
    \            }\n                    else\n                        data_fake.last_closep\
    \ = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags\
    \ & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n\
    \                        data_fake.start_class = &this_class;\n              \
    \          f = SCF_DO_STCLASS_AND;\n                    }\n                  \
    \  if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\
    \n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n\
    \                            nextbranch = trie_node + trie->jump[0];\n       \
    \                 scan= trie_node + trie->jump[word];\n                      \
    \  /* We go from the jump point to the branch that follows\n                 \
    \          it. Note this means we need the vestigal unused\n                 \
    \          branches even though they arent otherwise used. */\n              \
    \          /* optimise study_chunk() for TRIE */\n                        minnext\
    \ = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext,\
    \ (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth,\
    \ NULL, f, depth+1,\n                            mutate_ok);\n               \
    \     }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n\
    \                        nextbranch= regnext((regnode*)nextbranch);\n\n      \
    \              if (min1 > (SSize_t)(minnext + trie->minlen))\n               \
    \         min1 = minnext + trie->minlen;\n                    if (deltanext ==\
    \ SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n    \
    \                    max1 = SSize_t_MAX;\n                    } else if (max1\
    \ < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1\
    \ = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags\
    \ & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n               \
    \     if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin\
    \ > min + min1)\n\t                    stopmin = min + min1;\n\t             \
    \   flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                \
    \    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if\
    \ (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n     \
    \                       data->flags |= SF_HAS_EVAL;\n                        data->whilem_c\
    \ = data_fake.whilem_c;\n                    }\n                    if (flags\
    \ & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass\
    \ *) &this_class);\n                }\n            }\n            if (flags &\
    \ SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta\
    \ += max1 - min1;\n                if (max1 != min1 || is_inf)\n             \
    \       data->cur_is_floating = 1; /* float */\n            }\n            min\
    \ += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX\
    \ - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n     \
    \           else\n                    delta = SSize_t_MAX;\n            }\n  \
    \          if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &accum);\n                if (min1)\
    \ {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n            \
    \    }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n  \
    \              if (min1) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n\
    \                }\n                else {\n                    /* Switch to OR\
    \ mode: cache the old value of\n                     * data->start_class */\n\t\
    \t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp,\
    \ regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n         \
    \           StructCopy(&accum, data->start_class, regnode_ssc);\n            \
    \        flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n     \
    \       scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)]\
    \ == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[\
    \ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta\
    \ += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n\
    \            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything...\
    \ */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t\
    \        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen\
    \ - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings\
    \ -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old\
    \ or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\
    \tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need\
    \ to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"\
    frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth,\
    \ flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n\
    \        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n\
    \        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last\
    \ = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto\
    \ fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\"\
    , data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ?\
    \ SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta\
    \ = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n\
    \    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags\
    \ &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\
    \tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n\
    \        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\"\
    , data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin\
    \ ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN))\
    \ {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen\
    \ = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n \
    \               RExC_maxlen = final_minlen + delta;\n        }\n        return\
    \ final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nSTATIC SSize_t\nS_study_chunk(pTHX_\
    \ RExC_state_t *pRExC_state, regnode **scanp,\n                        SSize_t\
    \ *minlenp, SSize_t *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\
    \t\t\tI32 stopparen,\n                        U32 recursed_depth,\n\t\t\tregnode_ssc\
    \ *and_withp,\n\t\t\tU32 flags, U32 depth, bool was_mutate_ok)\n\t\t\t/* scanp:\
    \ Start here (read-write). */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\
    \t\t\t/* last: Stop before this one. */\n\t\t\t/* data: string data about the\
    \ pattern */\n\t\t\t/* stopparen: treat close N as END */\n\t\t\t/* recursed:\
    \ which subroutines have we recursed into */\n\t\t\t/* and_withp: Valid if flags\
    \ & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n    /* There must be at least this number\
    \ of characters to match */\n    SSize_t min = 0;\n    I32 pars = 0, code;\n \
    \   regnode *scan = *scanp, *next;\n    SSize_t delta = 0;\n    int is_inf = (flags\
    \ & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n    int is_inf_internal = 0;\t\
    \t/* The studied chunk is infinite */\n    I32 is_par = OP(scan) == OPEN ? ARG(scan)\
    \ : 0;\n    scan_data_t data_fake;\n    SV *re_trie_maxbuff = NULL;\n    regnode\
    \ *first_non_open = scan;\n    SSize_t stopmin = SSize_t_MAX;\n    scan_frame\
    \ *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n\
    \    RExC_study_started= 1;\n\n    Zero(&data_fake, 1, scan_data_t);\n\n    if\
    \ ( depth == 0 ) {\n        while (first_non_open && OP(first_non_open) == OPEN)\n\
    \            first_non_open=regnext(first_non_open);\n    }\n\n\n  fake_study_recurse:\n\
    \    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n    );\n    DEBUG_OPTIMISE_MORE_r(\n\
    \    {\n        Perl_re_indentf( aTHX_  \"study_chunk stopparen=%ld recursed_count=%lu\
    \ depth=%lu recursed_depth=%lu scan=%p last=%p\",\n            depth, (long)stopparen,\n\
    \            (unsigned long)RExC_study_chunk_recursed_count,\n            (unsigned\
    \ long)depth, (unsigned long)recursed_depth,\n            scan,\n            last);\n\
    \        if (recursed_depth) {\n            U32 i;\n            U32 j;\n     \
    \       for ( j = 0 ; j < recursed_depth ; j++ ) {\n                for ( i =\
    \ 0 ; i < (U32)RExC_total_parens ; i++ ) {\n                    if (\n       \
    \                 PAREN_TEST(RExC_study_chunk_recursed +\n                   \
    \                ( j * RExC_study_chunk_recursed_bytes), i )\n               \
    \         && (\n                            !j ||\n                          \
    \  !PAREN_TEST(RExC_study_chunk_recursed +\n                                 \
    \  (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n                       \
    \ )\n                    ) {\n                        Perl_re_printf( aTHX_ \"\
    \ %d\",(int)i);\n                        break;\n                    }\n     \
    \           }\n                if ( j + 1 < recursed_depth ) {\n             \
    \       Perl_re_printf( aTHX_  \",\");\n                }\n            }\n   \
    \     }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n    while ( scan\
    \ && OP(scan) != END && scan < last ){\n        UV min_subtract = 0;    /* How\
    \ mmany chars to subtract from the minimum\n                                 \
    \  node length to get a real minimum (because\n                              \
    \     the folded version may be shorter) */\n\tbool unfolded_multi_char = FALSE;\n\
    \        /* avoid mutating ops if we are anywhere within the recursed or\n   \
    \      * enframed handling for a GOSUB: the outermost level will handle it.\n\
    \         */\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n\
    \t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n\
    \        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason\
    \ we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/\
    \ which cant be dealt with by the normal EXACT\n         * parsing code, as each\
    \ (?:..) is handled by a different invocation of\n         * reg() -- Yves\n \
    \        */\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract,\
    \ &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current\
    \ node and optimize\n           away all the NOTHINGs from it.\n         */\n\
    \        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot\
    \ be a switch, since we\n\t   look into several different things.  */\n      \
    \  if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n           \
    \ SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n         \
    \   I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan)\
    \ == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\
    \n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n\
    \            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n\
    \            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"\
    next\", next, depth, flags);\n\n            /* we suppose the run is continuous,\
    \ last=next...\n             * NOTE we dont use the return here! */\n        \
    \    /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state,\
    \ &scan, &minlen,\n                              &deltanext, next, &data_fake,\
    \ stopparen,\n                              recursed_depth, NULL, f, depth+1,\
    \ mutate_ok);\n\n            scan = next;\n        } else\n        if (\n    \
    \        OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n        \
    \    OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code\
    \ = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n\
    \             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\
    \n             * IFTHEN is special as it might not appear in pairs.\n        \
    \     * Not sure whether BRANCH-BRANCHJ is possible, regardless\n            \
    \ * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN)\
    \ {\n                /* NOTE - There is similar code to this block below for\n\
    \                 * handling TRIE nodes on a re-study.  If you change stuff here\n\
    \                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX,\
    \ num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n\
    \                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge\
    \ strings after this. */\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\
    \t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\
    \t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc\
    \ this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\
    \n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\
    \t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\
    \tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t\
    \    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything\
    \ */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\
    \t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\t\
    ssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\
    \t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\
    \t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous,\
    \ last=next...*/\n                    /* recurse study_chunk() for each BRANCH\
    \ in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n\
    \                                      &deltanext, next, &data_fake, stopparen,\n\
    \                                      recursed_depth, NULL, f, depth+1,\n   \
    \                                   mutate_ok);\n\n\t\t    if (min1 > minnext)\n\
    \t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf =\
    \ is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext\
    \ + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t\
    \    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t        \
    \    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin\
    \ > minnext)\n\t                    stopmin = min + min1;\n\t                flags\
    \ &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags\
    \ |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags\
    \ & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c\
    \ = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\t\
    ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code\
    \ == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta\
    \ >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\
    \t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 !=\
    \ min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\
    \t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\
    \t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif\
    \ (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class,\
    \ (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1)\
    \ {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\
    \t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\
    \t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n      \
    \              && OP(startbranch) == BRANCH\n                    && mutate_ok\n\
    \                ) {\n\t\t/* demq.\n\n                   Assuming this was/is\
    \ a branch we are dealing with: 'scan'\n                   now points at the item\
    \ that follows the branch sequence,\n                   whatever it is. We now\
    \ start at the beginning of the\n                   sequence and look for subsequences\
    \ of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n  \
    \                 which would be constructed from a pattern like\n           \
    \        /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need\
    \ to turn the first\n\t\t   element into a trie and then add the subsequent branch\
    \ exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n         \
    \            1. patterns where the whole set of branches can be\n            \
    \            converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\
    \n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for\
    \ the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\
    \t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE;\
    \ BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\
    \t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding\
    \ the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not\
    \ we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\
    \t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested\
    \ if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t  \
    \  if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME,\
    \ 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff,\
    \ RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0\
    \  ) {\n                        regnode *cur;\n                        regnode\
    \ *first = (regnode *)NULL;\n                        regnode *last = (regnode\
    \ *)NULL;\n                        regnode *tail = scan;\n                   \
    \     U8 trietype = 0;\n                        U32 count=0;\n\n             \
    \           /* var tail is used because there may be a TAIL\n                \
    \           regop in the way. Ie, the exacts will point to the\n             \
    \              thing following the TAIL, but the last branch will\n          \
    \                 point at the TAIL. So we advance tail. If we\n             \
    \              have nested (?:) we may have to move through several\n        \
    \                   tails.\n                         */\n\n                  \
    \      while ( OP( tail ) == TAIL ) {\n                            /* this is\
    \ the TAIL generated by (?:) */\n                            tail = regnext( tail\
    \ );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n\
    \                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n\
    \                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\"\
    ,\n                              depth+1,\n                              \"Looking\
    \ for TRIE'able sequences. Tail node is \",\n                              (UV)\
    \ REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv\
    \ )\n                            );\n                        });\n\n         \
    \               /*\n\n                            Step through the branches\n\
    \                                cur represents each branch,\n               \
    \                 noper is the first thing to be matched as part\n           \
    \                           of that branch\n                                noper_next\
    \ is the regnext() of that node.\n\n                            We normally handle\
    \ a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump\
    \ trie\" but we also\n                            support building with NOJUMPTRIE,\
    \ which restricts\n                            the trie logic to structures like\
    \ /FOO|BAR/.\n\n                            If noper is a trieable nodetype then\
    \ the branch is\n                            a possible optimization target. If\
    \ we are building\n                            under NOJUMPTRIE then we require\
    \ that noper_next is\n                            the same as scan (our current\
    \ position in the regex\n                            program).\n\n           \
    \                 Once we have two or more consecutive such branches\n       \
    \                     we can create a trie of the EXACT's contents and\n     \
    \                       stitch it in place into the program.\n\n             \
    \               If the sequence represents all of the branches in\n          \
    \                  the alternation we replace the entire thing with a\n      \
    \                      single TRIE node.\n\n                            Otherwise\
    \ when it is a subsequence we need to\n                            stitch it in\
    \ place and replace only the relevant\n                            branches. This\
    \ means the first branch has to remain\n                            as it is used\
    \ by the alternation logic, and its\n                            next pointer,\
    \ and needs to be repointed at the item\n                            on the branch\
    \ chain following the last branch we\n                            have optimized\
    \ away.\n\n                            This could be either a BRANCH, in which\
    \ case the\n                            subsequence is internal, or it could be\
    \ the item\n                            following the branch sequence in which\
    \ case the\n                            subsequence is at the end (which does\
    \ not\n                            necessarily mean the first node is the start\
    \ of the\n                            alternation).\n\n                      \
    \      TRIE_TYPE(X) is a define which maps the optype to a\n                 \
    \           trietype.\n\n                                optype          |  trietype\n\
    \                                ----------------+-----------\n              \
    \                  NOTHING         | NOTHING\n                               \
    \ EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n\
    \                                EXACTFU         | EXACTFU\n                 \
    \               EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP\
    \        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n\
    \                                EXACTL          | EXACTL\n                  \
    \              EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define\
    \ TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n   \
    \                    ? NOTHING                                            \\\n\
    \                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\
    \n                         ? EXACT                                           \
    \ \\\n                         : (     EXACTFU == (X)                        \
    \     \\\n                              || EXACTFU_ONLY8 == (X)              \
    \         \\\n                              || EXACTFUP == (X) )             \
    \             \\\n                           ? EXACTFU                       \
    \                 \\\n                           : ( EXACTFAA == (X) )       \
    \                     \\\n                             ? EXACTFAA            \
    \                         \\\n                             : ( EXACTL == (X) )\
    \                            \\\n                               ? EXACTL     \
    \                                \\\n                               : ( EXACTFLU8\
    \ == (X) )                       \\\n                                 ? EXACTFLU8\
    \                                \\\n                                 : 0 )\n\n\
    \                        /* dont use tail as the end marker for this traverse\
    \ */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext(\
    \ cur ) ) {\n                            regnode * const noper = NEXTOPER( cur\
    \ );\n                            U8 noper_type = OP( noper );\n             \
    \               U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING)\
    \ || defined(NOJUMPTRIE)\n                            regnode * const noper_next\
    \ = regnext( noper );\n                            U8 noper_next_type = (noper_next\
    \ && noper_next < tail) ? OP(noper_next) : 0;\n                            U8\
    \ noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type\
    \ ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n      \
    \                          regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n\
    \                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n \
    \                                  depth+1,\n                                \
    \   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n\
    \                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n\
    \                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n     \
    \                               REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\
    \n                                if ( noper_next ) {\n                      \
    \            regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n   \
    \                               Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n  \
    \                                  REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n\
    \                                }\n                                Perl_re_printf(\
    \ aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n      \
    \                             REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\
    \t\t\t\t);\n                            });\n\n                            /*\
    \ Is noper a trieable nodetype that can be merged\n                          \
    \   * with the current trie (if there is one)? */\n                          \
    \  if ( noper_trietype\n                                  &&\n               \
    \                   (\n                                        ( noper_trietype\
    \ == NOTHING )\n                                        || ( trietype == NOTHING\
    \ )\n                                        || ( trietype == noper_trietype )\n\
    \                                  )\n#ifdef NOJUMPTRIE\n                    \
    \              && noper_next >= tail\n#endif\n                               \
    \   && count < U16_MAX)\n                            {\n                     \
    \           /* Handle mergable triable node Either we are\n                  \
    \               * the first node in a new trieable sequence,\n               \
    \                  * in which case we do some bookkeeping,\n                 \
    \                * otherwise we update the end pointer. */\n                 \
    \               if ( !first ) {\n                                    first = cur;\n\
    \t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\
    \t\t\t\t\tregnode * const noper_next = regnext( noper );\n                   \
    \                     U8 noper_next_type = (noper_next && noper_next < tail) ?\
    \ OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE(\
    \ noper_next_type ) :0;\n#endif\n\n                                        if\
    \ ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n \
    \                                       } else if (noper_next_type)  {\n     \
    \                                       /* a NOTHING regop is 1 regop wide.\n\
    \                                             * We need at least two for a trie\n\
    \                                             * so we can't merge this in */\n\
    \                                            first = NULL;\n                 \
    \                       }\n                                    } else {\n    \
    \                                    trietype = noper_trietype;\n            \
    \                        }\n                                } else {\n       \
    \                             if ( trietype == NOTHING )\n                   \
    \                     trietype = noper_trietype;\n                           \
    \         last = cur;\n                                }\n\t\t\t\tif (first)\n\
    \t\t\t\t    count++;\n                            } /* end handle mergable triable\
    \ node */\n                            else {\n                              \
    \  /* handle unmergable node -\n                                 * noper may either\
    \ be a triable node which can\n                                 * not be tried\
    \ together with the current trie,\n                                 * or a non\
    \ triable node */\n                                if ( last ) {\n           \
    \                         /* If last is set and trietype is not\n            \
    \                         * NOTHING then we have found at least two\n        \
    \                             * triable branch sequences in a row of a\n     \
    \                                * similar trietype so we can turn them\n    \
    \                                 * into a trie. If/when we allow NOTHING to\n\
    \                                     * start a trie sequence this condition\n\
    \                                     * will be required, and it isn't expensive\n\
    \                                     * so we leave it in for now. */\n      \
    \                              if ( trietype && trietype != NOTHING )\n      \
    \                                  make_trie( pRExC_state,\n                 \
    \                               startbranch, first, cur, tail,\n             \
    \                                   count, trietype, depth+1 );\n            \
    \                        last = NULL; /* note: we clear/update\n             \
    \                                       first, trietype etc below,\n         \
    \                                           so we dont do it here */\n       \
    \                         }\n                                if ( noper_trietype\n\
    #ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n\
    #endif\n                                ){\n                                 \
    \   /* noper is triable, so we can start a new\n                             \
    \        * trie sequence */\n                                    count = 1;\n\
    \                                    first = cur;\n                          \
    \          trietype = noper_trietype;\n                                } else\
    \ if (first) {\n                                    /* if we already saw a first\
    \ but the\n                                     * current node is not triable\
    \ then we have\n                                     * to reset the first information.\
    \ */\n                                    count = 0;\n                       \
    \             first = NULL;\n                                    trietype = 0;\n\
    \                                }\n                            } /* end handle\
    \ unmergable node */\n                        } /* loop over branches */\n   \
    \                     DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx,\
    \ RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf(\
    \ aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1,\
    \ SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                       \
    \     Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n\
    \                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \                               PL_reg_name[trietype]\n                      \
    \      );\n\n                        });\n                        if ( last &&\
    \ trietype ) {\n                            if ( trietype != NOTHING ) {\n   \
    \                             /* the last branch of the sequence was part of\n\
    \                                 * a trie, so we have to construct it here\n\
    \                                 * outside of the loop */\n                 \
    \               made= make_trie( pRExC_state, startbranch,\n                 \
    \                                first, scan, tail, count,\n                 \
    \                                trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n\
    \                                if ( ((made == MADE_EXACT_TRIE &&\n         \
    \                            startbranch == first)\n                         \
    \            || ( first_non_open == first )) &&\n                            \
    \         depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n\
    \                                    if ( startbranch == first\n             \
    \                            && scan >= tail )\n                             \
    \       {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n\
    \                                    }\n                                }\n#endif\n\
    \                            } else {\n                                /* at this\
    \ point we know whatever we have is a\n                                 * NOTHING\
    \ sequence/branch AND if 'startbranch'\n                                 * is\
    \ 'first' then we can turn the whole thing\n                                 *\
    \ into a NOTHING\n                                 */\n                      \
    \          if ( startbranch == first ) {\n                                   \
    \ regnode *opt;\n                                    /* the entire thing is a\
    \ NOTHING sequence,\n                                     * something like this:\
    \ (?:|) So we can\n                                     * turn it into a plain\
    \ NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n\
    \                                        regprop(RExC_rx, RExC_mysv, cur, NULL,\
    \ pRExC_state);\n                                        Perl_re_indentf( aTHX_\
    \  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                             \
    \             depth+1,\n                                          SvPV_nolen_const(\
    \ RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n\
    \                                    OP(startbranch)= NOTHING;\n             \
    \                       NEXT_OFF(startbranch)= tail - startbranch;\n         \
    \                           for ( opt= startbranch + 1; opt < tail ; opt++ )\n\
    \                                        OP(opt)= OPTIMIZED;\n               \
    \                 }\n                            }\n                        }\
    \ /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n\
    \                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ )\
    \ {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\
    \t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\
    \t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB)\
    \ {\n            I32 paren = 0;\n            regnode *start = NULL;\n        \
    \    regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\
    \n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup,\
    \ note this code has side effects beyond\n                 * the rest of this\
    \ block. Specifically setting\n                 * RExC_recurse[] must happen at\
    \ least once during\n                 * study_chunk(). */\n                paren\
    \ = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n          \
    \      start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\
    \n                /* NOTE we MUST always execute the above code, even\n      \
    \           * if we do nothing with a GOSUB */\n                if (\n       \
    \             ( flags & SCF_IN_DEFINE )\n                    ||\n            \
    \        (\n                        (is_inf_internal || is_inf || (data && data->flags\
    \ & SF_IS_INF))\n                        &&\n                        ( (flags\
    \ & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n        \
    \        ) {\n                    /* no need to do anything here if we are in\
    \ a define. */\n                    /* or we are after some kind of infinite construct\n\
    \                     * so we can skip recursing into this item.\n           \
    \          * Since it is infinite we will not change the maxlen\n            \
    \         * or delta, and if we miss something that might raise\n            \
    \         * the minlen it will merely pessimise a little.\n                  \
    \   *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n   \
    \                  * might result in a minlen of 1 and not of 4,\n           \
    \          * but this doesn't make us mismatch, just try a bit\n             \
    \        * harder than we should.\n                     * */\n               \
    \     scan= regnext(scan);\n                    continue;\n                }\n\
    \n                if (\n                    !recursed_depth\n                \
    \    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1)\
    \ * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n          \
    \          /* it is quite possible that there are more efficient ways\n      \
    \               * to do this. We maintain a bitmap per level of recursion\n  \
    \                   * of which patterns we have entered so we can detect if a\n\
    \                     * pattern creates a possible infinite loop. When we\n  \
    \                   * recurse down a level we copy the previous levels bitmap\n\
    \                     * down. When we are at recursion level 0 we zero the top\n\
    \                     * level bitmap. It would be nice to implement a different\n\
    \                     * more efficient way of doing this. In particular the top\n\
    \                     * level bitmap may be unnecessary.\n                   \
    \  */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed,\
    \ RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n      \
    \                  Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed_bytes, U8);\n        \
    \            }\n                    /* we havent recursed into this paren yet,\
    \ so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data,\
    \ depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth\
    \ * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth=\
    \ recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"\
    gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite\
    \ recursion, assume infinite length\n                     * */\n             \
    \       if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n\
    \                    }\n                    is_inf = is_inf_internal = 1;\n  \
    \                  if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n   \
    \                     ssc_anything(data->start_class);\n                    flags\
    \ &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we\
    \ dont recurse later on. */\n\t        }\n            } else {\n\t        paren\
    \ = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\
    \t    }\n            if (start) {\n                scan_frame *newframe;\n   \
    \             assert(end);\n                if (!RExC_frame_last) {\n        \
    \            Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames,\
    \ newframe);\n                    RExC_frame_head= newframe;\n               \
    \     RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame)\
    \ {\n                    Newxz(newframe, 1, scan_frame);\n                   \
    \ RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame=\
    \ RExC_frame_last;\n                    RExC_frame_count++;\n                }\
    \ else {\n                    newframe= RExC_frame_last->next_frame;\n       \
    \         }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode\
    \ = regnext(scan);\n                newframe->last_regnode = last;\n         \
    \       newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth\
    \ = recursed_depth;\n                newframe->this_prev_frame= frame;\n     \
    \           newframe->in_gosub = (\n                    (frame && frame->in_gosub)\
    \ || OP(scan) == GOSUB\n                );\n\n                DEBUG_STUDYDATA(\"\
    frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan,\
    \ depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t\
    \        stopparen = paren;\n\t        last = end;\n                depth = depth\
    \ + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\
    \t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) ==\
    \ EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t\
    \ l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\
    \t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s +\
    \ l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\
    \t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest\
    \ substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset,\
    \ later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update\
    \ the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t   \
    \ data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\
    \t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\
    \t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\
    \t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8)\
    \ : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n\
    \                                              (U8*)STRING(scan)+STR_LEN(scan));\n\
    \t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As\
    \ in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n    \
    \        /* ANDing the code point leaves at most it, and not in locale, and\n\
    \             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND)\
    \ {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class)\
    \ &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\
    \t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class,\
    \ uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)]\
    \ == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t\
    \ l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /*\
    \ Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\
    \t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\
    \t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n    \
    \        delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min\
    \ += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min\
    \ = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\
    \tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\
    \t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist\
    \ = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n\
    \                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan)\
    \ != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n\
    \                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                    ANYOF_POSIXL_ZERO(data->start_class);\n                 \
    \   ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n            \
    \    }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class,\
    \ EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a\
    \ */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n                flags &= ~SCF_DO_STCLASS;\n              \
    \  SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan)))\
    \ {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t\
    \    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc\
    \ this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\
    \n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)*\
    \ . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif\
    \ (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\
    \t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n\
    \                        || OP(next) == EXACTL\n                        || (flags\
    \ & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount\
    \ = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\
    \tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\
    \t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\
    \n                /* This temporary node can now be turned into EXACTFU, and\n\
    \                 * must, as regexec.c doesn't handle it */\n                if\
    \ (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n                    OP(next) =\
    \ EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n\
    \                    &&   isALPHA_A(* STRING(next))\n                    && (\
    \         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n\
    \                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n\
    \                    &&   mutate_ok\n                ) {\n                   \
    \ /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\
    \n                    assert(isALPHA_A(* STRING(next)));\n\n                 \
    \   /* Then replace it by an ANYOFM node, with\n                    * the mask\
    \ set to the complement of the\n                    * bit that differs between\
    \ upper and lower\n                    * case, and the lowest code point of the\n\
    \                    * pair (which the '&' forces) */\n                    OP(next)\
    \ = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n      \
    \              FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\
    \t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t   \
    \ data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal\
    \ = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\
    \t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\
    \t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\
    \t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount\
    \ = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX)\
    \ {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags\
    \ = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan)\
    \ + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\
    \t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n   \
    \                     scan_commit(pRExC_state, data, minlenp, is_inf);\n     \
    \               /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\
    \t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\
    \t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\
    \t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\
    \t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear\
    \ cache processing any {n,m}\n\t\t   regops for which the combination of input\
    \ pos and regex\n\t\t   pos is not enough information to determine if a match\n\
    \t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/\
    \ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\
    \t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats\
    \ into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount >\
    \ 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t\
    /* This will finish on WHILEM, setting scan, or on NULL: */\n                /*\
    \ recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state,\
    \ &scan, minlenp, &deltanext,\n                                  last, data, stopparen,\
    \ recursed_depth, NULL,\n                                  (mincount == 0\n  \
    \                                 ? (f & ~SCF_DO_SUBSTR)\n                   \
    \                : f)\n                                  , depth+1, mutate_ok);\n\
    \n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif\
    \ (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\
    \t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |=\
    \ SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\
    \t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan =\
    \ next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\
    \t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval\
    \ || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext\
    \ == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n        \
    \            && maxcount <= REG_INFTY/3) /* Complement check for big\n       \
    \                                            count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end,\
    \ packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n\
    \                            \"Quantifier unexpected on zero-length expression\
    \ \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF,\
    \ RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n             \
    \   }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext\
    \ )\n                    || min >= SSize_t_MAX - minnext * mincount )\n      \
    \          {\n                    FAIL(\"Regexp out of space\");\n           \
    \     }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext ==\
    \ SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext +\
    \ deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf)\
    \ {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta +=\
    \ (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n\
    \                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\t\
    if (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t\
    \      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext ==\
    \ 1\n                      && mutate_ok\n                ) {\n\t\t    /* Try to\
    \ optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\
    \t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n\
    #endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\
    \t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\
    \t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\
    \t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens)\
    \ {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n     \
    \                   RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\
    \t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags\
    \ = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t\
    /* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was\
    \ count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t\
    \    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count.\
    \ */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t\
    }\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan)\
    \ == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags\
    \ & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t   \
    \   && minnext != 0\t/* CURLYM can't handle zero width */\n                  \
    \       /* Nor characters whose fold at run-time may be\n                    \
    \      * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\
    \                      && mutate_ok\n\t\t) {\n\t\t    /* XXXX How to optimize\
    \ if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode\
    \ *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\
    \n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over\
    \ embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t\
    \    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away\
    \ parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\
    \t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) +\
    \ EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif\
    \ (RExC_open_parens) {\n                             /*open->CURLYM*/\n      \
    \                      RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n\
    \                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(nxt2)\n                                                   \
    \      + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED;\
    \ /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1\
    \ + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just\
    \ for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM))\
    \ {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\
    \t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\
    \t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\
    \t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t  \
    \  }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n \
    \                       /* recurse study_chunk() on optimised CURLYX => CURLYM\
    \ */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n      \
    \                              NULL, stopparen, recursed_depth, NULL, 0,\n   \
    \                                 depth+1, mutate_ok);\n\t\t    }\n\t\t    else\n\
    \t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t &&\
    \ (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression\
    \ above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we\
    \ care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\
    \t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair.\
    \ */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan\
    \ + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\
    \t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n           \
    \         if (nxt->flags & 0xf) {\n                        /* we've already set\
    \ whilem count on this node */\n                    } else if (++data->whilem_c\
    \ < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n\
    \                        nxt->flags = (U8)(data->whilem_c\n                  \
    \          | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\
    \t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN\
    \ last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                   \
    \ if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                \
    \                                                  string. */\n\t\t\tSSize_t b\
    \ = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\
    \t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\
    \t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old\
    \ >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n  \
    \                                             (U8 *) SvEND(data->last_found))\n\
    \                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the\
    \ added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n      \
    \                  last_chrs = UTF ? utf8_length((U8*)(s + old),\n           \
    \                                 (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext\
    \ == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string\
    \ */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l)\
    \ + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str),\
    \ l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str,\
    \ SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\t\
    SvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\
    \tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\
    \t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv,\
    \ PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\t\
    mg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                         \
    \       last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\
    \t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last\
    \ copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t\
    \    data->last_start_max =\n                              is_inf\n          \
    \                     ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n \
    \                                (maxcount - 1) * (minnext + data->pos_delta);\n\
    \t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min\
    \ += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\"\
    \ UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\"\
    \ UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf\
    \ \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX,\
    \ (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\n\
    Perl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted\
    \ * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount),\
    \ (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n\
    \                        || -counted * deltanext + (minnext + deltanext) * maxcount\
    \ - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta\
    \ = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext\
    \ +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if\
    \ (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\
    \t\t\t    the group.  */\n                        scan_commit(pRExC_state, data,\
    \ minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv\
    \ = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv)\
    \ ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\
    \tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end\
    \ = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\
    \t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min\
    \ + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /*\
    \ float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data &&\
    \ (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\
    \t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n\
    \                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\"\
    ,\n                                                                    OP(scan));\n\
    #endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR)\
    \ {\n                    /* Cannot expect anything... */\n                   \
    \ scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags &\
    \ SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n       \
    \                 /* Actually is any start char, but very few code points\n  \
    \                       * aren't start characters */\n                       \
    \ ssc_match_all_cp(data->start_class);\n                    }\n              \
    \      else {\n                        ssc_anything(data->start_class);\n    \
    \                }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\
    \t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS)\
    \ {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n\
    \                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n\
    \                    ssc_clear_locale(data->start_class);\n                  \
    \  ANYOF_FLAGS(data->start_class)\n                                          \
    \      &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else\
    \ if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n\
    \                              PL_XPosix_ptrs[_CC_VERTSPACE],\n              \
    \                FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n\n                    /* See commit msg for\n              \
    \       * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n\
    \                                                &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n\
    \            if (delta != SSize_t_MAX)\n                delta++;    /* Because\
    \ of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n  \
    \              /* Cannot expect anything... */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n               \
    \ if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta +=\
    \ 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t  \
    \  }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\
    \t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool\
    \ invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will\
    \ only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef\
    \ DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx\
    \ opcode %d\",\n                                                             \
    \        OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t   \
    \ break;\n\n\t\tcase REG_ANY:\n                    {\n                       \
    \ SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist\
    \ = add_cp_to_invlist(REG_ANY_invlist,\n                                     \
    \                       '\\n');\n                        if (flags & SCF_DO_STCLASS_OR)\
    \ {\n                            ssc_union(data->start_class,\n              \
    \                        REG_ANY_invlist,\n                                  \
    \    TRUE /* TRUE => invert, hence all but \\n\n                             \
    \               */\n                                      );\n               \
    \         }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n\
    \                            ssc_intersection(data->start_class,\n           \
    \                                  REG_ANY_invlist,\n                        \
    \                     TRUE  /* TRUE => invert */\n                           \
    \                  );\n                            ssc_clear_locale(data->start_class);\n\
    \                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\
    \t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case\
    \ ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n \
    \               case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class,\n                                (regnode_charclass *) scan);\n\
    \t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                 \
    \                                         (regnode_charclass *) scan);\n\t\t \
    \   break;\n\n                case NANYOFM:\n                case ANYOFM:\n  \
    \                {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\
    \n                    if (flags & SCF_DO_STCLASS_OR) {\n                     \
    \   ssc_union(data->start_class, cp_list, invert);\n                    }\n  \
    \                  else if (flags & SCF_DO_STCLASS_AND) {\n                  \
    \      ssc_intersection(data->start_class, cp_list, invert);\n               \
    \     }\n\n                    SvREFCNT_dec_NN(cp_list);\n                   \
    \ break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n          \
    \          namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n      \
    \              if (flags & SCF_DO_STCLASS_AND) {\n                        bool\
    \ was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n\
    \                                                                 namedclass));\n\
    \                        ANYOF_POSIXL_ZERO(data->start_class);\n             \
    \           if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class,\
    \ namedclass);\n                        }\n                        /* No individual\
    \ code points can now match */\n                        data->start_class->invlist\n\
    \                                                = sv_2mortal(_new_invlist(0));\n\
    \                    }\n                    else {\n                        int\
    \ complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this\
    \ class was already there,\n                         * the result is that they\
    \ match all code points,\n                         * (\\d + \\D == everything).\
    \  Remove the classes from\n                         * future consideration. \
    \ Locale is not relevant in\n                         * this case */\n       \
    \                 if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n  \
    \                          ssc_match_all_cp(data->start_class);\n            \
    \                ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n        \
    \                    ANYOF_POSIXL_CLEAR(data->start_class, complement);\n    \
    \                    }\n                        else {  /* The usual case; just\
    \ add this class to the\n                                   existing set */\n\
    \                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n\
    \                        }\n                    }\n                    break;\n\
    \n                case NPOSIXA:   /* For these, we always know the exact set of\n\
    \                                   what's matched */\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n            \
    \        my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n     \
    \               goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n\
    \                    invert = 1;\n                    /* FALLTHROUGH */\n\t\t\
    case POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)],\
    \ NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points\
    \ unless the\n                     * target string being matched is UTF-8, which\
    \ is\n                     * unknowable until match time.  Since we are going\
    \ to\n                     * invert, we want to get rid of all of them so that\
    \ the\n                     * inversion will match all */\n                  \
    \  if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist,\
    \ PL_UpperLatin1,\n                                          &my_invlist);\n \
    \                   }\n\n                  join_posix_and_ascii:\n\n         \
    \           if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class,\
    \ my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n\
    \                    }\n                    else {\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class,\
    \ my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\
    \t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t\
    }\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags\
    \ |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n\
    \            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if\
    \ (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate\
    \ parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\
    \t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n         \
    \   if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) ==\
    \ UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n\
    \                   In this case we can't do fixed string optimisation.\n    \
    \            */\n\n                SSize_t deltanext, minnext, fake = 0;\n   \
    \             regnode *nscan;\n                regnode_ssc intrnl;\n         \
    \       int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n                if (data) {\n                    data_fake.whilem_c\
    \ = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\
    \t\t}\n                else\n                    data_fake.last_closep = &fake;\n\
    \t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS\
    \ && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead\
    \ */\n                    ssc_init(pRExC_state, &intrnl);\n                  \
    \  data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\
    \t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                 \
    \   f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n    \
    \            nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk()\
    \ for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan,\
    \ minlenp, &deltanext,\n                                      last, &data_fake,\
    \ stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n\
    \                                      mutate_ok);\n                if (scan->flags)\
    \ {\n                    if (   deltanext < 0\n                        || deltanext\
    \ > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n         \
    \               || minnext + deltanext > (I32)U8_MAX)\n                    {\n\
    \t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n        \
    \                      (UV)U8_MAX);\n                    }\n\n               \
    \     /* The 'next_off' field has been repurposed to count the\n             \
    \        * additional starting positions to try beyond the initial\n         \
    \            * one.  (This leaves it at 0 for non-variable length\n          \
    \           * matches to avoid breakage for those not using this\n           \
    \          * extension) */\n                    if (deltanext) {\n           \
    \             scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n\
    \                            WARN_EXPERIMENTAL__VLB,\n                       \
    \     \"Variable length lookbehind is experimental\");\n                    }\n\
    \                    scan->flags = (U8)minnext + deltanext;\n                }\n\
    \                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\
    \                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND)\
    \ {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after:\
    \ ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by\
    \ study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t\
    \ * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl\
    \ #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t \
    \   }  else {\n                        /* AND before and after: combine and continue.\
    \  These\n                         * assertions are zero-length, so can match\
    \ an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                   |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n\
    \            else {\n                /* Positive Lookahead/lookbehind\n      \
    \             In this case we can do fixed string optimisation,\n            \
    \       but we must be careful about it. Note in the case of\n               \
    \    lookbehind the positions will be offset by the minimum\n                \
    \   length of the pattern, something we won't know about\n                   until\
    \ after the recurse.\n                */\n                SSize_t deltanext, fake\
    \ = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n\
    \                int f = 0;\n                /* We use SAVEFREEPV so that when\
    \ the full compile\n                    is finished perl will clean up the allocated\n\
    \                    minlens when it's all done. This way we don't\n         \
    \           have to worry about freeing them when we know\n                  \
    \  they wont be used, which would be a pain.\n                 */\n          \
    \      SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n   \
    \             SAVEFREEPV(minnextp);\n\n                if (data) {\n         \
    \           StructCopy(data, &data_fake, scan_data_t);\n                    if\
    \ ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |=\
    \ SCF_DO_SUBSTR;\n                        if (scan->flags)\n                 \
    \           scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n         \
    \               data_fake.last_found=newSVsv(data->last_found);\n            \
    \        }\n                }\n                else\n                    data_fake.last_closep\
    \ = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags\
    \ = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta\
    \ = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n\
    \                if ( flags & SCF_DO_STCLASS && !scan->flags\n               \
    \      && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state,\
    \ &intrnl);\n                    data_fake.start_class = &intrnl;\n          \
    \          f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags\
    \ & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n\
    \                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\
    \n                /* positive lookahead study_chunk() recursion */\n         \
    \       *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n             \
    \                           &deltanext, last, &data_fake,\n                  \
    \                      stopparen, recursed_depth, NULL,\n                    \
    \                    f, depth+1, mutate_ok);\n                if (scan->flags)\
    \ {\n                    assert(0);  /* This code has never been tested since\
    \ this\n                                   is normally not compiled */\n     \
    \               if (   deltanext < 0\n                        || deltanext > (I32)\
    \ U8_MAX\n                        || *minnextp > (I32)U8_MAX\n               \
    \         || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\
    \tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n            \
    \                  (UV)U8_MAX);\n                    }\n\n                   \
    \ if (deltanext) {\n                        scan->next_off = deltanext;\n    \
    \                }\n                    scan->flags = (U8)*minnextp + deltanext;\n\
    \                }\n\n                *minnextp += min;\n\n                if\
    \ (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class)\
    \ |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n\
    \                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n         \
    \               pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found)\
    \ {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n\
    \                            RExC_rx->minlen=*minnextp;\n                    \
    \    scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n               \
    \         SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for\
    \ (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp\
    \ != minlenp) {\n                                data->substrs[i].min_offset =\n\
    \                                            data_fake.substrs[i].min_offset;\n\
    \                                data->substrs[i].max_offset =\n             \
    \                               data_fake.substrs[i].max_offset;\n           \
    \                     data->substrs[i].minlenp =\n                           \
    \                 data_fake.substrs[i].minlenp;\n                            \
    \    data->substrs[i].lookbehind += scan->flags;\n                           \
    \ }\n                        }\n                    }\n                }\n\t \
    \   }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\
    \t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen ==\
    \ (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par)\
    \ {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next\
    \ < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if\
    \ (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL)\
    \ {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)]\
    \ == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data\
    \ && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t      \
    \  if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan)\
    \ == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf\
    \ = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything\
    \ */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT)\
    \ &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n  \
    \              if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n\
    \                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs\
    \ < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n       \
    \         RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs\
    \ = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n  \
    \      else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is\
    \ similar code to this block above for handling\n               BRANCH nodes on\
    \ the initial study.  If you change stuff here\n               check there too.\
    \ */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n\
    \            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan)\
    \ ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc\
    \ accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n\
    \                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n\
    \                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump)\
    \ {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n\
    \            } else {\n                const regnode *nextbranch= NULL;\n    \
    \            U32 word;\n\n                for ( word=1 ; word <= trie->wordcount\
    \ ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0,\
    \ f = 0, fake;\n                    regnode_ssc this_class;\n\n              \
    \      StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n               \
    \     if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n\
    \                        data_fake.last_closep = data->last_closep;\n        \
    \            }\n                    else\n                        data_fake.last_closep\
    \ = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags\
    \ & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n\
    \                        data_fake.start_class = &this_class;\n              \
    \          f = SCF_DO_STCLASS_AND;\n                    }\n                  \
    \  if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\
    \n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n\
    \                            nextbranch = trie_node + trie->jump[0];\n       \
    \                 scan= trie_node + trie->jump[word];\n                      \
    \  /* We go from the jump point to the branch that follows\n                 \
    \          it. Note this means we need the vestigal unused\n                 \
    \          branches even though they arent otherwise used. */\n              \
    \          /* optimise study_chunk() for TRIE */\n                        minnext\
    \ = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext,\
    \ (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth,\
    \ NULL, f, depth+1,\n                            mutate_ok);\n               \
    \     }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n\
    \                        nextbranch= regnext((regnode*)nextbranch);\n\n      \
    \              if (min1 > (SSize_t)(minnext + trie->minlen))\n               \
    \         min1 = minnext + trie->minlen;\n                    if (deltanext ==\
    \ SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n    \
    \                    max1 = SSize_t_MAX;\n                    } else if (max1\
    \ < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1\
    \ = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags\
    \ & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n               \
    \     if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin\
    \ > min + min1)\n\t                    stopmin = min + min1;\n\t             \
    \   flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                \
    \    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if\
    \ (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n     \
    \                       data->flags |= SF_HAS_EVAL;\n                        data->whilem_c\
    \ = data_fake.whilem_c;\n                    }\n                    if (flags\
    \ & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass\
    \ *) &this_class);\n                }\n            }\n            if (flags &\
    \ SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta\
    \ += max1 - min1;\n                if (max1 != min1 || is_inf)\n             \
    \       data->cur_is_floating = 1; /* float */\n            }\n            min\
    \ += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX\
    \ - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n     \
    \           else\n                    delta = SSize_t_MAX;\n            }\n  \
    \          if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &accum);\n                if (min1)\
    \ {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n            \
    \    }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n  \
    \              if (min1) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n\
    \                }\n                else {\n                    /* Switch to OR\
    \ mode: cache the old value of\n                     * data->start_class */\n\t\
    \t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp,\
    \ regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n         \
    \           StructCopy(&accum, data->start_class, regnode_ssc);\n            \
    \        flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n     \
    \       scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)]\
    \ == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[\
    \ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta\
    \ += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n\
    \            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything...\
    \ */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t\
    \        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen\
    \ - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings\
    \ -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old\
    \ or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\
    \tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need\
    \ to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"\
    frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth,\
    \ flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n\
    \        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n\
    \        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last\
    \ = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto\
    \ fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\"\
    , data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ?\
    \ SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta\
    \ = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n\
    \    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags\
    \ &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\
    \tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n\
    \        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\"\
    , data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin\
    \ ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN))\
    \ {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen\
    \ = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n \
    \               RExC_maxlen = final_minlen + delta;\n        }\n        return\
    \ final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nSTATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t *pRExC_state, regnode\
    \ **scanp,\n                        SSize_t *minlenp, SSize_t *deltap,\n\t\t\t\
    regnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n             \
    \           U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\t\tU32 flags,\
    \ U32 depth, bool was_mutate_ok)\n\t\t\t/* scanp: Start here (read-write). */\n\
    \t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before this\
    \ one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen:\
    \ treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed\
    \ into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n\
    \    /* There must be at least this number of characters to match */\n    SSize_t\
    \ min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t\
    \ delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n\
    \    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32\
    \ is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n   \
    \ SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t\
    \ stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\
    \n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake,\
    \ 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open &&\
    \ OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n\
    \    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n\
    \    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"\
    study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p\
    \ last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n\
    \            (unsigned long)depth, (unsigned long)recursed_depth,\n          \
    \  scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n\
    \            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n\
    \                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n        \
    \            if (\n                        PAREN_TEST(RExC_study_chunk_recursed\
    \ +\n                                   ( j * RExC_study_chunk_recursed_bytes),\
    \ i )\n                        && (\n                            !j ||\n     \
    \                       !PAREN_TEST(RExC_study_chunk_recursed +\n            \
    \                       (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n  \
    \                      )\n                    ) {\n                        Perl_re_printf(\
    \ aTHX_ \" %d\",(int)i);\n                        break;\n                   \
    \ }\n                }\n                if ( j + 1 < recursed_depth ) {\n    \
    \                Perl_re_printf( aTHX_  \",\");\n                }\n         \
    \   }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n   \
    \ while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract =\
    \ 0;    /* How mmany chars to subtract from the minimum\n                    \
    \               node length to get a real minimum (because\n                 \
    \                  the folded version may be shorter) */\n\tbool unfolded_multi_char\
    \ = FALSE;\n        /* avoid mutating ops if we are anywhere within the recursed\
    \ or\n         * enframed handling for a GOSUB: the outermost level will handle\
    \ it.\n         */\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n\
    \t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n\
    \        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason\
    \ we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/\
    \ which cant be dealt with by the normal EXACT\n         * parsing code, as each\
    \ (?:..) is handled by a different invocation of\n         * reg() -- Yves\n \
    \        */\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract,\
    \ &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current\
    \ node and optimize\n           away all the NOTHINGs from it.\n         */\n\
    \        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot\
    \ be a switch, since we\n\t   look into several different things.  */\n      \
    \  if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n           \
    \ SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n         \
    \   I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan)\
    \ == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\
    \n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n\
    \            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n\
    \            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"\
    next\", next, depth, flags);\n\n            /* we suppose the run is continuous,\
    \ last=next...\n             * NOTE we dont use the return here! */\n        \
    \    /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state,\
    \ &scan, &minlen,\n                              &deltanext, next, &data_fake,\
    \ stopparen,\n                              recursed_depth, NULL, f, depth+1,\
    \ mutate_ok);\n\n            scan = next;\n        } else\n        if (\n    \
    \        OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n        \
    \    OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code\
    \ = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n\
    \             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\
    \n             * IFTHEN is special as it might not appear in pairs.\n        \
    \     * Not sure whether BRANCH-BRANCHJ is possible, regardless\n            \
    \ * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN)\
    \ {\n                /* NOTE - There is similar code to this block below for\n\
    \                 * handling TRIE nodes on a re-study.  If you change stuff here\n\
    \                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX,\
    \ num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n\
    \                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge\
    \ strings after this. */\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\
    \t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\
    \t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc\
    \ this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\
    \n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\
    \t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\
    \tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t\
    \    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything\
    \ */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\
    \t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\t\
    ssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\
    \t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\
    \t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous,\
    \ last=next...*/\n                    /* recurse study_chunk() for each BRANCH\
    \ in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n\
    \                                      &deltanext, next, &data_fake, stopparen,\n\
    \                                      recursed_depth, NULL, f, depth+1,\n   \
    \                                   mutate_ok);\n\n\t\t    if (min1 > minnext)\n\
    \t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf =\
    \ is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext\
    \ + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t\
    \    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t        \
    \    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin\
    \ > minnext)\n\t                    stopmin = min + min1;\n\t                flags\
    \ &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags\
    \ |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags\
    \ & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c\
    \ = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\t\
    ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code\
    \ == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta\
    \ >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\
    \t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 !=\
    \ min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\
    \t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\
    \t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif\
    \ (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class,\
    \ (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1)\
    \ {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\
    \t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\
    \t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n      \
    \              && OP(startbranch) == BRANCH\n                    && mutate_ok\n\
    \                ) {\n\t\t/* demq.\n\n                   Assuming this was/is\
    \ a branch we are dealing with: 'scan'\n                   now points at the item\
    \ that follows the branch sequence,\n                   whatever it is. We now\
    \ start at the beginning of the\n                   sequence and look for subsequences\
    \ of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n  \
    \                 which would be constructed from a pattern like\n           \
    \        /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need\
    \ to turn the first\n\t\t   element into a trie and then add the subsequent branch\
    \ exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n         \
    \            1. patterns where the whole set of branches can be\n            \
    \            converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\
    \n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for\
    \ the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\
    \t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE;\
    \ BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\
    \t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding\
    \ the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not\
    \ we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\
    \t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested\
    \ if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t  \
    \  if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME,\
    \ 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff,\
    \ RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0\
    \  ) {\n                        regnode *cur;\n                        regnode\
    \ *first = (regnode *)NULL;\n                        regnode *last = (regnode\
    \ *)NULL;\n                        regnode *tail = scan;\n                   \
    \     U8 trietype = 0;\n                        U32 count=0;\n\n             \
    \           /* var tail is used because there may be a TAIL\n                \
    \           regop in the way. Ie, the exacts will point to the\n             \
    \              thing following the TAIL, but the last branch will\n          \
    \                 point at the TAIL. So we advance tail. If we\n             \
    \              have nested (?:) we may have to move through several\n        \
    \                   tails.\n                         */\n\n                  \
    \      while ( OP( tail ) == TAIL ) {\n                            /* this is\
    \ the TAIL generated by (?:) */\n                            tail = regnext( tail\
    \ );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n\
    \                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n\
    \                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\"\
    ,\n                              depth+1,\n                              \"Looking\
    \ for TRIE'able sequences. Tail node is \",\n                              (UV)\
    \ REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv\
    \ )\n                            );\n                        });\n\n         \
    \               /*\n\n                            Step through the branches\n\
    \                                cur represents each branch,\n               \
    \                 noper is the first thing to be matched as part\n           \
    \                           of that branch\n                                noper_next\
    \ is the regnext() of that node.\n\n                            We normally handle\
    \ a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump\
    \ trie\" but we also\n                            support building with NOJUMPTRIE,\
    \ which restricts\n                            the trie logic to structures like\
    \ /FOO|BAR/.\n\n                            If noper is a trieable nodetype then\
    \ the branch is\n                            a possible optimization target. If\
    \ we are building\n                            under NOJUMPTRIE then we require\
    \ that noper_next is\n                            the same as scan (our current\
    \ position in the regex\n                            program).\n\n           \
    \                 Once we have two or more consecutive such branches\n       \
    \                     we can create a trie of the EXACT's contents and\n     \
    \                       stitch it in place into the program.\n\n             \
    \               If the sequence represents all of the branches in\n          \
    \                  the alternation we replace the entire thing with a\n      \
    \                      single TRIE node.\n\n                            Otherwise\
    \ when it is a subsequence we need to\n                            stitch it in\
    \ place and replace only the relevant\n                            branches. This\
    \ means the first branch has to remain\n                            as it is used\
    \ by the alternation logic, and its\n                            next pointer,\
    \ and needs to be repointed at the item\n                            on the branch\
    \ chain following the last branch we\n                            have optimized\
    \ away.\n\n                            This could be either a BRANCH, in which\
    \ case the\n                            subsequence is internal, or it could be\
    \ the item\n                            following the branch sequence in which\
    \ case the\n                            subsequence is at the end (which does\
    \ not\n                            necessarily mean the first node is the start\
    \ of the\n                            alternation).\n\n                      \
    \      TRIE_TYPE(X) is a define which maps the optype to a\n                 \
    \           trietype.\n\n                                optype          |  trietype\n\
    \                                ----------------+-----------\n              \
    \                  NOTHING         | NOTHING\n                               \
    \ EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n\
    \                                EXACTFU         | EXACTFU\n                 \
    \               EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP\
    \        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n\
    \                                EXACTL          | EXACTL\n                  \
    \              EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define\
    \ TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n   \
    \                    ? NOTHING                                            \\\n\
    \                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\
    \n                         ? EXACT                                           \
    \ \\\n                         : (     EXACTFU == (X)                        \
    \     \\\n                              || EXACTFU_ONLY8 == (X)              \
    \         \\\n                              || EXACTFUP == (X) )             \
    \             \\\n                           ? EXACTFU                       \
    \                 \\\n                           : ( EXACTFAA == (X) )       \
    \                     \\\n                             ? EXACTFAA            \
    \                         \\\n                             : ( EXACTL == (X) )\
    \                            \\\n                               ? EXACTL     \
    \                                \\\n                               : ( EXACTFLU8\
    \ == (X) )                       \\\n                                 ? EXACTFLU8\
    \                                \\\n                                 : 0 )\n\n\
    \                        /* dont use tail as the end marker for this traverse\
    \ */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext(\
    \ cur ) ) {\n                            regnode * const noper = NEXTOPER( cur\
    \ );\n                            U8 noper_type = OP( noper );\n             \
    \               U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING)\
    \ || defined(NOJUMPTRIE)\n                            regnode * const noper_next\
    \ = regnext( noper );\n                            U8 noper_next_type = (noper_next\
    \ && noper_next < tail) ? OP(noper_next) : 0;\n                            U8\
    \ noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type\
    \ ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n      \
    \                          regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n\
    \                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n \
    \                                  depth+1,\n                                \
    \   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n\
    \                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n\
    \                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n     \
    \                               REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\
    \n                                if ( noper_next ) {\n                      \
    \            regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n   \
    \                               Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n  \
    \                                  REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n\
    \                                }\n                                Perl_re_printf(\
    \ aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n      \
    \                             REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\
    \t\t\t\t);\n                            });\n\n                            /*\
    \ Is noper a trieable nodetype that can be merged\n                          \
    \   * with the current trie (if there is one)? */\n                          \
    \  if ( noper_trietype\n                                  &&\n               \
    \                   (\n                                        ( noper_trietype\
    \ == NOTHING )\n                                        || ( trietype == NOTHING\
    \ )\n                                        || ( trietype == noper_trietype )\n\
    \                                  )\n#ifdef NOJUMPTRIE\n                    \
    \              && noper_next >= tail\n#endif\n                               \
    \   && count < U16_MAX)\n                            {\n                     \
    \           /* Handle mergable triable node Either we are\n                  \
    \               * the first node in a new trieable sequence,\n               \
    \                  * in which case we do some bookkeeping,\n                 \
    \                * otherwise we update the end pointer. */\n                 \
    \               if ( !first ) {\n                                    first = cur;\n\
    \t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\
    \t\t\t\t\tregnode * const noper_next = regnext( noper );\n                   \
    \                     U8 noper_next_type = (noper_next && noper_next < tail) ?\
    \ OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE(\
    \ noper_next_type ) :0;\n#endif\n\n                                        if\
    \ ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n \
    \                                       } else if (noper_next_type)  {\n     \
    \                                       /* a NOTHING regop is 1 regop wide.\n\
    \                                             * We need at least two for a trie\n\
    \                                             * so we can't merge this in */\n\
    \                                            first = NULL;\n                 \
    \                       }\n                                    } else {\n    \
    \                                    trietype = noper_trietype;\n            \
    \                        }\n                                } else {\n       \
    \                             if ( trietype == NOTHING )\n                   \
    \                     trietype = noper_trietype;\n                           \
    \         last = cur;\n                                }\n\t\t\t\tif (first)\n\
    \t\t\t\t    count++;\n                            } /* end handle mergable triable\
    \ node */\n                            else {\n                              \
    \  /* handle unmergable node -\n                                 * noper may either\
    \ be a triable node which can\n                                 * not be tried\
    \ together with the current trie,\n                                 * or a non\
    \ triable node */\n                                if ( last ) {\n           \
    \                         /* If last is set and trietype is not\n            \
    \                         * NOTHING then we have found at least two\n        \
    \                             * triable branch sequences in a row of a\n     \
    \                                * similar trietype so we can turn them\n    \
    \                                 * into a trie. If/when we allow NOTHING to\n\
    \                                     * start a trie sequence this condition\n\
    \                                     * will be required, and it isn't expensive\n\
    \                                     * so we leave it in for now. */\n      \
    \                              if ( trietype && trietype != NOTHING )\n      \
    \                                  make_trie( pRExC_state,\n                 \
    \                               startbranch, first, cur, tail,\n             \
    \                                   count, trietype, depth+1 );\n            \
    \                        last = NULL; /* note: we clear/update\n             \
    \                                       first, trietype etc below,\n         \
    \                                           so we dont do it here */\n       \
    \                         }\n                                if ( noper_trietype\n\
    #ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n\
    #endif\n                                ){\n                                 \
    \   /* noper is triable, so we can start a new\n                             \
    \        * trie sequence */\n                                    count = 1;\n\
    \                                    first = cur;\n                          \
    \          trietype = noper_trietype;\n                                } else\
    \ if (first) {\n                                    /* if we already saw a first\
    \ but the\n                                     * current node is not triable\
    \ then we have\n                                     * to reset the first information.\
    \ */\n                                    count = 0;\n                       \
    \             first = NULL;\n                                    trietype = 0;\n\
    \                                }\n                            } /* end handle\
    \ unmergable node */\n                        } /* loop over branches */\n   \
    \                     DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx,\
    \ RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf(\
    \ aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1,\
    \ SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                       \
    \     Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n\
    \                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \                               PL_reg_name[trietype]\n                      \
    \      );\n\n                        });\n                        if ( last &&\
    \ trietype ) {\n                            if ( trietype != NOTHING ) {\n   \
    \                             /* the last branch of the sequence was part of\n\
    \                                 * a trie, so we have to construct it here\n\
    \                                 * outside of the loop */\n                 \
    \               made= make_trie( pRExC_state, startbranch,\n                 \
    \                                first, scan, tail, count,\n                 \
    \                                trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n\
    \                                if ( ((made == MADE_EXACT_TRIE &&\n         \
    \                            startbranch == first)\n                         \
    \            || ( first_non_open == first )) &&\n                            \
    \         depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n\
    \                                    if ( startbranch == first\n             \
    \                            && scan >= tail )\n                             \
    \       {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n\
    \                                    }\n                                }\n#endif\n\
    \                            } else {\n                                /* at this\
    \ point we know whatever we have is a\n                                 * NOTHING\
    \ sequence/branch AND if 'startbranch'\n                                 * is\
    \ 'first' then we can turn the whole thing\n                                 *\
    \ into a NOTHING\n                                 */\n                      \
    \          if ( startbranch == first ) {\n                                   \
    \ regnode *opt;\n                                    /* the entire thing is a\
    \ NOTHING sequence,\n                                     * something like this:\
    \ (?:|) So we can\n                                     * turn it into a plain\
    \ NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n\
    \                                        regprop(RExC_rx, RExC_mysv, cur, NULL,\
    \ pRExC_state);\n                                        Perl_re_indentf( aTHX_\
    \  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                             \
    \             depth+1,\n                                          SvPV_nolen_const(\
    \ RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n\
    \                                    OP(startbranch)= NOTHING;\n             \
    \                       NEXT_OFF(startbranch)= tail - startbranch;\n         \
    \                           for ( opt= startbranch + 1; opt < tail ; opt++ )\n\
    \                                        OP(opt)= OPTIMIZED;\n               \
    \                 }\n                            }\n                        }\
    \ /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n\
    \                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ )\
    \ {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\
    \t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\
    \t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB)\
    \ {\n            I32 paren = 0;\n            regnode *start = NULL;\n        \
    \    regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\
    \n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup,\
    \ note this code has side effects beyond\n                 * the rest of this\
    \ block. Specifically setting\n                 * RExC_recurse[] must happen at\
    \ least once during\n                 * study_chunk(). */\n                paren\
    \ = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n          \
    \      start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\
    \n                /* NOTE we MUST always execute the above code, even\n      \
    \           * if we do nothing with a GOSUB */\n                if (\n       \
    \             ( flags & SCF_IN_DEFINE )\n                    ||\n            \
    \        (\n                        (is_inf_internal || is_inf || (data && data->flags\
    \ & SF_IS_INF))\n                        &&\n                        ( (flags\
    \ & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n        \
    \        ) {\n                    /* no need to do anything here if we are in\
    \ a define. */\n                    /* or we are after some kind of infinite construct\n\
    \                     * so we can skip recursing into this item.\n           \
    \          * Since it is infinite we will not change the maxlen\n            \
    \         * or delta, and if we miss something that might raise\n            \
    \         * the minlen it will merely pessimise a little.\n                  \
    \   *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n   \
    \                  * might result in a minlen of 1 and not of 4,\n           \
    \          * but this doesn't make us mismatch, just try a bit\n             \
    \        * harder than we should.\n                     * */\n               \
    \     scan= regnext(scan);\n                    continue;\n                }\n\
    \n                if (\n                    !recursed_depth\n                \
    \    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1)\
    \ * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n          \
    \          /* it is quite possible that there are more efficient ways\n      \
    \               * to do this. We maintain a bitmap per level of recursion\n  \
    \                   * of which patterns we have entered so we can detect if a\n\
    \                     * pattern creates a possible infinite loop. When we\n  \
    \                   * recurse down a level we copy the previous levels bitmap\n\
    \                     * down. When we are at recursion level 0 we zero the top\n\
    \                     * level bitmap. It would be nice to implement a different\n\
    \                     * more efficient way of doing this. In particular the top\n\
    \                     * level bitmap may be unnecessary.\n                   \
    \  */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed,\
    \ RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n      \
    \                  Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed_bytes, U8);\n        \
    \            }\n                    /* we havent recursed into this paren yet,\
    \ so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data,\
    \ depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth\
    \ * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth=\
    \ recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"\
    gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite\
    \ recursion, assume infinite length\n                     * */\n             \
    \       if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n\
    \                    }\n                    is_inf = is_inf_internal = 1;\n  \
    \                  if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n   \
    \                     ssc_anything(data->start_class);\n                    flags\
    \ &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we\
    \ dont recurse later on. */\n\t        }\n            } else {\n\t        paren\
    \ = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\
    \t    }\n            if (start) {\n                scan_frame *newframe;\n   \
    \             assert(end);\n                if (!RExC_frame_last) {\n        \
    \            Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames,\
    \ newframe);\n                    RExC_frame_head= newframe;\n               \
    \     RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame)\
    \ {\n                    Newxz(newframe, 1, scan_frame);\n                   \
    \ RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame=\
    \ RExC_frame_last;\n                    RExC_frame_count++;\n                }\
    \ else {\n                    newframe= RExC_frame_last->next_frame;\n       \
    \         }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode\
    \ = regnext(scan);\n                newframe->last_regnode = last;\n         \
    \       newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth\
    \ = recursed_depth;\n                newframe->this_prev_frame= frame;\n     \
    \           newframe->in_gosub = (\n                    (frame && frame->in_gosub)\
    \ || OP(scan) == GOSUB\n                );\n\n                DEBUG_STUDYDATA(\"\
    frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan,\
    \ depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t\
    \        stopparen = paren;\n\t        last = end;\n                depth = depth\
    \ + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\
    \t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) ==\
    \ EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t\
    \ l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\
    \t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s +\
    \ l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\
    \t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest\
    \ substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset,\
    \ later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update\
    \ the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t   \
    \ data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\
    \t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\
    \t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\
    \t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8)\
    \ : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n\
    \                                              (U8*)STRING(scan)+STR_LEN(scan));\n\
    \t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As\
    \ in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n    \
    \        /* ANDing the code point leaves at most it, and not in locale, and\n\
    \             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND)\
    \ {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class)\
    \ &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\
    \t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class,\
    \ uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)]\
    \ == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t\
    \ l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /*\
    \ Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\
    \t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\
    \t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n    \
    \        delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min\
    \ += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min\
    \ = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\
    \tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\
    \t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist\
    \ = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n\
    \                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan)\
    \ != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n\
    \                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                    ANYOF_POSIXL_ZERO(data->start_class);\n                 \
    \   ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n            \
    \    }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class,\
    \ EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a\
    \ */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n                flags &= ~SCF_DO_STCLASS;\n              \
    \  SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan)))\
    \ {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t\
    \    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc\
    \ this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\
    \n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)*\
    \ . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif\
    \ (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\
    \t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n\
    \                        || OP(next) == EXACTL\n                        || (flags\
    \ & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount\
    \ = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\
    \tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\
    \t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\
    \n                /* This temporary node can now be turned into EXACTFU, and\n\
    \                 * must, as regexec.c doesn't handle it */\n                if\
    \ (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n                    OP(next) =\
    \ EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n\
    \                    &&   isALPHA_A(* STRING(next))\n                    && (\
    \         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n\
    \                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n\
    \                    &&   mutate_ok\n                ) {\n                   \
    \ /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\
    \n                    assert(isALPHA_A(* STRING(next)));\n\n                 \
    \   /* Then replace it by an ANYOFM node, with\n                    * the mask\
    \ set to the complement of the\n                    * bit that differs between\
    \ upper and lower\n                    * case, and the lowest code point of the\n\
    \                    * pair (which the '&' forces) */\n                    OP(next)\
    \ = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n      \
    \              FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\
    \t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t   \
    \ data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal\
    \ = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\
    \t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\
    \t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\
    \t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount\
    \ = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX)\
    \ {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags\
    \ = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan)\
    \ + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\
    \t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n   \
    \                     scan_commit(pRExC_state, data, minlenp, is_inf);\n     \
    \               /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\
    \t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\
    \t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\
    \t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\
    \t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear\
    \ cache processing any {n,m}\n\t\t   regops for which the combination of input\
    \ pos and regex\n\t\t   pos is not enough information to determine if a match\n\
    \t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/\
    \ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\
    \t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats\
    \ into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount >\
    \ 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t\
    /* This will finish on WHILEM, setting scan, or on NULL: */\n                /*\
    \ recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state,\
    \ &scan, minlenp, &deltanext,\n                                  last, data, stopparen,\
    \ recursed_depth, NULL,\n                                  (mincount == 0\n  \
    \                                 ? (f & ~SCF_DO_SUBSTR)\n                   \
    \                : f)\n                                  , depth+1, mutate_ok);\n\
    \n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif\
    \ (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\
    \t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |=\
    \ SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\
    \t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan =\
    \ next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\
    \t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval\
    \ || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext\
    \ == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n        \
    \            && maxcount <= REG_INFTY/3) /* Complement check for big\n       \
    \                                            count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end,\
    \ packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n\
    \                            \"Quantifier unexpected on zero-length expression\
    \ \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF,\
    \ RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n             \
    \   }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext\
    \ )\n                    || min >= SSize_t_MAX - minnext * mincount )\n      \
    \          {\n                    FAIL(\"Regexp out of space\");\n           \
    \     }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext ==\
    \ SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext +\
    \ deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf)\
    \ {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta +=\
    \ (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n\
    \                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\t\
    if (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t\
    \      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext ==\
    \ 1\n                      && mutate_ok\n                ) {\n\t\t    /* Try to\
    \ optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\
    \t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n\
    #endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\
    \t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\
    \t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\
    \t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens)\
    \ {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n     \
    \                   RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\
    \t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags\
    \ = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t\
    /* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was\
    \ count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t\
    \    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count.\
    \ */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t\
    }\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan)\
    \ == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags\
    \ & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t   \
    \   && minnext != 0\t/* CURLYM can't handle zero width */\n                  \
    \       /* Nor characters whose fold at run-time may be\n                    \
    \      * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\
    \                      && mutate_ok\n\t\t) {\n\t\t    /* XXXX How to optimize\
    \ if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode\
    \ *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\
    \n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over\
    \ embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t\
    \    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away\
    \ parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\
    \t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) +\
    \ EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif\
    \ (RExC_open_parens) {\n                             /*open->CURLYM*/\n      \
    \                      RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n\
    \                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(nxt2)\n                                                   \
    \      + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED;\
    \ /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1\
    \ + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just\
    \ for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM))\
    \ {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\
    \t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\
    \t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\
    \t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t  \
    \  }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n \
    \                       /* recurse study_chunk() on optimised CURLYX => CURLYM\
    \ */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n      \
    \                              NULL, stopparen, recursed_depth, NULL, 0,\n   \
    \                                 depth+1, mutate_ok);\n\t\t    }\n\t\t    else\n\
    \t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t &&\
    \ (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression\
    \ above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we\
    \ care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\
    \t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair.\
    \ */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan\
    \ + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\
    \t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n           \
    \         if (nxt->flags & 0xf) {\n                        /* we've already set\
    \ whilem count on this node */\n                    } else if (++data->whilem_c\
    \ < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n\
    \                        nxt->flags = (U8)(data->whilem_c\n                  \
    \          | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\
    \t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN\
    \ last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                   \
    \ if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                \
    \                                                  string. */\n\t\t\tSSize_t b\
    \ = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\
    \t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\
    \t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old\
    \ >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n  \
    \                                             (U8 *) SvEND(data->last_found))\n\
    \                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the\
    \ added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n      \
    \                  last_chrs = UTF ? utf8_length((U8*)(s + old),\n           \
    \                                 (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext\
    \ == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string\
    \ */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l)\
    \ + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str),\
    \ l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str,\
    \ SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\t\
    SvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\
    \tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\
    \t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv,\
    \ PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\t\
    mg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                         \
    \       last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\
    \t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last\
    \ copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t\
    \    data->last_start_max =\n                              is_inf\n          \
    \                     ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n \
    \                                (maxcount - 1) * (minnext + data->pos_delta);\n\
    \t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min\
    \ += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\"\
    \ UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\"\
    \ UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf\
    \ \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX,\
    \ (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\n\
    Perl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted\
    \ * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount),\
    \ (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n\
    \                        || -counted * deltanext + (minnext + deltanext) * maxcount\
    \ - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta\
    \ = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext\
    \ +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if\
    \ (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\
    \t\t\t    the group.  */\n                        scan_commit(pRExC_state, data,\
    \ minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv\
    \ = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv)\
    \ ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\
    \tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end\
    \ = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\
    \t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min\
    \ + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /*\
    \ float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data &&\
    \ (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\
    \t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n\
    \                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\"\
    ,\n                                                                    OP(scan));\n\
    #endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR)\
    \ {\n                    /* Cannot expect anything... */\n                   \
    \ scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags &\
    \ SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n       \
    \                 /* Actually is any start char, but very few code points\n  \
    \                       * aren't start characters */\n                       \
    \ ssc_match_all_cp(data->start_class);\n                    }\n              \
    \      else {\n                        ssc_anything(data->start_class);\n    \
    \                }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\
    \t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS)\
    \ {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n\
    \                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n\
    \                    ssc_clear_locale(data->start_class);\n                  \
    \  ANYOF_FLAGS(data->start_class)\n                                          \
    \      &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else\
    \ if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n\
    \                              PL_XPosix_ptrs[_CC_VERTSPACE],\n              \
    \                FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n\n                    /* See commit msg for\n              \
    \       * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n\
    \                                                &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n\
    \            if (delta != SSize_t_MAX)\n                delta++;    /* Because\
    \ of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n  \
    \              /* Cannot expect anything... */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n               \
    \ if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta +=\
    \ 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t  \
    \  }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\
    \t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool\
    \ invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will\
    \ only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef\
    \ DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx\
    \ opcode %d\",\n                                                             \
    \        OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t   \
    \ break;\n\n\t\tcase REG_ANY:\n                    {\n                       \
    \ SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist\
    \ = add_cp_to_invlist(REG_ANY_invlist,\n                                     \
    \                       '\\n');\n                        if (flags & SCF_DO_STCLASS_OR)\
    \ {\n                            ssc_union(data->start_class,\n              \
    \                        REG_ANY_invlist,\n                                  \
    \    TRUE /* TRUE => invert, hence all but \\n\n                             \
    \               */\n                                      );\n               \
    \         }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n\
    \                            ssc_intersection(data->start_class,\n           \
    \                                  REG_ANY_invlist,\n                        \
    \                     TRUE  /* TRUE => invert */\n                           \
    \                  );\n                            ssc_clear_locale(data->start_class);\n\
    \                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\
    \t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case\
    \ ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n \
    \               case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class,\n                                (regnode_charclass *) scan);\n\
    \t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                 \
    \                                         (regnode_charclass *) scan);\n\t\t \
    \   break;\n\n                case NANYOFM:\n                case ANYOFM:\n  \
    \                {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\
    \n                    if (flags & SCF_DO_STCLASS_OR) {\n                     \
    \   ssc_union(data->start_class, cp_list, invert);\n                    }\n  \
    \                  else if (flags & SCF_DO_STCLASS_AND) {\n                  \
    \      ssc_intersection(data->start_class, cp_list, invert);\n               \
    \     }\n\n                    SvREFCNT_dec_NN(cp_list);\n                   \
    \ break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n          \
    \          namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n      \
    \              if (flags & SCF_DO_STCLASS_AND) {\n                        bool\
    \ was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n\
    \                                                                 namedclass));\n\
    \                        ANYOF_POSIXL_ZERO(data->start_class);\n             \
    \           if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class,\
    \ namedclass);\n                        }\n                        /* No individual\
    \ code points can now match */\n                        data->start_class->invlist\n\
    \                                                = sv_2mortal(_new_invlist(0));\n\
    \                    }\n                    else {\n                        int\
    \ complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this\
    \ class was already there,\n                         * the result is that they\
    \ match all code points,\n                         * (\\d + \\D == everything).\
    \  Remove the classes from\n                         * future consideration. \
    \ Locale is not relevant in\n                         * this case */\n       \
    \                 if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n  \
    \                          ssc_match_all_cp(data->start_class);\n            \
    \                ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n        \
    \                    ANYOF_POSIXL_CLEAR(data->start_class, complement);\n    \
    \                    }\n                        else {  /* The usual case; just\
    \ add this class to the\n                                   existing set */\n\
    \                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n\
    \                        }\n                    }\n                    break;\n\
    \n                case NPOSIXA:   /* For these, we always know the exact set of\n\
    \                                   what's matched */\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n            \
    \        my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n     \
    \               goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n\
    \                    invert = 1;\n                    /* FALLTHROUGH */\n\t\t\
    case POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)],\
    \ NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points\
    \ unless the\n                     * target string being matched is UTF-8, which\
    \ is\n                     * unknowable until match time.  Since we are going\
    \ to\n                     * invert, we want to get rid of all of them so that\
    \ the\n                     * inversion will match all */\n                  \
    \  if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist,\
    \ PL_UpperLatin1,\n                                          &my_invlist);\n \
    \                   }\n\n                  join_posix_and_ascii:\n\n         \
    \           if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class,\
    \ my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n\
    \                    }\n                    else {\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class,\
    \ my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\
    \t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t\
    }\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags\
    \ |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n\
    \            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if\
    \ (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate\
    \ parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\
    \t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n         \
    \   if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) ==\
    \ UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n\
    \                   In this case we can't do fixed string optimisation.\n    \
    \            */\n\n                SSize_t deltanext, minnext, fake = 0;\n   \
    \             regnode *nscan;\n                regnode_ssc intrnl;\n         \
    \       int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n                if (data) {\n                    data_fake.whilem_c\
    \ = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\
    \t\t}\n                else\n                    data_fake.last_closep = &fake;\n\
    \t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS\
    \ && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead\
    \ */\n                    ssc_init(pRExC_state, &intrnl);\n                  \
    \  data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\
    \t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                 \
    \   f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n    \
    \            nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk()\
    \ for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan,\
    \ minlenp, &deltanext,\n                                      last, &data_fake,\
    \ stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n\
    \                                      mutate_ok);\n                if (scan->flags)\
    \ {\n                    if (   deltanext < 0\n                        || deltanext\
    \ > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n         \
    \               || minnext + deltanext > (I32)U8_MAX)\n                    {\n\
    \t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n        \
    \                      (UV)U8_MAX);\n                    }\n\n               \
    \     /* The 'next_off' field has been repurposed to count the\n             \
    \        * additional starting positions to try beyond the initial\n         \
    \            * one.  (This leaves it at 0 for non-variable length\n          \
    \           * matches to avoid breakage for those not using this\n           \
    \          * extension) */\n                    if (deltanext) {\n           \
    \             scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n\
    \                            WARN_EXPERIMENTAL__VLB,\n                       \
    \     \"Variable length lookbehind is experimental\");\n                    }\n\
    \                    scan->flags = (U8)minnext + deltanext;\n                }\n\
    \                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\
    \                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND)\
    \ {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after:\
    \ ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by\
    \ study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t\
    \ * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl\
    \ #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t \
    \   }  else {\n                        /* AND before and after: combine and continue.\
    \  These\n                         * assertions are zero-length, so can match\
    \ an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                   |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n\
    \            else {\n                /* Positive Lookahead/lookbehind\n      \
    \             In this case we can do fixed string optimisation,\n            \
    \       but we must be careful about it. Note in the case of\n               \
    \    lookbehind the positions will be offset by the minimum\n                \
    \   length of the pattern, something we won't know about\n                   until\
    \ after the recurse.\n                */\n                SSize_t deltanext, fake\
    \ = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n\
    \                int f = 0;\n                /* We use SAVEFREEPV so that when\
    \ the full compile\n                    is finished perl will clean up the allocated\n\
    \                    minlens when it's all done. This way we don't\n         \
    \           have to worry about freeing them when we know\n                  \
    \  they wont be used, which would be a pain.\n                 */\n          \
    \      SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n   \
    \             SAVEFREEPV(minnextp);\n\n                if (data) {\n         \
    \           StructCopy(data, &data_fake, scan_data_t);\n                    if\
    \ ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |=\
    \ SCF_DO_SUBSTR;\n                        if (scan->flags)\n                 \
    \           scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n         \
    \               data_fake.last_found=newSVsv(data->last_found);\n            \
    \        }\n                }\n                else\n                    data_fake.last_closep\
    \ = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags\
    \ = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta\
    \ = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n\
    \                if ( flags & SCF_DO_STCLASS && !scan->flags\n               \
    \      && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state,\
    \ &intrnl);\n                    data_fake.start_class = &intrnl;\n          \
    \          f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags\
    \ & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n\
    \                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\
    \n                /* positive lookahead study_chunk() recursion */\n         \
    \       *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n             \
    \                           &deltanext, last, &data_fake,\n                  \
    \                      stopparen, recursed_depth, NULL,\n                    \
    \                    f, depth+1, mutate_ok);\n                if (scan->flags)\
    \ {\n                    assert(0);  /* This code has never been tested since\
    \ this\n                                   is normally not compiled */\n     \
    \               if (   deltanext < 0\n                        || deltanext > (I32)\
    \ U8_MAX\n                        || *minnextp > (I32)U8_MAX\n               \
    \         || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\
    \tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n            \
    \                  (UV)U8_MAX);\n                    }\n\n                   \
    \ if (deltanext) {\n                        scan->next_off = deltanext;\n    \
    \                }\n                    scan->flags = (U8)*minnextp + deltanext;\n\
    \                }\n\n                *minnextp += min;\n\n                if\
    \ (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class)\
    \ |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n\
    \                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n         \
    \               pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found)\
    \ {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n\
    \                            RExC_rx->minlen=*minnextp;\n                    \
    \    scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n               \
    \         SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for\
    \ (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp\
    \ != minlenp) {\n                                data->substrs[i].min_offset =\n\
    \                                            data_fake.substrs[i].min_offset;\n\
    \                                data->substrs[i].max_offset =\n             \
    \                               data_fake.substrs[i].max_offset;\n           \
    \                     data->substrs[i].minlenp =\n                           \
    \                 data_fake.substrs[i].minlenp;\n                            \
    \    data->substrs[i].lookbehind += scan->flags;\n                           \
    \ }\n                        }\n                    }\n                }\n\t \
    \   }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\
    \t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen ==\
    \ (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par)\
    \ {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next\
    \ < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if\
    \ (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL)\
    \ {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)]\
    \ == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data\
    \ && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t      \
    \  if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan)\
    \ == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf\
    \ = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything\
    \ */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT)\
    \ &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n  \
    \              if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n\
    \                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs\
    \ < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n       \
    \         RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs\
    \ = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n  \
    \      else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is\
    \ similar code to this block above for handling\n               BRANCH nodes on\
    \ the initial study.  If you change stuff here\n               check there too.\
    \ */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n\
    \            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan)\
    \ ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc\
    \ accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n\
    \                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n\
    \                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump)\
    \ {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n\
    \            } else {\n                const regnode *nextbranch= NULL;\n    \
    \            U32 word;\n\n                for ( word=1 ; word <= trie->wordcount\
    \ ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0,\
    \ f = 0, fake;\n                    regnode_ssc this_class;\n\n              \
    \      StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n               \
    \     if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n\
    \                        data_fake.last_closep = data->last_closep;\n        \
    \            }\n                    else\n                        data_fake.last_closep\
    \ = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags\
    \ & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n\
    \                        data_fake.start_class = &this_class;\n              \
    \          f = SCF_DO_STCLASS_AND;\n                    }\n                  \
    \  if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\
    \n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n\
    \                            nextbranch = trie_node + trie->jump[0];\n       \
    \                 scan= trie_node + trie->jump[word];\n                      \
    \  /* We go from the jump point to the branch that follows\n                 \
    \          it. Note this means we need the vestigal unused\n                 \
    \          branches even though they arent otherwise used. */\n              \
    \          /* optimise study_chunk() for TRIE */\n                        minnext\
    \ = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext,\
    \ (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth,\
    \ NULL, f, depth+1,\n                            mutate_ok);\n               \
    \     }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n\
    \                        nextbranch= regnext((regnode*)nextbranch);\n\n      \
    \              if (min1 > (SSize_t)(minnext + trie->minlen))\n               \
    \         min1 = minnext + trie->minlen;\n                    if (deltanext ==\
    \ SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n    \
    \                    max1 = SSize_t_MAX;\n                    } else if (max1\
    \ < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1\
    \ = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags\
    \ & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n               \
    \     if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin\
    \ > min + min1)\n\t                    stopmin = min + min1;\n\t             \
    \   flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                \
    \    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if\
    \ (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n     \
    \                       data->flags |= SF_HAS_EVAL;\n                        data->whilem_c\
    \ = data_fake.whilem_c;\n                    }\n                    if (flags\
    \ & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass\
    \ *) &this_class);\n                }\n            }\n            if (flags &\
    \ SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta\
    \ += max1 - min1;\n                if (max1 != min1 || is_inf)\n             \
    \       data->cur_is_floating = 1; /* float */\n            }\n            min\
    \ += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX\
    \ - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n     \
    \           else\n                    delta = SSize_t_MAX;\n            }\n  \
    \          if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &accum);\n                if (min1)\
    \ {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n            \
    \    }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n  \
    \              if (min1) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n\
    \                }\n                else {\n                    /* Switch to OR\
    \ mode: cache the old value of\n                     * data->start_class */\n\t\
    \t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp,\
    \ regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n         \
    \           StructCopy(&accum, data->start_class, regnode_ssc);\n            \
    \        flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n     \
    \       scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)]\
    \ == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[\
    \ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta\
    \ += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n\
    \            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything...\
    \ */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t\
    \        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen\
    \ - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings\
    \ -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old\
    \ or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\
    \tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need\
    \ to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"\
    frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth,\
    \ flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n\
    \        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n\
    \        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last\
    \ = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto\
    \ fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\"\
    , data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ?\
    \ SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta\
    \ = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n\
    \    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags\
    \ &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\
    \tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n\
    \        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\"\
    , data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin\
    \ ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN))\
    \ {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen\
    \ = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n \
    \               RExC_maxlen = final_minlen + delta;\n        }\n        return\
    \ final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nSTATIC SSize_t\nS_study_chunk(pTHX_ RExC_state_t\
    \ *pRExC_state, regnode **scanp,\n                        SSize_t *minlenp, SSize_t\
    \ *deltap,\n\t\t\tregnode *last,\n\t\t\tscan_data_t *data,\n\t\t\tI32 stopparen,\n\
    \                        U32 recursed_depth,\n\t\t\tregnode_ssc *and_withp,\n\t\
    \t\tU32 flags, U32 depth, bool was_mutate_ok)\n\t\t\t/* scanp: Start here (read-write).\
    \ */\n\t\t\t/* deltap: Write maxlen-minlen here. */\n\t\t\t/* last: Stop before\
    \ this one. */\n\t\t\t/* data: string data about the pattern */\n\t\t\t/* stopparen:\
    \ treat close N as END */\n\t\t\t/* recursed: which subroutines have we recursed\
    \ into */\n\t\t\t/* and_withp: Valid if flags & SCF_DO_STCLASS_OR */\n{\n    dVAR;\n\
    \    /* There must be at least this number of characters to match */\n    SSize_t\
    \ min = 0;\n    I32 pars = 0, code;\n    regnode *scan = *scanp, *next;\n    SSize_t\
    \ delta = 0;\n    int is_inf = (flags & SCF_DO_SUBSTR) && (data->flags & SF_IS_INF);\n\
    \    int is_inf_internal = 0;\t\t/* The studied chunk is infinite */\n    I32\
    \ is_par = OP(scan) == OPEN ? ARG(scan) : 0;\n    scan_data_t data_fake;\n   \
    \ SV *re_trie_maxbuff = NULL;\n    regnode *first_non_open = scan;\n    SSize_t\
    \ stopmin = SSize_t_MAX;\n    scan_frame *frame = NULL;\n    GET_RE_DEBUG_FLAGS_DECL;\n\
    \n    PERL_ARGS_ASSERT_STUDY_CHUNK;\n    RExC_study_started= 1;\n\n    Zero(&data_fake,\
    \ 1, scan_data_t);\n\n    if ( depth == 0 ) {\n        while (first_non_open &&\
    \ OP(first_non_open) == OPEN)\n            first_non_open=regnext(first_non_open);\n\
    \    }\n\n\n  fake_study_recurse:\n    DEBUG_r(\n        RExC_study_chunk_recursed_count++;\n\
    \    );\n    DEBUG_OPTIMISE_MORE_r(\n    {\n        Perl_re_indentf( aTHX_  \"\
    study_chunk stopparen=%ld recursed_count=%lu depth=%lu recursed_depth=%lu scan=%p\
    \ last=%p\",\n            depth, (long)stopparen,\n            (unsigned long)RExC_study_chunk_recursed_count,\n\
    \            (unsigned long)depth, (unsigned long)recursed_depth,\n          \
    \  scan,\n            last);\n        if (recursed_depth) {\n            U32 i;\n\
    \            U32 j;\n            for ( j = 0 ; j < recursed_depth ; j++ ) {\n\
    \                for ( i = 0 ; i < (U32)RExC_total_parens ; i++ ) {\n        \
    \            if (\n                        PAREN_TEST(RExC_study_chunk_recursed\
    \ +\n                                   ( j * RExC_study_chunk_recursed_bytes),\
    \ i )\n                        && (\n                            !j ||\n     \
    \                       !PAREN_TEST(RExC_study_chunk_recursed +\n            \
    \                       (( j - 1 ) * RExC_study_chunk_recursed_bytes), i)\n  \
    \                      )\n                    ) {\n                        Perl_re_printf(\
    \ aTHX_ \" %d\",(int)i);\n                        break;\n                   \
    \ }\n                }\n                if ( j + 1 < recursed_depth ) {\n    \
    \                Perl_re_printf( aTHX_  \",\");\n                }\n         \
    \   }\n        }\n        Perl_re_printf( aTHX_ \"\\n\");\n    }\n    );\n   \
    \ while ( scan && OP(scan) != END && scan < last ){\n        UV min_subtract =\
    \ 0;    /* How mmany chars to subtract from the minimum\n                    \
    \               node length to get a real minimum (because\n                 \
    \                  the folded version may be shorter) */\n\tbool unfolded_multi_char\
    \ = FALSE;\n        /* avoid mutating ops if we are anywhere within the recursed\
    \ or\n         * enframed handling for a GOSUB: the outermost level will handle\
    \ it.\n         */\n        bool mutate_ok = was_mutate_ok && !(frame && frame->in_gosub);\n\
    \t/* Peephole optimizer: */\n        DEBUG_STUDYDATA(\"Peep\", data, depth, is_inf);\n\
    \        DEBUG_PEEP(\"Peep\", scan, depth, flags);\n\n\n        /* The reason\
    \ we do this here is that we need to deal with things like\n         * /(?:f)(?:o)(?:o)/\
    \ which cant be dealt with by the normal EXACT\n         * parsing code, as each\
    \ (?:..) is handled by a different invocation of\n         * reg() -- Yves\n \
    \        */\n        if (mutate_ok)\n            JOIN_EXACT(scan,&min_subtract,\
    \ &unfolded_multi_char, 0);\n\n        /* Follow the next-chain of the current\
    \ node and optimize\n           away all the NOTHINGs from it.\n         */\n\
    \        rck_elide_nothing(scan);\n\n\t/* The principal pseudo-switch.  Cannot\
    \ be a switch, since we\n\t   look into several different things.  */\n      \
    \  if ( OP(scan) == DEFINEP ) {\n            SSize_t minlen = 0;\n           \
    \ SSize_t deltanext = 0;\n            SSize_t fake_last_close = 0;\n         \
    \   I32 f = SCF_IN_DEFINE;\n\n            StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n            scan = regnext(scan);\n            assert( OP(scan)\
    \ == IFTHEN );\n            DEBUG_PEEP(\"expect IFTHEN\", scan, depth, flags);\n\
    \n            data_fake.last_closep= &fake_last_close;\n            minlen = *minlenp;\n\
    \            next = regnext(scan);\n            scan = NEXTOPER(NEXTOPER(scan));\n\
    \            DEBUG_PEEP(\"scan\", scan, depth, flags);\n            DEBUG_PEEP(\"\
    next\", next, depth, flags);\n\n            /* we suppose the run is continuous,\
    \ last=next...\n             * NOTE we dont use the return here! */\n        \
    \    /* DEFINEP study_chunk() recursion */\n            (void)study_chunk(pRExC_state,\
    \ &scan, &minlen,\n                              &deltanext, next, &data_fake,\
    \ stopparen,\n                              recursed_depth, NULL, f, depth+1,\
    \ mutate_ok);\n\n            scan = next;\n        } else\n        if (\n    \
    \        OP(scan) == BRANCH  ||\n            OP(scan) == BRANCHJ ||\n        \
    \    OP(scan) == IFTHEN\n        ) {\n\t    next = regnext(scan);\n\t    code\
    \ = OP(scan);\n\n            /* The op(next)==code check below is to see if we\n\
    \             * have \"BRANCH-BRANCH\", \"BRANCHJ-BRANCHJ\", \"IFTHEN-IFTHEN\"\
    \n             * IFTHEN is special as it might not appear in pairs.\n        \
    \     * Not sure whether BRANCH-BRANCHJ is possible, regardless\n            \
    \ * we dont handle it cleanly. */\n\t    if (OP(next) == code || code == IFTHEN)\
    \ {\n                /* NOTE - There is similar code to this block below for\n\
    \                 * handling TRIE nodes on a re-study.  If you change stuff here\n\
    \                 * check there too. */\n\t\tSSize_t max1 = 0, min1 = SSize_t_MAX,\
    \ num = 0;\n\t\tregnode_ssc accum;\n\t\tregnode * const startbranch=scan;\n\n\
    \                if (flags & SCF_DO_SUBSTR) {\n                    /* Cannot merge\
    \ strings after this. */\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                }\n\n                if (flags & SCF_DO_STCLASS)\n\
    \t\t    ssc_init_zero(pRExC_state, &accum);\n\n\t\twhile (OP(scan) == code) {\n\
    \t\t    SSize_t deltanext, minnext, fake;\n\t\t    I32 f = 0;\n\t\t    regnode_ssc\
    \ this_class;\n\n                    DEBUG_PEEP(\"Branch\", scan, depth, flags);\n\
    \n\t\t    num++;\n                    StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n\t\t    if (data) {\n\t\t\tdata_fake.whilem_c = data->whilem_c;\n\
    \t\t\tdata_fake.last_closep = data->last_closep;\n\t\t    }\n\t\t    else\n\t\t\
    \tdata_fake.last_closep = &fake;\n\n\t\t    data_fake.pos_delta = delta;\n\t\t\
    \    next = regnext(scan);\n\n                    scan = NEXTOPER(scan); /* everything\
    \ */\n                    if (code != BRANCH)    /* everything but BRANCH */\n\
    \t\t\tscan = NEXTOPER(scan);\n\n\t\t    if (flags & SCF_DO_STCLASS) {\n\t\t\t\
    ssc_init(pRExC_state, &this_class);\n\t\t\tdata_fake.start_class = &this_class;\n\
    \t\t\tf = SCF_DO_STCLASS_AND;\n\t\t    }\n\t\t    if (flags & SCF_WHILEM_VISITED_POS)\n\
    \t\t\tf |= SCF_WHILEM_VISITED_POS;\n\n\t\t    /* we suppose the run is continuous,\
    \ last=next...*/\n                    /* recurse study_chunk() for each BRANCH\
    \ in an alternation */\n\t\t    minnext = study_chunk(pRExC_state, &scan, minlenp,\n\
    \                                      &deltanext, next, &data_fake, stopparen,\n\
    \                                      recursed_depth, NULL, f, depth+1,\n   \
    \                                   mutate_ok);\n\n\t\t    if (min1 > minnext)\n\
    \t\t\tmin1 = minnext;\n\t\t    if (deltanext == SSize_t_MAX) {\n\t\t\tis_inf =\
    \ is_inf_internal = 1;\n\t\t\tmax1 = SSize_t_MAX;\n\t\t    } else if (max1 < minnext\
    \ + deltanext)\n\t\t\tmax1 = minnext + deltanext;\n\t\t    scan = next;\n\t\t\
    \    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\t\t\tpars++;\n\t        \
    \    if (data_fake.flags & SCF_SEEN_ACCEPT) {\n\t                if ( stopmin\
    \ > minnext)\n\t                    stopmin = min + min1;\n\t                flags\
    \ &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                    data->flags\
    \ |= SCF_SEEN_ACCEPT;\n\t            }\n\t\t    if (data) {\n\t\t\tif (data_fake.flags\
    \ & SF_HAS_EVAL)\n\t\t\t    data->flags |= SF_HAS_EVAL;\n\t\t\tdata->whilem_c\
    \ = data_fake.whilem_c;\n\t\t    }\n\t\t    if (flags & SCF_DO_STCLASS)\n\t\t\t\
    ssc_or(pRExC_state, &accum, (regnode_charclass*)&this_class);\n\t\t}\n\t\tif (code\
    \ == IFTHEN && num < 2) /* Empty ELSE branch */\n\t\t    min1 = 0;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    data->pos_min += min1;\n\t\t    if (data->pos_delta\
    \ >= SSize_t_MAX - (max1 - min1))\n\t\t        data->pos_delta = SSize_t_MAX;\n\
    \t\t    else\n\t\t        data->pos_delta += max1 - min1;\n\t\t    if (max1 !=\
    \ min1 || is_inf)\n\t\t\tdata->cur_is_floating = 1;\n\t\t}\n\t\tmin += min1;\n\
    \t\tif (delta == SSize_t_MAX\n\t\t || SSize_t_MAX - delta - (max1 - min1) < 0)\n\
    \t\t    delta = SSize_t_MAX;\n\t\telse\n\t\t    delta += max1 - min1;\n\t\tif\
    \ (flags & SCF_DO_STCLASS_OR) {\n\t\t    ssc_or(pRExC_state, data->start_class,\
    \ (regnode_charclass*) &accum);\n\t\t    if (min1) {\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n\t\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t\t    }\n\t\t}\n\t\telse if (flags & SCF_DO_STCLASS_AND) {\n\t\t    if (min1)\
    \ {\n\t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) &accum);\n\
    \t\t\tflags &= ~SCF_DO_STCLASS;\n\t\t    }\n\t\t    else {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&accum, data->start_class, regnode_ssc);\n\t\t\tflags |= SCF_DO_STCLASS_OR;\n\
    \t\t    }\n\t\t}\n\n                if (PERL_ENABLE_TRIE_OPTIMISATION\n      \
    \              && OP(startbranch) == BRANCH\n                    && mutate_ok\n\
    \                ) {\n\t\t/* demq.\n\n                   Assuming this was/is\
    \ a branch we are dealing with: 'scan'\n                   now points at the item\
    \ that follows the branch sequence,\n                   whatever it is. We now\
    \ start at the beginning of the\n                   sequence and look for subsequences\
    \ of\n\n\t\t   BRANCH->EXACT=>x1\n\t\t   BRANCH->EXACT=>x2\n\t\t   tail\n\n  \
    \                 which would be constructed from a pattern like\n           \
    \        /A|LIST|OF|WORDS/\n\n\t\t   If we can find such a subsequence we need\
    \ to turn the first\n\t\t   element into a trie and then add the subsequent branch\
    \ exact\n\t\t   strings to the trie.\n\n\t\t   We have two cases\n\n         \
    \            1. patterns where the whole set of branches can be\n            \
    \            converted.\n\n\t\t     2. patterns where only a subset can be converted.\n\
    \n\t\t   In case 1 we can replace the whole set with a single regop\n\t\t   for\
    \ the trie. In case 2 we need to keep the start and end\n\t\t   branches so\n\n\
    \t\t     'BRANCH EXACT; BRANCH EXACT; BRANCH X'\n\t\t     becomes BRANCH TRIE;\
    \ BRANCH X;\n\n\t\t  There is an additional case, that being where there is a\n\
    \t\t  common prefix, which gets split out into an EXACT like node\n\t\t  preceding\
    \ the TRIE node.\n\n\t\t  If x(1..n)==tail then we can do a simple trie, if not\
    \ we make\n\t\t  a \"jump\" trie, such that when we match the appropriate word\n\
    \t\t  we \"jump\" to the appropriate tail node. Essentially we turn\n\t\t  a nested\
    \ if into a case structure of sorts.\n\n\t\t*/\n\n\t\t    int made=0;\n\t\t  \
    \  if (!re_trie_maxbuff) {\n\t\t\tre_trie_maxbuff = get_sv(RE_TRIE_MAXBUF_NAME,\
    \ 1);\n\t\t\tif (!SvIOK(re_trie_maxbuff))\n\t\t\t    sv_setiv(re_trie_maxbuff,\
    \ RE_TRIE_MAXBUF_INIT);\n\t\t    }\n                    if ( SvIV(re_trie_maxbuff)>=0\
    \  ) {\n                        regnode *cur;\n                        regnode\
    \ *first = (regnode *)NULL;\n                        regnode *last = (regnode\
    \ *)NULL;\n                        regnode *tail = scan;\n                   \
    \     U8 trietype = 0;\n                        U32 count=0;\n\n             \
    \           /* var tail is used because there may be a TAIL\n                \
    \           regop in the way. Ie, the exacts will point to the\n             \
    \              thing following the TAIL, but the last branch will\n          \
    \                 point at the TAIL. So we advance tail. If we\n             \
    \              have nested (?:) we may have to move through several\n        \
    \                   tails.\n                         */\n\n                  \
    \      while ( OP( tail ) == TAIL ) {\n                            /* this is\
    \ the TAIL generated by (?:) */\n                            tail = regnext( tail\
    \ );\n                        }\n\n\n                        DEBUG_TRIE_COMPILE_r({\n\
    \                            regprop(RExC_rx, RExC_mysv, tail, NULL, pRExC_state);\n\
    \                            Perl_re_indentf( aTHX_  \"%s %\" UVuf \":%s\\n\"\
    ,\n                              depth+1,\n                              \"Looking\
    \ for TRIE'able sequences. Tail node is \",\n                              (UV)\
    \ REGNODE_OFFSET(tail),\n                              SvPV_nolen_const( RExC_mysv\
    \ )\n                            );\n                        });\n\n         \
    \               /*\n\n                            Step through the branches\n\
    \                                cur represents each branch,\n               \
    \                 noper is the first thing to be matched as part\n           \
    \                           of that branch\n                                noper_next\
    \ is the regnext() of that node.\n\n                            We normally handle\
    \ a case like this\n                            /FOO[xyz]|BAR[pqr]/ via a \"jump\
    \ trie\" but we also\n                            support building with NOJUMPTRIE,\
    \ which restricts\n                            the trie logic to structures like\
    \ /FOO|BAR/.\n\n                            If noper is a trieable nodetype then\
    \ the branch is\n                            a possible optimization target. If\
    \ we are building\n                            under NOJUMPTRIE then we require\
    \ that noper_next is\n                            the same as scan (our current\
    \ position in the regex\n                            program).\n\n           \
    \                 Once we have two or more consecutive such branches\n       \
    \                     we can create a trie of the EXACT's contents and\n     \
    \                       stitch it in place into the program.\n\n             \
    \               If the sequence represents all of the branches in\n          \
    \                  the alternation we replace the entire thing with a\n      \
    \                      single TRIE node.\n\n                            Otherwise\
    \ when it is a subsequence we need to\n                            stitch it in\
    \ place and replace only the relevant\n                            branches. This\
    \ means the first branch has to remain\n                            as it is used\
    \ by the alternation logic, and its\n                            next pointer,\
    \ and needs to be repointed at the item\n                            on the branch\
    \ chain following the last branch we\n                            have optimized\
    \ away.\n\n                            This could be either a BRANCH, in which\
    \ case the\n                            subsequence is internal, or it could be\
    \ the item\n                            following the branch sequence in which\
    \ case the\n                            subsequence is at the end (which does\
    \ not\n                            necessarily mean the first node is the start\
    \ of the\n                            alternation).\n\n                      \
    \      TRIE_TYPE(X) is a define which maps the optype to a\n                 \
    \           trietype.\n\n                                optype          |  trietype\n\
    \                                ----------------+-----------\n              \
    \                  NOTHING         | NOTHING\n                               \
    \ EXACT           | EXACT\n                                EXACT_ONLY8     | EXACT\n\
    \                                EXACTFU         | EXACTFU\n                 \
    \               EXACTFU_ONLY8   | EXACTFU\n                                EXACTFUP\
    \        | EXACTFU\n                                EXACTFAA        | EXACTFAA\n\
    \                                EXACTL          | EXACTL\n                  \
    \              EXACTFLU8       | EXACTFLU8\n\n\n                        */\n#define\
    \ TRIE_TYPE(X) ( ( NOTHING == (X) )                                   \\\n   \
    \                    ? NOTHING                                            \\\n\
    \                       : ( EXACT == (X) || EXACT_ONLY8 == (X) )             \\\
    \n                         ? EXACT                                           \
    \ \\\n                         : (     EXACTFU == (X)                        \
    \     \\\n                              || EXACTFU_ONLY8 == (X)              \
    \         \\\n                              || EXACTFUP == (X) )             \
    \             \\\n                           ? EXACTFU                       \
    \                 \\\n                           : ( EXACTFAA == (X) )       \
    \                     \\\n                             ? EXACTFAA            \
    \                         \\\n                             : ( EXACTL == (X) )\
    \                            \\\n                               ? EXACTL     \
    \                                \\\n                               : ( EXACTFLU8\
    \ == (X) )                       \\\n                                 ? EXACTFLU8\
    \                                \\\n                                 : 0 )\n\n\
    \                        /* dont use tail as the end marker for this traverse\
    \ */\n                        for ( cur = startbranch ; cur != scan ; cur = regnext(\
    \ cur ) ) {\n                            regnode * const noper = NEXTOPER( cur\
    \ );\n                            U8 noper_type = OP( noper );\n             \
    \               U8 noper_trietype = TRIE_TYPE( noper_type );\n#if defined(DEBUGGING)\
    \ || defined(NOJUMPTRIE)\n                            regnode * const noper_next\
    \ = regnext( noper );\n                            U8 noper_next_type = (noper_next\
    \ && noper_next < tail) ? OP(noper_next) : 0;\n                            U8\
    \ noper_next_trietype = (noper_next && noper_next < tail) ? TRIE_TYPE( noper_next_type\
    \ ) :0;\n#endif\n\n                            DEBUG_TRIE_COMPILE_r({\n      \
    \                          regprop(RExC_rx, RExC_mysv, cur, NULL, pRExC_state);\n\
    \                                Perl_re_indentf( aTHX_  \"- %d:%s (%d)\",\n \
    \                                  depth+1,\n                                \
    \   REG_NODE_NUM(cur), SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur) );\n\n\
    \                                regprop(RExC_rx, RExC_mysv, noper, NULL, pRExC_state);\n\
    \                                Perl_re_printf( aTHX_  \" -> %d:%s\",\n     \
    \                               REG_NODE_NUM(noper), SvPV_nolen_const(RExC_mysv));\n\
    \n                                if ( noper_next ) {\n                      \
    \            regprop(RExC_rx, RExC_mysv, noper_next, NULL, pRExC_state);\n   \
    \                               Perl_re_printf( aTHX_ \"\\t=> %d:%s\\t\",\n  \
    \                                  REG_NODE_NUM(noper_next), SvPV_nolen_const(RExC_mysv));\n\
    \                                }\n                                Perl_re_printf(\
    \ aTHX_  \"(First==%d,Last==%d,Cur==%d,tt==%s,ntt==%s,nntt==%s)\\n\",\n      \
    \                             REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \t\t\t\t   PL_reg_name[trietype], PL_reg_name[noper_trietype], PL_reg_name[noper_next_trietype]\n\
    \t\t\t\t);\n                            });\n\n                            /*\
    \ Is noper a trieable nodetype that can be merged\n                          \
    \   * with the current trie (if there is one)? */\n                          \
    \  if ( noper_trietype\n                                  &&\n               \
    \                   (\n                                        ( noper_trietype\
    \ == NOTHING )\n                                        || ( trietype == NOTHING\
    \ )\n                                        || ( trietype == noper_trietype )\n\
    \                                  )\n#ifdef NOJUMPTRIE\n                    \
    \              && noper_next >= tail\n#endif\n                               \
    \   && count < U16_MAX)\n                            {\n                     \
    \           /* Handle mergable triable node Either we are\n                  \
    \               * the first node in a new trieable sequence,\n               \
    \                  * in which case we do some bookkeeping,\n                 \
    \                * otherwise we update the end pointer. */\n                 \
    \               if ( !first ) {\n                                    first = cur;\n\
    \t\t\t\t    if ( noper_trietype == NOTHING ) {\n#if !defined(DEBUGGING) && !defined(NOJUMPTRIE)\n\
    \t\t\t\t\tregnode * const noper_next = regnext( noper );\n                   \
    \                     U8 noper_next_type = (noper_next && noper_next < tail) ?\
    \ OP(noper_next) : 0;\n\t\t\t\t\tU8 noper_next_trietype = noper_next_type ? TRIE_TYPE(\
    \ noper_next_type ) :0;\n#endif\n\n                                        if\
    \ ( noper_next_trietype ) {\n\t\t\t\t\t    trietype = noper_next_trietype;\n \
    \                                       } else if (noper_next_type)  {\n     \
    \                                       /* a NOTHING regop is 1 regop wide.\n\
    \                                             * We need at least two for a trie\n\
    \                                             * so we can't merge this in */\n\
    \                                            first = NULL;\n                 \
    \                       }\n                                    } else {\n    \
    \                                    trietype = noper_trietype;\n            \
    \                        }\n                                } else {\n       \
    \                             if ( trietype == NOTHING )\n                   \
    \                     trietype = noper_trietype;\n                           \
    \         last = cur;\n                                }\n\t\t\t\tif (first)\n\
    \t\t\t\t    count++;\n                            } /* end handle mergable triable\
    \ node */\n                            else {\n                              \
    \  /* handle unmergable node -\n                                 * noper may either\
    \ be a triable node which can\n                                 * not be tried\
    \ together with the current trie,\n                                 * or a non\
    \ triable node */\n                                if ( last ) {\n           \
    \                         /* If last is set and trietype is not\n            \
    \                         * NOTHING then we have found at least two\n        \
    \                             * triable branch sequences in a row of a\n     \
    \                                * similar trietype so we can turn them\n    \
    \                                 * into a trie. If/when we allow NOTHING to\n\
    \                                     * start a trie sequence this condition\n\
    \                                     * will be required, and it isn't expensive\n\
    \                                     * so we leave it in for now. */\n      \
    \                              if ( trietype && trietype != NOTHING )\n      \
    \                                  make_trie( pRExC_state,\n                 \
    \                               startbranch, first, cur, tail,\n             \
    \                                   count, trietype, depth+1 );\n            \
    \                        last = NULL; /* note: we clear/update\n             \
    \                                       first, trietype etc below,\n         \
    \                                           so we dont do it here */\n       \
    \                         }\n                                if ( noper_trietype\n\
    #ifdef NOJUMPTRIE\n                                     && noper_next >= tail\n\
    #endif\n                                ){\n                                 \
    \   /* noper is triable, so we can start a new\n                             \
    \        * trie sequence */\n                                    count = 1;\n\
    \                                    first = cur;\n                          \
    \          trietype = noper_trietype;\n                                } else\
    \ if (first) {\n                                    /* if we already saw a first\
    \ but the\n                                     * current node is not triable\
    \ then we have\n                                     * to reset the first information.\
    \ */\n                                    count = 0;\n                       \
    \             first = NULL;\n                                    trietype = 0;\n\
    \                                }\n                            } /* end handle\
    \ unmergable node */\n                        } /* loop over branches */\n   \
    \                     DEBUG_TRIE_COMPILE_r({\n                            regprop(RExC_rx,\
    \ RExC_mysv, cur, NULL, pRExC_state);\n                            Perl_re_indentf(\
    \ aTHX_  \"- %s (%d) <SCAN FINISHED> \",\n                              depth+1,\
    \ SvPV_nolen_const( RExC_mysv ), REG_NODE_NUM(cur));\n                       \
    \     Perl_re_printf( aTHX_  \"(First==%d, Last==%d, Cur==%d, tt==%s)\\n\",\n\
    \                               REG_NODE_NUM(first), REG_NODE_NUM(last), REG_NODE_NUM(cur),\n\
    \                               PL_reg_name[trietype]\n                      \
    \      );\n\n                        });\n                        if ( last &&\
    \ trietype ) {\n                            if ( trietype != NOTHING ) {\n   \
    \                             /* the last branch of the sequence was part of\n\
    \                                 * a trie, so we have to construct it here\n\
    \                                 * outside of the loop */\n                 \
    \               made= make_trie( pRExC_state, startbranch,\n                 \
    \                                first, scan, tail, count,\n                 \
    \                                trietype, depth+1 );\n#ifdef TRIE_STUDY_OPT\n\
    \                                if ( ((made == MADE_EXACT_TRIE &&\n         \
    \                            startbranch == first)\n                         \
    \            || ( first_non_open == first )) &&\n                            \
    \         depth==0 ) {\n                                    flags |= SCF_TRIE_RESTUDY;\n\
    \                                    if ( startbranch == first\n             \
    \                            && scan >= tail )\n                             \
    \       {\n                                        RExC_seen &=~REG_TOP_LEVEL_BRANCHES_SEEN;\n\
    \                                    }\n                                }\n#endif\n\
    \                            } else {\n                                /* at this\
    \ point we know whatever we have is a\n                                 * NOTHING\
    \ sequence/branch AND if 'startbranch'\n                                 * is\
    \ 'first' then we can turn the whole thing\n                                 *\
    \ into a NOTHING\n                                 */\n                      \
    \          if ( startbranch == first ) {\n                                   \
    \ regnode *opt;\n                                    /* the entire thing is a\
    \ NOTHING sequence,\n                                     * something like this:\
    \ (?:|) So we can\n                                     * turn it into a plain\
    \ NOTHING op. */\n                                    DEBUG_TRIE_COMPILE_r({\n\
    \                                        regprop(RExC_rx, RExC_mysv, cur, NULL,\
    \ pRExC_state);\n                                        Perl_re_indentf( aTHX_\
    \  \"- %s (%d) <NOTHING BRANCH SEQUENCE>\\n\",\n                             \
    \             depth+1,\n                                          SvPV_nolen_const(\
    \ RExC_mysv ), REG_NODE_NUM(cur));\n\n                                    });\n\
    \                                    OP(startbranch)= NOTHING;\n             \
    \                       NEXT_OFF(startbranch)= tail - startbranch;\n         \
    \                           for ( opt= startbranch + 1; opt < tail ; opt++ )\n\
    \                                        OP(opt)= OPTIMIZED;\n               \
    \                 }\n                            }\n                        }\
    \ /* end if ( last) */\n                    } /* TRIE_MAXBUF is non zero */\n\n\
    \                } /* do trie */\n\n\t    }\n\t    else if ( code == BRANCHJ )\
    \ {  /* single branch is optimized. */\n\t\tscan = NEXTOPER(NEXTOPER(scan));\n\
    \t    } else\t\t\t/* single branch is optimized. */\n\t\tscan = NEXTOPER(scan);\n\
    \t    continue;\n        } else if (OP(scan) == SUSPEND || OP(scan) == GOSUB)\
    \ {\n            I32 paren = 0;\n            regnode *start = NULL;\n        \
    \    regnode *end = NULL;\n            U32 my_recursed_depth= recursed_depth;\n\
    \n            if (OP(scan) != SUSPEND) { /* GOSUB */\n                /* Do setup,\
    \ note this code has side effects beyond\n                 * the rest of this\
    \ block. Specifically setting\n                 * RExC_recurse[] must happen at\
    \ least once during\n                 * study_chunk(). */\n                paren\
    \ = ARG(scan);\n                RExC_recurse[ARG2L(scan)] = scan;\n          \
    \      start = REGNODE_p(RExC_open_parens[paren]);\n                end   = REGNODE_p(RExC_close_parens[paren]);\n\
    \n                /* NOTE we MUST always execute the above code, even\n      \
    \           * if we do nothing with a GOSUB */\n                if (\n       \
    \             ( flags & SCF_IN_DEFINE )\n                    ||\n            \
    \        (\n                        (is_inf_internal || is_inf || (data && data->flags\
    \ & SF_IS_INF))\n                        &&\n                        ( (flags\
    \ & (SCF_DO_STCLASS | SCF_DO_SUBSTR)) == 0 )\n                    )\n        \
    \        ) {\n                    /* no need to do anything here if we are in\
    \ a define. */\n                    /* or we are after some kind of infinite construct\n\
    \                     * so we can skip recursing into this item.\n           \
    \          * Since it is infinite we will not change the maxlen\n            \
    \         * or delta, and if we miss something that might raise\n            \
    \         * the minlen it will merely pessimise a little.\n                  \
    \   *\n                     * Iow /(?(DEFINE)(?<foo>foo|food))a+(?&foo)/\n   \
    \                  * might result in a minlen of 1 and not of 4,\n           \
    \          * but this doesn't make us mismatch, just try a bit\n             \
    \        * harder than we should.\n                     * */\n               \
    \     scan= regnext(scan);\n                    continue;\n                }\n\
    \n                if (\n                    !recursed_depth\n                \
    \    ||\n                    !PAREN_TEST(RExC_study_chunk_recursed + ((recursed_depth-1)\
    \ * RExC_study_chunk_recursed_bytes), paren)\n                ) {\n          \
    \          /* it is quite possible that there are more efficient ways\n      \
    \               * to do this. We maintain a bitmap per level of recursion\n  \
    \                   * of which patterns we have entered so we can detect if a\n\
    \                     * pattern creates a possible infinite loop. When we\n  \
    \                   * recurse down a level we copy the previous levels bitmap\n\
    \                     * down. When we are at recursion level 0 we zero the top\n\
    \                     * level bitmap. It would be nice to implement a different\n\
    \                     * more efficient way of doing this. In particular the top\n\
    \                     * level bitmap may be unnecessary.\n                   \
    \  */\n                    if (!recursed_depth) {\n                        Zero(RExC_study_chunk_recursed,\
    \ RExC_study_chunk_recursed_bytes, U8);\n                    } else {\n      \
    \                  Copy(RExC_study_chunk_recursed + ((recursed_depth-1) * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed + (recursed_depth * RExC_study_chunk_recursed_bytes),\n\
    \                             RExC_study_chunk_recursed_bytes, U8);\n        \
    \            }\n                    /* we havent recursed into this paren yet,\
    \ so recurse into it */\n                    DEBUG_STUDYDATA(\"gosub-set\", data,\
    \ depth, is_inf);\n                    PAREN_SET(RExC_study_chunk_recursed + (recursed_depth\
    \ * RExC_study_chunk_recursed_bytes), paren);\n                    my_recursed_depth=\
    \ recursed_depth + 1;\n                } else {\n                    DEBUG_STUDYDATA(\"\
    gosub-inf\", data, depth, is_inf);\n                    /* some form of infinite\
    \ recursion, assume infinite length\n                     * */\n             \
    \       if (flags & SCF_DO_SUBSTR) {\n                        scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n                        data->cur_is_floating = 1;\n\
    \                    }\n                    is_inf = is_inf_internal = 1;\n  \
    \                  if (flags & SCF_DO_STCLASS_OR) /* Allow everything */\n   \
    \                     ssc_anything(data->start_class);\n                    flags\
    \ &= ~SCF_DO_STCLASS;\n\n                    start= NULL; /* reset start so we\
    \ dont recurse later on. */\n\t        }\n            } else {\n\t        paren\
    \ = stopparen;\n                start = scan + 2;\n\t        end = regnext(scan);\n\
    \t    }\n            if (start) {\n                scan_frame *newframe;\n   \
    \             assert(end);\n                if (!RExC_frame_last) {\n        \
    \            Newxz(newframe, 1, scan_frame);\n                    SAVEDESTRUCTOR_X(S_unwind_scan_frames,\
    \ newframe);\n                    RExC_frame_head= newframe;\n               \
    \     RExC_frame_count++;\n                } else if (!RExC_frame_last->next_frame)\
    \ {\n                    Newxz(newframe, 1, scan_frame);\n                   \
    \ RExC_frame_last->next_frame= newframe;\n                    newframe->prev_frame=\
    \ RExC_frame_last;\n                    RExC_frame_count++;\n                }\
    \ else {\n                    newframe= RExC_frame_last->next_frame;\n       \
    \         }\n                RExC_frame_last= newframe;\n\n                newframe->next_regnode\
    \ = regnext(scan);\n                newframe->last_regnode = last;\n         \
    \       newframe->stopparen = stopparen;\n                newframe->prev_recursed_depth\
    \ = recursed_depth;\n                newframe->this_prev_frame= frame;\n     \
    \           newframe->in_gosub = (\n                    (frame && frame->in_gosub)\
    \ || OP(scan) == GOSUB\n                );\n\n                DEBUG_STUDYDATA(\"\
    frame-new\", data, depth, is_inf);\n                DEBUG_PEEP(\"fnew\", scan,\
    \ depth, flags);\n\n\t        frame = newframe;\n\t        scan =  start;\n\t\
    \        stopparen = paren;\n\t        last = end;\n                depth = depth\
    \ + 1;\n                recursed_depth= my_recursed_depth;\n\n\t        continue;\n\
    \t    }\n\t}\n\telse if (   OP(scan) == EXACT\n                 || OP(scan) ==\
    \ EXACT_ONLY8\n                 || OP(scan) == EXACTL)\n        {\n\t    SSize_t\
    \ l = STR_LEN(scan);\n\t    UV uc;\n            assert(l);\n\t    if (UTF) {\n\
    \t\tconst U8 * const s = (U8*)STRING(scan);\n\t\tuc = utf8_to_uvchr_buf(s, s +\
    \ l, NULL);\n\t\tl = utf8_length(s, s + l);\n\t    } else {\n\t\tuc = *((U8*)STRING(scan));\n\
    \t    }\n\t    min += l;\n\t    if (flags & SCF_DO_SUBSTR) { /* Update longest\
    \ substr. */\n\t\t/* The code below prefers earlier match for fixed\n\t\t   offset,\
    \ later match for variable offset.  */\n\t\tif (data->last_end == -1) { /* Update\
    \ the start info. */\n\t\t    data->last_start_min = data->pos_min;\n \t\t   \
    \ data->last_start_max = is_inf\n \t\t\t? SSize_t_MAX : data->pos_min + data->pos_delta;\n\
    \t\t}\n\t\tsv_catpvn(data->last_found, STRING(scan), STR_LEN(scan));\n\t\tif (UTF)\n\
    \t\t    SvUTF8_on(data->last_found);\n\t\t{\n\t\t    SV * const sv = data->last_found;\n\
    \t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\tmg_find(sv, PERL_MAGIC_utf8)\
    \ : NULL;\n\t\t    if (mg && mg->mg_len >= 0)\n\t\t\tmg->mg_len += utf8_length((U8*)STRING(scan),\n\
    \                                              (U8*)STRING(scan)+STR_LEN(scan));\n\
    \t\t}\n\t\tdata->last_end = data->pos_min + l;\n\t\tdata->pos_min += l; /* As\
    \ in the first entry. */\n\t\tdata->flags &= ~SF_BEFORE_EOL;\n\t    }\n\n    \
    \        /* ANDing the code point leaves at most it, and not in locale, and\n\
    \             * can't match null string */\n\t    if (flags & SCF_DO_STCLASS_AND)\
    \ {\n                ssc_cp_and(data->start_class, uc);\n                ANYOF_FLAGS(data->start_class)\
    \ &= ~SSC_MATCHES_EMPTY_STRING;\n                ssc_clear_locale(data->start_class);\n\
    \t    }\n\t    else if (flags & SCF_DO_STCLASS_OR) {\n                ssc_add_cp(data->start_class,\
    \ uc);\n\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \t    }\n\t    flags &= ~SCF_DO_STCLASS;\n\t}\n        else if (PL_regkind[OP(scan)]\
    \ == EXACT) {\n            /* But OP != EXACT!, so is EXACTFish */\n\t    SSize_t\
    \ l = STR_LEN(scan);\n            const U8 * s = (U8*)STRING(scan);\n\n\t    /*\
    \ Search for fixed substrings supports EXACT only. */\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n\t\tassert(data);\n                scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t    }\n\t    if (UTF) {\n\t\tl = utf8_length(s, s + l);\n\t    }\n\
    \t    if (unfolded_multi_char) {\n                RExC_seen |= REG_UNFOLDED_MULTI_SEEN;\n\
    \t    }\n\t    min += l - min_subtract;\n            assert (min >= 0);\n    \
    \        delta += min_subtract;\n\t    if (flags & SCF_DO_SUBSTR) {\n\t\tdata->pos_min\
    \ += l - min_subtract;\n\t\tif (data->pos_min < 0) {\n                    data->pos_min\
    \ = 0;\n                }\n                data->pos_delta += min_subtract;\n\t\
    \tif (min_subtract) {\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\
    \t    }\n\n            if (flags & SCF_DO_STCLASS) {\n                SV* EXACTF_invlist\
    \ = _make_exactf_invlist(pRExC_state, scan);\n\n                assert(EXACTF_invlist);\n\
    \                if (flags & SCF_DO_STCLASS_AND) {\n                    if (OP(scan)\
    \ != EXACTFL)\n                        ssc_clear_locale(data->start_class);\n\
    \                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                    ANYOF_POSIXL_ZERO(data->start_class);\n                 \
    \   ssc_intersection(data->start_class, EXACTF_invlist, FALSE);\n            \
    \    }\n                else {  /* SCF_DO_STCLASS_OR */\n                    ssc_union(data->start_class,\
    \ EXACTF_invlist, FALSE);\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\n                    /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a\
    \ */\n                    ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n                flags &= ~SCF_DO_STCLASS;\n              \
    \  SvREFCNT_dec(EXACTF_invlist);\n            }\n\t}\n\telse if (REGNODE_VARIES(OP(scan)))\
    \ {\n\t    SSize_t mincount, maxcount, minnext, deltanext, pos_before = 0;\n\t\
    \    I32 fl = 0, f = flags;\n\t    regnode * const oscan = scan;\n\t    regnode_ssc\
    \ this_class;\n\t    regnode_ssc *oclass = NULL;\n\t    I32 next_is_eval = 0;\n\
    \n\t    switch (PL_regkind[OP(scan)]) {\n\t    case WHILEM:\t\t/* End of (?:...)*\
    \ . */\n\t\tscan = NEXTOPER(scan);\n\t\tgoto finish;\n\t    case PLUS:\n\t\tif\
    \ (flags & (SCF_DO_SUBSTR | SCF_DO_STCLASS)) {\n\t\t    next = NEXTOPER(scan);\n\
    \t\t    if (   OP(next) == EXACT\n                        || OP(next) == EXACT_ONLY8\n\
    \                        || OP(next) == EXACTL\n                        || (flags\
    \ & SCF_DO_STCLASS))\n                    {\n\t\t\tmincount = 1;\n\t\t\tmaxcount\
    \ = REG_INFTY;\n\t\t\tnext = regnext(scan);\n\t\t\tscan = NEXTOPER(scan);\n\t\t\
    \tgoto do_curly;\n\t\t    }\n\t\t}\n\t\tif (flags & SCF_DO_SUBSTR)\n\t\t    data->pos_min++;\n\
    \t\tmin++;\n\t\t/* FALLTHROUGH */\n\t    case STAR:\n                next = NEXTOPER(scan);\n\
    \n                /* This temporary node can now be turned into EXACTFU, and\n\
    \                 * must, as regexec.c doesn't handle it */\n                if\
    \ (OP(next) == EXACTFU_S_EDGE && mutate_ok) {\n                    OP(next) =\
    \ EXACTFU;\n                }\n\n                if (     STR_LEN(next) == 1\n\
    \                    &&   isALPHA_A(* STRING(next))\n                    && (\
    \         OP(next) == EXACTFAA\n                        || (     OP(next) == EXACTFU\n\
    \                            && ! HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(* STRING(next))))\n\
    \                    &&   mutate_ok\n                ) {\n                   \
    \ /* These differ in just one bit */\n                    U8 mask = ~ ('A' ^ 'a');\n\
    \n                    assert(isALPHA_A(* STRING(next)));\n\n                 \
    \   /* Then replace it by an ANYOFM node, with\n                    * the mask\
    \ set to the complement of the\n                    * bit that differs between\
    \ upper and lower\n                    * case, and the lowest code point of the\n\
    \                    * pair (which the '&' forces) */\n                    OP(next)\
    \ = ANYOFM;\n                    ARG_SET(next, *STRING(next) & mask);\n      \
    \              FLAGS(next) = mask;\n                }\n\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    mincount = 0;\n\t\t    maxcount = REG_INFTY;\n\t\t    next = regnext(scan);\n\
    \t\t    scan = NEXTOPER(scan);\n\t\t    goto do_curly;\n\t\t}\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n                    /* Cannot extend fixed substrings */\n\t\t   \
    \ data->cur_is_floating = 1; /* float */\n\t\t}\n                is_inf = is_inf_internal\
    \ = 1;\n                scan = regnext(scan);\n\t\tgoto optimize_curly_tail;\n\
    \t    case CURLY:\n\t        if (stopparen>0 && (OP(scan)==CURLYN || OP(scan)==CURLYM)\n\
    \t            && (scan->flags == stopparen))\n\t\t{\n\t\t    mincount = 1;\n\t\
    \t    maxcount = 1;\n\t\t} else {\n\t\t    mincount = ARG1(scan);\n\t\t    maxcount\
    \ = ARG2(scan);\n\t\t}\n\t\tnext = regnext(scan);\n\t\tif (OP(scan) == CURLYX)\
    \ {\n\t\t    I32 lp = (data ? *(data->last_closep) : 0);\n\t\t    scan->flags\
    \ = ((lp <= (I32)U8_MAX) ? (U8)lp : U8_MAX);\n\t\t}\n\t\tscan = NEXTOPER(scan)\
    \ + EXTRA_STEP_2ARGS;\n\t\tnext_is_eval = (OP(scan) == EVAL);\n\t      do_curly:\n\
    \t\tif (flags & SCF_DO_SUBSTR) {\n                    if (mincount == 0)\n   \
    \                     scan_commit(pRExC_state, data, minlenp, is_inf);\n     \
    \               /* Cannot extend fixed substrings */\n\t\t    pos_before = data->pos_min;\n\
    \t\t}\n\t\tif (data) {\n\t\t    fl = data->flags;\n\t\t    data->flags &= ~(SF_HAS_PAR|SF_IN_PAR|SF_HAS_EVAL);\n\
    \t\t    if (is_inf)\n\t\t\tdata->flags |= SF_IS_INF;\n\t\t}\n\t\tif (flags & SCF_DO_STCLASS)\
    \ {\n\t\t    ssc_init(pRExC_state, &this_class);\n\t\t    oclass = data->start_class;\n\
    \t\t    data->start_class = &this_class;\n\t\t    f |= SCF_DO_STCLASS_AND;\n\t\
    \t    f &= ~SCF_DO_STCLASS_OR;\n\t\t}\n\t        /* Exclude from super-linear\
    \ cache processing any {n,m}\n\t\t   regops for which the combination of input\
    \ pos and regex\n\t\t   pos is not enough information to determine if a match\n\
    \t\t   will be possible.\n\n\t\t   For example, in the regex /foo(bar\\s*){4,8}baz/\
    \ with the\n\t\t   regex pos at the \\s*, the prospects for a match depend not\n\
    \t\t   only on the input position but also on how many (bar\\s*)\n\t\t   repeats\
    \ into the {4,8} we are. */\n               if ((mincount > 1) || (maxcount >\
    \ 1 && maxcount != REG_INFTY))\n\t\t    f &= ~SCF_WHILEM_VISITED_POS;\n\n\t\t\
    /* This will finish on WHILEM, setting scan, or on NULL: */\n                /*\
    \ recurse study_chunk() on loop bodies */\n\t\tminnext = study_chunk(pRExC_state,\
    \ &scan, minlenp, &deltanext,\n                                  last, data, stopparen,\
    \ recursed_depth, NULL,\n                                  (mincount == 0\n  \
    \                                 ? (f & ~SCF_DO_SUBSTR)\n                   \
    \                : f)\n                                  , depth+1, mutate_ok);\n\
    \n\t\tif (flags & SCF_DO_STCLASS)\n\t\t    data->start_class = oclass;\n\t\tif\
    \ (mincount == 0 || minnext == 0) {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\
    \t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND) {\n\t\t\t/* Switch to\
    \ OR mode: cache the old value of\n\t\t\t * data->start_class */\n\t\t\tINIT_AND_WITHP;\n\
    \t\t\tStructCopy(data->start_class, and_withp, regnode_ssc);\n\t\t\tflags &= ~SCF_DO_STCLASS_AND;\n\
    \t\t\tStructCopy(&this_class, data->start_class, regnode_ssc);\n\t\t\tflags |=\
    \ SCF_DO_STCLASS_OR;\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n\t\t} else {\t\t/* Non-zero len */\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ {\n\t\t\tssc_or(pRExC_state, data->start_class, (regnode_charclass *) &this_class);\n\
    \t\t\tssc_and(pRExC_state, data->start_class, (regnode_charclass *) and_withp);\n\
    \t\t    }\n\t\t    else if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &this_class);\n\t\t    flags &= ~SCF_DO_STCLASS;\n\
    \t\t}\n\t\tif (!scan) \t\t/* It was not CURLYX, but CURLY. */\n\t\t    scan =\
    \ next;\n\t\tif (((flags & (SCF_TRIE_DOING_RESTUDY|SCF_DO_SUBSTR))==SCF_DO_SUBSTR)\n\
    \t\t    /* ? quantifier ok, except for (?{ ... }) */\n\t\t    && (next_is_eval\
    \ || !(mincount == 0 && maxcount == 1))\n\t\t    && (minnext == 0) && (deltanext\
    \ == 0)\n\t\t    && data && !(data->flags & (SF_HAS_PAR|SF_IN_PAR))\n        \
    \            && maxcount <= REG_INFTY/3) /* Complement check for big\n       \
    \                                            count */\n\t\t{\n\t\t    _WARN_HELPER(RExC_precomp_end,\
    \ packWARN(WARN_REGEXP),\n                        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP),\n\
    \                            \"Quantifier unexpected on zero-length expression\
    \ \"\n                            \"in regex m/%\" UTF8f \"/\",\n\t\t\t     UTF8fARG(UTF,\
    \ RExC_precomp_end - RExC_precomp,\n\t\t\t\t  RExC_precomp)));\n             \
    \   }\n\n                if ( ( minnext > 0 && mincount >= SSize_t_MAX / minnext\
    \ )\n                    || min >= SSize_t_MAX - minnext * mincount )\n      \
    \          {\n                    FAIL(\"Regexp out of space\");\n           \
    \     }\n\n\t\tmin += minnext * mincount;\n\t\tis_inf_internal |= deltanext ==\
    \ SSize_t_MAX\n                         || (maxcount == REG_INFTY && minnext +\
    \ deltanext > 0);\n\t\tis_inf |= is_inf_internal;\n                if (is_inf)\
    \ {\n\t\t    delta = SSize_t_MAX;\n                } else {\n\t\t    delta +=\
    \ (minnext + deltanext) * maxcount\n                             - minnext * mincount;\n\
    \                }\n\t\t/* Try powerful optimization CURLYX => CURLYN. */\n\t\t\
    if (  OP(oscan) == CURLYX && data\n\t\t      && data->flags & SF_IN_PAR\n\t\t\
    \      && !(data->flags & SF_HAS_EVAL)\n\t\t      && !deltanext && minnext ==\
    \ 1\n                      && mutate_ok\n                ) {\n\t\t    /* Try to\
    \ optimize to CURLYN.  */\n\t\t    regnode *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS;\n\
    \t\t    regnode * const nxt1 = nxt;\n#ifdef DEBUGGING\n\t\t    regnode *nxt2;\n\
    #endif\n\n\t\t    /* Skip open. */\n\t\t    nxt = regnext(nxt);\n\t\t    if (!REGNODE_SIMPLE(OP(nxt))\n\
    \t\t\t&& !(PL_regkind[OP(nxt)] == EXACT\n\t\t\t     && STR_LEN(nxt) == 1))\n\t\
    \t\tgoto nogo;\n#ifdef DEBUGGING\n\t\t    nxt2 = nxt;\n#endif\n\t\t    nxt = regnext(nxt);\n\
    \t\t    if (OP(nxt) != CLOSE)\n\t\t\tgoto nogo;\n\t\t    if (RExC_open_parens)\
    \ {\n\n                        /*open->CURLYM*/\n                        RExC_open_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(oscan);\n\n                        /*close->while*/\n     \
    \                   RExC_close_parens[ARG(nxt1)] = REGNODE_OFFSET(nxt) + 2;\n\t\
    \t    }\n\t\t    /* Now we know that nxt2 is the only contents: */\n\t\t    oscan->flags\
    \ = (U8)ARG(nxt);\n\t\t    OP(oscan) = CURLYN;\n\t\t    OP(nxt1) = NOTHING;\t\
    /* was OPEN. */\n\n#ifdef DEBUGGING\n\t\t    OP(nxt1 + 1) = OPTIMIZED; /* was\
    \ count. */\n\t\t    NEXT_OFF(nxt1+ 1) = 0; /* just for consistency. */\n\t\t\
    \    NEXT_OFF(nxt2) = 0;\t/* just for consistency with CURLY. */\n\t\t    OP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\t\t    OP(nxt + 1) = OPTIMIZED; /* was count.\
    \ */\n\t\t    NEXT_OFF(nxt+ 1) = 0; /* just for consistency. */\n#endif\n\t\t\
    }\n\t      nogo:\n\n\t\t/* Try optimization CURLYX => CURLYM. */\n\t\tif (  OP(oscan)\
    \ == CURLYX && data\n\t\t      && !(data->flags & SF_HAS_PAR)\n\t\t      && !(data->flags\
    \ & SF_HAS_EVAL)\n\t\t      && !deltanext\t/* atom is fixed width */\n\t\t   \
    \   && minnext != 0\t/* CURLYM can't handle zero width */\n                  \
    \       /* Nor characters whose fold at run-time may be\n                    \
    \      * multi-character */\n                      && ! (RExC_seen & REG_UNFOLDED_MULTI_SEEN)\n\
    \                      && mutate_ok\n\t\t) {\n\t\t    /* XXXX How to optimize\
    \ if data == 0? */\n\t\t    /* Optimize to a simpler form.  */\n\t\t    regnode\
    \ *nxt = NEXTOPER(oscan) + EXTRA_STEP_2ARGS; /* OPEN */\n\t\t    regnode *nxt2;\n\
    \n\t\t    OP(oscan) = CURLYM;\n\t\t    while ( (nxt2 = regnext(nxt)) /* skip over\
    \ embedded stuff*/\n\t\t\t    && (OP(nxt2) != WHILEM))\n\t\t\tnxt = nxt2;\n\t\t\
    \    OP(nxt2)  = SUCCEED; /* Whas WHILEM */\n\t\t    /* Need to optimize away\
    \ parenths. */\n\t\t    if ((data->flags & SF_IN_PAR) && OP(nxt) == CLOSE) {\n\
    \t\t\t/* Set the parenth number.  */\n\t\t\tregnode *nxt1 = NEXTOPER(oscan) +\
    \ EXTRA_STEP_2ARGS; /* OPEN*/\n\n\t\t\toscan->flags = (U8)ARG(nxt);\n\t\t\tif\
    \ (RExC_open_parens) {\n                             /*open->CURLYM*/\n      \
    \                      RExC_open_parens[ARG(nxt1)] = REGNODE_OFFSET(oscan);\n\n\
    \                            /*close->NOTHING*/\n                            RExC_close_parens[ARG(nxt1)]\
    \ = REGNODE_OFFSET(nxt2)\n                                                   \
    \      + 1;\n\t\t\t}\n\t\t\tOP(nxt1) = OPTIMIZED;\t/* was OPEN. */\n\t\t\tOP(nxt)\
    \ = OPTIMIZED;\t/* was CLOSE. */\n\n#ifdef DEBUGGING\n\t\t\tOP(nxt1 + 1) = OPTIMIZED;\
    \ /* was count. */\n\t\t\tOP(nxt + 1) = OPTIMIZED; /* was count. */\n\t\t\tNEXT_OFF(nxt1\
    \ + 1) = 0; /* just for consistency. */\n\t\t\tNEXT_OFF(nxt + 1) = 0; /* just\
    \ for consistency. */\n#endif\n#if 0\n\t\t\twhile ( nxt1 && (OP(nxt1) != WHILEM))\
    \ {\n\t\t\t    regnode *nnxt = regnext(nxt1);\n\t\t\t    if (nnxt == nxt) {\n\t\
    \t\t\tif (reg_off_by_arg[OP(nxt1)])\n\t\t\t\t    ARG_SET(nxt1, nxt2 - nxt1);\n\
    \t\t\t\telse if (nxt2 - nxt1 < U16_MAX)\n\t\t\t\t    NEXT_OFF(nxt1) = nxt2 - nxt1;\n\
    \t\t\t\telse\n\t\t\t\t    OP(nxt) = NOTHING;\t/* Cannot beautify */\n\t\t\t  \
    \  }\n\t\t\t    nxt1 = nnxt;\n\t\t\t}\n#endif\n\t\t\t/* Optimize again: */\n \
    \                       /* recurse study_chunk() on optimised CURLYX => CURLYM\
    \ */\n\t\t\tstudy_chunk(pRExC_state, &nxt1, minlenp, &deltanext, nxt,\n      \
    \                              NULL, stopparen, recursed_depth, NULL, 0,\n   \
    \                                 depth+1, mutate_ok);\n\t\t    }\n\t\t    else\n\
    \t\t\toscan->flags = 0;\n\t\t}\n\t\telse if ((OP(oscan) == CURLYX)\n\t\t\t &&\
    \ (flags & SCF_WHILEM_VISITED_POS)\n\t\t\t /* See the comment on a similar expression\
    \ above.\n\t\t\t    However, this time it's not a subexpression\n\t\t\t    we\
    \ care about, but the expression itself. */\n\t\t\t && (maxcount == REG_INFTY)\n\
    \t\t\t && data) {\n\t\t    /* This stays as CURLYX, we can put the count/of pair.\
    \ */\n\t\t    /* Find WHILEM (as in regexec.c) */\n\t\t    regnode *nxt = oscan\
    \ + NEXT_OFF(oscan);\n\n\t\t    if (OP(PREVOPER(nxt)) == NOTHING) /* LONGJMP */\n\
    \t\t\tnxt += ARG(nxt);\n                    nxt = PREVOPER(nxt);\n           \
    \         if (nxt->flags & 0xf) {\n                        /* we've already set\
    \ whilem count on this node */\n                    } else if (++data->whilem_c\
    \ < 16) {\n                        assert(data->whilem_c <= RExC_whilem_seen);\n\
    \                        nxt->flags = (U8)(data->whilem_c\n                  \
    \          | (RExC_whilem_seen << 4)); /* On WHILEM */\n                    }\n\
    \t\t}\n\t\tif (data && fl & (SF_HAS_PAR|SF_IN_PAR))\n\t\t    pars++;\n\t\tif (flags\
    \ & SCF_DO_SUBSTR) {\n\t\t    SV *last_str = NULL;\n                    STRLEN\
    \ last_chrs = 0;\n\t\t    int counted = mincount != 0;\n\n                   \
    \ if (data->last_end > 0 && mincount != 0) { /* Ends with a\n                \
    \                                                  string. */\n\t\t\tSSize_t b\
    \ = pos_before >= data->last_start_min\n\t\t\t    ? pos_before : data->last_start_min;\n\
    \t\t\tSTRLEN l;\n\t\t\tconst char * const s = SvPV_const(data->last_found, l);\n\
    \t\t\tSSize_t old = b - data->last_start_min;\n                        assert(old\
    \ >= 0);\n\n\t\t\tif (UTF)\n\t\t\t    old = utf8_hop_forward((U8*)s, old,\n  \
    \                                             (U8 *) SvEND(data->last_found))\n\
    \                                - (U8*)s;\n\t\t\tl -= old;\n\t\t\t/* Get the\
    \ added string: */\n\t\t\tlast_str = newSVpvn_utf8(s  + old, l, UTF);\n      \
    \                  last_chrs = UTF ? utf8_length((U8*)(s + old),\n           \
    \                                 (U8*)(s + old + l)) : l;\n\t\t\tif (deltanext\
    \ == 0 && pos_before == b) {\n\t\t\t    /* What was added is a constant string\
    \ */\n\t\t\t    if (mincount > 1) {\n\n\t\t\t\tSvGROW(last_str, (mincount * l)\
    \ + 1);\n\t\t\t\trepeatcpy(SvPVX(last_str) + l,\n\t\t\t\t\t  SvPVX_const(last_str),\
    \ l,\n                                          mincount - 1);\n\t\t\t\tSvCUR_set(last_str,\
    \ SvCUR(last_str) * mincount);\n\t\t\t\t/* Add additional parts. */\n\t\t\t\t\
    SvCUR_set(data->last_found,\n\t\t\t\t\t  SvCUR(data->last_found) - l);\n\t\t\t\
    \tsv_catsv(data->last_found, last_str);\n\t\t\t\t{\n\t\t\t\t    SV * sv = data->last_found;\n\
    \t\t\t\t    MAGIC *mg =\n\t\t\t\t\tSvUTF8(sv) && SvMAGICAL(sv) ?\n\t\t\t\t\tmg_find(sv,\
    \ PERL_MAGIC_utf8) : NULL;\n\t\t\t\t    if (mg && mg->mg_len >= 0)\n\t\t\t\t\t\
    mg->mg_len += last_chrs * (mincount-1);\n\t\t\t\t}\n                         \
    \       last_chrs *= mincount;\n\t\t\t\tdata->last_end += l * (mincount - 1);\n\
    \t\t\t    }\n\t\t\t} else {\n\t\t\t    /* start offset must point into the last\
    \ copy */\n\t\t\t    data->last_start_min += minnext * (mincount - 1);\n\t\t\t\
    \    data->last_start_max =\n                              is_inf\n          \
    \                     ? SSize_t_MAX\n\t\t\t       : data->last_start_max +\n \
    \                                (maxcount - 1) * (minnext + data->pos_delta);\n\
    \t\t\t}\n\t\t    }\n\t\t    /* It is counted once already... */\n\t\t    data->pos_min\
    \ += minnext * (mincount - counted);\n#if 0\nPerl_re_printf( aTHX_  \"counted=%\"\
    \ UVuf \" deltanext=%\" UVuf\n                              \" SSize_t_MAX=%\"\
    \ UVuf \" minnext=%\" UVuf\n                              \" maxcount=%\" UVuf\
    \ \" mincount=%\" UVuf \"\\n\",\n    (UV)counted, (UV)deltanext, (UV)SSize_t_MAX,\
    \ (UV)minnext, (UV)maxcount,\n    (UV)mincount);\nif (deltanext != SSize_t_MAX)\n\
    Perl_re_printf( aTHX_  \"LHS=%\" UVuf \" RHS=%\" UVuf \"\\n\",\n    (UV)(-counted\
    \ * deltanext + (minnext + deltanext) * maxcount\n          - minnext * mincount),\
    \ (UV)(SSize_t_MAX - data->pos_delta));\n#endif\n\t\t    if (deltanext == SSize_t_MAX\n\
    \                        || -counted * deltanext + (minnext + deltanext) * maxcount\
    \ - minnext * mincount >= SSize_t_MAX - data->pos_delta)\n\t\t        data->pos_delta\
    \ = SSize_t_MAX;\n\t\t    else\n\t\t        data->pos_delta += - counted * deltanext\
    \ +\n\t\t\t(minnext + deltanext) * maxcount - minnext * mincount;\n\t\t    if\
    \ (mincount != maxcount) {\n\t\t\t /* Cannot extend fixed substrings found inside\n\
    \t\t\t    the group.  */\n                        scan_commit(pRExC_state, data,\
    \ minlenp, is_inf);\n\t\t\tif (mincount && last_str) {\n\t\t\t    SV * const sv\
    \ = data->last_found;\n\t\t\t    MAGIC * const mg = SvUTF8(sv) && SvMAGICAL(sv)\
    \ ?\n\t\t\t\tmg_find(sv, PERL_MAGIC_utf8) : NULL;\n\n\t\t\t    if (mg)\n\t\t\t\
    \tmg->mg_len = -1;\n\t\t\t    sv_setsv(sv, last_str);\n\t\t\t    data->last_end\
    \ = data->pos_min;\n\t\t\t    data->last_start_min = data->pos_min - last_chrs;\n\
    \t\t\t    data->last_start_max = is_inf\n\t\t\t\t? SSize_t_MAX\n\t\t\t\t: data->pos_min\
    \ + data->pos_delta - last_chrs;\n\t\t\t}\n\t\t\tdata->cur_is_floating = 1; /*\
    \ float */\n\t\t    }\n\t\t    SvREFCNT_dec(last_str);\n\t\t}\n\t\tif (data &&\
    \ (fl & SF_HAS_EVAL))\n\t\t    data->flags |= SF_HAS_EVAL;\n\t      optimize_curly_tail:\n\
    \t\trck_elide_nothing(oscan);\n\t\tcontinue;\n\n\t    default:\n#ifdef DEBUGGING\n\
    \                Perl_croak(aTHX_ \"panic: unexpected varying REx opcode %d\"\
    ,\n                                                                    OP(scan));\n\
    #endif\n            case REF:\n            case CLUMP:\n\t\tif (flags & SCF_DO_SUBSTR)\
    \ {\n                    /* Cannot expect anything... */\n                   \
    \ scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n\t\t}\n\t\tis_inf = is_inf_internal = 1;\n\t\tif (flags &\
    \ SCF_DO_STCLASS_OR) {\n                    if (OP(scan) == CLUMP) {\n       \
    \                 /* Actually is any start char, but very few code points\n  \
    \                       * aren't start characters */\n                       \
    \ ssc_match_all_cp(data->start_class);\n                    }\n              \
    \      else {\n                        ssc_anything(data->start_class);\n    \
    \                }\n                }\n\t\tflags &= ~SCF_DO_STCLASS;\n\t\tbreak;\n\
    \t    }\n\t}\n\telse if (OP(scan) == LNBREAK) {\n\t    if (flags & SCF_DO_STCLASS)\
    \ {\n    \t        if (flags & SCF_DO_STCLASS_AND) {\n                    ssc_intersection(data->start_class,\n\
    \                                    PL_XPosix_ptrs[_CC_VERTSPACE], FALSE);\n\
    \                    ssc_clear_locale(data->start_class);\n                  \
    \  ANYOF_FLAGS(data->start_class)\n                                          \
    \      &= ~SSC_MATCHES_EMPTY_STRING;\n                }\n                else\
    \ if (flags & SCF_DO_STCLASS_OR) {\n                    ssc_union(data->start_class,\n\
    \                              PL_XPosix_ptrs[_CC_VERTSPACE],\n              \
    \                FALSE);\n\t\t    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n\n                    /* See commit msg for\n              \
    \       * 749e076fceedeb708a624933726e7989f2302f6a */\n                    ANYOF_FLAGS(data->start_class)\n\
    \                                                &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \                }\n\t\tflags &= ~SCF_DO_STCLASS;\n            }\n\t    min++;\n\
    \            if (delta != SSize_t_MAX)\n                delta++;    /* Because\
    \ of the 2 char string cr-lf */\n            if (flags & SCF_DO_SUBSTR) {\n  \
    \              /* Cannot expect anything... */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n    \t        data->pos_min += 1;\n               \
    \ if (data->pos_delta != SSize_t_MAX) {\n                    data->pos_delta +=\
    \ 1;\n                }\n\t\tdata->cur_is_floating = 1; /* float */\n    \t  \
    \  }\n\t}\n\telse if (REGNODE_SIMPLE(OP(scan))) {\n\n\t    if (flags & SCF_DO_SUBSTR)\
    \ {\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n\t\tdata->pos_min++;\n\
    \t    }\n\t    min++;\n\t    if (flags & SCF_DO_STCLASS) {\n                bool\
    \ invert = 0;\n                SV* my_invlist = NULL;\n                U8 namedclass;\n\
    \n                /* See commit msg 749e076fceedeb708a624933726e7989f2302f6a */\n\
    \                ANYOF_FLAGS(data->start_class) &= ~SSC_MATCHES_EMPTY_STRING;\n\
    \n\t\t/* Some of the logic below assumes that switching\n\t\t   locale on will\
    \ only add false positives. */\n\t\tswitch (OP(scan)) {\n\n\t\tdefault:\n#ifdef\
    \ DEBUGGING\n                   Perl_croak(aTHX_ \"panic: unexpected simple REx\
    \ opcode %d\",\n                                                             \
    \        OP(scan));\n#endif\n\t\tcase SANY:\n\t\t    if (flags & SCF_DO_STCLASS_OR)\
    \ /* Allow everything */\n\t\t\tssc_match_all_cp(data->start_class);\n\t\t   \
    \ break;\n\n\t\tcase REG_ANY:\n                    {\n                       \
    \ SV* REG_ANY_invlist = _new_invlist(2);\n                        REG_ANY_invlist\
    \ = add_cp_to_invlist(REG_ANY_invlist,\n                                     \
    \                       '\\n');\n                        if (flags & SCF_DO_STCLASS_OR)\
    \ {\n                            ssc_union(data->start_class,\n              \
    \                        REG_ANY_invlist,\n                                  \
    \    TRUE /* TRUE => invert, hence all but \\n\n                             \
    \               */\n                                      );\n               \
    \         }\n                        else if (flags & SCF_DO_STCLASS_AND) {\n\
    \                            ssc_intersection(data->start_class,\n           \
    \                                  REG_ANY_invlist,\n                        \
    \                     TRUE  /* TRUE => invert */\n                           \
    \                  );\n                            ssc_clear_locale(data->start_class);\n\
    \                        }\n                        SvREFCNT_dec_NN(REG_ANY_invlist);\n\
    \t\t    }\n\t\t    break;\n\n                case ANYOFD:\n                case\
    \ ANYOFL:\n                case ANYOFPOSIXL:\n                case ANYOFH:\n \
    \               case ANYOF:\n\t\t    if (flags & SCF_DO_STCLASS_AND)\n\t\t\tssc_and(pRExC_state,\
    \ data->start_class,\n                                (regnode_charclass *) scan);\n\
    \t\t    else\n\t\t\tssc_or(pRExC_state, data->start_class,\n                 \
    \                                         (regnode_charclass *) scan);\n\t\t \
    \   break;\n\n                case NANYOFM:\n                case ANYOFM:\n  \
    \                {\n                    SV* cp_list = get_ANYOFM_contents(scan);\n\
    \n                    if (flags & SCF_DO_STCLASS_OR) {\n                     \
    \   ssc_union(data->start_class, cp_list, invert);\n                    }\n  \
    \                  else if (flags & SCF_DO_STCLASS_AND) {\n                  \
    \      ssc_intersection(data->start_class, cp_list, invert);\n               \
    \     }\n\n                    SvREFCNT_dec_NN(cp_list);\n                   \
    \ break;\n                  }\n\n\t\tcase NPOSIXL:\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\n\t\tcase POSIXL:\n          \
    \          namedclass = classnum_to_namedclass(FLAGS(scan)) + invert;\n      \
    \              if (flags & SCF_DO_STCLASS_AND) {\n                        bool\
    \ was_there = cBOOL(\n                                          ANYOF_POSIXL_TEST(data->start_class,\n\
    \                                                                 namedclass));\n\
    \                        ANYOF_POSIXL_ZERO(data->start_class);\n             \
    \           if (was_there) {    /* Do an AND */\n                            ANYOF_POSIXL_SET(data->start_class,\
    \ namedclass);\n                        }\n                        /* No individual\
    \ code points can now match */\n                        data->start_class->invlist\n\
    \                                                = sv_2mortal(_new_invlist(0));\n\
    \                    }\n                    else {\n                        int\
    \ complement = namedclass + ((invert) ? -1 : 1);\n\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n\n                        /* If the complement of this\
    \ class was already there,\n                         * the result is that they\
    \ match all code points,\n                         * (\\d + \\D == everything).\
    \  Remove the classes from\n                         * future consideration. \
    \ Locale is not relevant in\n                         * this case */\n       \
    \                 if (ANYOF_POSIXL_TEST(data->start_class, complement)) {\n  \
    \                          ssc_match_all_cp(data->start_class);\n            \
    \                ANYOF_POSIXL_CLEAR(data->start_class, namedclass);\n        \
    \                    ANYOF_POSIXL_CLEAR(data->start_class, complement);\n    \
    \                    }\n                        else {  /* The usual case; just\
    \ add this class to the\n                                   existing set */\n\
    \                            ANYOF_POSIXL_SET(data->start_class, namedclass);\n\
    \                        }\n                    }\n                    break;\n\
    \n                case NPOSIXA:   /* For these, we always know the exact set of\n\
    \                                   what's matched */\n                    invert\
    \ = 1;\n                    /* FALLTHROUGH */\n\t\tcase POSIXA:\n            \
    \        my_invlist = invlist_clone(PL_Posix_ptrs[FLAGS(scan)], NULL);\n     \
    \               goto join_posix_and_ascii;\n\n\t\tcase NPOSIXD:\n\t\tcase NPOSIXU:\n\
    \                    invert = 1;\n                    /* FALLTHROUGH */\n\t\t\
    case POSIXD:\n\t\tcase POSIXU:\n                    my_invlist = invlist_clone(PL_XPosix_ptrs[FLAGS(scan)],\
    \ NULL);\n\n                    /* NPOSIXD matches all upper Latin1 code points\
    \ unless the\n                     * target string being matched is UTF-8, which\
    \ is\n                     * unknowable until match time.  Since we are going\
    \ to\n                     * invert, we want to get rid of all of them so that\
    \ the\n                     * inversion will match all */\n                  \
    \  if (OP(scan) == NPOSIXD) {\n                        _invlist_subtract(my_invlist,\
    \ PL_UpperLatin1,\n                                          &my_invlist);\n \
    \                   }\n\n                  join_posix_and_ascii:\n\n         \
    \           if (flags & SCF_DO_STCLASS_AND) {\n                        ssc_intersection(data->start_class,\
    \ my_invlist, invert);\n                        ssc_clear_locale(data->start_class);\n\
    \                    }\n                    else {\n                        assert(flags\
    \ & SCF_DO_STCLASS_OR);\n                        ssc_union(data->start_class,\
    \ my_invlist, invert);\n                    }\n                    SvREFCNT_dec(my_invlist);\n\
    \t\t}\n\t\tif (flags & SCF_DO_STCLASS_OR)\n\t\t    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) and_withp);\n\t\tflags &= ~SCF_DO_STCLASS;\n\t    }\n\t\
    }\n\telse if (PL_regkind[OP(scan)] == EOL && flags & SCF_DO_SUBSTR) {\n\t    data->flags\
    \ |= (OP(scan) == MEOL\n\t\t\t    ? SF_BEFORE_MEOL\n\t\t\t    : SF_BEFORE_SEOL);\n\
    \            scan_commit(pRExC_state, data, minlenp, is_inf);\n\n\t}\n\telse if\
    \ (  PL_regkind[OP(scan)] == BRANCHJ\n\t\t /* Lookbehind, or need to calculate\
    \ parens/evals/stclass: */\n\t\t   && (scan->flags || data || (flags & SCF_DO_STCLASS))\n\
    \t\t   && (OP(scan) == IFMATCH || OP(scan) == UNLESSM))\n        {\n         \
    \   if ( !PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n                || OP(scan) ==\
    \ UNLESSM )\n            {\n                /* Negative Lookahead/lookbehind\n\
    \                   In this case we can't do fixed string optimisation.\n    \
    \            */\n\n                SSize_t deltanext, minnext, fake = 0;\n   \
    \             regnode *nscan;\n                regnode_ssc intrnl;\n         \
    \       int f = 0;\n\n                StructCopy(&zero_scan_data, &data_fake,\
    \ scan_data_t);\n                if (data) {\n                    data_fake.whilem_c\
    \ = data->whilem_c;\n                    data_fake.last_closep = data->last_closep;\n\
    \t\t}\n                else\n                    data_fake.last_closep = &fake;\n\
    \t\tdata_fake.pos_delta = delta;\n                if ( flags & SCF_DO_STCLASS\
    \ && !scan->flags\n                     && OP(scan) == IFMATCH ) { /* Lookahead\
    \ */\n                    ssc_init(pRExC_state, &intrnl);\n                  \
    \  data_fake.start_class = &intrnl;\n                    f |= SCF_DO_STCLASS_AND;\n\
    \t\t}\n                if (flags & SCF_WHILEM_VISITED_POS)\n                 \
    \   f |= SCF_WHILEM_VISITED_POS;\n                next = regnext(scan);\n    \
    \            nscan = NEXTOPER(NEXTOPER(scan));\n\n                /* recurse study_chunk()\
    \ for lookahead body */\n                minnext = study_chunk(pRExC_state, &nscan,\
    \ minlenp, &deltanext,\n                                      last, &data_fake,\
    \ stopparen,\n                                      recursed_depth, NULL, f, depth+1,\n\
    \                                      mutate_ok);\n                if (scan->flags)\
    \ {\n                    if (   deltanext < 0\n                        || deltanext\
    \ > (I32) U8_MAX\n                        || minnext > (I32)U8_MAX\n         \
    \               || minnext + deltanext > (I32)U8_MAX)\n                    {\n\
    \t\t\tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n        \
    \                      (UV)U8_MAX);\n                    }\n\n               \
    \     /* The 'next_off' field has been repurposed to count the\n             \
    \        * additional starting positions to try beyond the initial\n         \
    \            * one.  (This leaves it at 0 for non-variable length\n          \
    \           * matches to avoid breakage for those not using this\n           \
    \          * extension) */\n                    if (deltanext) {\n           \
    \             scan->next_off = deltanext;\n                        ckWARNexperimental(RExC_parse,\n\
    \                            WARN_EXPERIMENTAL__VLB,\n                       \
    \     \"Variable length lookbehind is experimental\");\n                    }\n\
    \                    scan->flags = (U8)minnext + deltanext;\n                }\n\
    \                if (data) {\n                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n\
    \                        pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                }\n                if (f & SCF_DO_STCLASS_AND)\
    \ {\n\t\t    if (flags & SCF_DO_STCLASS_OR) {\n\t\t\t/* OR before, AND after:\
    \ ideally we would recurse with\n\t\t\t * data_fake to get the AND applied by\
    \ study of the\n\t\t\t * remainder of the pattern, and then derecurse;\n\t\t\t\
    \ * *** HACK *** for now just treat as \"no information\".\n\t\t\t * See [perl\
    \ #56690].\n\t\t\t */\n\t\t\tssc_init(pRExC_state, data->start_class);\n\t\t \
    \   }  else {\n                        /* AND before and after: combine and continue.\
    \  These\n                         * assertions are zero-length, so can match\
    \ an EMPTY\n                         * string */\n\t\t\tssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                        ANYOF_FLAGS(data->start_class)\n\
    \                                                   |= SSC_MATCHES_EMPTY_STRING;\n\
    \t\t    }\n                }\n\t    }\n#if PERL_ENABLE_POSITIVE_ASSERTION_STUDY\n\
    \            else {\n                /* Positive Lookahead/lookbehind\n      \
    \             In this case we can do fixed string optimisation,\n            \
    \       but we must be careful about it. Note in the case of\n               \
    \    lookbehind the positions will be offset by the minimum\n                \
    \   length of the pattern, something we won't know about\n                   until\
    \ after the recurse.\n                */\n                SSize_t deltanext, fake\
    \ = 0;\n                regnode *nscan;\n                regnode_ssc intrnl;\n\
    \                int f = 0;\n                /* We use SAVEFREEPV so that when\
    \ the full compile\n                    is finished perl will clean up the allocated\n\
    \                    minlens when it's all done. This way we don't\n         \
    \           have to worry about freeing them when we know\n                  \
    \  they wont be used, which would be a pain.\n                 */\n          \
    \      SSize_t *minnextp;\n                Newx( minnextp, 1, SSize_t );\n   \
    \             SAVEFREEPV(minnextp);\n\n                if (data) {\n         \
    \           StructCopy(data, &data_fake, scan_data_t);\n                    if\
    \ ((flags & SCF_DO_SUBSTR) && data->last_found) {\n                        f |=\
    \ SCF_DO_SUBSTR;\n                        if (scan->flags)\n                 \
    \           scan_commit(pRExC_state, &data_fake, minlenp, is_inf);\n         \
    \               data_fake.last_found=newSVsv(data->last_found);\n            \
    \        }\n                }\n                else\n                    data_fake.last_closep\
    \ = &fake;\n                data_fake.flags = 0;\n                data_fake.substrs[0].flags\
    \ = 0;\n                data_fake.substrs[1].flags = 0;\n\t\tdata_fake.pos_delta\
    \ = delta;\n                if (is_inf)\n\t            data_fake.flags |= SF_IS_INF;\n\
    \                if ( flags & SCF_DO_STCLASS && !scan->flags\n               \
    \      && OP(scan) == IFMATCH ) { /* Lookahead */\n                    ssc_init(pRExC_state,\
    \ &intrnl);\n                    data_fake.start_class = &intrnl;\n          \
    \          f |= SCF_DO_STCLASS_AND;\n                }\n                if (flags\
    \ & SCF_WHILEM_VISITED_POS)\n                    f |= SCF_WHILEM_VISITED_POS;\n\
    \                next = regnext(scan);\n                nscan = NEXTOPER(NEXTOPER(scan));\n\
    \n                /* positive lookahead study_chunk() recursion */\n         \
    \       *minnextp = study_chunk(pRExC_state, &nscan, minnextp,\n             \
    \                           &deltanext, last, &data_fake,\n                  \
    \                      stopparen, recursed_depth, NULL,\n                    \
    \                    f, depth+1, mutate_ok);\n                if (scan->flags)\
    \ {\n                    assert(0);  /* This code has never been tested since\
    \ this\n                                   is normally not compiled */\n     \
    \               if (   deltanext < 0\n                        || deltanext > (I32)\
    \ U8_MAX\n                        || *minnextp > (I32)U8_MAX\n               \
    \         || *minnextp + deltanext > (I32)U8_MAX)\n                    {\n\t\t\
    \tFAIL2(\"Lookbehind longer than %\" UVuf \" not implemented\",\n            \
    \                  (UV)U8_MAX);\n                    }\n\n                   \
    \ if (deltanext) {\n                        scan->next_off = deltanext;\n    \
    \                }\n                    scan->flags = (U8)*minnextp + deltanext;\n\
    \                }\n\n                *minnextp += min;\n\n                if\
    \ (f & SCF_DO_STCLASS_AND) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &intrnl);\n                    ANYOF_FLAGS(data->start_class)\
    \ |= SSC_MATCHES_EMPTY_STRING;\n                }\n                if (data) {\n\
    \                    if (data_fake.flags & (SF_HAS_PAR|SF_IN_PAR))\n         \
    \               pars++;\n                    if (data_fake.flags & SF_HAS_EVAL)\n\
    \                        data->flags |= SF_HAS_EVAL;\n                    data->whilem_c\
    \ = data_fake.whilem_c;\n                    if ((flags & SCF_DO_SUBSTR) && data_fake.last_found)\
    \ {\n                        int i;\n                        if (RExC_rx->minlen<*minnextp)\n\
    \                            RExC_rx->minlen=*minnextp;\n                    \
    \    scan_commit(pRExC_state, &data_fake, minnextp, is_inf);\n               \
    \         SvREFCNT_dec_NN(data_fake.last_found);\n\n                        for\
    \ (i = 0; i < 2; i++) {\n                            if (data_fake.substrs[i].minlenp\
    \ != minlenp) {\n                                data->substrs[i].min_offset =\n\
    \                                            data_fake.substrs[i].min_offset;\n\
    \                                data->substrs[i].max_offset =\n             \
    \                               data_fake.substrs[i].max_offset;\n           \
    \                     data->substrs[i].minlenp =\n                           \
    \                 data_fake.substrs[i].minlenp;\n                            \
    \    data->substrs[i].lookbehind += scan->flags;\n                           \
    \ }\n                        }\n                    }\n                }\n\t \
    \   }\n#endif\n\t}\n\n\telse if (OP(scan) == OPEN) {\n\t    if (stopparen != (I32)ARG(scan))\n\
    \t        pars++;\n\t}\n\telse if (OP(scan) == CLOSE) {\n\t    if (stopparen ==\
    \ (I32)ARG(scan)) {\n\t        break;\n\t    }\n\t    if ((I32)ARG(scan) == is_par)\
    \ {\n\t\tnext = regnext(scan);\n\n\t\tif ( next && (OP(next) != WHILEM) && next\
    \ < last)\n\t\t    is_par = 0;\t\t/* Disable optimization */\n\t    }\n\t    if\
    \ (data)\n\t\t*(data->last_closep) = ARG(scan);\n\t}\n\telse if (OP(scan) == EVAL)\
    \ {\n\t\tif (data)\n\t\t    data->flags |= SF_HAS_EVAL;\n\t}\n\telse if ( PL_regkind[OP(scan)]\
    \ == ENDLIKE ) {\n\t    if (flags & SCF_DO_SUBSTR) {\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n\t\tflags &= ~SCF_DO_SUBSTR;\n\t    }\n\t    if (data\
    \ && OP(scan)==ACCEPT) {\n\t        data->flags |= SCF_SEEN_ACCEPT;\n\t      \
    \  if (stopmin > min)\n\t            stopmin = min;\n\t    }\n\t}\n\telse if (OP(scan)\
    \ == LOGICAL && scan->flags == 2) /* Embedded follows */\n\t{\n\t\tif (flags &\
    \ SCF_DO_SUBSTR) {\n                    scan_commit(pRExC_state, data, minlenp,\
    \ is_inf);\n\t\t    data->cur_is_floating = 1; /* float */\n\t\t}\n\t\tis_inf\
    \ = is_inf_internal = 1;\n\t\tif (flags & SCF_DO_STCLASS_OR) /* Allow everything\
    \ */\n\t\t    ssc_anything(data->start_class);\n\t\tflags &= ~SCF_DO_STCLASS;\n\
    \t}\n\telse if (OP(scan) == GPOS) {\n            if (!(RExC_rx->intflags & PREGf_GPOS_FLOAT)\
    \ &&\n\t        !(delta || is_inf || (data && data->pos_delta)))\n\t    {\n  \
    \              if (!(RExC_rx->intflags & PREGf_ANCH) && (flags & SCF_DO_SUBSTR))\n\
    \                    RExC_rx->intflags |= PREGf_ANCH_GPOS;\n\t        if (RExC_rx->gofs\
    \ < (STRLEN)min)\n\t\t    RExC_rx->gofs = min;\n            } else {\n       \
    \         RExC_rx->intflags |= PREGf_GPOS_FLOAT;\n                RExC_rx->gofs\
    \ = 0;\n            }\n\t}\n#ifdef TRIE_STUDY_OPT\n#ifdef FULL_TRIE_STUDY\n  \
    \      else if (PL_regkind[OP(scan)] == TRIE) {\n            /* NOTE - There is\
    \ similar code to this block above for handling\n               BRANCH nodes on\
    \ the initial study.  If you change stuff here\n               check there too.\
    \ */\n            regnode *trie_node= scan;\n            regnode *tail= regnext(scan);\n\
    \            reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[ ARG(scan)\
    \ ];\n            SSize_t max1 = 0, min1 = SSize_t_MAX;\n            regnode_ssc\
    \ accum;\n\n            if (flags & SCF_DO_SUBSTR) { /* XXXX Add !SUSPEND? */\n\
    \                /* Cannot merge strings after this. */\n                scan_commit(pRExC_state,\
    \ data, minlenp, is_inf);\n            }\n            if (flags & SCF_DO_STCLASS)\n\
    \                ssc_init_zero(pRExC_state, &accum);\n\n            if (!trie->jump)\
    \ {\n                min1= trie->minlen;\n                max1= trie->maxlen;\n\
    \            } else {\n                const regnode *nextbranch= NULL;\n    \
    \            U32 word;\n\n                for ( word=1 ; word <= trie->wordcount\
    \ ; word++)\n                {\n                    SSize_t deltanext=0, minnext=0,\
    \ f = 0, fake;\n                    regnode_ssc this_class;\n\n              \
    \      StructCopy(&zero_scan_data, &data_fake, scan_data_t);\n               \
    \     if (data) {\n                        data_fake.whilem_c = data->whilem_c;\n\
    \                        data_fake.last_closep = data->last_closep;\n        \
    \            }\n                    else\n                        data_fake.last_closep\
    \ = &fake;\n\t\t    data_fake.pos_delta = delta;\n                    if (flags\
    \ & SCF_DO_STCLASS) {\n                        ssc_init(pRExC_state, &this_class);\n\
    \                        data_fake.start_class = &this_class;\n              \
    \          f = SCF_DO_STCLASS_AND;\n                    }\n                  \
    \  if (flags & SCF_WHILEM_VISITED_POS)\n                        f |= SCF_WHILEM_VISITED_POS;\n\
    \n                    if (trie->jump[word]) {\n                        if (!nextbranch)\n\
    \                            nextbranch = trie_node + trie->jump[0];\n       \
    \                 scan= trie_node + trie->jump[word];\n                      \
    \  /* We go from the jump point to the branch that follows\n                 \
    \          it. Note this means we need the vestigal unused\n                 \
    \          branches even though they arent otherwise used. */\n              \
    \          /* optimise study_chunk() for TRIE */\n                        minnext\
    \ = study_chunk(pRExC_state, &scan, minlenp,\n                            &deltanext,\
    \ (regnode *)nextbranch, &data_fake,\n                            stopparen, recursed_depth,\
    \ NULL, f, depth+1,\n                            mutate_ok);\n               \
    \     }\n                    if (nextbranch && PL_regkind[OP(nextbranch)]==BRANCH)\n\
    \                        nextbranch= regnext((regnode*)nextbranch);\n\n      \
    \              if (min1 > (SSize_t)(minnext + trie->minlen))\n               \
    \         min1 = minnext + trie->minlen;\n                    if (deltanext ==\
    \ SSize_t_MAX) {\n                        is_inf = is_inf_internal = 1;\n    \
    \                    max1 = SSize_t_MAX;\n                    } else if (max1\
    \ < (SSize_t)(minnext + deltanext + trie->maxlen))\n                        max1\
    \ = minnext + deltanext + trie->maxlen;\n\n                    if (data_fake.flags\
    \ & (SF_HAS_PAR|SF_IN_PAR))\n                        pars++;\n               \
    \     if (data_fake.flags & SCF_SEEN_ACCEPT) {\n                        if ( stopmin\
    \ > min + min1)\n\t                    stopmin = min + min1;\n\t             \
    \   flags &= ~SCF_DO_SUBSTR;\n\t                if (data)\n\t                \
    \    data->flags |= SCF_SEEN_ACCEPT;\n\t            }\n                    if\
    \ (data) {\n                        if (data_fake.flags & SF_HAS_EVAL)\n     \
    \                       data->flags |= SF_HAS_EVAL;\n                        data->whilem_c\
    \ = data_fake.whilem_c;\n                    }\n                    if (flags\
    \ & SCF_DO_STCLASS)\n                        ssc_or(pRExC_state, &accum, (regnode_charclass\
    \ *) &this_class);\n                }\n            }\n            if (flags &\
    \ SCF_DO_SUBSTR) {\n                data->pos_min += min1;\n                data->pos_delta\
    \ += max1 - min1;\n                if (max1 != min1 || is_inf)\n             \
    \       data->cur_is_floating = 1; /* float */\n            }\n            min\
    \ += min1;\n            if (delta != SSize_t_MAX) {\n                if (SSize_t_MAX\
    \ - (max1 - min1) >= delta)\n                    delta += max1 - min1;\n     \
    \           else\n                    delta = SSize_t_MAX;\n            }\n  \
    \          if (flags & SCF_DO_STCLASS_OR) {\n                ssc_or(pRExC_state,\
    \ data->start_class, (regnode_charclass *) &accum);\n                if (min1)\
    \ {\n                    ssc_and(pRExC_state, data->start_class, (regnode_charclass\
    \ *) and_withp);\n                    flags &= ~SCF_DO_STCLASS;\n            \
    \    }\n            }\n            else if (flags & SCF_DO_STCLASS_AND) {\n  \
    \              if (min1) {\n                    ssc_and(pRExC_state, data->start_class,\
    \ (regnode_charclass *) &accum);\n                    flags &= ~SCF_DO_STCLASS;\n\
    \                }\n                else {\n                    /* Switch to OR\
    \ mode: cache the old value of\n                     * data->start_class */\n\t\
    \t    INIT_AND_WITHP;\n                    StructCopy(data->start_class, and_withp,\
    \ regnode_ssc);\n                    flags &= ~SCF_DO_STCLASS_AND;\n         \
    \           StructCopy(&accum, data->start_class, regnode_ssc);\n            \
    \        flags |= SCF_DO_STCLASS_OR;\n                }\n            }\n     \
    \       scan= tail;\n            continue;\n        }\n#else\n\telse if (PL_regkind[OP(scan)]\
    \ == TRIE) {\n\t    reg_trie_data *trie = (reg_trie_data*)RExC_rxi->data->data[\
    \ ARG(scan) ];\n\t    U8*bang=NULL;\n\n\t    min += trie->minlen;\n\t    delta\
    \ += (trie->maxlen - trie->minlen);\n\t    flags &= ~SCF_DO_STCLASS; /* xxx */\n\
    \            if (flags & SCF_DO_SUBSTR) {\n                /* Cannot expect anything...\
    \ */\n                scan_commit(pRExC_state, data, minlenp, is_inf);\n    \t\
    \        data->pos_min += trie->minlen;\n    \t        data->pos_delta += (trie->maxlen\
    \ - trie->minlen);\n\t\tif (trie->maxlen != trie->minlen)\n\t\t    data->cur_is_floating\
    \ = 1; /* float */\n    \t    }\n    \t    if (trie->jump) /* no more substrings\
    \ -- for now /grr*/\n               flags &= ~SCF_DO_SUBSTR;\n\t}\n#endif /* old\
    \ or new */\n#endif /* TRIE_STUDY_OPT */\n\n\t/* Else: zero-length, ignore. */\n\
    \tscan = regnext(scan);\n    }\n\n  finish:\n    if (frame) {\n        /* we need\
    \ to unwind recursion. */\n        depth = depth - 1;\n\n        DEBUG_STUDYDATA(\"\
    frame-end\", data, depth, is_inf);\n        DEBUG_PEEP(\"fend\", scan, depth,\
    \ flags);\n\n        /* restore previous context */\n        last = frame->last_regnode;\n\
    \        scan = frame->next_regnode;\n        stopparen = frame->stopparen;\n\
    \        recursed_depth = frame->prev_recursed_depth;\n\n        RExC_frame_last\
    \ = frame->prev_frame;\n        frame = frame->this_prev_frame;\n        goto\
    \ fake_study_recurse;\n    }\n\n    assert(!frame);\n    DEBUG_STUDYDATA(\"pre-fin\"\
    , data, depth, is_inf);\n\n    *scanp = scan;\n    *deltap = is_inf_internal ?\
    \ SSize_t_MAX : delta;\n\n    if (flags & SCF_DO_SUBSTR && is_inf)\n\tdata->pos_delta\
    \ = SSize_t_MAX - data->pos_min;\n    if (is_par > (I32)U8_MAX)\n\tis_par = 0;\n\
    \    if (is_par && pars==1 && data) {\n\tdata->flags |= SF_IN_PAR;\n\tdata->flags\
    \ &= ~SF_HAS_PAR;\n    }\n    else if (pars && data) {\n\tdata->flags |= SF_HAS_PAR;\n\
    \tdata->flags &= ~SF_IN_PAR;\n    }\n    if (flags & SCF_DO_STCLASS_OR)\n\tssc_and(pRExC_state,\
    \ data->start_class, (regnode_charclass *) and_withp);\n    if (flags & SCF_TRIE_RESTUDY)\n\
    \        data->flags |= \tSCF_TRIE_RESTUDY;\n\n    DEBUG_STUDYDATA(\"post-fin\"\
    , data, depth, is_inf);\n\n    {\n        SSize_t final_minlen= min < stopmin\
    \ ? min : stopmin;\n\n        if (!(RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN))\
    \ {\n            if (final_minlen > SSize_t_MAX - delta)\n                RExC_maxlen\
    \ = SSize_t_MAX;\n            else if (RExC_maxlen < final_minlen + delta)\n \
    \               RExC_maxlen = final_minlen + delta;\n        }\n        return\
    \ final_minlen;\n    }\n    NOT_REACHED; /* NOTREACHED */"
  verbose: true
environment:
  env_type: judge
  id_save: 486837
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
