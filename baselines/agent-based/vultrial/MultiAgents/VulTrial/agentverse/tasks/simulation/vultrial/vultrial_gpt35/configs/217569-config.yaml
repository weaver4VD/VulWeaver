agents:
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ MagickBooleanType GetEXIFProperty(const Image *image,\n  const char *property)\n\
    {\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS\
    \  12\n#define EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT\
    \  3\n#define EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE\
    \  6\n#define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG\
    \  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE\
    \  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define\
    \ TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\
    \n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n\
    \ \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n \
    \  for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",arg); \\\n     if (length >= (MaxTextExtent-1)) \\\n\
    \       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t\
    \ \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned\
    \ char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0;\
    \ component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MaxTextExtent-1))\
    \ \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\
    \n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\
    \n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n \
    \     description[36];\n  } TagInfo;\n\n  static const TagInfo\n    EXIFTag[]\
    \ =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002,\
    \ \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n\
    \      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\"\
    \ },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\"\
    \ },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\"\
    \ },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\"\
    \ },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\"\
    \ },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\"\
    \ },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\"\
    \ },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\"\
    \ },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\"\
    \ },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\"\
    \ },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\"\
    \ },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\"\
    \ },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\"\
    \ },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\"\
    \ },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\"\
    \ },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\"\
    \ },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\"\
    \ },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\"\
    \ },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\"\
    \ },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\"\
    \ },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\"\
    \ },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n\
    \      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n\
    \      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\"\
    \ },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\"\
    \ },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\"\
    \ },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\"\
    \ },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\"\
    \ },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\"\
    \ },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\"\
    \ },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203,\
    \ \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\"\
    \ },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\"\
    \ },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\"\
    \ },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\"\
    \ },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\"\
    \ },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301,\
    \ \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {\
    \  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\"\
    \ },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\"\
    \ },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"\
    exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n   \
    \   {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\"\
    \ },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\"\
    \ },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\"\
    \ },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\"\
    \ },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\"\
    \ },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\"\
    \ },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\"\
    \ },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\"\
    \ },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\"\
    \ },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\"\
    \ },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"\
    exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n  \
    \    {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\"\
    \ },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\"\
    \ },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026,\
    \ \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\"\
    \ },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"\
    exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\"\
    \ },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"\
    exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\"\
    \ },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\"\
    \ },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"\
    exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\"\
    \ },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\"\
    \ },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\"\
    \ },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038,\
    \ \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\"\
    \ },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"\
    exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n  \
    \    {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\"\
    \ },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\"\
    \ },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\"\
    \ },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\"\
    \ },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\"\
    \ },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\"\
    \ },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\"\
    \ },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\"\
    \ },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\"\
    \ },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\"\
    \ },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\"\
    \ },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\"\
    \ },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769,\
    \ \"exif:ExifOffset\" },  /* specs as \"Exif IFD Pointer\"? */\n      {  0x8773,\
    \ \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n\
    \      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\"\
    \ }, /* specs as \"GPSInfo IFD Pointer\"? */\n      {  0x8827, \"exif:PhotographicSensitivity\"\
    \ },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\
    \      \n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\"\
    \ },\n      {  0x8830, \"exif:SensitivityType\" },\n      {  0x8831, \"exif:StandardOutputSensitivity\"\
    \ },\n      {  0x8832, \"exif:RecommendedExposureIndex\" },\n      {  0x8833,\
    \ \"exif:ISOSpeed\" },\n      {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n   \
    \   {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n      {  0x9000, \"exif:ExifVersion\"\
    \ },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\"\
    \ },\n      {  0x9010, \"exif:OffsetTime\" },\n      {  0x9011, \"exif:OffsetTimeOriginal\"\
    \ },\n      {  0x9012, \"exif:OffsetTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\"\
    \ },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"\
    exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n    \
    \  {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\"\
    \ },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\"\
    \ },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\"\
    \ },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\"\
    \ },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\"\
    \ },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9211, \"\
    exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n \
    \     {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\"\
    \ },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9286, \"exif:UserComment\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9400, \"\
    exif:Temperature\" },\n      {  0x9401, \"exif:Humidity\" },\n      {  0x9402,\
    \ \"exif:Pressure\" },\n      {  0x9403, \"exif:WaterDepth\" },\n      {  0x9404,\
    \ \"exif:Acceleration\" },\n      {  0x9405, \"exif:CameraElevationAngle\" },\
    \    \n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\"\
    \ },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\"\
    \ },\n      {  0x9C9f, \"exif:WinXP-Subject\" },      \n      {  0xa000, \"exif:FlashPixVersion\"\
    \ },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:PixelXDimension\"\
    \ },\n      {  0xa003, \"exif:PixelYDimension\" },\n      {  0xa004, \"exif:RelatedSoundFile\"\
    \ },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"\
    exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n\
    \      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\"\
    \ },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"\
    exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\"\
    \ },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\"\
    \ },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\"\
    \ },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\"\
    \ },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\"\
    \ },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\"\
    \ },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"\
    exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {\
    \  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n   \
    \   {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\"\
    \ },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\"\
    \ },\n      {  0xa430, \"exif:CameraOwnerName\" },\n      {  0xa431, \"exif:BodySerialNumber\"\
    \ },\n      {  0xa432, \"exif:LensSpecification\" },\n      {  0xa433, \"exif:LensMake\"\
    \ },\n      {  0xa434, \"exif:LensModel\" },\n      {  0xa435, \"exif:LensSerialNumber\"\
    \ },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\"\
    \ },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\"\
    \ },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\"\
    \ },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\"\
    \ },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\"\
    \ },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\"\
    \ },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\"\
    \ },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\"\
    \ },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\"\
    \ },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\"\
    \ },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\"\
    \ },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\"\
    \ },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\"\
    \ },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\"\
    \ },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\"\
    \ },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\"\
    \ },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\"\
    \ },\n      { 0x1001f, \"exif:GPSHPositioningError\" },\n      { 0x00000, \"\"\
    \ }\n    };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf\
    \ */\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n\
    \    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n\
    \    endian;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n\
    \    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n\
    \    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n\
    \    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2,\
    \ 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request\
    \ for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile\
    \ == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property ==\
    \ (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while\
    \ (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property)\
    \ <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n\
    \  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags\
    \ in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in\
    \ description=value format */\n      break;\n    }\n    case '!':\n    {\n   \
    \   tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n\
    \    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n\
    \        n;\n\n      /*\n        Check for a hex based tag specification first.\n\
    \      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n\
    \      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n\
    \      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n\
    \      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n \
    \         c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c\
    \ <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A')\
    \ && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n       \
    \       if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n  \
    \            else\n                return(MagickFalse);\n        }\n      } while\
    \ (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n\
    \        Try to match the text with a tag name instead.\n      */\n      for (i=0;\
    \ ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n      \
    \  if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n   \
    \         tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n    \
    \  }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n\
    \  length=GetStringInfoLength(profile);\n  if (length < 6)\n    return(MagickFalse);\n\
    \  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n\
    \      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n\
    \    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n\
    \      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n\
    \  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n\
    \  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n \
    \     endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2)\
    \ != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first\
    \ IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if\
    \ ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n\
    \    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n\
    \  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int\
    \ (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void\
    \ *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then\
    \ pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n       \
    \ directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n\
    \        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory\
    \ < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine\
    \ how many entries there are in the current IFD.\n    */\n    number_entries=(size_t)\
    \ ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries;\
    \ entry++)\n    {\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n\
    \        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\
    \n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n\
    \        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q)\
    \ == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n\
    \      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n  \
    \    format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format\
    \ >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      if (format\
    \ == 0)\n        break;  /* corrupt EXIF */\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n\
    \      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t)\
    \ components*tag_bytes[format];\n      if (number_bytes < components)\n      \
    \  break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n\
    \      else\n        {\n          ssize_t\n            dir_offset;\n\n       \
    \   /*\n            The directory entry contains an offset.\n          */\n  \
    \        dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if\
    \ ((dir_offset < 0) || (size_t) dir_offset >= length)\n            continue;\n\
    \          if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n   \
    \         continue;  /* prevent overflow */\n          if (((size_t) dir_offset+number_bytes)\
    \ > length)\n            continue;\n          p=(unsigned char *) (exif+dir_offset);\n\
    \        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n\
    \          char\n            buffer[MaxTextExtent],\n            *value;\n\n \
    \         if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n         \
    \   break;\n          value=(char *) NULL;\n          *buffer='\\0';\n       \
    \   switch (format)\n          {\n            case EXIF_FMT_BYTE:\n          \
    \  case EXIF_FMT_UNDEFINED:\n            {\n              value=(char *) NULL;\n\
    \              if (~((size_t) number_bytes) >= 1)\n                value=(char\
    \ *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n\
    \              if (value != (char *) NULL)\n                {\n              \
    \    for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n       \
    \             value[i]='.';\n                    if (isprint((int) p[i]) != 0)\
    \ \n                      value[i]=(char) p[i];\n                  }\n       \
    \           value[i]='\\0';\n                }\n              break;\n       \
    \     }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"\
    %.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n\
    \            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hd\",ReadPropertySignedShort(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n         \
    \   }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"\
    %.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n    \
    \          break;\n            }\n            case EXIF_FMT_SLONG:\n         \
    \   {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n               \
    \ ReadPropertySignedLong(endian,p1));\n              break;\n            }\n \
    \           case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"\
    %.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n\
    \                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SRATIONAL:\n            {\n        \
    \      EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n\
    \                ReadPropertySignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SINGLE:\n            {\n           \
    \   EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n\
    \              break;\n            }\n            case EXIF_FMT_DOUBLE:\n    \
    \        {\n              EXIFMultipleValues(8,\"%.20g\",(double)\n          \
    \      ReadPropertySignedLong(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_STRING:\n            default:\n            {\n\
    \              if ((p < exif) || (p > (exif+length-number_bytes)))\n         \
    \       break;\n              value=(char *) NULL;\n              if (~((size_t)\
    \ number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t)\
    \ number_bytes+1UL,\n                  sizeof(*value));\n              if (value\
    \ != (char *) NULL)\n                {\n                  ssize_t\n          \
    \          i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n\
    \                  {\n                    value[i]='.';\n                    if\
    \ ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char)\
    \ p[i];\n                  }\n                  value[i]='\\0';\n            \
    \    }\n              break;\n            }\n          }\n          if (value\
    \ != (char *) NULL)\n            {\n              char\n                *key;\n\
    \n              const char\n                *p;\n\n              key=AcquireString(property);\n\
    \              switch (all)\n              {\n                case 1:\n      \
    \          {\n                  const char\n                    *description;\n\
    \n                  ssize_t\n                    i;\n\n                  description=\"\
    unknown\";\n                  for (i=0; ; i++)\n                  {\n        \
    \            if (EXIFTag[i].tag == 0)\n                      break;\n        \
    \            if (EXIFTag[i].tag == tag_value)\n                      {\n     \
    \                   description=EXIFTag[i].description;\n                    \
    \    break;\n                      }\n                  }\n                  (void)\
    \ FormatLocaleString(key,MaxTextExtent,\"%s\",\n                    description);\n\
    \                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n \
    \               case 2:\n                {\n                  if (tag_value <\
    \ 0x10000)\n                    (void) FormatLocaleString(key,MaxTextExtent,\"\
    #%04lx\",\n                      (unsigned long) tag_value);\n               \
    \   else\n                    if (tag_value < 0x20000)\n                     \
    \ (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                  \
    \      (unsigned long) (tag_value & 0xffff));\n                    else\n    \
    \                  (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n\
    \                  break;\n                }\n                default:\n     \
    \           {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                }\n              }\n          \
    \    p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n\
    \                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n  \
    \                image->properties,key);\n              if (p == (const char *)\
    \ NULL)\n                (void) SetImageProperty((Image *) image,key,value);\n\
    \              value=DestroyString(value);\n              key=DestroyString(key);\n\
    \              status=MagickTrue;\n            }\n        }\n        if ((tag_value\
    \ == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value\
    \ == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\
    \n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n           \
    \ if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n       \
    \       {\n                ssize_t\n                  tag_offset1;\n\n       \
    \         tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n \
    \                 0);\n                directory_stack[level].directory=directory;\n\
    \                entry++;\n                directory_stack[level].entry=entry;\n\
    \                directory_stack[level].offset=tag_offset;\n                level++;\n\
    \                /*\n                  Check for duplicate tag.\n            \
    \    */\n                for (i=0; i < level; i++)\n                  if (directory_stack[i].directory\
    \ == (exif+tag_offset1))\n                    break;\n                if (i <\
    \ level)\n                  break;  /* duplicate tag */\n                directory_stack[level].directory=exif+offset;\n\
    \                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n\
    \                level++;\n                if ((directory+2+(12*number_entries)+4)\
    \ > (exif+length))\n                  break;\n                offset=(ssize_t)\
    \ ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n\
    \                if ((offset != 0) && ((size_t) offset < length) &&\n        \
    \            (level < (MaxDirectoryStack-2)))\n                  {\n         \
    \           directory_stack[level].directory=exif+offset;\n                  \
    \  directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n\
    \                    level++;\n                  }\n              }\n        \
    \    break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n\
    \  return(status);\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nstatic MagickBooleanType\
    \ GetEXIFProperty(const Image *image,\n  const char *property)\n{\n#define MaxDirectoryStack\
    \  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define\
    \ EXIF_FMT_BYTE  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define\
    \ EXIF_FMT_ULONG  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n\
    #define EXIF_FMT_UNDEFINED  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG\
    \  9\n#define EXIF_FMT_SRATIONAL  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE\
    \  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define\
    \ TAG_INTEROP_OFFSET  0xa005\n\n#define EXIFMultipleValues(size,format,arg) \\\
    \n{ \\\n   ssize_t \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n\
    \ \\\n   unsigned char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n \
    \  for (component=0; component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",arg); \\\n     if (length >= (MaxTextExtent-1)) \\\n\
    \       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t\
    \ \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned\
    \ char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0;\
    \ component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MaxTextExtent-1))\
    \ \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\
    \n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\
    \n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n \
    \     description[36];\n  } TagInfo;\n\n  static const TagInfo\n    EXIFTag[]\
    \ =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002,\
    \ \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n\
    \      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\"\
    \ },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\"\
    \ },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\"\
    \ },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\"\
    \ },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\"\
    \ },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\"\
    \ },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\"\
    \ },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\"\
    \ },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\"\
    \ },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\"\
    \ },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\"\
    \ },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\"\
    \ },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\"\
    \ },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\"\
    \ },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\"\
    \ },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\"\
    \ },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\"\
    \ },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\"\
    \ },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\"\
    \ },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\"\
    \ },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\"\
    \ },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n\
    \      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n\
    \      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\"\
    \ },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\"\
    \ },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\"\
    \ },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\"\
    \ },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\"\
    \ },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\"\
    \ },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\"\
    \ },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203,\
    \ \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\"\
    \ },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\"\
    \ },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\"\
    \ },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\"\
    \ },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\"\
    \ },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301,\
    \ \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {\
    \  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\"\
    \ },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\"\
    \ },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"\
    exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n   \
    \   {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\"\
    \ },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\"\
    \ },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\"\
    \ },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\"\
    \ },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\"\
    \ },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\"\
    \ },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\"\
    \ },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\"\
    \ },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\"\
    \ },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\"\
    \ },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"\
    exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n  \
    \    {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\"\
    \ },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\"\
    \ },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026,\
    \ \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\"\
    \ },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"\
    exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\"\
    \ },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"\
    exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\"\
    \ },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\"\
    \ },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"\
    exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\"\
    \ },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\"\
    \ },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\"\
    \ },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038,\
    \ \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\"\
    \ },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"\
    exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n  \
    \    {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\"\
    \ },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\"\
    \ },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\"\
    \ },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\"\
    \ },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\"\
    \ },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\"\
    \ },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\"\
    \ },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\"\
    \ },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\"\
    \ },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\"\
    \ },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\"\
    \ },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\"\
    \ },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769,\
    \ \"exif:ExifOffset\" },  /* specs as \"Exif IFD Pointer\"? */\n      {  0x8773,\
    \ \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n\
    \      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\"\
    \ }, /* specs as \"GPSInfo IFD Pointer\"? */\n      {  0x8827, \"exif:PhotographicSensitivity\"\
    \ },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\
    \      \n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\"\
    \ },\n      {  0x8830, \"exif:SensitivityType\" },\n      {  0x8831, \"exif:StandardOutputSensitivity\"\
    \ },\n      {  0x8832, \"exif:RecommendedExposureIndex\" },\n      {  0x8833,\
    \ \"exif:ISOSpeed\" },\n      {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n   \
    \   {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n      {  0x9000, \"exif:ExifVersion\"\
    \ },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\"\
    \ },\n      {  0x9010, \"exif:OffsetTime\" },\n      {  0x9011, \"exif:OffsetTimeOriginal\"\
    \ },\n      {  0x9012, \"exif:OffsetTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\"\
    \ },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"\
    exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n    \
    \  {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\"\
    \ },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\"\
    \ },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\"\
    \ },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\"\
    \ },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\"\
    \ },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9211, \"\
    exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n \
    \     {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\"\
    \ },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9286, \"exif:UserComment\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9400, \"\
    exif:Temperature\" },\n      {  0x9401, \"exif:Humidity\" },\n      {  0x9402,\
    \ \"exif:Pressure\" },\n      {  0x9403, \"exif:WaterDepth\" },\n      {  0x9404,\
    \ \"exif:Acceleration\" },\n      {  0x9405, \"exif:CameraElevationAngle\" },\
    \    \n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\"\
    \ },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\"\
    \ },\n      {  0x9C9f, \"exif:WinXP-Subject\" },      \n      {  0xa000, \"exif:FlashPixVersion\"\
    \ },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:PixelXDimension\"\
    \ },\n      {  0xa003, \"exif:PixelYDimension\" },\n      {  0xa004, \"exif:RelatedSoundFile\"\
    \ },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"\
    exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n\
    \      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\"\
    \ },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"\
    exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\"\
    \ },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\"\
    \ },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\"\
    \ },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\"\
    \ },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\"\
    \ },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\"\
    \ },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"\
    exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {\
    \  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n   \
    \   {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\"\
    \ },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\"\
    \ },\n      {  0xa430, \"exif:CameraOwnerName\" },\n      {  0xa431, \"exif:BodySerialNumber\"\
    \ },\n      {  0xa432, \"exif:LensSpecification\" },\n      {  0xa433, \"exif:LensMake\"\
    \ },\n      {  0xa434, \"exif:LensModel\" },\n      {  0xa435, \"exif:LensSerialNumber\"\
    \ },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\"\
    \ },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\"\
    \ },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\"\
    \ },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\"\
    \ },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\"\
    \ },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\"\
    \ },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\"\
    \ },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\"\
    \ },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\"\
    \ },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\"\
    \ },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\"\
    \ },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\"\
    \ },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\"\
    \ },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\"\
    \ },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\"\
    \ },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\"\
    \ },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\"\
    \ },\n      { 0x1001f, \"exif:GPSHPositioningError\" },\n      { 0x00000, \"\"\
    \ }\n    };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf\
    \ */\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n\
    \    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n\
    \    endian;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n\
    \    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n\
    \    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n\
    \    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2,\
    \ 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request\
    \ for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile\
    \ == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property ==\
    \ (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while\
    \ (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property)\
    \ <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n\
    \  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags\
    \ in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in\
    \ description=value format */\n      break;\n    }\n    case '!':\n    {\n   \
    \   tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n\
    \    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n\
    \        n;\n\n      /*\n        Check for a hex based tag specification first.\n\
    \      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n\
    \      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n\
    \      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n\
    \      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n \
    \         c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c\
    \ <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A')\
    \ && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n       \
    \       if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n  \
    \            else\n                return(MagickFalse);\n        }\n      } while\
    \ (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n\
    \        Try to match the text with a tag name instead.\n      */\n      for (i=0;\
    \ ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n      \
    \  if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n   \
    \         tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n    \
    \  }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n\
    \  length=GetStringInfoLength(profile);\n  if (length < 6)\n    return(MagickFalse);\n\
    \  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n\
    \      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n\
    \    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n\
    \      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n\
    \  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n\
    \  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n \
    \     endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2)\
    \ != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first\
    \ IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if\
    \ ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n\
    \    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n\
    \  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int\
    \ (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void\
    \ *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then\
    \ pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n       \
    \ directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n\
    \        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory\
    \ < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine\
    \ how many entries there are in the current IFD.\n    */\n    number_entries=(size_t)\
    \ ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries;\
    \ entry++)\n    {\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n\
    \        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\
    \n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n\
    \        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q)\
    \ == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n\
    \      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n  \
    \    format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format\
    \ >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      if (format\
    \ == 0)\n        break;  /* corrupt EXIF */\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n\
    \      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t)\
    \ components*tag_bytes[format];\n      if (number_bytes < components)\n      \
    \  break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n\
    \      else\n        {\n          ssize_t\n            dir_offset;\n\n       \
    \   /*\n            The directory entry contains an offset.\n          */\n  \
    \        dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if\
    \ ((dir_offset < 0) || (size_t) dir_offset >= length)\n            continue;\n\
    \          if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n   \
    \         continue;  /* prevent overflow */\n          if (((size_t) dir_offset+number_bytes)\
    \ > length)\n            continue;\n          p=(unsigned char *) (exif+dir_offset);\n\
    \        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n\
    \          char\n            buffer[MaxTextExtent],\n            *value;\n\n \
    \         if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n         \
    \   break;\n          value=(char *) NULL;\n          *buffer='\\0';\n       \
    \   switch (format)\n          {\n            case EXIF_FMT_BYTE:\n          \
    \  case EXIF_FMT_UNDEFINED:\n            {\n              value=(char *) NULL;\n\
    \              if (~((size_t) number_bytes) >= 1)\n                value=(char\
    \ *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n\
    \              if (value != (char *) NULL)\n                {\n              \
    \    for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n       \
    \             value[i]='.';\n                    if (isprint((int) p[i]) != 0)\
    \ \n                      value[i]=(char) p[i];\n                  }\n       \
    \           value[i]='\\0';\n                }\n              break;\n       \
    \     }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"\
    %.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n\
    \            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hd\",ReadPropertySignedShort(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n         \
    \   }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"\
    %.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n    \
    \          break;\n            }\n            case EXIF_FMT_SLONG:\n         \
    \   {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n               \
    \ ReadPropertySignedLong(endian,p1));\n              break;\n            }\n \
    \           case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"\
    %.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n\
    \                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SRATIONAL:\n            {\n        \
    \      EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n\
    \                ReadPropertySignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SINGLE:\n            {\n           \
    \   EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n\
    \              break;\n            }\n            case EXIF_FMT_DOUBLE:\n    \
    \        {\n              EXIFMultipleValues(8,\"%.20g\",(double)\n          \
    \      ReadPropertySignedLong(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_STRING:\n            default:\n            {\n\
    \              if ((p < exif) || (p > (exif+length-number_bytes)))\n         \
    \       break;\n              value=(char *) NULL;\n              if (~((size_t)\
    \ number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t)\
    \ number_bytes+1UL,\n                  sizeof(*value));\n              if (value\
    \ != (char *) NULL)\n                {\n                  ssize_t\n          \
    \          i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n\
    \                  {\n                    value[i]='.';\n                    if\
    \ ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char)\
    \ p[i];\n                  }\n                  value[i]='\\0';\n            \
    \    }\n              break;\n            }\n          }\n          if (value\
    \ != (char *) NULL)\n            {\n              char\n                *key;\n\
    \n              const char\n                *p;\n\n              key=AcquireString(property);\n\
    \              switch (all)\n              {\n                case 1:\n      \
    \          {\n                  const char\n                    *description;\n\
    \n                  ssize_t\n                    i;\n\n                  description=\"\
    unknown\";\n                  for (i=0; ; i++)\n                  {\n        \
    \            if (EXIFTag[i].tag == 0)\n                      break;\n        \
    \            if (EXIFTag[i].tag == tag_value)\n                      {\n     \
    \                   description=EXIFTag[i].description;\n                    \
    \    break;\n                      }\n                  }\n                  (void)\
    \ FormatLocaleString(key,MaxTextExtent,\"%s\",\n                    description);\n\
    \                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n \
    \               case 2:\n                {\n                  if (tag_value <\
    \ 0x10000)\n                    (void) FormatLocaleString(key,MaxTextExtent,\"\
    #%04lx\",\n                      (unsigned long) tag_value);\n               \
    \   else\n                    if (tag_value < 0x20000)\n                     \
    \ (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                  \
    \      (unsigned long) (tag_value & 0xffff));\n                    else\n    \
    \                  (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n\
    \                  break;\n                }\n                default:\n     \
    \           {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                }\n              }\n          \
    \    p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n\
    \                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n  \
    \                image->properties,key);\n              if (p == (const char *)\
    \ NULL)\n                (void) SetImageProperty((Image *) image,key,value);\n\
    \              value=DestroyString(value);\n              key=DestroyString(key);\n\
    \              status=MagickTrue;\n            }\n        }\n        if ((tag_value\
    \ == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value\
    \ == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\
    \n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n           \
    \ if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n       \
    \       {\n                ssize_t\n                  tag_offset1;\n\n       \
    \         tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n \
    \                 0);\n                directory_stack[level].directory=directory;\n\
    \                entry++;\n                directory_stack[level].entry=entry;\n\
    \                directory_stack[level].offset=tag_offset;\n                level++;\n\
    \                /*\n                  Check for duplicate tag.\n            \
    \    */\n                for (i=0; i < level; i++)\n                  if (directory_stack[i].directory\
    \ == (exif+tag_offset1))\n                    break;\n                if (i <\
    \ level)\n                  break;  /* duplicate tag */\n                directory_stack[level].directory=exif+offset;\n\
    \                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n\
    \                level++;\n                if ((directory+2+(12*number_entries)+4)\
    \ > (exif+length))\n                  break;\n                offset=(ssize_t)\
    \ ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n\
    \                if ((offset != 0) && ((size_t) offset < length) &&\n        \
    \            (level < (MaxDirectoryStack-2)))\n                  {\n         \
    \           directory_stack[level].directory=exif+offset;\n                  \
    \  directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n\
    \                    level++;\n                  }\n              }\n        \
    \    break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n\
    \  return(status);\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nstatic MagickBooleanType GetEXIFProperty(const\
    \ Image *image,\n  const char *property)\n{\n#define MaxDirectoryStack  16\n#define\
    \ EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE\
    \  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG\
    \  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED\
    \  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL\
    \  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET\
    \  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\
    \n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component;\
    \ \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1;\
    \ \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components;\
    \ component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",arg); \\\n     if (length >= (MaxTextExtent-1)) \\\n\
    \       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t\
    \ \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned\
    \ char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0;\
    \ component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MaxTextExtent-1))\
    \ \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\
    \n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\
    \n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n \
    \     description[36];\n  } TagInfo;\n\n  static const TagInfo\n    EXIFTag[]\
    \ =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002,\
    \ \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n\
    \      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\"\
    \ },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\"\
    \ },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\"\
    \ },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\"\
    \ },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\"\
    \ },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\"\
    \ },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\"\
    \ },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\"\
    \ },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\"\
    \ },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\"\
    \ },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\"\
    \ },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\"\
    \ },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\"\
    \ },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\"\
    \ },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\"\
    \ },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\"\
    \ },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\"\
    \ },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\"\
    \ },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\"\
    \ },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\"\
    \ },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\"\
    \ },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n\
    \      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n\
    \      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\"\
    \ },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\"\
    \ },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\"\
    \ },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\"\
    \ },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\"\
    \ },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\"\
    \ },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\"\
    \ },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203,\
    \ \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\"\
    \ },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\"\
    \ },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\"\
    \ },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\"\
    \ },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\"\
    \ },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301,\
    \ \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {\
    \  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\"\
    \ },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\"\
    \ },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"\
    exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n   \
    \   {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\"\
    \ },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\"\
    \ },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\"\
    \ },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\"\
    \ },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\"\
    \ },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\"\
    \ },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\"\
    \ },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\"\
    \ },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\"\
    \ },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\"\
    \ },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"\
    exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n  \
    \    {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\"\
    \ },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\"\
    \ },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026,\
    \ \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\"\
    \ },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"\
    exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\"\
    \ },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"\
    exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\"\
    \ },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\"\
    \ },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"\
    exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\"\
    \ },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\"\
    \ },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\"\
    \ },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038,\
    \ \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\"\
    \ },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"\
    exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n  \
    \    {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\"\
    \ },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\"\
    \ },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\"\
    \ },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\"\
    \ },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\"\
    \ },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\"\
    \ },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\"\
    \ },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\"\
    \ },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\"\
    \ },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\"\
    \ },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\"\
    \ },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\"\
    \ },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769,\
    \ \"exif:ExifOffset\" },  /* specs as \"Exif IFD Pointer\"? */\n      {  0x8773,\
    \ \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n\
    \      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\"\
    \ }, /* specs as \"GPSInfo IFD Pointer\"? */\n      {  0x8827, \"exif:PhotographicSensitivity\"\
    \ },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\
    \      \n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\"\
    \ },\n      {  0x8830, \"exif:SensitivityType\" },\n      {  0x8831, \"exif:StandardOutputSensitivity\"\
    \ },\n      {  0x8832, \"exif:RecommendedExposureIndex\" },\n      {  0x8833,\
    \ \"exif:ISOSpeed\" },\n      {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n   \
    \   {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n      {  0x9000, \"exif:ExifVersion\"\
    \ },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\"\
    \ },\n      {  0x9010, \"exif:OffsetTime\" },\n      {  0x9011, \"exif:OffsetTimeOriginal\"\
    \ },\n      {  0x9012, \"exif:OffsetTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\"\
    \ },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"\
    exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n    \
    \  {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\"\
    \ },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\"\
    \ },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\"\
    \ },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\"\
    \ },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\"\
    \ },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9211, \"\
    exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n \
    \     {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\"\
    \ },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9286, \"exif:UserComment\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9400, \"\
    exif:Temperature\" },\n      {  0x9401, \"exif:Humidity\" },\n      {  0x9402,\
    \ \"exif:Pressure\" },\n      {  0x9403, \"exif:WaterDepth\" },\n      {  0x9404,\
    \ \"exif:Acceleration\" },\n      {  0x9405, \"exif:CameraElevationAngle\" },\
    \    \n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\"\
    \ },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\"\
    \ },\n      {  0x9C9f, \"exif:WinXP-Subject\" },      \n      {  0xa000, \"exif:FlashPixVersion\"\
    \ },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:PixelXDimension\"\
    \ },\n      {  0xa003, \"exif:PixelYDimension\" },\n      {  0xa004, \"exif:RelatedSoundFile\"\
    \ },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"\
    exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n\
    \      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\"\
    \ },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"\
    exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\"\
    \ },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\"\
    \ },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\"\
    \ },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\"\
    \ },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\"\
    \ },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\"\
    \ },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"\
    exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {\
    \  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n   \
    \   {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\"\
    \ },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\"\
    \ },\n      {  0xa430, \"exif:CameraOwnerName\" },\n      {  0xa431, \"exif:BodySerialNumber\"\
    \ },\n      {  0xa432, \"exif:LensSpecification\" },\n      {  0xa433, \"exif:LensMake\"\
    \ },\n      {  0xa434, \"exif:LensModel\" },\n      {  0xa435, \"exif:LensSerialNumber\"\
    \ },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\"\
    \ },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\"\
    \ },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\"\
    \ },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\"\
    \ },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\"\
    \ },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\"\
    \ },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\"\
    \ },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\"\
    \ },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\"\
    \ },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\"\
    \ },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\"\
    \ },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\"\
    \ },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\"\
    \ },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\"\
    \ },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\"\
    \ },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\"\
    \ },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\"\
    \ },\n      { 0x1001f, \"exif:GPSHPositioningError\" },\n      { 0x00000, \"\"\
    \ }\n    };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf\
    \ */\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n\
    \    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n\
    \    endian;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n\
    \    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n\
    \    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n\
    \    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2,\
    \ 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request\
    \ for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile\
    \ == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property ==\
    \ (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while\
    \ (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property)\
    \ <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n\
    \  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags\
    \ in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in\
    \ description=value format */\n      break;\n    }\n    case '!':\n    {\n   \
    \   tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n\
    \    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n\
    \        n;\n\n      /*\n        Check for a hex based tag specification first.\n\
    \      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n\
    \      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n\
    \      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n\
    \      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n \
    \         c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c\
    \ <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A')\
    \ && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n       \
    \       if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n  \
    \            else\n                return(MagickFalse);\n        }\n      } while\
    \ (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n\
    \        Try to match the text with a tag name instead.\n      */\n      for (i=0;\
    \ ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n      \
    \  if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n   \
    \         tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n    \
    \  }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n\
    \  length=GetStringInfoLength(profile);\n  if (length < 6)\n    return(MagickFalse);\n\
    \  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n\
    \      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n\
    \    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n\
    \      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n\
    \  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n\
    \  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n \
    \     endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2)\
    \ != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first\
    \ IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if\
    \ ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n\
    \    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n\
    \  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int\
    \ (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void\
    \ *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then\
    \ pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n       \
    \ directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n\
    \        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory\
    \ < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine\
    \ how many entries there are in the current IFD.\n    */\n    number_entries=(size_t)\
    \ ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries;\
    \ entry++)\n    {\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n\
    \        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\
    \n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n\
    \        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q)\
    \ == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n\
    \      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n  \
    \    format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format\
    \ >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      if (format\
    \ == 0)\n        break;  /* corrupt EXIF */\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n\
    \      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t)\
    \ components*tag_bytes[format];\n      if (number_bytes < components)\n      \
    \  break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n\
    \      else\n        {\n          ssize_t\n            dir_offset;\n\n       \
    \   /*\n            The directory entry contains an offset.\n          */\n  \
    \        dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if\
    \ ((dir_offset < 0) || (size_t) dir_offset >= length)\n            continue;\n\
    \          if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n   \
    \         continue;  /* prevent overflow */\n          if (((size_t) dir_offset+number_bytes)\
    \ > length)\n            continue;\n          p=(unsigned char *) (exif+dir_offset);\n\
    \        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n\
    \          char\n            buffer[MaxTextExtent],\n            *value;\n\n \
    \         if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n         \
    \   break;\n          value=(char *) NULL;\n          *buffer='\\0';\n       \
    \   switch (format)\n          {\n            case EXIF_FMT_BYTE:\n          \
    \  case EXIF_FMT_UNDEFINED:\n            {\n              value=(char *) NULL;\n\
    \              if (~((size_t) number_bytes) >= 1)\n                value=(char\
    \ *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n\
    \              if (value != (char *) NULL)\n                {\n              \
    \    for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n       \
    \             value[i]='.';\n                    if (isprint((int) p[i]) != 0)\
    \ \n                      value[i]=(char) p[i];\n                  }\n       \
    \           value[i]='\\0';\n                }\n              break;\n       \
    \     }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"\
    %.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n\
    \            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hd\",ReadPropertySignedShort(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n         \
    \   }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"\
    %.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n    \
    \          break;\n            }\n            case EXIF_FMT_SLONG:\n         \
    \   {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n               \
    \ ReadPropertySignedLong(endian,p1));\n              break;\n            }\n \
    \           case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"\
    %.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n\
    \                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SRATIONAL:\n            {\n        \
    \      EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n\
    \                ReadPropertySignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SINGLE:\n            {\n           \
    \   EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n\
    \              break;\n            }\n            case EXIF_FMT_DOUBLE:\n    \
    \        {\n              EXIFMultipleValues(8,\"%.20g\",(double)\n          \
    \      ReadPropertySignedLong(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_STRING:\n            default:\n            {\n\
    \              if ((p < exif) || (p > (exif+length-number_bytes)))\n         \
    \       break;\n              value=(char *) NULL;\n              if (~((size_t)\
    \ number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t)\
    \ number_bytes+1UL,\n                  sizeof(*value));\n              if (value\
    \ != (char *) NULL)\n                {\n                  ssize_t\n          \
    \          i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n\
    \                  {\n                    value[i]='.';\n                    if\
    \ ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char)\
    \ p[i];\n                  }\n                  value[i]='\\0';\n            \
    \    }\n              break;\n            }\n          }\n          if (value\
    \ != (char *) NULL)\n            {\n              char\n                *key;\n\
    \n              const char\n                *p;\n\n              key=AcquireString(property);\n\
    \              switch (all)\n              {\n                case 1:\n      \
    \          {\n                  const char\n                    *description;\n\
    \n                  ssize_t\n                    i;\n\n                  description=\"\
    unknown\";\n                  for (i=0; ; i++)\n                  {\n        \
    \            if (EXIFTag[i].tag == 0)\n                      break;\n        \
    \            if (EXIFTag[i].tag == tag_value)\n                      {\n     \
    \                   description=EXIFTag[i].description;\n                    \
    \    break;\n                      }\n                  }\n                  (void)\
    \ FormatLocaleString(key,MaxTextExtent,\"%s\",\n                    description);\n\
    \                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n \
    \               case 2:\n                {\n                  if (tag_value <\
    \ 0x10000)\n                    (void) FormatLocaleString(key,MaxTextExtent,\"\
    #%04lx\",\n                      (unsigned long) tag_value);\n               \
    \   else\n                    if (tag_value < 0x20000)\n                     \
    \ (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                  \
    \      (unsigned long) (tag_value & 0xffff));\n                    else\n    \
    \                  (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n\
    \                  break;\n                }\n                default:\n     \
    \           {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                }\n              }\n          \
    \    p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n\
    \                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n  \
    \                image->properties,key);\n              if (p == (const char *)\
    \ NULL)\n                (void) SetImageProperty((Image *) image,key,value);\n\
    \              value=DestroyString(value);\n              key=DestroyString(key);\n\
    \              status=MagickTrue;\n            }\n        }\n        if ((tag_value\
    \ == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value\
    \ == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\
    \n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n           \
    \ if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n       \
    \       {\n                ssize_t\n                  tag_offset1;\n\n       \
    \         tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n \
    \                 0);\n                directory_stack[level].directory=directory;\n\
    \                entry++;\n                directory_stack[level].entry=entry;\n\
    \                directory_stack[level].offset=tag_offset;\n                level++;\n\
    \                /*\n                  Check for duplicate tag.\n            \
    \    */\n                for (i=0; i < level; i++)\n                  if (directory_stack[i].directory\
    \ == (exif+tag_offset1))\n                    break;\n                if (i <\
    \ level)\n                  break;  /* duplicate tag */\n                directory_stack[level].directory=exif+offset;\n\
    \                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n\
    \                level++;\n                if ((directory+2+(12*number_entries)+4)\
    \ > (exif+length))\n                  break;\n                offset=(ssize_t)\
    \ ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n\
    \                if ((offset != 0) && ((size_t) offset < length) &&\n        \
    \            (level < (MaxDirectoryStack-2)))\n                  {\n         \
    \           directory_stack[level].directory=exif+offset;\n                  \
    \  directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n\
    \                    level++;\n                  }\n              }\n        \
    \    break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n\
    \  return(status);\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nstatic MagickBooleanType GetEXIFProperty(const\
    \ Image *image,\n  const char *property)\n{\n#define MaxDirectoryStack  16\n#define\
    \ EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define EXIF_FMT_BYTE\
    \  1\n#define EXIF_FMT_STRING  2\n#define EXIF_FMT_USHORT  3\n#define EXIF_FMT_ULONG\
    \  4\n#define EXIF_FMT_URATIONAL  5\n#define EXIF_FMT_SBYTE  6\n#define EXIF_FMT_UNDEFINED\
    \  7\n#define EXIF_FMT_SSHORT  8\n#define EXIF_FMT_SLONG  9\n#define EXIF_FMT_SRATIONAL\
    \  10\n#define EXIF_FMT_SINGLE  11\n#define EXIF_FMT_DOUBLE  12\n#define TAG_EXIF_OFFSET\
    \  0x8769\n#define TAG_GPS_OFFSET  0x8825\n#define TAG_INTEROP_OFFSET  0xa005\n\
    \n#define EXIFMultipleValues(size,format,arg) \\\n{ \\\n   ssize_t \\\n     component;\
    \ \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned char \\\n     *p1;\
    \ \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0; component < components;\
    \ component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",arg); \\\n     if (length >= (MaxTextExtent-1)) \\\n\
    \       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n#define EXIFMultipleFractions(size,format,arg1,arg2) \\\n{ \\\n   ssize_t\
    \ \\\n     component; \\\n \\\n   size_t \\\n     length; \\\n \\\n   unsigned\
    \ char \\\n     *p1; \\\n \\\n   length=0; \\\n   p1=p; \\\n   for (component=0;\
    \ component < components; component++) \\\n   { \\\n     length+=FormatLocaleString(buffer+length,MaxTextExtent-length,\
    \ \\\n       format\", \",(arg1),(arg2)); \\\n     if (length >= (MaxTextExtent-1))\
    \ \\\n       length=MaxTextExtent-1; \\\n     p1+=size; \\\n   } \\\n   if (length\
    \ > 1) \\\n     buffer[length-2]='\\0'; \\\n   value=AcquireString(buffer); \\\
    \n}\n\n  typedef struct _DirectoryInfo\n  {\n    const unsigned char\n      *directory;\n\
    \n    size_t\n      entry;\n\n    ssize_t\n      offset;\n  } DirectoryInfo;\n\
    \n  typedef struct _TagInfo\n  {\n    size_t\n      tag;\n\n    const char\n \
    \     description[36];\n  } TagInfo;\n\n  static const TagInfo\n    EXIFTag[]\
    \ =\n    {\n      {  0x001, \"exif:InteroperabilityIndex\" },\n      {  0x002,\
    \ \"exif:InteroperabilityVersion\" },\n      {  0x100, \"exif:ImageWidth\" },\n\
    \      {  0x101, \"exif:ImageLength\" },\n      {  0x102, \"exif:BitsPerSample\"\
    \ },\n      {  0x103, \"exif:Compression\" },\n      {  0x106, \"exif:PhotometricInterpretation\"\
    \ },\n      {  0x10a, \"exif:FillOrder\" },\n      {  0x10d, \"exif:DocumentName\"\
    \ },\n      {  0x10e, \"exif:ImageDescription\" },\n      {  0x10f, \"exif:Make\"\
    \ },\n      {  0x110, \"exif:Model\" },\n      {  0x111, \"exif:StripOffsets\"\
    \ },\n      {  0x112, \"exif:Orientation\" },\n      {  0x115, \"exif:SamplesPerPixel\"\
    \ },\n      {  0x116, \"exif:RowsPerStrip\" },\n      {  0x117, \"exif:StripByteCounts\"\
    \ },\n      {  0x11a, \"exif:XResolution\" },\n      {  0x11b, \"exif:YResolution\"\
    \ },\n      {  0x11c, \"exif:PlanarConfiguration\" },\n      {  0x11d, \"exif:PageName\"\
    \ },\n      {  0x11e, \"exif:XPosition\" },\n      {  0x11f, \"exif:YPosition\"\
    \ },\n      {  0x118, \"exif:MinSampleValue\" },\n      {  0x119, \"exif:MaxSampleValue\"\
    \ },\n      {  0x120, \"exif:FreeOffsets\" },\n      {  0x121, \"exif:FreeByteCounts\"\
    \ },\n      {  0x122, \"exif:GrayResponseUnit\" },\n      {  0x123, \"exif:GrayResponseCurve\"\
    \ },\n      {  0x124, \"exif:T4Options\" },\n      {  0x125, \"exif:T6Options\"\
    \ },\n      {  0x128, \"exif:ResolutionUnit\" },\n      {  0x12d, \"exif:TransferFunction\"\
    \ },\n      {  0x131, \"exif:Software\" },\n      {  0x132, \"exif:DateTime\"\
    \ },\n      {  0x13b, \"exif:Artist\" },\n      {  0x13e, \"exif:WhitePoint\"\
    \ },\n      {  0x13f, \"exif:PrimaryChromaticities\" },\n      {  0x140, \"exif:ColorMap\"\
    \ },\n      {  0x141, \"exif:HalfToneHints\" },\n      {  0x142, \"exif:TileWidth\"\
    \ },\n      {  0x143, \"exif:TileLength\" },\n      {  0x144, \"exif:TileOffsets\"\
    \ },\n      {  0x145, \"exif:TileByteCounts\" },\n      {  0x14a, \"exif:SubIFD\"\
    \ },\n      {  0x14c, \"exif:InkSet\" },\n      {  0x14d, \"exif:InkNames\" },\n\
    \      {  0x14e, \"exif:NumberOfInks\" },\n      {  0x150, \"exif:DotRange\" },\n\
    \      {  0x151, \"exif:TargetPrinter\" },\n      {  0x152, \"exif:ExtraSample\"\
    \ },\n      {  0x153, \"exif:SampleFormat\" },\n      {  0x154, \"exif:SMinSampleValue\"\
    \ },\n      {  0x155, \"exif:SMaxSampleValue\" },\n      {  0x156, \"exif:TransferRange\"\
    \ },\n      {  0x157, \"exif:ClipPath\" },\n      {  0x158, \"exif:XClipPathUnits\"\
    \ },\n      {  0x159, \"exif:YClipPathUnits\" },\n      {  0x15a, \"exif:Indexed\"\
    \ },\n      {  0x15b, \"exif:JPEGTables\" },\n      {  0x15f, \"exif:OPIProxy\"\
    \ },\n      {  0x200, \"exif:JPEGProc\" },\n      {  0x201, \"exif:JPEGInterchangeFormat\"\
    \ },\n      {  0x202, \"exif:JPEGInterchangeFormatLength\" },\n      {  0x203,\
    \ \"exif:JPEGRestartInterval\" },\n      {  0x205, \"exif:JPEGLosslessPredictors\"\
    \ },\n      {  0x206, \"exif:JPEGPointTransforms\" },\n      {  0x207, \"exif:JPEGQTables\"\
    \ },\n      {  0x208, \"exif:JPEGDCTables\" },\n      {  0x209, \"exif:JPEGACTables\"\
    \ },\n      {  0x211, \"exif:YCbCrCoefficients\" },\n      {  0x212, \"exif:YCbCrSubSampling\"\
    \ },\n      {  0x213, \"exif:YCbCrPositioning\" },\n      {  0x214, \"exif:ReferenceBlackWhite\"\
    \ },\n      {  0x2bc, \"exif:ExtensibleMetadataPlatform\" },\n      {  0x301,\
    \ \"exif:Gamma\" },\n      {  0x302, \"exif:ICCProfileDescriptor\" },\n      {\
    \  0x303, \"exif:SRGBRenderingIntent\" },\n      {  0x320, \"exif:ImageTitle\"\
    \ },\n      {  0x5001, \"exif:ResolutionXUnit\" },\n      {  0x5002, \"exif:ResolutionYUnit\"\
    \ },\n      {  0x5003, \"exif:ResolutionXLengthUnit\" },\n      {  0x5004, \"\
    exif:ResolutionYLengthUnit\" },\n      {  0x5005, \"exif:PrintFlags\" },\n   \
    \   {  0x5006, \"exif:PrintFlagsVersion\" },\n      {  0x5007, \"exif:PrintFlagsCrop\"\
    \ },\n      {  0x5008, \"exif:PrintFlagsBleedWidth\" },\n      {  0x5009, \"exif:PrintFlagsBleedWidthScale\"\
    \ },\n      {  0x500A, \"exif:HalftoneLPI\" },\n      {  0x500B, \"exif:HalftoneLPIUnit\"\
    \ },\n      {  0x500C, \"exif:HalftoneDegree\" },\n      {  0x500D, \"exif:HalftoneShape\"\
    \ },\n      {  0x500E, \"exif:HalftoneMisc\" },\n      {  0x500F, \"exif:HalftoneScreen\"\
    \ },\n      {  0x5010, \"exif:JPEGQuality\" },\n      {  0x5011, \"exif:GridSize\"\
    \ },\n      {  0x5012, \"exif:ThumbnailFormat\" },\n      {  0x5013, \"exif:ThumbnailWidth\"\
    \ },\n      {  0x5014, \"exif:ThumbnailHeight\" },\n      {  0x5015, \"exif:ThumbnailColorDepth\"\
    \ },\n      {  0x5016, \"exif:ThumbnailPlanes\" },\n      {  0x5017, \"exif:ThumbnailRawBytes\"\
    \ },\n      {  0x5018, \"exif:ThumbnailSize\" },\n      {  0x5019, \"exif:ThumbnailCompressedSize\"\
    \ },\n      {  0x501a, \"exif:ColorTransferFunction\" },\n      {  0x501b, \"\
    exif:ThumbnailData\" },\n      {  0x5020, \"exif:ThumbnailImageWidth\" },\n  \
    \    {  0x5021, \"exif:ThumbnailImageHeight\" },\n      {  0x5022, \"exif:ThumbnailBitsPerSample\"\
    \ },\n      {  0x5023, \"exif:ThumbnailCompression\" },\n      {  0x5024, \"exif:ThumbnailPhotometricInterp\"\
    \ },\n      {  0x5025, \"exif:ThumbnailImageDescription\" },\n      {  0x5026,\
    \ \"exif:ThumbnailEquipMake\" },\n      {  0x5027, \"exif:ThumbnailEquipModel\"\
    \ },\n      {  0x5028, \"exif:ThumbnailStripOffsets\" },\n      {  0x5029, \"\
    exif:ThumbnailOrientation\" },\n      {  0x502a, \"exif:ThumbnailSamplesPerPixel\"\
    \ },\n      {  0x502b, \"exif:ThumbnailRowsPerStrip\" },\n      {  0x502c, \"\
    exif:ThumbnailStripBytesCount\" },\n      {  0x502d, \"exif:ThumbnailResolutionX\"\
    \ },\n      {  0x502e, \"exif:ThumbnailResolutionY\" },\n      {  0x502f, \"exif:ThumbnailPlanarConfig\"\
    \ },\n      {  0x5030, \"exif:ThumbnailResolutionUnit\" },\n      {  0x5031, \"\
    exif:ThumbnailTransferFunction\" },\n      {  0x5032, \"exif:ThumbnailSoftwareUsed\"\
    \ },\n      {  0x5033, \"exif:ThumbnailDateTime\" },\n      {  0x5034, \"exif:ThumbnailArtist\"\
    \ },\n      {  0x5035, \"exif:ThumbnailWhitePoint\" },\n      {  0x5036, \"exif:ThumbnailPrimaryChromaticities\"\
    \ },\n      {  0x5037, \"exif:ThumbnailYCbCrCoefficients\" },\n      {  0x5038,\
    \ \"exif:ThumbnailYCbCrSubsampling\" },\n      {  0x5039, \"exif:ThumbnailYCbCrPositioning\"\
    \ },\n      {  0x503A, \"exif:ThumbnailRefBlackWhite\" },\n      {  0x503B, \"\
    exif:ThumbnailCopyRight\" },\n      {  0x5090, \"exif:LuminanceTable\" },\n  \
    \    {  0x5091, \"exif:ChrominanceTable\" },\n      {  0x5100, \"exif:FrameDelay\"\
    \ },\n      {  0x5101, \"exif:LoopCount\" },\n      {  0x5110, \"exif:PixelUnit\"\
    \ },\n      {  0x5111, \"exif:PixelPerUnitX\" },\n      {  0x5112, \"exif:PixelPerUnitY\"\
    \ },\n      {  0x5113, \"exif:PaletteHistogram\" },\n      {  0x1000, \"exif:RelatedImageFileFormat\"\
    \ },\n      {  0x1001, \"exif:RelatedImageLength\" },\n      {  0x1002, \"exif:RelatedImageWidth\"\
    \ },\n      {  0x800d, \"exif:ImageID\" },\n      {  0x80e3, \"exif:Matteing\"\
    \ },\n      {  0x80e4, \"exif:DataType\" },\n      {  0x80e5, \"exif:ImageDepth\"\
    \ },\n      {  0x80e6, \"exif:TileDepth\" },\n      {  0x828d, \"exif:CFARepeatPatternDim\"\
    \ },\n      {  0x828e, \"exif:CFAPattern2\" },\n      {  0x828f, \"exif:BatteryLevel\"\
    \ },\n      {  0x8298, \"exif:Copyright\" },\n      {  0x829a, \"exif:ExposureTime\"\
    \ },\n      {  0x829d, \"exif:FNumber\" },\n      {  0x83bb, \"exif:IPTC/NAA\"\
    \ },\n      {  0x84e3, \"exif:IT8RasterPadding\" },\n      {  0x84e5, \"exif:IT8ColorTable\"\
    \ },\n      {  0x8649, \"exif:ImageResourceInformation\" },\n      {  0x8769,\
    \ \"exif:ExifOffset\" },  /* specs as \"Exif IFD Pointer\"? */\n      {  0x8773,\
    \ \"exif:InterColorProfile\" },\n      {  0x8822, \"exif:ExposureProgram\" },\n\
    \      {  0x8824, \"exif:SpectralSensitivity\" },\n      {  0x8825, \"exif:GPSInfo\"\
    \ }, /* specs as \"GPSInfo IFD Pointer\"? */\n      {  0x8827, \"exif:PhotographicSensitivity\"\
    \ },\n      {  0x8828, \"exif:OECF\" },\n      {  0x8829, \"exif:Interlace\" },\
    \      \n      {  0x882a, \"exif:TimeZoneOffset\" },\n      {  0x882b, \"exif:SelfTimerMode\"\
    \ },\n      {  0x8830, \"exif:SensitivityType\" },\n      {  0x8831, \"exif:StandardOutputSensitivity\"\
    \ },\n      {  0x8832, \"exif:RecommendedExposureIndex\" },\n      {  0x8833,\
    \ \"exif:ISOSpeed\" },\n      {  0x8834, \"exif:ISOSpeedLatitudeyyy\" },\n   \
    \   {  0x8835, \"exif:ISOSpeedLatitudezzz\" },\n      {  0x9000, \"exif:ExifVersion\"\
    \ },\n      {  0x9003, \"exif:DateTimeOriginal\" },\n      {  0x9004, \"exif:DateTimeDigitized\"\
    \ },\n      {  0x9010, \"exif:OffsetTime\" },\n      {  0x9011, \"exif:OffsetTimeOriginal\"\
    \ },\n      {  0x9012, \"exif:OffsetTimeDigitized\" },\n      {  0x9101, \"exif:ComponentsConfiguration\"\
    \ },\n      {  0x9102, \"exif:CompressedBitsPerPixel\" },\n      {  0x9201, \"\
    exif:ShutterSpeedValue\" },\n      {  0x9202, \"exif:ApertureValue\" },\n    \
    \  {  0x9203, \"exif:BrightnessValue\" },\n      {  0x9204, \"exif:ExposureBiasValue\"\
    \ },\n      {  0x9205, \"exif:MaxApertureValue\" },\n      {  0x9206, \"exif:SubjectDistance\"\
    \ },\n      {  0x9207, \"exif:MeteringMode\" },\n      {  0x9208, \"exif:LightSource\"\
    \ },\n      {  0x9209, \"exif:Flash\" },\n      {  0x920a, \"exif:FocalLength\"\
    \ },\n      {  0x920b, \"exif:FlashEnergy\" },\n      {  0x920c, \"exif:SpatialFrequencyResponse\"\
    \ },\n      {  0x920d, \"exif:Noise\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9211, \"\
    exif:ImageNumber\" },\n      {  0x9212, \"exif:SecurityClassification\" },\n \
    \     {  0x9213, \"exif:ImageHistory\" },\n      {  0x9214, \"exif:SubjectArea\"\
    \ },\n      {  0x9215, \"exif:ExposureIndex\" },\n      {  0x9216, \"exif:TIFF-EPStandardID\"\
    \ },\n      {  0x927c, \"exif:MakerNote\" },\n      {  0x9286, \"exif:UserComment\"\
    \ },\n      {  0x9290, \"exif:SubSecTime\" },\n      {  0x9291, \"exif:SubSecTimeOriginal\"\
    \ },\n      {  0x9292, \"exif:SubSecTimeDigitized\" },    \n      {  0x9400, \"\
    exif:Temperature\" },\n      {  0x9401, \"exif:Humidity\" },\n      {  0x9402,\
    \ \"exif:Pressure\" },\n      {  0x9403, \"exif:WaterDepth\" },\n      {  0x9404,\
    \ \"exif:Acceleration\" },\n      {  0x9405, \"exif:CameraElevationAngle\" },\
    \    \n      {  0x9C9b, \"exif:WinXP-Title\" },\n      {  0x9C9c, \"exif:WinXP-Comments\"\
    \ },\n      {  0x9C9d, \"exif:WinXP-Author\" },\n      {  0x9C9e, \"exif:WinXP-Keywords\"\
    \ },\n      {  0x9C9f, \"exif:WinXP-Subject\" },      \n      {  0xa000, \"exif:FlashPixVersion\"\
    \ },\n      {  0xa001, \"exif:ColorSpace\" },\n      {  0xa002, \"exif:PixelXDimension\"\
    \ },\n      {  0xa003, \"exif:PixelYDimension\" },\n      {  0xa004, \"exif:RelatedSoundFile\"\
    \ },\n      {  0xa005, \"exif:InteroperabilityOffset\" },\n      {  0xa20b, \"\
    exif:FlashEnergy\" },\n      {  0xa20c, \"exif:SpatialFrequencyResponse\" },\n\
    \      {  0xa20d, \"exif:Noise\" },\n      {  0xa20e, \"exif:FocalPlaneXResolution\"\
    \ },\n      {  0xa20f, \"exif:FocalPlaneYResolution\" },\n      {  0xa210, \"\
    exif:FocalPlaneResolutionUnit\" },\n      {  0xa214, \"exif:SubjectLocation\"\
    \ },\n      {  0xa215, \"exif:ExposureIndex\" },\n      {  0xa216, \"exif:TIFF/EPStandardID\"\
    \ },\n      {  0xa217, \"exif:SensingMethod\" },\n      {  0xa300, \"exif:FileSource\"\
    \ },\n      {  0xa301, \"exif:SceneType\" },\n      {  0xa302, \"exif:CFAPattern\"\
    \ },\n      {  0xa401, \"exif:CustomRendered\" },\n      {  0xa402, \"exif:ExposureMode\"\
    \ },\n      {  0xa403, \"exif:WhiteBalance\" },\n      {  0xa404, \"exif:DigitalZoomRatio\"\
    \ },\n      {  0xa405, \"exif:FocalLengthIn35mmFilm\" },\n      {  0xa406, \"\
    exif:SceneCaptureType\" },\n      {  0xa407, \"exif:GainControl\" },\n      {\
    \  0xa408, \"exif:Contrast\" },\n      {  0xa409, \"exif:Saturation\" },\n   \
    \   {  0xa40a, \"exif:Sharpness\" },\n      {  0xa40b, \"exif:DeviceSettingDescription\"\
    \ },\n      {  0xa40c, \"exif:SubjectDistanceRange\" },\n      {  0xa420, \"exif:ImageUniqueID\"\
    \ },\n      {  0xa430, \"exif:CameraOwnerName\" },\n      {  0xa431, \"exif:BodySerialNumber\"\
    \ },\n      {  0xa432, \"exif:LensSpecification\" },\n      {  0xa433, \"exif:LensMake\"\
    \ },\n      {  0xa434, \"exif:LensModel\" },\n      {  0xa435, \"exif:LensSerialNumber\"\
    \ },\n      {  0xc4a5, \"exif:PrintImageMatching\" },\n      {  0xa500, \"exif:Gamma\"\
    \ },\n      {  0xc640, \"exif:CR2Slice\" },\n      { 0x10000, \"exif:GPSVersionID\"\
    \ },\n      { 0x10001, \"exif:GPSLatitudeRef\" },\n      { 0x10002, \"exif:GPSLatitude\"\
    \ },\n      { 0x10003, \"exif:GPSLongitudeRef\" },\n      { 0x10004, \"exif:GPSLongitude\"\
    \ },\n      { 0x10005, \"exif:GPSAltitudeRef\" },\n      { 0x10006, \"exif:GPSAltitude\"\
    \ },\n      { 0x10007, \"exif:GPSTimeStamp\" },\n      { 0x10008, \"exif:GPSSatellites\"\
    \ },\n      { 0x10009, \"exif:GPSStatus\" },\n      { 0x1000a, \"exif:GPSMeasureMode\"\
    \ },\n      { 0x1000b, \"exif:GPSDop\" },\n      { 0x1000c, \"exif:GPSSpeedRef\"\
    \ },\n      { 0x1000d, \"exif:GPSSpeed\" },\n      { 0x1000e, \"exif:GPSTrackRef\"\
    \ },\n      { 0x1000f, \"exif:GPSTrack\" },\n      { 0x10010, \"exif:GPSImgDirectionRef\"\
    \ },\n      { 0x10011, \"exif:GPSImgDirection\" },\n      { 0x10012, \"exif:GPSMapDatum\"\
    \ },\n      { 0x10013, \"exif:GPSDestLatitudeRef\" },\n      { 0x10014, \"exif:GPSDestLatitude\"\
    \ },\n      { 0x10015, \"exif:GPSDestLongitudeRef\" },\n      { 0x10016, \"exif:GPSDestLongitude\"\
    \ },\n      { 0x10017, \"exif:GPSDestBearingRef\" },\n      { 0x10018, \"exif:GPSDestBearing\"\
    \ },\n      { 0x10019, \"exif:GPSDestDistanceRef\" },\n      { 0x1001a, \"exif:GPSDestDistance\"\
    \ },\n      { 0x1001b, \"exif:GPSProcessingMethod\" },\n      { 0x1001c, \"exif:GPSAreaInformation\"\
    \ },\n      { 0x1001d, \"exif:GPSDateStamp\" },\n      { 0x1001e, \"exif:GPSDifferential\"\
    \ },\n      { 0x1001f, \"exif:GPSHPositioningError\" },\n      { 0x00000, \"\"\
    \ }\n    };  /* http://www.cipa.jp/std/documents/e/DC-008-Translation-2016-E.pdf\
    \ */\n\n  const StringInfo\n    *profile;\n\n  const unsigned char\n    *directory,\n\
    \    *exif;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n\
    \    endian;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    i;\n\n  size_t\n\
    \    entry,\n    length,\n    number_entries,\n    tag,\n    tag_value;\n\n  SplayTreeInfo\n\
    \    *exif_resources;\n\n  ssize_t\n    all,\n    id,\n    level,\n    offset,\n\
    \    tag_offset;\n\n  static int\n    tag_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2,\
    \ 4, 8, 4, 8};\n\n  /*\n    If EXIF data exists, then try to parse the request\
    \ for a tag.\n  */\n  profile=GetImageProfile(image,\"exif\");\n  if (profile\
    \ == (const StringInfo *) NULL)\n    return(MagickFalse);\n  if ((property ==\
    \ (const char *) NULL) || (*property == '\\0'))\n    return(MagickFalse);\n  while\
    \ (isspace((int) ((unsigned char) *property)) != 0)\n    property++;\n  if (strlen(property)\
    \ <= 5)\n    return(MagickFalse);\n  all=0;\n  tag=(~0UL);\n  switch (*(property+5))\n\
    \  {\n    case '*':\n    {\n      /*\n        Caller has asked for all the tags\
    \ in the EXIF data.\n      */\n      tag=0;\n      all=1; /* return the data in\
    \ description=value format */\n      break;\n    }\n    case '!':\n    {\n   \
    \   tag=0;\n      all=2; /* return the data in tagid=value format */\n      break;\n\
    \    }\n    case '#':\n    case '@':\n    {\n      int\n        c;\n\n      size_t\n\
    \        n;\n\n      /*\n        Check for a hex based tag specification first.\n\
    \      */\n      tag=(*(property+5) == '@') ? 1UL : 0UL;\n      property+=6;\n\
    \      n=strlen(property);\n      if (n != 4)\n        return(MagickFalse);\n\
    \      /*\n        Parse tag specification as a hex number.\n      */\n      n/=4;\n\
    \      do\n      {\n        for (i=(ssize_t) n-1L; i >= 0; i--)\n        {\n \
    \         c=(*property++);\n          tag<<=4;\n          if ((c >= '0') && (c\
    \ <= '9'))\n            tag|=(c-'0');\n          else\n            if ((c >= 'A')\
    \ && (c <= 'F'))\n              tag|=(c-('A'-10));\n            else\n       \
    \       if ((c >= 'a') && (c <= 'f'))\n                tag|=(c-('a'-10));\n  \
    \            else\n                return(MagickFalse);\n        }\n      } while\
    \ (*property != '\\0');\n      break;\n    }\n    default:\n    {\n      /*\n\
    \        Try to match the text with a tag name instead.\n      */\n      for (i=0;\
    \ ; i++)\n      {\n        if (EXIFTag[i].tag == 0)\n          break;\n      \
    \  if (LocaleCompare(EXIFTag[i].description,property) == 0)\n          {\n   \
    \         tag=(size_t) EXIFTag[i].tag;\n            break;\n          }\n    \
    \  }\n      break;\n    }\n  }\n  if (tag == (~0UL))\n    return(MagickFalse);\n\
    \  length=GetStringInfoLength(profile);\n  if (length < 6)\n    return(MagickFalse);\n\
    \  exif=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x45)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x78)\n\
    \      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x69)\n      continue;\n\
    \    if (ReadPropertyByte(&exif,&length) != 0x66)\n      continue;\n    if (ReadPropertyByte(&exif,&length)\
    \ != 0x00)\n      continue;\n    if (ReadPropertyByte(&exif,&length) != 0x00)\n\
    \      continue;\n    break;\n  }\n  if (length < 16)\n    return(MagickFalse);\n\
    \  id=(ssize_t) ReadPropertySignedShort(LSBEndian,exif);\n  endian=LSBEndian;\n\
    \  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n \
    \     endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadPropertyUnsignedShort(endian,exif+2)\
    \ != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first\
    \ IFD.\n  */\n  offset=(ssize_t) ReadPropertySignedLong(endian,exif+4);\n  if\
    \ ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  /*\n\
    \    Set the pointer to the first IFD and follow it were it leads.\n  */\n  status=MagickFalse;\n\
    \  directory=exif+offset;\n  level=0;\n  entry=0;\n  tag_offset=0;\n  exif_resources=NewSplayTree((int\
    \ (*)(const void *,const void *)) NULL,\n    (void *(*)(void *)) NULL,(void *(*)(void\
    \ *)) NULL);\n  do\n  {\n    /*\n      If there is anything on the stack then\
    \ pop it off.\n    */\n    if (level > 0)\n      {\n        level--;\n       \
    \ directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n\
    \        tag_offset=directory_stack[level].offset;\n      }\n    if ((directory\
    \ < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine\
    \ how many entries there are in the current IFD.\n    */\n    number_entries=(size_t)\
    \ ReadPropertyUnsignedShort(endian,directory);\n    for ( ; entry < number_entries;\
    \ entry++)\n    {\n      unsigned char\n        *p,\n        *q;\n\n      size_t\n\
    \        format;\n\n      ssize_t\n        number_bytes,\n        components;\n\
    \n      q=(unsigned char *) (directory+(12*entry)+2);\n      if (q > (exif+length-12))\n\
    \        break;  /* corrupt EXIF */\n      if (GetValueFromSplayTree(exif_resources,q)\
    \ == q)\n        break;\n      (void) AddValueToSplayTree(exif_resources,q,q);\n\
    \      tag_value=(size_t) ReadPropertyUnsignedShort(endian,q)+tag_offset;\n  \
    \    format=(size_t) ReadPropertyUnsignedShort(endian,q+2);\n      if (format\
    \ >= (sizeof(tag_bytes)/sizeof(*tag_bytes)))\n        break;\n      if (format\
    \ == 0)\n        break;  /* corrupt EXIF */\n      components=(ssize_t) ReadPropertySignedLong(endian,q+4);\n\
    \      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t)\
    \ components*tag_bytes[format];\n      if (number_bytes < components)\n      \
    \  break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n\
    \      else\n        {\n          ssize_t\n            dir_offset;\n\n       \
    \   /*\n            The directory entry contains an offset.\n          */\n  \
    \        dir_offset=(ssize_t) ReadPropertySignedLong(endian,q+8);\n          if\
    \ ((dir_offset < 0) || (size_t) dir_offset >= length)\n            continue;\n\
    \          if (((size_t) dir_offset+number_bytes) < (size_t) dir_offset)\n   \
    \         continue;  /* prevent overflow */\n          if (((size_t) dir_offset+number_bytes)\
    \ > length)\n            continue;\n          p=(unsigned char *) (exif+dir_offset);\n\
    \        }\n      if ((all != 0) || (tag == (size_t) tag_value))\n        {\n\
    \          char\n            buffer[MaxTextExtent],\n            *value;\n\n \
    \         if ((p < exif) || (p > (exif+length-tag_bytes[format])))\n         \
    \   break;\n          value=(char *) NULL;\n          *buffer='\\0';\n       \
    \   switch (format)\n          {\n            case EXIF_FMT_BYTE:\n          \
    \  case EXIF_FMT_UNDEFINED:\n            {\n              value=(char *) NULL;\n\
    \              if (~((size_t) number_bytes) >= 1)\n                value=(char\
    \ *) AcquireQuantumMemory((size_t) number_bytes+1UL,\n                  sizeof(*value));\n\
    \              if (value != (char *) NULL)\n                {\n              \
    \    for (i=0; i < (ssize_t) number_bytes; i++)\n                  {\n       \
    \             value[i]='.';\n                    if (isprint((int) p[i]) != 0)\
    \ \n                      value[i]=(char) p[i];\n                  }\n       \
    \           value[i]='\\0';\n                }\n              break;\n       \
    \     }\n            case EXIF_FMT_SBYTE:\n            {\n              EXIFMultipleValues(1,\"\
    %.20g\",(double) (*(signed char *) p1));\n              break;\n            }\n\
    \            case EXIF_FMT_SSHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hd\",ReadPropertySignedShort(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_USHORT:\n            {\n              EXIFMultipleValues(2,\"\
    %hu\",ReadPropertyUnsignedShort(endian,p1));\n              break;\n         \
    \   }\n            case EXIF_FMT_ULONG:\n            {\n              EXIFMultipleValues(4,\"\
    %.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1));\n    \
    \          break;\n            }\n            case EXIF_FMT_SLONG:\n         \
    \   {\n              EXIFMultipleValues(4,\"%.20g\",(double)\n               \
    \ ReadPropertySignedLong(endian,p1));\n              break;\n            }\n \
    \           case EXIF_FMT_URATIONAL:\n            {\n              EXIFMultipleFractions(8,\"\
    %.20g/%.20g\",(double)\n                ReadPropertyUnsignedLong(endian,p1),(double)\n\
    \                ReadPropertyUnsignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SRATIONAL:\n            {\n        \
    \      EXIFMultipleFractions(8,\"%.20g/%.20g\",(double)\n                ReadPropertySignedLong(endian,p1),(double)\n\
    \                ReadPropertySignedLong(endian,p1+4));\n              break;\n\
    \            }\n            case EXIF_FMT_SINGLE:\n            {\n           \
    \   EXIFMultipleValues(4,\"%.20g\",(double)\n                ReadPropertySignedLong(endian,p1));\n\
    \              break;\n            }\n            case EXIF_FMT_DOUBLE:\n    \
    \        {\n              EXIFMultipleValues(8,\"%.20g\",(double)\n          \
    \      ReadPropertySignedLong(endian,p1));\n              break;\n           \
    \ }\n            case EXIF_FMT_STRING:\n            default:\n            {\n\
    \              if ((p < exif) || (p > (exif+length-number_bytes)))\n         \
    \       break;\n              value=(char *) NULL;\n              if (~((size_t)\
    \ number_bytes) >= 1)\n                value=(char *) AcquireQuantumMemory((size_t)\
    \ number_bytes+1UL,\n                  sizeof(*value));\n              if (value\
    \ != (char *) NULL)\n                {\n                  ssize_t\n          \
    \          i;\n\n                  for (i=0; i < (ssize_t) number_bytes; i++)\n\
    \                  {\n                    value[i]='.';\n                    if\
    \ ((isprint((int) p[i]) != 0) || (p[i] == '\\0'))\n                      value[i]=(char)\
    \ p[i];\n                  }\n                  value[i]='\\0';\n            \
    \    }\n              break;\n            }\n          }\n          if (value\
    \ != (char *) NULL)\n            {\n              char\n                *key;\n\
    \n              const char\n                *p;\n\n              key=AcquireString(property);\n\
    \              switch (all)\n              {\n                case 1:\n      \
    \          {\n                  const char\n                    *description;\n\
    \n                  ssize_t\n                    i;\n\n                  description=\"\
    unknown\";\n                  for (i=0; ; i++)\n                  {\n        \
    \            if (EXIFTag[i].tag == 0)\n                      break;\n        \
    \            if (EXIFTag[i].tag == tag_value)\n                      {\n     \
    \                   description=EXIFTag[i].description;\n                    \
    \    break;\n                      }\n                  }\n                  (void)\
    \ FormatLocaleString(key,MaxTextExtent,\"%s\",\n                    description);\n\
    \                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                  break;\n                }\n \
    \               case 2:\n                {\n                  if (tag_value <\
    \ 0x10000)\n                    (void) FormatLocaleString(key,MaxTextExtent,\"\
    #%04lx\",\n                      (unsigned long) tag_value);\n               \
    \   else\n                    if (tag_value < 0x20000)\n                     \
    \ (void) FormatLocaleString(key,MaxTextExtent,\"@%04lx\",\n                  \
    \      (unsigned long) (tag_value & 0xffff));\n                    else\n    \
    \                  (void) FormatLocaleString(key,MaxTextExtent,\"unknown\");\n\
    \                  break;\n                }\n                default:\n     \
    \           {\n                  if (level == 2)\n                    (void) SubstituteString(&key,\"\
    exif:\",\"exif:thumbnail:\");\n                }\n              }\n          \
    \    p=(const char *) NULL;\n              if (image->properties != (void *) NULL)\n\
    \                p=(const char *) GetValueFromSplayTree((SplayTreeInfo *)\n  \
    \                image->properties,key);\n              if (p == (const char *)\
    \ NULL)\n                (void) SetImageProperty((Image *) image,key,value);\n\
    \              value=DestroyString(value);\n              key=DestroyString(key);\n\
    \              status=MagickTrue;\n            }\n        }\n        if ((tag_value\
    \ == TAG_EXIF_OFFSET) ||\n            (tag_value == TAG_INTEROP_OFFSET) || (tag_value\
    \ == TAG_GPS_OFFSET))\n          {\n            ssize_t\n              offset;\n\
    \n            offset=(ssize_t) ReadPropertySignedLong(endian,p);\n           \
    \ if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n       \
    \       {\n                ssize_t\n                  tag_offset1;\n\n       \
    \         tag_offset1=(ssize_t) ((tag_value == TAG_GPS_OFFSET) ? 0x10000 :\n \
    \                 0);\n                directory_stack[level].directory=directory;\n\
    \                entry++;\n                directory_stack[level].entry=entry;\n\
    \                directory_stack[level].offset=tag_offset;\n                level++;\n\
    \                /*\n                  Check for duplicate tag.\n            \
    \    */\n                for (i=0; i < level; i++)\n                  if (directory_stack[i].directory\
    \ == (exif+tag_offset1))\n                    break;\n                if (i <\
    \ level)\n                  break;  /* duplicate tag */\n                directory_stack[level].directory=exif+offset;\n\
    \                directory_stack[level].offset=tag_offset1;\n                directory_stack[level].entry=0;\n\
    \                level++;\n                if ((directory+2+(12*number_entries)+4)\
    \ > (exif+length))\n                  break;\n                offset=(ssize_t)\
    \ ReadPropertySignedLong(endian,directory+2+(12*\n                  number_entries));\n\
    \                if ((offset != 0) && ((size_t) offset < length) &&\n        \
    \            (level < (MaxDirectoryStack-2)))\n                  {\n         \
    \           directory_stack[level].directory=exif+offset;\n                  \
    \  directory_stack[level].entry=0;\n                    directory_stack[level].offset=tag_offset1;\n\
    \                    level++;\n                  }\n              }\n        \
    \    break;\n          }\n    }\n  } while (level > 0);\n  exif_resources=DestroySplayTree(exif_resources);\n\
    \  return(status);\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 217569
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
