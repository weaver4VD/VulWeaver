agents:
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\n  void\
    \ Compute(OpKernelContext *ctx) override {\n    const Tensor *indices_t, *values_t,\
    \ *shape_t, *reduction_axes_t;\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\"\
    , &indices_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"input_values\", &values_t));\n\
    \    OP_REQUIRES_OK(ctx, ctx->input(\"input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx,\
    \ ctx->input(\"reduction_axes\", &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx,\
    \ ValidateInputs(shape_t, reduction_axes_t));\n\n    // TODO(zongheng): we will\
    \ call Reorder() below, which will modify\n    // in-place the underlying indices\
    \ and values buffers.  To avoid\n    // surprises of this kernel being stateful,\
    \ we work around the above by\n    // making deep copies here.  Remove this if/when\
    \ we change Reorder()'s\n    // semantics.\n    const auto shape_vec = shape_t->vec<int64>();\n\
    \    SparseTensor sp;\n    OP_REQUIRES_OK(ctx, SparseTensor::Create(\n       \
    \ tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),\n               \
    \     TensorShape(shape_vec), &sp));\n    ReduceDetails reduction = SparseTensorReduceHelper(\n\
    \        sp, reduction_axes_t->flat<int32>(), keep_dims_);\n\n    Tensor *out_values;\n\
    \    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, reduction.reduced_shape,\
    \ &out_values));\n    auto out_flat = out_values->flat<T>();\n    out_flat.setZero();\n\
    \n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,\n\
    \                                           TensorShape({}), &tmp_reduced_val));\n\
    \    auto reduced_val = tmp_reduced_val.scalar<T>();\n\n    // Compute strides,\
    \ and use it to convert coords to flat index.  The\n    // coordinates returned\
    \ by .group() have the same ndims as group_by_dims.\n    gtl::InlinedVector<int64,\
    \ 8> output_strides(reduction.group_by_dims.size());\n    if (!output_strides.empty())\
    \ {  // Do this iff we don't reduce all.\n      output_strides.back() = 1;\n \
    \     for (int d = output_strides.size() - 2; d >= 0; --d) {\n        output_strides[d]\
    \ =\n            output_strides[d + 1] * shape_vec(reduction.group_by_dims[d +\
    \ 1]);\n      }\n    }\n\n    auto CoordinatesToFlatIndex = [](ArraySlice<int64>\
    \ coords,\n                                     ArraySlice<int64> strides) ->\
    \ int64 {\n      if (strides.empty()) {  // Reduce all.\n        return 0;\n \
    \     }\n      CHECK_EQ(coords.size(), strides.size());\n      int64_t idx = 0;\n\
    \      for (int i = 0; i < coords.size(); ++i) {\n        idx += coords[i] * strides[i];\n\
    \      }\n      return idx;\n    };\n\n    // Each group maps one-on-one onto\
    \ a value in the reduced tensor.\n    // g.group() provides the coordinates of\
    \ a particular reduced value.\n    sp.Reorder<T>(reduction.reorder_dims);\n  \
    \  for (const auto &g : sp.group(reduction.group_by_dims)) {\n      Op::template\
    \ Run<T>(ctx, reduced_val, g.template values<T>());\n      const int64_t idx =\
    \ CoordinatesToFlatIndex(g.group(), output_strides);\n      out_flat(idx) = reduced_val();\n\
    \      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(), \",\")\n          \
    \    << \"; idx: \" << idx << \"; group \" << Op::Name() << \": \"\n         \
    \     << reduced_val();\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\n  void Compute(OpKernelContext\
    \ *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n\
    \    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx,\
    \ ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"\
    input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\"\
    , &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\
    \n    // TODO(zongheng): we will call Reorder() below, which will modify\n   \
    \ // in-place the underlying indices and values buffers.  To avoid\n    // surprises\
    \ of this kernel being stateful, we work around the above by\n    // making deep\
    \ copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n\
    \    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n   \
    \ OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t),\
    \ tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n\
    \    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(),\
    \ keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0,\
    \ reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n\
    \    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx,\
    \ ctx->allocate_temp(DataTypeToEnum<T>::value,\n                             \
    \              TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\
    \n    // Compute strides, and use it to convert coords to flat index.  The\n \
    \   // coordinates returned by .group() have the same ndims as group_by_dims.\n\
    \    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n\
    \    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n   \
    \   output_strides.back() = 1;\n      for (int d = output_strides.size() - 2;\
    \ d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d +\
    \ 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto\
    \ CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                    \
    \                 ArraySlice<int64> strides) -> int64 {\n      if (strides.empty())\
    \ {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(),\
    \ strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size();\
    \ ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n\
    \    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n\
    \    // g.group() provides the coordinates of a particular reduced value.\n  \
    \  sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims))\
    \ {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n  \
    \    const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n\
    \      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(),\
    \ \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() <<\
    \ \": \"\n              << reduced_val();\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    model: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    model_type: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\n  void Compute(OpKernelContext *ctx) override\
    \ {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n  \
    \  OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx,\
    \ ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"\
    input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\"\
    , &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\
    \n    // TODO(zongheng): we will call Reorder() below, which will modify\n   \
    \ // in-place the underlying indices and values buffers.  To avoid\n    // surprises\
    \ of this kernel being stateful, we work around the above by\n    // making deep\
    \ copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n\
    \    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n   \
    \ OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t),\
    \ tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n\
    \    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(),\
    \ keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0,\
    \ reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n\
    \    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx,\
    \ ctx->allocate_temp(DataTypeToEnum<T>::value,\n                             \
    \              TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\
    \n    // Compute strides, and use it to convert coords to flat index.  The\n \
    \   // coordinates returned by .group() have the same ndims as group_by_dims.\n\
    \    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n\
    \    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n   \
    \   output_strides.back() = 1;\n      for (int d = output_strides.size() - 2;\
    \ d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d +\
    \ 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto\
    \ CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                    \
    \                 ArraySlice<int64> strides) -> int64 {\n      if (strides.empty())\
    \ {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(),\
    \ strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size();\
    \ ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n\
    \    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n\
    \    // g.group() provides the coordinates of a particular reduced value.\n  \
    \  sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims))\
    \ {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n  \
    \    const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n\
    \      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(),\
    \ \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() <<\
    \ \": \"\n              << reduced_val();\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\n  void Compute(OpKernelContext\
    \ *ctx) override {\n    const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;\n\
    \    OP_REQUIRES_OK(ctx, ctx->input(\"input_indices\", &indices_t));\n    OP_REQUIRES_OK(ctx,\
    \ ctx->input(\"input_values\", &values_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"\
    input_shape\", &shape_t));\n    OP_REQUIRES_OK(ctx, ctx->input(\"reduction_axes\"\
    , &reduction_axes_t));\n\n    OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));\n\
    \n    // TODO(zongheng): we will call Reorder() below, which will modify\n   \
    \ // in-place the underlying indices and values buffers.  To avoid\n    // surprises\
    \ of this kernel being stateful, we work around the above by\n    // making deep\
    \ copies here.  Remove this if/when we change Reorder()'s\n    // semantics.\n\
    \    const auto shape_vec = shape_t->vec<int64>();\n    SparseTensor sp;\n   \
    \ OP_REQUIRES_OK(ctx, SparseTensor::Create(\n        tensor::DeepCopy(*indices_t),\
    \ tensor::DeepCopy(*values_t),\n                    TensorShape(shape_vec), &sp));\n\
    \    ReduceDetails reduction = SparseTensorReduceHelper(\n        sp, reduction_axes_t->flat<int32>(),\
    \ keep_dims_);\n\n    Tensor *out_values;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0,\
    \ reduction.reduced_shape, &out_values));\n    auto out_flat = out_values->flat<T>();\n\
    \    out_flat.setZero();\n\n    Tensor tmp_reduced_val;\n    OP_REQUIRES_OK(ctx,\
    \ ctx->allocate_temp(DataTypeToEnum<T>::value,\n                             \
    \              TensorShape({}), &tmp_reduced_val));\n    auto reduced_val = tmp_reduced_val.scalar<T>();\n\
    \n    // Compute strides, and use it to convert coords to flat index.  The\n \
    \   // coordinates returned by .group() have the same ndims as group_by_dims.\n\
    \    gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());\n\
    \    if (!output_strides.empty()) {  // Do this iff we don't reduce all.\n   \
    \   output_strides.back() = 1;\n      for (int d = output_strides.size() - 2;\
    \ d >= 0; --d) {\n        output_strides[d] =\n            output_strides[d +\
    \ 1] * shape_vec(reduction.group_by_dims[d + 1]);\n      }\n    }\n\n    auto\
    \ CoordinatesToFlatIndex = [](ArraySlice<int64> coords,\n                    \
    \                 ArraySlice<int64> strides) -> int64 {\n      if (strides.empty())\
    \ {  // Reduce all.\n        return 0;\n      }\n      CHECK_EQ(coords.size(),\
    \ strides.size());\n      int64_t idx = 0;\n      for (int i = 0; i < coords.size();\
    \ ++i) {\n        idx += coords[i] * strides[i];\n      }\n      return idx;\n\
    \    };\n\n    // Each group maps one-on-one onto a value in the reduced tensor.\n\
    \    // g.group() provides the coordinates of a particular reduced value.\n  \
    \  sp.Reorder<T>(reduction.reorder_dims);\n    for (const auto &g : sp.group(reduction.group_by_dims))\
    \ {\n      Op::template Run<T>(ctx, reduced_val, g.template values<T>());\n  \
    \    const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);\n\
    \      out_flat(idx) = reduced_val();\n      VLOG(2) << \"coords: \" << absl::StrJoin(g.group(),\
    \ \",\")\n              << \"; idx: \" << idx << \"; group \" << Op::Name() <<\
    \ \": \"\n              << reduced_val();\n    }\n  }"
  verbose: true
environment:
  env_type: judge
  id_save: 198116
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
