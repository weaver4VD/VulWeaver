agents:
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\ndo_mouse(\n\
    \    oparg_T\t*oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t//\
    \ K_LEFTMOUSE, etc\n    int\t\tdir,\t\t// Direction to 'put' if necessary\n  \
    \  long\tcount,\n    int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n\
    {\n    static int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n \
    \   static int\tgot_click = FALSE;\t// got a click some time back\n\n    int\t\
    \twhich_button;\t// MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE;\
    \ // If FALSE it's a drag or release event\n    int\t\tis_drag = FALSE;  // If\
    \ TRUE it's a drag event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n\
    \    pos_T\tstart_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\
    \tin_status_line;\t// mouse in status line\n    static int\tin_tab_line = FALSE;\
    \ // mouse clicked in tab line\n    int\t\tin_sep_line;\t// mouse in vertical\
    \ separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n\
    #endif\n    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\t\
    leftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active\
    \ = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n\
    #if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n   \
    \ // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore\
    \ mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore\
    \ mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command\
    \ line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n\
    \    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n\
    #endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\
    \t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\
    \t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c),\
    \ &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is\
    \ the same mouse event then use that\n\t    // one. Speeds up dragging the status\
    \ line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\
    \t    // below need to come before the next character, do not do this\n\t    //\
    \ when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() !=\
    \ NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col\
    \ = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\
    \t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\t\
    vungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\
    \t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse\
    \ moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\
    \tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t\
    \    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n\
    #endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped\
    \ dragging the status or separator line.  The pointer is\n    // most likely still\
    \ on the status or separator line.\n    if (!is_drag && drag_status_line)\n  \
    \  {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n  \
    \  }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\t\
    update_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release\
    \ events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n \
    \   else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return\
    \ FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click\
    \ = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn\
    \ FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n\
    \    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n\
    \    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count\
    \ > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click\
    \ = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL\
    \ only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button\
    \ != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag\
    \ and release events, as well as\n    // multiple clicks and the middle mouse\
    \ button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\"\
    .\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\
    \t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\
    \t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\
    \t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask\
    \ & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\
    \t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement\
    \ command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button\
    \ that is held down, ignore\n    // drag/release events.\n    if (!is_click &&\
    \ which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname\
    \ = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does\
    \ a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\
    \tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't\
    \ know what the user wanted\n\t    // to do. Go back to normal mode: Clear the\
    \ operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t \
    \   {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual\
    \ was active, yank the highlighted text and put it\n\t    // before the mouse\
    \ pointer position.\n\t    // In Select mode replace the highlighted text with\
    \ the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\
    \t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"\
    +p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\
    \t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn\
    \ FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if\
    \ ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert\
    \ mode doesn't move the mouse, just insert the\n\t// contents of a register. \
    \ '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste\
    \ at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the\
    \ GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t   \
    \ if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname\
    \ = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\
    \t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL,\
    \ BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat\
    \ it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\
    \t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname\
    \ == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n\
    \    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\
    \tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n\
    \    if (TabPageIdxs != NULL)  // only when initialized\n    {\n\t// Check for\
    \ clicking in the tab page line.\n\tif (mouse_row == 0 && firstwin->w_winrow >\
    \ 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1\
    \ = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\
    \t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t \
    \   // click in a tab selects that tab page\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\
    \t\t    && cmdwin_type == 0\n# endif\n\t\t    && mouse_col < Columns)\n\t    {\n\
    \t\tin_tab_line = TRUE;\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\tif (c1 >= 0)\n\t\
    \t{\n\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t \
    \   {\n\t\t\t// double click opens new page\n\t\t\tend_visual_mode_keep_button();\n\
    \t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\
    \t\t    else\n\t\t    {\n\t\t\t// Go to specified tab page, or next one if not\
    \ clicking\n\t\t\t// on a label.\n\t\t\tgoto_tabpage(c1);\n\n\t\t\t// It's like\
    \ clicking on the status line of a window.\n\t\t\tif (curwin != old_curwin)\n\t\
    \t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \    tabpage_T\t*tp;\n\n\t\t    // Close the current or specified tab page.\n\t\
    \t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\
    \t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage->tp_next != NULL)\n\
    \t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\
    \ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\t\
    else if (is_drag && in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t\
    \    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\t    return FALSE;\n\t}\n    }\n\
    \n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n\
    \    // right button up   -> pop-up menu\n    // shift-left button -> right button\n\
    \    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n\
    \    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT\
    \ | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if\
    \ (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK)\
    \ \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore\
    \ right button release events, only shows the popup\n\t\t    // menu on the button\
    \ down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN)\
    \ || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore\
    \ right button down and drag mouse events.  Windows\n\t\t    // only shows the\
    \ popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n\
    # endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n\
    # endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore\
    \ right button release events, only shows the popup\n\t\t// menu on the button\
    \ down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem,\
    \ \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before\
    \ showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T\
    \    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t \
    \   // selection or the current window (might have false\n\t\t    // negative\
    \ here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\
    \t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t\
    \    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\
    \t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\
    \t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags\
    \ = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t\
    {\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol,\
    \ &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\
    \t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags,\
    \ NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\
    \t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t\
    \    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t\
    // ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) !=\
    \ 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\
    \t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button\
    \ = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT |\
    \ MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\
    \t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\
    \t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\
    \t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\
    \t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t//\
    \ cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual\
    \ = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t\
    \    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\
    \t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending,\
    \ ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag\
    \ && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type\
    \ = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n\
    \    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n\
    \    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive),\
    \ which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has\
    \ no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n\
    \    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags &\
    \ IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n\
    \    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE\
    \ | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE\
    \ || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\
    \t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping\
    \ to another window, clear a pending operator.  That's a bit\n    // friendlier\
    \ than beeping and not jumping to that window.\n    if (curwin != old_curwin &&\
    \ oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n\
    \    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE\
    \ | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open\
    \ or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum,\
    \ 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the\
    \ cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor\
    \ = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n\
    \    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n\
    \    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n \
    \   }\n#endif\n\n    // Set global flag that we are extending the Visual area\
    \ with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active\
    \ && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow\
    \ scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\
    \t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window,\
    \ scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\t\
    scroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\
    \t// right click in visual mode\n    {\n       // When ALT is pressed make Visual\
    \ mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\
    \n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t//\
    \ that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\
    \t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\
    \t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col =\
    \ leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum\
    \ >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum\
    \ = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual\
    \ = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\
    \t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor\
    \ = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the\
    \ click is before the start of visual, change the start.\n\t    // If the click\
    \ is after the end of visual, change the end.  If\n\t    // the click is inside\
    \ the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\
    \t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\
    \t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare\
    \ column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t  \
    \  if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col -\
    \ curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual\
    \ = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\t\
    else\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\
    \t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t//\
    \ closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t//\
    \ closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle\
    \ line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col\
    \ + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t \
    \   VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual\
    \ mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT)\
    \ && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click:\
    \ Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname =\
    \ '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\
    \t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\t\
    if (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\
    \t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t\
    }\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where\
    \ the paste started, so in edit() Insstart can be set\n\t// to this position\n\
    \tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname,\
    \ NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n\
    \    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n \
    \   // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\
    \t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n\
    \    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u\
    \ *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u\
    \ *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\
    \n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n\
    \    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\
    \t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\t\
    if (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\
    \tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse\
    \ click searches for the next occurrence of the word under\n    // the mouse pointer\n\
    \    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT)\
    \ || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif\
    \ (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\
    \t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on\
    \ status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\t\
    if ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line =\
    \ TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n\
    \    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\
    \t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n\
    \    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\t\
    if (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor\
    \ = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual =\
    \ curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\t\
    VIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"\
    mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with\
    \ ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode\
    \ = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else\
    \ if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode =\
    \ Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.\
    \  Needed because start and\n\t    // end may still be the same, and the selection\
    \ needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double\
    \ click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) ==\
    \ MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t   \
    \ if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white\
    \ space) is\n\t\t// not a word character, try finding a match and select a (),\n\
    \t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\
    \twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\
    \t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\
    \t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\
    \t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL))\
    \ != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type\
    \ == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t \
    \   {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\
    \t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t \
    \   if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found\
    \ a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor,\
    \ orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t \
    \   find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\
    \t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col\
    \ +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\
    \t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t\
    \    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else\
    \ if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t\
    \    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    //\
    \ If Visual mode changed show it later.\n    if ((!VIsual_active && old_active\
    \ && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\
    \t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\
    \n    return moved;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\ndo_mouse(\n    oparg_T\t\
    *oap,\t\t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n\
    \    int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n   \
    \ int\t\tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static\
    \ int\tdo_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\t\
    got_click = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t\
    // MOUSE_LEFT, _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's\
    \ a drag or release event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag\
    \ event\n    int\t\tjump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\t\
    start_visual;\n    int\t\tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t\
    // mouse in status line\n    static int\tin_tab_line = FALSE; // mouse clicked\
    \ in tab line\n    int\t\tin_sep_line;\t// mouse in vertical separator line\n\
    \    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n\
    \    win_T\t*old_curwin = curwin;\n    static pos_T orig_cursor;\n    colnr_T\t\
    leftcol, rightcol;\n    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active\
    \ = VIsual_active;\n    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n\
    #if defined(FEAT_FOLDING)\n    save_cursor = curwin->w_cursor;\n#endif\n\n   \
    \ // When GUI is active, always recognize mouse events, otherwise:\n    // - Ignore\
    \ mouse event in normal mode if 'mouse' doesn't include 'n'.\n    // - Ignore\
    \ mouse event in visual mode if 'mouse' doesn't include 'v'.\n    // - For command\
    \ line and insert mode 'mouse' is checked before calling\n    //\t do_mouse().\n\
    \    if (do_always)\n\tdo_always = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n\
    #endif\n\t{\n\t    if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\
    \t\t    return FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\
    \t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c),\
    \ &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is\
    \ the same mouse event then use that\n\t    // one. Speeds up dragging the status\
    \ line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\
    \t    // below need to come before the next character, do not do this\n\t    //\
    \ when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() !=\
    \ NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col\
    \ = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\
    \t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\t\
    vungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\
    \t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse\
    \ moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\
    \tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t\
    \    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n\
    #endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped\
    \ dragging the status or separator line.  The pointer is\n    // most likely still\
    \ on the status or separator line.\n    if (!is_drag && drag_status_line)\n  \
    \  {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n  \
    \  }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\t\
    update_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release\
    \ events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n \
    \   else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return\
    \ FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click\
    \ = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn\
    \ FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n\
    \    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n\
    \    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count\
    \ > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click\
    \ = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL\
    \ only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button\
    \ != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag\
    \ and release events, as well as\n    // multiple clicks and the middle mouse\
    \ button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\"\
    .\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\
    \t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\
    \t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\
    \t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask\
    \ & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\
    \t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement\
    \ command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button\
    \ that is held down, ignore\n    // drag/release events.\n    if (!is_click &&\
    \ which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname\
    \ = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does\
    \ a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\
    \tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't\
    \ know what the user wanted\n\t    // to do. Go back to normal mode: Clear the\
    \ operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t \
    \   {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual\
    \ was active, yank the highlighted text and put it\n\t    // before the mouse\
    \ pointer position.\n\t    // In Select mode replace the highlighted text with\
    \ the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\
    \t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"\
    +p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\
    \t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn\
    \ FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if\
    \ ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert\
    \ mode doesn't move the mouse, just insert the\n\t// contents of a register. \
    \ '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste\
    \ at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the\
    \ GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t   \
    \ if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname\
    \ = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\
    \t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL,\
    \ BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat\
    \ it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\
    \t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname\
    \ == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n\
    \    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\
    \tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n\
    \    if (TabPageIdxs != NULL)  // only when initialized\n    {\n\t// Check for\
    \ clicking in the tab page line.\n\tif (mouse_row == 0 && firstwin->w_winrow >\
    \ 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1\
    \ = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\
    \t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t \
    \   // click in a tab selects that tab page\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\
    \t\t    && cmdwin_type == 0\n# endif\n\t\t    && mouse_col < Columns)\n\t    {\n\
    \t\tin_tab_line = TRUE;\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\tif (c1 >= 0)\n\t\
    \t{\n\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t \
    \   {\n\t\t\t// double click opens new page\n\t\t\tend_visual_mode_keep_button();\n\
    \t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\
    \t\t    else\n\t\t    {\n\t\t\t// Go to specified tab page, or next one if not\
    \ clicking\n\t\t\t// on a label.\n\t\t\tgoto_tabpage(c1);\n\n\t\t\t// It's like\
    \ clicking on the status line of a window.\n\t\t\tif (curwin != old_curwin)\n\t\
    \t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \    tabpage_T\t*tp;\n\n\t\t    // Close the current or specified tab page.\n\t\
    \t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\
    \t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage->tp_next != NULL)\n\
    \t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\
    \ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\t\
    else if (is_drag && in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t\
    \    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\t    return FALSE;\n\t}\n    }\n\
    \n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n\
    \    // right button up   -> pop-up menu\n    // shift-left button -> right button\n\
    \    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n\
    \    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT\
    \ | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if\
    \ (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK)\
    \ \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore\
    \ right button release events, only shows the popup\n\t\t    // menu on the button\
    \ down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN)\
    \ || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore\
    \ right button down and drag mouse events.  Windows\n\t\t    // only shows the\
    \ popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n\
    # endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n\
    # endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore\
    \ right button release events, only shows the popup\n\t\t// menu on the button\
    \ down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem,\
    \ \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before\
    \ showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T\
    \    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t \
    \   // selection or the current window (might have false\n\t\t    // negative\
    \ here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\
    \t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t\
    \    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\
    \t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\
    \t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags\
    \ = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t\
    {\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol,\
    \ &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\
    \t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags,\
    \ NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\
    \t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t\
    \    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t\
    // ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) !=\
    \ 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\
    \t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button\
    \ = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT |\
    \ MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\
    \t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\
    \t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\
    \t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\
    \t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t//\
    \ cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual\
    \ = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t\
    \    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\
    \t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending,\
    \ ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag\
    \ && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type\
    \ = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n\
    \    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n\
    \    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive),\
    \ which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has\
    \ no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n\
    \    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags &\
    \ IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n\
    \    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE\
    \ | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE\
    \ || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\
    \t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping\
    \ to another window, clear a pending operator.  That's a bit\n    // friendlier\
    \ than beeping and not jumping to that window.\n    if (curwin != old_curwin &&\
    \ oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n\
    \    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE\
    \ | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open\
    \ or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum,\
    \ 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the\
    \ cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor\
    \ = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n\
    \    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n\
    \    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n \
    \   }\n#endif\n\n    // Set global flag that we are extending the Visual area\
    \ with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active\
    \ && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow\
    \ scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\
    \t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window,\
    \ scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\t\
    scroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\
    \t// right click in visual mode\n    {\n       // When ALT is pressed make Visual\
    \ mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\
    \n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t//\
    \ that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\
    \t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\
    \t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col =\
    \ leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum\
    \ >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum\
    \ = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual\
    \ = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\
    \t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor\
    \ = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the\
    \ click is before the start of visual, change the start.\n\t    // If the click\
    \ is after the end of visual, change the end.  If\n\t    // the click is inside\
    \ the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\
    \t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\
    \t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare\
    \ column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t  \
    \  if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col -\
    \ curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual\
    \ = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\t\
    else\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\
    \t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t//\
    \ closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t//\
    \ closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle\
    \ line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col\
    \ + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t \
    \   VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual\
    \ mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT)\
    \ && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click:\
    \ Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname =\
    \ '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\
    \t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\t\
    if (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\
    \t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t\
    }\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where\
    \ the paste started, so in edit() Insstart can be set\n\t// to this position\n\
    \tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname,\
    \ NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n\
    \    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n \
    \   // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\
    \t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n\
    \    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u\
    \ *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u\
    \ *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\
    \n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n\
    \    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\
    \t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\t\
    if (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\
    \tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse\
    \ click searches for the next occurrence of the word under\n    // the mouse pointer\n\
    \    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT)\
    \ || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif\
    \ (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\
    \t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on\
    \ status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\t\
    if ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line =\
    \ TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n\
    \    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\
    \t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n\
    \    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\t\
    if (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor\
    \ = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual =\
    \ curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\t\
    VIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"\
    mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with\
    \ ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode\
    \ = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else\
    \ if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode =\
    \ Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.\
    \  Needed because start and\n\t    // end may still be the same, and the selection\
    \ needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double\
    \ click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) ==\
    \ MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t   \
    \ if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white\
    \ space) is\n\t\t// not a word character, try finding a match and select a (),\n\
    \t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\
    \twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\
    \t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\
    \t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\
    \t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL))\
    \ != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type\
    \ == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t \
    \   {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\
    \t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t \
    \   if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found\
    \ a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor,\
    \ orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t \
    \   find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\
    \t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col\
    \ +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\
    \t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t\
    \    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else\
    \ if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t\
    \    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    //\
    \ If Visual mode changed show it later.\n    if ((!VIsual_active && old_active\
    \ && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\
    \t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\
    \n    return moved;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\ndo_mouse(\n    oparg_T\t*oap,\t\t// operator\
    \ argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n    int\t\tdir,\t\
    \t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\tfixindent)\t\
    // PUT_FIXINDENT if fixing indent necessary\n{\n    static int\tdo_always = FALSE;\t\
    // ignore 'mouse' setting next time\n    static int\tgot_click = FALSE;\t// got\
    \ a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT, _MIDDLE or\
    \ _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release event\n\
    \    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\tjump_flags\
    \ = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\tmoved;\t\
    \t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status line\n\
    \    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n    int\t\t\
    in_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n#if defined(FEAT_FOLDING)\n\
    \    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin = curwin;\n    static\
    \ pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n    pos_T\tend_visual;\n\
    \    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n    int\t\told_mode\
    \ = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n    save_cursor\
    \ = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always recognize mouse\
    \ events, otherwise:\n    // - Ignore mouse event in normal mode if 'mouse' doesn't\
    \ include 'n'.\n    // - Ignore mouse event in visual mode if 'mouse' doesn't\
    \ include 'v'.\n    // - For command line and insert mode 'mouse' is checked before\
    \ calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always = FALSE;\n  \
    \  else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t    if (VIsual_active)\n\
    \t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return FALSE;\n\t    }\n\t\
    \    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\t\treturn FALSE;\n\
    \t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c),\
    \ &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is\
    \ the same mouse event then use that\n\t    // one. Speeds up dragging the status\
    \ line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\
    \t    // below need to come before the next character, do not do this\n\t    //\
    \ when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() !=\
    \ NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col\
    \ = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\
    \t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\t\
    vungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\
    \t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse\
    \ moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\
    \tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t\
    \    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n\
    #endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped\
    \ dragging the status or separator line.  The pointer is\n    // most likely still\
    \ on the status or separator line.\n    if (!is_drag && drag_status_line)\n  \
    \  {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n  \
    \  }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\t\
    update_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release\
    \ events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n \
    \   else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return\
    \ FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click\
    \ = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn\
    \ FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n\
    \    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n\
    \    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count\
    \ > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click\
    \ = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL\
    \ only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button\
    \ != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag\
    \ and release events, as well as\n    // multiple clicks and the middle mouse\
    \ button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\"\
    .\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\
    \t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\
    \t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\
    \t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask\
    \ & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\
    \t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement\
    \ command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button\
    \ that is held down, ignore\n    // drag/release events.\n    if (!is_click &&\
    \ which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname\
    \ = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does\
    \ a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\
    \tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't\
    \ know what the user wanted\n\t    // to do. Go back to normal mode: Clear the\
    \ operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t \
    \   {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual\
    \ was active, yank the highlighted text and put it\n\t    // before the mouse\
    \ pointer position.\n\t    // In Select mode replace the highlighted text with\
    \ the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\
    \t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"\
    +p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\
    \t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn\
    \ FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if\
    \ ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert\
    \ mode doesn't move the mouse, just insert the\n\t// contents of a register. \
    \ '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste\
    \ at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the\
    \ GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t   \
    \ if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname\
    \ = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\
    \t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL,\
    \ BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat\
    \ it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\
    \t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname\
    \ == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n\
    \    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\
    \tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n\
    \    if (TabPageIdxs != NULL)  // only when initialized\n    {\n\t// Check for\
    \ clicking in the tab page line.\n\tif (mouse_row == 0 && firstwin->w_winrow >\
    \ 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1\
    \ = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\
    \t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t \
    \   // click in a tab selects that tab page\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\
    \t\t    && cmdwin_type == 0\n# endif\n\t\t    && mouse_col < Columns)\n\t    {\n\
    \t\tin_tab_line = TRUE;\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\tif (c1 >= 0)\n\t\
    \t{\n\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t \
    \   {\n\t\t\t// double click opens new page\n\t\t\tend_visual_mode_keep_button();\n\
    \t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\
    \t\t    else\n\t\t    {\n\t\t\t// Go to specified tab page, or next one if not\
    \ clicking\n\t\t\t// on a label.\n\t\t\tgoto_tabpage(c1);\n\n\t\t\t// It's like\
    \ clicking on the status line of a window.\n\t\t\tif (curwin != old_curwin)\n\t\
    \t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \    tabpage_T\t*tp;\n\n\t\t    // Close the current or specified tab page.\n\t\
    \t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\
    \t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage->tp_next != NULL)\n\
    \t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\
    \ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\t\
    else if (is_drag && in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t\
    \    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\t    return FALSE;\n\t}\n    }\n\
    \n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n\
    \    // right button up   -> pop-up menu\n    // shift-left button -> right button\n\
    \    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n\
    \    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT\
    \ | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if\
    \ (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK)\
    \ \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore\
    \ right button release events, only shows the popup\n\t\t    // menu on the button\
    \ down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN)\
    \ || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore\
    \ right button down and drag mouse events.  Windows\n\t\t    // only shows the\
    \ popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n\
    # endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n\
    # endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore\
    \ right button release events, only shows the popup\n\t\t// menu on the button\
    \ down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem,\
    \ \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before\
    \ showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T\
    \    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t \
    \   // selection or the current window (might have false\n\t\t    // negative\
    \ here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\
    \t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t\
    \    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\
    \t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\
    \t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags\
    \ = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t\
    {\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol,\
    \ &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\
    \t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags,\
    \ NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\
    \t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t\
    \    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t\
    // ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) !=\
    \ 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\
    \t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button\
    \ = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT |\
    \ MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\
    \t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\
    \t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\
    \t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\
    \t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t//\
    \ cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual\
    \ = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t\
    \    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\
    \t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending,\
    \ ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag\
    \ && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type\
    \ = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n\
    \    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n\
    \    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive),\
    \ which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has\
    \ no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n\
    \    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags &\
    \ IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n\
    \    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE\
    \ | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE\
    \ || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\
    \t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping\
    \ to another window, clear a pending operator.  That's a bit\n    // friendlier\
    \ than beeping and not jumping to that window.\n    if (curwin != old_curwin &&\
    \ oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n\
    \    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE\
    \ | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open\
    \ or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum,\
    \ 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the\
    \ cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor\
    \ = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n\
    \    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n\
    \    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n \
    \   }\n#endif\n\n    // Set global flag that we are extending the Visual area\
    \ with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active\
    \ && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow\
    \ scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\
    \t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window,\
    \ scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\t\
    scroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\
    \t// right click in visual mode\n    {\n       // When ALT is pressed make Visual\
    \ mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\
    \n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t//\
    \ that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\
    \t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\
    \t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col =\
    \ leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum\
    \ >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum\
    \ = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual\
    \ = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\
    \t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor\
    \ = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the\
    \ click is before the start of visual, change the start.\n\t    // If the click\
    \ is after the end of visual, change the end.  If\n\t    // the click is inside\
    \ the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\
    \t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\
    \t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare\
    \ column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t  \
    \  if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col -\
    \ curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual\
    \ = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\t\
    else\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\
    \t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t//\
    \ closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t//\
    \ closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle\
    \ line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col\
    \ + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t \
    \   VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual\
    \ mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT)\
    \ && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click:\
    \ Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname =\
    \ '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\
    \t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\t\
    if (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\
    \t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t\
    }\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where\
    \ the paste started, so in edit() Insstart can be set\n\t// to this position\n\
    \tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname,\
    \ NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n\
    \    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n \
    \   // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\
    \t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n\
    \    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u\
    \ *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u\
    \ *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\
    \n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n\
    \    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\
    \t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\t\
    if (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\
    \tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse\
    \ click searches for the next occurrence of the word under\n    // the mouse pointer\n\
    \    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT)\
    \ || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif\
    \ (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\
    \t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on\
    \ status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\t\
    if ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line =\
    \ TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n\
    \    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\
    \t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n\
    \    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\t\
    if (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor\
    \ = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual =\
    \ curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\t\
    VIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"\
    mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with\
    \ ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode\
    \ = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else\
    \ if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode =\
    \ Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.\
    \  Needed because start and\n\t    // end may still be the same, and the selection\
    \ needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double\
    \ click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) ==\
    \ MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t   \
    \ if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white\
    \ space) is\n\t\t// not a word character, try finding a match and select a (),\n\
    \t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\
    \twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\
    \t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\
    \t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\
    \t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL))\
    \ != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type\
    \ == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t \
    \   {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\
    \t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t \
    \   if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found\
    \ a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor,\
    \ orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t \
    \   find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\
    \t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col\
    \ +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\
    \t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t\
    \    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else\
    \ if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t\
    \    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    //\
    \ If Visual mode changed show it later.\n    if ((!VIsual_active && old_active\
    \ && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\
    \t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\
    \n    return moved;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\ndo_mouse(\n    oparg_T\t*oap,\t\
    \t// operator argument, can be NULL\n    int\t\tc,\t\t// K_LEFTMOUSE, etc\n  \
    \  int\t\tdir,\t\t// Direction to 'put' if necessary\n    long\tcount,\n    int\t\
    \tfixindent)\t// PUT_FIXINDENT if fixing indent necessary\n{\n    static int\t\
    do_always = FALSE;\t// ignore 'mouse' setting next time\n    static int\tgot_click\
    \ = FALSE;\t// got a click some time back\n\n    int\t\twhich_button;\t// MOUSE_LEFT,\
    \ _MIDDLE or _RIGHT\n    int\t\tis_click = FALSE; // If FALSE it's a drag or release\
    \ event\n    int\t\tis_drag = FALSE;  // If TRUE it's a drag event\n    int\t\t\
    jump_flags = 0;\t// flags for jump_to_mouse()\n    pos_T\tstart_visual;\n    int\t\
    \tmoved;\t\t// Has cursor moved?\n    int\t\tin_status_line;\t// mouse in status\
    \ line\n    static int\tin_tab_line = FALSE; // mouse clicked in tab line\n  \
    \  int\t\tin_sep_line;\t// mouse in vertical separator line\n    int\t\tc1, c2;\n\
    #if defined(FEAT_FOLDING)\n    pos_T\tsave_cursor;\n#endif\n    win_T\t*old_curwin\
    \ = curwin;\n    static pos_T orig_cursor;\n    colnr_T\tleftcol, rightcol;\n\
    \    pos_T\tend_visual;\n    int\t\tdiff;\n    int\t\told_active = VIsual_active;\n\
    \    int\t\told_mode = VIsual_mode;\n    int\t\tregname;\n\n#if defined(FEAT_FOLDING)\n\
    \    save_cursor = curwin->w_cursor;\n#endif\n\n    // When GUI is active, always\
    \ recognize mouse events, otherwise:\n    // - Ignore mouse event in normal mode\
    \ if 'mouse' doesn't include 'n'.\n    // - Ignore mouse event in visual mode\
    \ if 'mouse' doesn't include 'v'.\n    // - For command line and insert mode 'mouse'\
    \ is checked before calling\n    //\t do_mouse().\n    if (do_always)\n\tdo_always\
    \ = FALSE;\n    else\n#ifdef FEAT_GUI\n\tif (!gui.in_use)\n#endif\n\t{\n\t   \
    \ if (VIsual_active)\n\t    {\n\t\tif (!mouse_has(MOUSE_VISUAL))\n\t\t    return\
    \ FALSE;\n\t    }\n\t    else if (State == MODE_NORMAL && !mouse_has(MOUSE_NORMAL))\n\
    \t\treturn FALSE;\n\t}\n\n    for (;;)\n    {\n\twhich_button = get_mouse_button(KEY2TERMCAP1(c),\
    \ &is_click, &is_drag);\n\tif (is_drag)\n\t{\n\t    // If the next character is\
    \ the same mouse event then use that\n\t    // one. Speeds up dragging the status\
    \ line.\n\t    // Note: Since characters added to the stuff buffer in the code\n\
    \t    // below need to come before the next character, do not do this\n\t    //\
    \ when the current character was stuffed.\n\t    if (!KeyStuffed && vpeekc() !=\
    \ NUL)\n\t    {\n\t\tint nc;\n\t\tint save_mouse_row = mouse_row;\n\t\tint save_mouse_col\
    \ = mouse_col;\n\n\t\t// Need to get the character, peeking doesn't get the actual\n\
    \t\t// one.\n\t\tnc = safe_vgetc();\n\t\tif (c == nc)\n\t\t    continue;\n\t\t\
    vungetc(nc);\n\t\tmouse_row = save_mouse_row;\n\t\tmouse_col = save_mouse_col;\n\
    \t    }\n\t}\n\tbreak;\n    }\n\n    if (c == K_MOUSEMOVE)\n    {\n\t// Mouse\
    \ moved without a button pressed.\n#ifdef FEAT_BEVAL_TERM\n\tui_may_remove_balloon();\n\
    \tif (p_bevalterm)\n\t{\n\t    profile_setlimit(p_bdlay, &bevalexpr_due);\n\t\
    \    bevalexpr_due_set = TRUE;\n\t}\n#endif\n#ifdef FEAT_PROP_POPUP\n\tpopup_handle_mouse_moved();\n\
    #endif\n\treturn FALSE;\n    }\n\n#ifdef FEAT_MOUSESHAPE\n    // May have stopped\
    \ dragging the status or separator line.  The pointer is\n    // most likely still\
    \ on the status or separator line.\n    if (!is_drag && drag_status_line)\n  \
    \  {\n\tdrag_status_line = FALSE;\n\tupdate_mouseshape(SHAPE_IDX_STATUS);\n  \
    \  }\n    if (!is_drag && drag_sep_line)\n    {\n\tdrag_sep_line = FALSE;\n\t\
    update_mouseshape(SHAPE_IDX_VSEP);\n    }\n#endif\n\n    // Ignore drag and release\
    \ events if we didn't get a click.\n    if (is_click)\n\tgot_click = TRUE;\n \
    \   else\n    {\n\tif (!got_click)\t\t\t// didn't get click, ignore\n\t    return\
    \ FALSE;\n\tif (!is_drag)\t\t\t// release, reset got_click\n\t{\n\t    got_click\
    \ = FALSE;\n\t    if (in_tab_line)\n\t    {\n\t\tin_tab_line = FALSE;\n\t\treturn\
    \ FALSE;\n\t    }\n\t}\n    }\n\n    // CTRL right mouse button does CTRL-T\n\
    \    if (is_click && (mod_mask & MOD_MASK_CTRL) && which_button == MOUSE_RIGHT)\n\
    \    {\n\tif (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tif (count\
    \ > 1)\n\t    stuffnumReadbuff(count);\n\tstuffcharReadbuff(Ctrl_T);\n\tgot_click\
    \ = FALSE;\t\t// ignore drag&release now\n\treturn FALSE;\n    }\n\n    // CTRL\
    \ only works with left mouse button\n    if ((mod_mask & MOD_MASK_CTRL) && which_button\
    \ != MOUSE_LEFT)\n\treturn FALSE;\n\n    // When a modifier is down, ignore drag\
    \ and release events, as well as\n    // multiple clicks and the middle mouse\
    \ button.\n    // Accept shift-leftmouse drags when 'mousemodel' is \"popup.*\"\
    .\n    if ((mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT\n\t\t\t\t\
    \t\t\t     | MOD_MASK_META))\n\t    && (!is_click\n\t\t|| (mod_mask & MOD_MASK_MULTI_CLICK)\n\
    \t\t|| which_button == MOUSE_MIDDLE)\n\t    && !((mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT))\n\
    \t\t&& mouse_model_popup()\n\t\t&& which_button == MOUSE_LEFT)\n\t    && !((mod_mask\
    \ & MOD_MASK_ALT)\n\t\t&& !mouse_model_popup()\n\t\t&& which_button == MOUSE_RIGHT)\n\
    \t    )\n\treturn FALSE;\n\n    // If the button press was used as the movement\
    \ command for an operator\n    // (eg \"d<MOUSE>\"), or it is the middle button\
    \ that is held down, ignore\n    // drag/release events.\n    if (!is_click &&\
    \ which_button == MOUSE_MIDDLE)\n\treturn FALSE;\n\n    if (oap != NULL)\n\tregname\
    \ = oap->regname;\n    else\n\tregname = 0;\n\n    // Middle mouse button does\
    \ a 'put' of the selected text\n    if (which_button == MOUSE_MIDDLE)\n    {\n\
    \tif (State == MODE_NORMAL)\n\t{\n\t    // If an operator was pending, we don't\
    \ know what the user wanted\n\t    // to do. Go back to normal mode: Clear the\
    \ operator and beep().\n\t    if (oap != NULL && oap->op_type != OP_NOP)\n\t \
    \   {\n\t\tclearopbeep(oap);\n\t\treturn FALSE;\n\t    }\n\n\t    // If visual\
    \ was active, yank the highlighted text and put it\n\t    // before the mouse\
    \ pointer position.\n\t    // In Select mode replace the highlighted text with\
    \ the clipboard.\n\t    if (VIsual_active)\n\t    {\n\t\tif (VIsual_select)\n\t\
    \t{\n\t\t    stuffcharReadbuff(Ctrl_G);\n\t\t    stuffReadbuff((char_u *)\"\\\"\
    +p\");\n\t\t}\n\t\telse\n\t\t{\n\t\t    stuffcharReadbuff('y');\n\t\t    stuffcharReadbuff(K_MIDDLEMOUSE);\n\
    \t\t}\n\t\tdo_always = TRUE;\t// ignore 'mouse' setting next time\n\t\treturn\
    \ FALSE;\n\t    }\n\t    // The rest is below jump_to_mouse()\n\t}\n\n\telse if\
    \ ((State & MODE_INSERT) == 0)\n\t    return FALSE;\n\n\t// Middle click in insert\
    \ mode doesn't move the mouse, just insert the\n\t// contents of a register. \
    \ '.' register is special, can't insert that\n\t// with do_put().\n\t// Also paste\
    \ at the cursor if the current mode isn't in 'mouse' (only\n\t// happens for the\
    \ GUI).\n\tif ((State & MODE_INSERT) || !mouse_has(MOUSE_NORMAL))\n\t{\n\t   \
    \ if (regname == '.')\n\t\tinsert_reg(regname, TRUE);\n\t    else\n\t    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\t\tif (clip_star.available && regname == 0)\n\t\t    regname\
    \ = '*';\n#endif\n\t\tif ((State & REPLACE_FLAG) && !yank_register_mline(regname))\n\
    \t\t    insert_reg(regname, TRUE);\n\t\telse\n\t\t{\n\t\t    do_put(regname, NULL,\
    \ BACKWARD, 1L,\n\t\t\t\t\t\t      fixindent | PUT_CURSEND);\n\n\t\t    // Repeat\
    \ it with CTRL-R CTRL-O r or CTRL-R CTRL-P r\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\
    \t\t    AppendCharToRedobuff(fixindent ? Ctrl_P : Ctrl_O);\n\t\t    AppendCharToRedobuff(regname\
    \ == 0 ? '\"' : regname);\n\t\t}\n\t    }\n\t    return FALSE;\n\t}\n    }\n\n\
    \    // When dragging or button-up stay in the same window.\n    if (!is_click)\n\
    \tjump_flags |= MOUSE_FOCUS | MOUSE_DID_MOVE;\n\n    start_visual.lnum = 0;\n\n\
    \    if (TabPageIdxs != NULL)  // only when initialized\n    {\n\t// Check for\
    \ clicking in the tab page line.\n\tif (mouse_row == 0 && firstwin->w_winrow >\
    \ 0)\n\t{\n\t    if (is_drag)\n\t    {\n\t\tif (in_tab_line)\n\t\t{\n\t\t    c1\
    \ = TabPageIdxs[mouse_col];\n\t\t    tabpage_move(c1 <= 0 ? 9999 : c1 < tabpage_index(curtab)\n\
    \t\t\t\t\t\t\t\t    ? c1 - 1 : c1);\n\t\t}\n\t\treturn FALSE;\n\t    }\n\n\t \
    \   // click in a tab selects that tab page\n\t    if (is_click\n# ifdef FEAT_CMDWIN\n\
    \t\t    && cmdwin_type == 0\n# endif\n\t\t    && mouse_col < Columns)\n\t    {\n\
    \t\tin_tab_line = TRUE;\n\t\tc1 = TabPageIdxs[mouse_col];\n\t\tif (c1 >= 0)\n\t\
    \t{\n\t\t    if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t\t \
    \   {\n\t\t\t// double click opens new page\n\t\t\tend_visual_mode_keep_button();\n\
    \t\t\ttabpage_new();\n\t\t\ttabpage_move(c1 == 0 ? 9999 : c1 - 1);\n\t\t    }\n\
    \t\t    else\n\t\t    {\n\t\t\t// Go to specified tab page, or next one if not\
    \ clicking\n\t\t\t// on a label.\n\t\t\tgoto_tabpage(c1);\n\n\t\t\t// It's like\
    \ clicking on the status line of a window.\n\t\t\tif (curwin != old_curwin)\n\t\
    \t\t    end_visual_mode_keep_button();\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \    tabpage_T\t*tp;\n\n\t\t    // Close the current or specified tab page.\n\t\
    \t    if (c1 == -999)\n\t\t\ttp = curtab;\n\t\t    else\n\t\t\ttp = find_tabpage(-c1);\n\
    \t\t    if (tp == curtab)\n\t\t    {\n\t\t\tif (first_tabpage->tp_next != NULL)\n\
    \t\t\t    tabpage_close(FALSE);\n\t\t    }\n\t\t    else if (tp != NULL)\n\t\t\
    \ttabpage_close_other(tp, FALSE);\n\t\t}\n\t    }\n\t    return TRUE;\n\t}\n\t\
    else if (is_drag && in_tab_line)\n\t{\n\t    c1 = TabPageIdxs[mouse_col];\n\t\
    \    tabpage_move(c1 <= 0 ? 9999 : c1 - 1);\n\t    return FALSE;\n\t}\n    }\n\
    \n    // When 'mousemodel' is \"popup\" or \"popup_setpos\", translate mouse events:\n\
    \    // right button up   -> pop-up menu\n    // shift-left button -> right button\n\
    \    // alt-left button   -> alt-right button\n    if (mouse_model_popup())\n\
    \    {\n\tif (which_button == MOUSE_RIGHT\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT\
    \ | MOD_MASK_CTRL)))\n\t{\n#ifdef USE_POPUP_SETPOS\n# ifdef FEAT_GUI\n\t    if\
    \ (gui.in_use)\n\t    {\n#  if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK)\
    \ \\\n\t\t\t  || defined(FEAT_GUI_PHOTON)\n\t\tif (!is_click)\n\t\t    // Ignore\
    \ right button release events, only shows the popup\n\t\t    // menu on the button\
    \ down event.\n\t\t    return FALSE;\n#  endif\n#  if defined(FEAT_GUI_MSWIN)\
    \ || defined(FEAT_GUI_HAIKU)\n\t\tif (is_click || is_drag)\n\t\t    // Ignore\
    \ right button down and drag mouse events.  Windows\n\t\t    // only shows the\
    \ popup menu on the button up event.\n\t\t    return FALSE;\n#  endif\n\t    }\n\
    # endif\n# if defined(FEAT_GUI) && defined(FEAT_TERM_POPUP_MENU)\n\t    else\n\
    # endif\n# if defined(FEAT_TERM_POPUP_MENU)\n\t    if (!is_click)\n\t\t// Ignore\
    \ right button release events, only shows the popup\n\t\t// menu on the button\
    \ down event.\n\t\treturn FALSE;\n#endif\n\n\t    jump_flags = 0;\n\t    if (STRCMP(p_mousem,\
    \ \"popup_setpos\") == 0)\n\t    {\n\t\t// First set the cursor position before\
    \ showing the popup\n\t\t// menu.\n\t\tif (VIsual_active)\n\t\t{\n\t\t    pos_T\
    \    m_pos;\n\n\t\t    // set MOUSE_MAY_STOP_VIS if we are outside the\n\t\t \
    \   // selection or the current window (might have false\n\t\t    // negative\
    \ here)\n\t\t    if (mouse_row < curwin->w_winrow\n\t\t\t || mouse_row\n\t\t\t\
    \t  > (curwin->w_winrow + curwin->w_height))\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else if (get_fpos_of_mouse(&m_pos) != IN_BUFFER)\n\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t    else\n\t\t    {\n\t\t\tif ((LT_POS(curwin->w_cursor, VIsual)\n\t\t\t\t\
    \    && (LT_POS(m_pos, curwin->w_cursor)\n\t\t\t\t\t|| LT_POS(VIsual, m_pos)))\n\
    \t\t\t\t|| (LT_POS(VIsual, curwin->w_cursor)\n\t\t\t\t    && (LT_POS(m_pos, VIsual)\n\
    \t\t\t\t      || LT_POS(curwin->w_cursor, m_pos))))\n\t\t\t{\n\t\t\t    jump_flags\
    \ = MOUSE_MAY_STOP_VIS;\n\t\t\t}\n\t\t\telse if (VIsual_mode == Ctrl_V)\n\t\t\t\
    {\n\t\t\t    getvcols(curwin, &curwin->w_cursor, &VIsual,\n\t\t\t\t\t\t     &leftcol,\
    \ &rightcol);\n\t\t\t    getvcol(curwin, &m_pos, NULL, &m_pos.col, NULL);\n\t\t\
    \t    if (m_pos.col < leftcol || m_pos.col > rightcol)\n\t\t\t\tjump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    jump_flags = MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    if (jump_flags)\n\t    {\n\t\tjump_flags = jump_to_mouse(jump_flags,\
    \ NULL, which_button);\n\t\tupdate_curbuf(VIsual_active ? UPD_INVERTED : UPD_VALID);\n\
    \t\tsetcursor();\n\t\tout_flush();    // Update before showing popup menu\n\t\
    \    }\n# ifdef FEAT_MENU\n\t    show_popupmenu();\n\t    got_click = FALSE;\t\
    // ignore release events\n# endif\n\t    return (jump_flags & CURSOR_MOVED) !=\
    \ 0;\n#else\n\t    return FALSE;\n#endif\n\t}\n\tif (which_button == MOUSE_LEFT\n\
    \t\t\t\t&& (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_ALT)))\n\t{\n\t    which_button\
    \ = MOUSE_RIGHT;\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    if ((State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t\t\t    && !(mod_mask & (MOD_MASK_SHIFT |\
    \ MOD_MASK_CTRL)))\n    {\n\tif (which_button == MOUSE_LEFT)\n\t{\n\t    if (is_click)\n\
    \t    {\n\t\t// stop Visual mode for a left click in a window, but not when\n\t\
    \t// on a status line\n\t\tif (VIsual_active)\n\t\t    jump_flags |= MOUSE_MAY_STOP_VIS;\n\
    \t    }\n\t    else if (mouse_has(MOUSE_VISUAL))\n\t\tjump_flags |= MOUSE_MAY_VIS;\n\
    \t}\n\telse if (which_button == MOUSE_RIGHT)\n\t{\n\t    if (is_click && VIsual_active)\n\
    \t    {\n\t\t// Remember the start and end of visual before moving the\n\t\t//\
    \ cursor.\n\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t{\n\t\t    start_visual\
    \ = curwin->w_cursor;\n\t\t    end_visual = VIsual;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t    start_visual = VIsual;\n\t\t    end_visual = curwin->w_cursor;\n\t\t}\n\t\
    \    }\n\t    jump_flags |= MOUSE_FOCUS;\n\t    if (mouse_has(MOUSE_VISUAL))\n\
    \t\tjump_flags |= MOUSE_MAY_VIS;\n\t}\n    }\n\n    // If an operator is pending,\
    \ ignore all drags and releases until the\n    // next mouse click.\n    if (!is_drag\
    \ && oap != NULL && oap->op_type != OP_NOP)\n    {\n\tgot_click = FALSE;\n\toap->motion_type\
    \ = MCHAR;\n    }\n\n    // When releasing the button let jump_to_mouse() know.\n\
    \    if (!is_click && !is_drag)\n\tjump_flags |= MOUSE_RELEASED;\n\n    // JUMP!\n\
    \    jump_flags = jump_to_mouse(jump_flags,\n\t\t\toap == NULL ? NULL : &(oap->inclusive),\
    \ which_button);\n\n#ifdef FEAT_MENU\n    // A click in the window toolbar has\
    \ no side effects.\n    if (jump_flags & MOUSE_WINBAR)\n\treturn FALSE;\n#endif\n\
    \    moved = (jump_flags & CURSOR_MOVED);\n    in_status_line = (jump_flags &\
    \ IN_STATUS_LINE);\n    in_sep_line = (jump_flags & IN_SEP_LINE);\n\n#ifdef FEAT_NETBEANS_INTG\n\
    \    if (isNetbeansBuffer(curbuf)\n\t\t\t    && !(jump_flags & (IN_STATUS_LINE\
    \ | IN_SEP_LINE)))\n    {\n\tint key = KEY2TERMCAP1(c);\n\n\tif (key == (int)KE_LEFTRELEASE\
    \ || key == (int)KE_MIDDLERELEASE\n\t\t\t\t\t       || key == (int)KE_RIGHTRELEASE)\n\
    \t    netbeans_button_release(which_button);\n    }\n#endif\n\n    // When jumping\
    \ to another window, clear a pending operator.  That's a bit\n    // friendlier\
    \ than beeping and not jumping to that window.\n    if (curwin != old_curwin &&\
    \ oap != NULL && oap->op_type != OP_NOP)\n\tclearop(oap);\n\n#ifdef FEAT_FOLDING\n\
    \    if (mod_mask == 0\n\t    && !is_drag\n\t    && (jump_flags & (MOUSE_FOLD_CLOSE\
    \ | MOUSE_FOLD_OPEN))\n\t    && which_button == MOUSE_LEFT)\n    {\n\t// open\
    \ or close a fold at this line\n\tif (jump_flags & MOUSE_FOLD_OPEN)\n\t    openFold(curwin->w_cursor.lnum,\
    \ 1L);\n\telse\n\t    closeFold(curwin->w_cursor.lnum, 1L);\n\t// don't move the\
    \ cursor if still in the same window\n\tif (curwin == old_curwin)\n\t    curwin->w_cursor\
    \ = save_cursor;\n    }\n#endif\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_CMDWIN)\n\
    \    if ((jump_flags & IN_OTHER_WIN) && !VIsual_active && clip_star.available)\n\
    \    {\n\tclip_modeless(which_button, is_click, is_drag);\n\treturn FALSE;\n \
    \   }\n#endif\n\n    // Set global flag that we are extending the Visual area\
    \ with mouse\n    // dragging; temporarily minimize 'scrolloff'.\n    if (VIsual_active\
    \ && is_drag && get_scrolloff_value())\n    {\n\t// In the very first line, allow\
    \ scrolling one line\n\tif (mouse_row == 0)\n\t    mouse_dragging = 2;\n\telse\n\
    \t    mouse_dragging = 1;\n    }\n\n    // When dragging the mouse above the window,\
    \ scroll down.\n    if (is_drag && mouse_row < 0 && !in_status_line)\n    {\n\t\
    scroll_redraw(FALSE, 1L);\n\tmouse_row = 0;\n    }\n\n    if (start_visual.lnum)\t\
    \t// right click in visual mode\n    {\n       // When ALT is pressed make Visual\
    \ mode blockwise.\n       if (mod_mask & MOD_MASK_ALT)\n\t   VIsual_mode = Ctrl_V;\n\
    \n\t// In Visual-block mode, divide the area in four, pick up the corner\n\t//\
    \ that is in the quarter that the cursor is in.\n\tif (VIsual_mode == Ctrl_V)\n\
    \t{\n\t    getvcols(curwin, &start_visual, &end_visual, &leftcol, &rightcol);\n\
    \t    if (curwin->w_curswant > (leftcol + rightcol) / 2)\n\t\tend_visual.col =\
    \ leftcol;\n\t    else\n\t\tend_visual.col = rightcol;\n\t    if (curwin->w_cursor.lnum\
    \ >=\n\t\t\t\t    (start_visual.lnum + end_visual.lnum) / 2)\n\t\tend_visual.lnum\
    \ = start_visual.lnum;\n\n\t    // move VIsual to the right column\n\t    start_visual\
    \ = curwin->w_cursor;\t    // save the cursor pos\n\t    curwin->w_cursor = end_visual;\n\
    \t    coladvance(end_visual.col);\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor\
    \ = start_visual;\t    // restore the cursor\n\t}\n\telse\n\t{\n\t    // If the\
    \ click is before the start of visual, change the start.\n\t    // If the click\
    \ is after the end of visual, change the end.  If\n\t    // the click is inside\
    \ the visual, change the closest side.\n\t    if (LT_POS(curwin->w_cursor, start_visual))\n\
    \t\tVIsual = end_visual;\n\t    else if (LT_POS(end_visual, curwin->w_cursor))\n\
    \t\tVIsual = start_visual;\n\t    else\n\t    {\n\t\t// In the same line, compare\
    \ column number\n\t\tif (end_visual.lnum == start_visual.lnum)\n\t\t{\n\t\t  \
    \  if (curwin->w_cursor.col - start_visual.col >\n\t\t\t\t    end_visual.col -\
    \ curwin->w_cursor.col)\n\t\t\tVIsual = start_visual;\n\t\t    else\n\t\t\tVIsual\
    \ = end_visual;\n\t\t}\n\n\t\t// In different lines, compare line number\n\t\t\
    else\n\t\t{\n\t\t    diff = (curwin->w_cursor.lnum - start_visual.lnum) -\n\t\t\
    \t\t(end_visual.lnum - curwin->w_cursor.lnum);\n\n\t\t    if (diff > 0)\t\t//\
    \ closest to end\n\t\t\tVIsual = start_visual;\n\t\t    else if (diff < 0)\t//\
    \ closest to start\n\t\t\tVIsual = end_visual;\n\t\t    else\t\t\t// in the middle\
    \ line\n\t\t    {\n\t\t\tif (curwin->w_cursor.col <\n\t\t\t\t\t(start_visual.col\
    \ + end_visual.col) / 2)\n\t\t\t    VIsual = end_visual;\n\t\t\telse\n\t\t\t \
    \   VIsual = start_visual;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    // If Visual\
    \ mode started in insert mode, execute \"CTRL-O\"\n    else if ((State & MODE_INSERT)\
    \ && VIsual_active)\n\tstuffcharReadbuff(Ctrl_O);\n\n    // Middle mouse click:\
    \ Put text before cursor.\n    if (which_button == MOUSE_MIDDLE)\n    {\n#ifdef\
    \ FEAT_CLIPBOARD\n\tif (clip_star.available && regname == 0)\n\t    regname =\
    \ '*';\n#endif\n\tif (yank_register_mline(regname))\n\t{\n\t    if (mouse_past_bottom)\n\
    \t\tdir = FORWARD;\n\t}\n\telse if (mouse_past_eol)\n\t    dir = FORWARD;\n\n\t\
    if (fixindent)\n\t{\n\t    c1 = (dir == BACKWARD) ? '[' : ']';\n\t    c2 = 'p';\n\
    \t}\n\telse\n\t{\n\t    c1 = (dir == FORWARD) ? 'p' : 'P';\n\t    c2 = NUL;\n\t\
    }\n\tprep_redo(regname, count, NUL, c1, NUL, c2, NUL);\n\n\t// Remember where\
    \ the paste started, so in edit() Insstart can be set\n\t// to this position\n\
    \tif (restart_edit != 0)\n\t    where_paste_started = curwin->w_cursor;\n\tdo_put(regname,\
    \ NULL, dir, count, fixindent | PUT_CURSEND);\n    }\n\n#if defined(FEAT_QUICKFIX)\n\
    \    // Ctrl-Mouse click or double click in a quickfix window jumps to the\n \
    \   // error under the mouse pointer.\n    else if (((mod_mask & MOD_MASK_CTRL)\n\
    \t\t|| (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    && bt_quickfix(curbuf))\n\
    \    {\n\tif (curwin->w_llist_ref == NULL)\t// quickfix window\n\t    do_cmdline_cmd((char_u\
    \ *)\".cc\");\n\telse\t\t\t\t\t// location list window\n\t    do_cmdline_cmd((char_u\
    \ *)\".ll\");\n\tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n#endif\n\
    \n    // Ctrl-Mouse click (or double click in a help window) jumps to the tag\n\
    \    // under the mouse pointer.\n    else if ((mod_mask & MOD_MASK_CTRL) || (curbuf->b_help\n\
    \t\t     && (mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK))\n    {\n\t\
    if (State & MODE_INSERT)\n\t    stuffcharReadbuff(Ctrl_O);\n\tstuffcharReadbuff(Ctrl_RSB);\n\
    \tgot_click = FALSE;\t\t// ignore drag&release now\n    }\n\n    // Shift-Mouse\
    \ click searches for the next occurrence of the word under\n    // the mouse pointer\n\
    \    else if ((mod_mask & MOD_MASK_SHIFT))\n    {\n\tif ((State & MODE_INSERT)\
    \ || (VIsual_active && VIsual_select))\n\t    stuffcharReadbuff(Ctrl_O);\n\tif\
    \ (which_button == MOUSE_LEFT)\n\t    stuffcharReadbuff('*');\n\telse\t// MOUSE_RIGHT\n\
    \t    stuffcharReadbuff('#');\n    }\n\n    // Handle double clicks, unless on\
    \ status line\n    else if (in_status_line)\n    {\n#ifdef FEAT_MOUSESHAPE\n\t\
    if ((is_drag || is_click) && !drag_status_line)\n\t{\n\t    drag_status_line =\
    \ TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n    }\n    else if (in_sep_line)\n\
    \    {\n#ifdef FEAT_MOUSESHAPE\n\tif ((is_drag || is_click) && !drag_sep_line)\n\
    \t{\n\t    drag_sep_line = TRUE;\n\t    update_mouseshape(-1);\n\t}\n#endif\n\
    \    }\n    else if ((mod_mask & MOD_MASK_MULTI_CLICK)\n\t\t\t\t       && (State\
    \ & (MODE_NORMAL | MODE_INSERT))\n\t     && mouse_has(MOUSE_VISUAL))\n    {\n\t\
    if (is_click || !VIsual_active)\n\t{\n\t    if (VIsual_active)\n\t\torig_cursor\
    \ = VIsual;\n\t    else\n\t    {\n\t\tcheck_visual_highlight();\n\t\tVIsual =\
    \ curwin->w_cursor;\n\t\torig_cursor = VIsual;\n\t\tVIsual_active = TRUE;\n\t\t\
    VIsual_reselect = TRUE;\n\t\t// start Select mode if 'selectmode' contains \"\
    mouse\"\n\t\tmay_start_select('o');\n\t\tsetmouse();\n\t    }\n\t    if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_2CLICK)\n\t    {\n\t\t// Double click with\
    \ ALT pressed makes it blockwise.\n\t\tif (mod_mask & MOD_MASK_ALT)\n\t\t    VIsual_mode\
    \ = Ctrl_V;\n\t\telse\n\t\t    VIsual_mode = 'v';\n\t    }\n\t    else if ((mod_mask\
    \ & MOD_MASK_MULTI_CLICK) == MOD_MASK_3CLICK)\n\t\tVIsual_mode = 'V';\n\t    else\
    \ if ((mod_mask & MOD_MASK_MULTI_CLICK) == MOD_MASK_4CLICK)\n\t\tVIsual_mode =\
    \ Ctrl_V;\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.\
    \  Needed because start and\n\t    // end may still be the same, and the selection\
    \ needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t}\n\t// A double\
    \ click selects a word or a block.\n\tif ((mod_mask & MOD_MASK_MULTI_CLICK) ==\
    \ MOD_MASK_2CLICK)\n\t{\n\t    pos_T\t*pos = NULL;\n\t    int\t\tgc;\n\n\t   \
    \ if (is_click)\n\t    {\n\t\t// If the character under the cursor (skipping white\
    \ space) is\n\t\t// not a word character, try finding a match and select a (),\n\
    \t\t// {}, [], #if/#endif, etc. block.\n\t\tend_visual = curwin->w_cursor;\n\t\
    \twhile (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))\n\t\t    inc(&end_visual);\n\
    \t\tif (oap != NULL)\n\t\t    oap->motion_type = MCHAR;\n\t\tif (oap != NULL\n\
    \t\t\t&& VIsual_mode == 'v'\n\t\t\t&& !vim_iswordc(gchar_pos(&end_visual))\n\t\
    \t\t&& EQUAL_POS(curwin->w_cursor, VIsual)\n\t\t\t&& (pos = findmatch(oap, NUL))\
    \ != NULL)\n\t\t{\n\t\t    curwin->w_cursor = *pos;\n\t\t    if (oap->motion_type\
    \ == MLINE)\n\t\t\tVIsual_mode = 'V';\n\t\t    else if (*p_sel == 'e')\n\t\t \
    \   {\n\t\t\tif (LT_POS(curwin->w_cursor, VIsual))\n\t\t\t    ++VIsual.col;\n\t\
    \t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t    }\n\n\t \
    \   if (pos == NULL && (is_click || is_drag))\n\t    {\n\t\t// When not found\
    \ a match or when dragging: extend to include\n\t\t// a word.\n\t\tif (LT_POS(curwin->w_cursor,\
    \ orig_cursor))\n\t\t{\n\t\t    find_start_of_word(&curwin->w_cursor);\n\t\t \
    \   find_end_of_word(&VIsual);\n\t\t}\n\t\telse\n\t\t{\n\t\t    find_start_of_word(&VIsual);\n\
    \t\t    if (*p_sel == 'e' && *ml_get_cursor() != NUL)\n\t\t\tcurwin->w_cursor.col\
    \ +=\n\t\t\t\t\t (*mb_ptr2len)(ml_get_cursor());\n\t\t    find_end_of_word(&curwin->w_cursor);\n\
    \t\t}\n\t    }\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tif (is_click)\n\t\
    \    redraw_curbuf_later(UPD_INVERTED);\t// update the inversion\n    }\n    else\
    \ if (VIsual_active && !old_active)\n    {\n\tif (mod_mask & MOD_MASK_ALT)\n\t\
    \    VIsual_mode = Ctrl_V;\n\telse\n\t    VIsual_mode = 'v';\n    }\n\n    //\
    \ If Visual mode changed show it later.\n    if ((!VIsual_active && old_active\
    \ && mode_displayed)\n\t    || (VIsual_active && p_smd && msg_silent == 0\n\t\t\
    \t\t && (!old_active || VIsual_mode != old_mode)))\n\tredraw_cmdline = TRUE;\n\
    \n    return moved;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 418795
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
