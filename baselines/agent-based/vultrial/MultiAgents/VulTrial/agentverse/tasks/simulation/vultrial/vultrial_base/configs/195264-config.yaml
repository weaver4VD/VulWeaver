agents:
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ void compile_xclass_matchingpath(compiler_common *common, PCRE2_SPTR cc, jump_list\
    \ **backtracks)\n{\nDEFINE_COMPILER;\njump_list *found = NULL;\njump_list **list\
    \ = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\nsljit_uw c, charoffset, max\
    \ = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump = NULL;\nPCRE2_SPTR ccbegin;\n\
    int compares, invertcmp, numberofcmps;\n#if defined SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH\
    \ == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\nBOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE\
    \ && PCRE2_CODE_UNIT_WIDTH == [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status\
    \ = 0;\nint typereg = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n\
    #endif /* SUPPORT_UNICODE */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin\
    \ = cc;\ncompares = 0;\n\nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 /\
    \ sizeof(PCRE2_UCHAR);\n  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if\
    \ (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c\
    \ > max) max = c;\n    if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status\
    \ |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc ==\
    \ XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min)\
    \ min = c;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n\
    \    unicode_status |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n\
    #ifdef SUPPORT_UNICODE\n  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc\
    \ == XCL_NOTPROP);\n    cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n \
    \     {\n      other_cases = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases\
    \ != NOTACHAR)\n        {\n        if (*other_cases > max) max = *other_cases;\n\
    \        if (*other_cases < min) min = *other_cases;\n        other_cases++;\n\
    \        }\n      }\n    else\n      {\n      max = READ_CHAR_MAX;\n      min\
    \ = 0;\n      }\n\n    switch(*cc)\n      {\n      case PT_ANY:\n      /* Any\
    \ either accepts everything or ignored. */\n      if (cc[-1] == XCL_PROP)\n  \
    \      {\n        compile_char1_matchingpath(common, OP_ALLANY, cc, backtracks,\
    \ FALSE);\n        if (list == backtracks)\n          add_jump(compiler, backtracks,\
    \ JUMP(SLJIT_JUMP));\n        return;\n        }\n      break;\n\n      case PT_LAMP:\n\
    \      case PT_GC:\n      case PT_PC:\n      case PT_ALNUM:\n      unicode_status\
    \ |= XCLASS_HAS_TYPE;\n      break;\n\n      case PT_SCX:\n      unicode_status\
    \ |= XCLASS_HAS_SCRIPT_EXTENSION;\n      if (cc[-1] == XCL_NOTPROP)\n        {\n\
    \        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n        break;\n\
    \        }\n      compares++;\n      /* Fall through */ \n\n      case PT_SC:\n\
    \      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n      case PT_SPACE:\n\
    \      case PT_PXSPACE:\n      case PT_WORD:\n      case PT_PXGRAPH:\n      case\
    \ PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status |= XCLASS_SAVE_CHAR\
    \ | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n      case PT_UCNC:\n\
    \      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\n      case PT_BOOL:\n\
    \      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\n      case PT_BIDICL:\n\
    \      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\n      default:\n\
    \      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc += 2;\n    }\n#endif\
    \ /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n/* We are not necessary\
    \ in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif ((cc[-1] & XCL_NOT) !=\
    \ 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\nelse\n\
    \  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status &\
    \ XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n \
    \ read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\n\
    if ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n\
    \    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n\
    \      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR,\
    \ TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1),\
    \ (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    \
    \  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler,\
    \ &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks,\
    \ JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n\
    \    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER,\
    \ TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) !=\
    \ 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n\
    \  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH\
    \ == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM,\
    \ 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL,\
    \ TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0,\
    \ TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n\
    \    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n\
    \  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH ==\
    \ 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM,\
    \ MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n\
    \    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2,\
    \ 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n\
    \  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL,\
    \ TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1,\
    \ 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n\
    \  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1,\
    \ 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n\
    \  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status\
    \ & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2),\
    \ (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n\
    \    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n  \
    \  while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n\
    \        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc\
    \ == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n \
    \       GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc\
    \ == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n\
    \          {\n          compares--;\n          invertcmp = (compares == 0 && list\
    \ != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n\
    \          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n\
    \    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32\
    \ | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1]\
    \ >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n\
    \        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else\
    \ if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n   \
    \     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n  \
    \      switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n     \
    \     case PT_SC:\n          compares--;\n          invertcmp = (compares == 0\
    \ && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL\
    \ ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n\
    \        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n\
    \    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1,\
    \ 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1,\
    \ 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n\
    \      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status\
    \ & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP),\
    \ LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n\
    \          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR,\
    \ 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n\
    \          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n\n          jump\
    \ = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump\
    \ = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n\
    \              {\n              add_jump(compiler, backtracks, jump);\n      \
    \        jump = NULL;\n              }\n            invertcmp ^= 0x1;\n      \
    \      }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets)\
    \ + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n   \
    \       if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc\
    \ += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n\
    \      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status\
    \ & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0,\
    \ RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n\
    \    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\
    \n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\n\
    typeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n\
    \  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump =\
    \ NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c,\
    \ cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n\
    \      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps\
    \ > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n   \
    \   }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else\
    \ if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n\
    \    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE\
    \ || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps\
    \ == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n\
    \      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR |\
    \ SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^\
    \ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump\
    \ = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n\
    \      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n   \
    \ {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc ==\
    \ XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n\
    \      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n\
    \      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg,\
    \ 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n   \
    \   break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n\
    \      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg,\
    \ 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n\
    \      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM,\
    \ (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n\
    \      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing.\
    \ */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs -\
    \ ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE\
    \ - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /*\
    \ Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n \
    \     OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n\
    \      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets)\
    \ + cc[1];\n\n      /* At least three characters are required.\n         Otherwise\
    \ this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0]\
    \ != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n\
    \      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\
    \n      /* Optimizing character pairs, if their difference is power of 2. */\n\
    \      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if\
    \ (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1]\
    \ ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2,\
    \ 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2,\
    \ 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n    \
    \    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n    \
    \    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n \
    \       }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n    \
    \    {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0,\
    \ SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n  \
    \        OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n\
    \          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n\
    \          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n\
    \        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0),\
    \ TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n\
    \        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++\
    \ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      \
    \  }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2,\
    \ 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1,\
    \ 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n    \
    \  SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1,\
    \ 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0,\
    \ SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n    \
    \  break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest\
    \ two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM,\
    \ ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n\
    \      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\
    \n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM,\
    \ 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the\
    \ farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0,\
    \ SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\
    \n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\
    \n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR,\
    \ TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO\
    \ ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n\
    \      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n  \
    \    }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n\
    \    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found\
    \ != NULL)\n  set_jumps(found, LABEL());\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nstatic void compile_xclass_matchingpath(compiler_common\
    \ *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list\
    \ *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\n\
    sljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump\
    \ = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined\
    \ SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\
    BOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH ==\
    \ [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg\
    \ = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\
    \nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n\
    \    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n  \
    \  if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n\
    #endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n   \
    \ cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c,\
    \ cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status\
    \ |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n\
    \  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n   \
    \ cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n      {\n      other_cases\
    \ = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n\
    \        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases\
    \ < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n   \
    \ else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n\
    \      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored.\
    \ */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common,\
    \ OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n      \
    \    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n    \
    \    }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n\
    \      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\
    \n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n \
    \     if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n\
    \        break;\n        }\n      compares++;\n      /* Fall through */ \n\n \
    \     case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n\
    \      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case\
    \ PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status\
    \ |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n\
    \      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\
    \n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\
    \n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\
    \n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc +=\
    \ 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n\
    /* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif\
    \ ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\n\
    else\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status\
    \ & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n\
    \  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\n\
    if ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n\
    \    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n\
    \      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR,\
    \ TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1),\
    \ (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    \
    \  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler,\
    \ &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks,\
    \ JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n\
    \    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER,\
    \ TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) !=\
    \ 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n\
    \  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH\
    \ == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM,\
    \ 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL,\
    \ TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0,\
    \ TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n\
    \    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n\
    \  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH ==\
    \ 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM,\
    \ MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n\
    \    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2,\
    \ 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n\
    \  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL,\
    \ TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1,\
    \ 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n\
    \  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1,\
    \ 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n\
    \  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status\
    \ & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2),\
    \ (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n\
    \    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n  \
    \  while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n\
    \        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc\
    \ == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n \
    \       GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc\
    \ == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n\
    \          {\n          compares--;\n          invertcmp = (compares == 0 && list\
    \ != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n\
    \          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n\
    \    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32\
    \ | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1]\
    \ >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n\
    \        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else\
    \ if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n   \
    \     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n  \
    \      switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n     \
    \     case PT_SC:\n          compares--;\n          invertcmp = (compares == 0\
    \ && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL\
    \ ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n\
    \        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n\
    \    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1,\
    \ 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1,\
    \ 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n\
    \      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status\
    \ & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP),\
    \ LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n\
    \          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR,\
    \ 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n\
    \          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n\n          jump\
    \ = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump\
    \ = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n\
    \              {\n              add_jump(compiler, backtracks, jump);\n      \
    \        jump = NULL;\n              }\n            invertcmp ^= 0x1;\n      \
    \      }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets)\
    \ + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n   \
    \       if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc\
    \ += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n\
    \      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status\
    \ & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0,\
    \ RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n\
    \    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\
    \n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\n\
    typeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n\
    \  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump =\
    \ NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c,\
    \ cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n\
    \      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps\
    \ > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n   \
    \   }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else\
    \ if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n\
    \    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE\
    \ || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps\
    \ == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n\
    \      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR |\
    \ SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^\
    \ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump\
    \ = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n\
    \      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n   \
    \ {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc ==\
    \ XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n\
    \      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n\
    \      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg,\
    \ 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n   \
    \   break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n\
    \      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg,\
    \ 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n\
    \      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM,\
    \ (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n\
    \      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing.\
    \ */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs -\
    \ ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE\
    \ - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /*\
    \ Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n \
    \     OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n\
    \      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets)\
    \ + cc[1];\n\n      /* At least three characters are required.\n         Otherwise\
    \ this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0]\
    \ != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n\
    \      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\
    \n      /* Optimizing character pairs, if their difference is power of 2. */\n\
    \      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if\
    \ (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1]\
    \ ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2,\
    \ 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2,\
    \ 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n    \
    \    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n    \
    \    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n \
    \       }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n    \
    \    {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0,\
    \ SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n  \
    \        OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n\
    \          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n\
    \          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n\
    \        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0),\
    \ TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n\
    \        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++\
    \ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      \
    \  }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2,\
    \ 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1,\
    \ 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n    \
    \  SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1,\
    \ 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0,\
    \ SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n    \
    \  break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest\
    \ two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM,\
    \ ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n\
    \      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\
    \n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM,\
    \ 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the\
    \ farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0,\
    \ SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\
    \n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\
    \n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR,\
    \ TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO\
    \ ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n\
    \      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n  \
    \    }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n\
    \    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found\
    \ != NULL)\n  set_jumps(found, LABEL());\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nstatic void compile_xclass_matchingpath(compiler_common\
    \ *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list\
    \ *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\n\
    sljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump\
    \ = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined\
    \ SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\
    BOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH ==\
    \ [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg\
    \ = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\
    \nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n\
    \    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n  \
    \  if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n\
    #endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n   \
    \ cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c,\
    \ cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status\
    \ |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n\
    \  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n   \
    \ cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n      {\n      other_cases\
    \ = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n\
    \        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases\
    \ < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n   \
    \ else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n\
    \      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored.\
    \ */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common,\
    \ OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n      \
    \    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n    \
    \    }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n\
    \      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\
    \n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n \
    \     if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n\
    \        break;\n        }\n      compares++;\n      /* Fall through */ \n\n \
    \     case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n\
    \      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case\
    \ PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status\
    \ |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n\
    \      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\
    \n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\
    \n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\
    \n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc +=\
    \ 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n\
    /* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif\
    \ ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\n\
    else\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status\
    \ & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n\
    \  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\n\
    if ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n\
    \    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n\
    \      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR,\
    \ TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1),\
    \ (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    \
    \  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler,\
    \ &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks,\
    \ JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n\
    \    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER,\
    \ TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) !=\
    \ 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n\
    \  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH\
    \ == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM,\
    \ 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL,\
    \ TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0,\
    \ TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n\
    \    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n\
    \  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH ==\
    \ 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM,\
    \ MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n\
    \    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2,\
    \ 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n\
    \  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL,\
    \ TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1,\
    \ 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n\
    \  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1,\
    \ 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n\
    \  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status\
    \ & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2),\
    \ (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n\
    \    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n  \
    \  while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n\
    \        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc\
    \ == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n \
    \       GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc\
    \ == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n\
    \          {\n          compares--;\n          invertcmp = (compares == 0 && list\
    \ != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n\
    \          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n\
    \    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32\
    \ | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1]\
    \ >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n\
    \        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else\
    \ if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n   \
    \     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n  \
    \      switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n     \
    \     case PT_SC:\n          compares--;\n          invertcmp = (compares == 0\
    \ && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL\
    \ ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n\
    \        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n\
    \    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1,\
    \ 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1,\
    \ 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n\
    \      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status\
    \ & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP),\
    \ LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n\
    \          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR,\
    \ 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n\
    \          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n\n          jump\
    \ = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump\
    \ = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n\
    \              {\n              add_jump(compiler, backtracks, jump);\n      \
    \        jump = NULL;\n              }\n            invertcmp ^= 0x1;\n      \
    \      }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets)\
    \ + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n   \
    \       if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc\
    \ += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n\
    \      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status\
    \ & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0,\
    \ RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n\
    \    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\
    \n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\n\
    typeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n\
    \  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump =\
    \ NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c,\
    \ cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n\
    \      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps\
    \ > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n   \
    \   }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else\
    \ if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n\
    \    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE\
    \ || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps\
    \ == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n\
    \      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR |\
    \ SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^\
    \ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump\
    \ = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n\
    \      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n   \
    \ {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc ==\
    \ XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n\
    \      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n\
    \      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg,\
    \ 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n   \
    \   break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n\
    \      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg,\
    \ 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n\
    \      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM,\
    \ (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n\
    \      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing.\
    \ */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs -\
    \ ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE\
    \ - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /*\
    \ Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n \
    \     OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n\
    \      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets)\
    \ + cc[1];\n\n      /* At least three characters are required.\n         Otherwise\
    \ this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0]\
    \ != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n\
    \      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\
    \n      /* Optimizing character pairs, if their difference is power of 2. */\n\
    \      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if\
    \ (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1]\
    \ ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2,\
    \ 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2,\
    \ 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n    \
    \    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n    \
    \    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n \
    \       }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n    \
    \    {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0,\
    \ SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n  \
    \        OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n\
    \          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n\
    \          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n\
    \        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0),\
    \ TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n\
    \        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++\
    \ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      \
    \  }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2,\
    \ 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1,\
    \ 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n    \
    \  SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1,\
    \ 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0,\
    \ SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n    \
    \  break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest\
    \ two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM,\
    \ ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n\
    \      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\
    \n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM,\
    \ 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the\
    \ farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0,\
    \ SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\
    \n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\
    \n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR,\
    \ TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO\
    \ ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n\
    \      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n  \
    \    }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n\
    \    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found\
    \ != NULL)\n  set_jumps(found, LABEL());\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nstatic void compile_xclass_matchingpath(compiler_common\
    \ *common, PCRE2_SPTR cc, jump_list **backtracks)\n{\nDEFINE_COMPILER;\njump_list\
    \ *found = NULL;\njump_list **list = (cc[0] & XCL_NOT) == 0 ? &found : backtracks;\n\
    sljit_uw c, charoffset, max = 256, min = READ_CHAR_MAX;\nstruct sljit_jump *jump\
    \ = NULL;\nPCRE2_SPTR ccbegin;\nint compares, invertcmp, numberofcmps;\n#if defined\
    \ SUPPORT_UNICODE && (PCRE2_CODE_UNIT_WIDTH == 8 || PCRE2_CODE_UNIT_WIDTH == 16)\n\
    BOOL utf = common->utf;\n#endif /* SUPPORT_UNICODE && PCRE2_CODE_UNIT_WIDTH ==\
    \ [8|16] */\n\n#ifdef SUPPORT_UNICODE\nsljit_u32 unicode_status = 0;\nint typereg\
    \ = TMP1;\nconst sljit_u32 *other_cases;\nsljit_uw typeoffset;\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Scanning the necessary info. */\ncc++;\nccbegin = cc;\ncompares = 0;\n\
    \nif (cc[-1] & XCL_MAP)\n  {\n  min = 0;\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\nwhile (*cc != XCL_END)\n  {\n  compares++;\n  if (*cc == XCL_SINGLE)\n\
    \    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c > max) max = c;\n  \
    \  if (c < min) min = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status |= XCLASS_SAVE_CHAR;\n\
    #endif /* SUPPORT_UNICODE */\n    }\n  else if (*cc == XCL_RANGE)\n    {\n   \
    \ cc ++;\n    GETCHARINCTEST(c, cc);\n    if (c < min) min = c;\n    GETCHARINCTEST(c,\
    \ cc);\n    if (c > max) max = c;\n#ifdef SUPPORT_UNICODE\n    unicode_status\
    \ |= XCLASS_SAVE_CHAR;\n#endif /* SUPPORT_UNICODE */\n    }\n#ifdef SUPPORT_UNICODE\n\
    \  else\n    {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n   \
    \ cc++;\n    if (*cc == PT_CLIST && *cc == XCL_PROP)\n      {\n      other_cases\
    \ = PRIV(ucd_caseless_sets) + cc[1];\n      while (*other_cases != NOTACHAR)\n\
    \        {\n        if (*other_cases > max) max = *other_cases;\n        if (*other_cases\
    \ < min) min = *other_cases;\n        other_cases++;\n        }\n      }\n   \
    \ else\n      {\n      max = READ_CHAR_MAX;\n      min = 0;\n      }\n\n    switch(*cc)\n\
    \      {\n      case PT_ANY:\n      /* Any either accepts everything or ignored.\
    \ */\n      if (cc[-1] == XCL_PROP)\n        {\n        compile_char1_matchingpath(common,\
    \ OP_ALLANY, cc, backtracks, FALSE);\n        if (list == backtracks)\n      \
    \    add_jump(compiler, backtracks, JUMP(SLJIT_JUMP));\n        return;\n    \
    \    }\n      break;\n\n      case PT_LAMP:\n      case PT_GC:\n      case PT_PC:\n\
    \      case PT_ALNUM:\n      unicode_status |= XCLASS_HAS_TYPE;\n      break;\n\
    \n      case PT_SCX:\n      unicode_status |= XCLASS_HAS_SCRIPT_EXTENSION;\n \
    \     if (cc[-1] == XCL_NOTPROP)\n        {\n        unicode_status |= XCLASS_SCRIPT_EXTENSION_NOTPROP;\n\
    \        break;\n        }\n      compares++;\n      /* Fall through */ \n\n \
    \     case PT_SC:\n      unicode_status |= XCLASS_HAS_SCRIPT;\n      break;\n\n\
    \      case PT_SPACE:\n      case PT_PXSPACE:\n      case PT_WORD:\n      case\
    \ PT_PXGRAPH:\n      case PT_PXPRINT:\n      case PT_PXPUNCT:\n      unicode_status\
    \ |= XCLASS_SAVE_CHAR | XCLASS_HAS_TYPE;\n      break;\n\n      case PT_CLIST:\n\
    \      case PT_UCNC:\n      unicode_status |= XCLASS_SAVE_CHAR;\n      break;\n\
    \n      case PT_BOOL:\n      unicode_status |= XCLASS_HAS_BOOL;\n      break;\n\
    \n      case PT_BIDICL:\n      unicode_status |= XCLASS_HAS_BIDICL;\n      break;\n\
    \n      default:\n      SLJIT_UNREACHABLE();\n      break;\n      }\n    cc +=\
    \ 2;\n    }\n#endif /* SUPPORT_UNICODE */\n  }\nSLJIT_ASSERT(compares > 0);\n\n\
    /* We are not necessary in utf mode even in 8 bit mode. */\ncc = ccbegin;\nif\
    \ ((cc[-1] & XCL_NOT) != 0)\n  read_char(common, min, max, backtracks, READ_CHAR_UPDATE_STR_PTR);\n\
    else\n  {\n#ifdef SUPPORT_UNICODE\n  read_char(common, min, max, (unicode_status\
    \ & XCLASS_NEEDS_UCD) ? backtracks : NULL, 0);\n#else /* !SUPPORT_UNICODE */\n\
    \  read_char(common, min, max, NULL, 0);\n#endif /* SUPPORT_UNICODE */\n  }\n\n\
    if ((cc[-1] & XCL_HASPROP) == 0)\n  {\n  if ((cc[-1] & XCL_MAP) != 0)\n    {\n\
    \    jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n    if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, (((const sljit_u8 *)cc)[31] & 0x80) != 0, TRUE, &found))\n\
    \      {\n      OP2(SLJIT_AND, TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n      OP2(SLJIT_LSHR,\
    \ TMP1, 0, TMP1, 0, SLJIT_IMM, 3);\n      OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1),\
    \ (sljit_sw)cc);\n      OP2(SLJIT_SHL, TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    \
    \  OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0, TMP2, 0);\n      add_jump(compiler,\
    \ &found, JUMP(SLJIT_NOT_ZERO));\n      }\n\n    add_jump(compiler, backtracks,\
    \ JUMP(SLJIT_JUMP));\n    JUMPHERE(jump);\n\n    cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \    }\n  else\n    {\n    OP2(SLJIT_SUB, TMP2, 0, TMP1, 0, SLJIT_IMM, min);\n\
    \    add_jump(compiler, (cc[-1] & XCL_NOT) == 0 ? backtracks : &found, CMP(SLJIT_GREATER,\
    \ TMP2, 0, SLJIT_IMM, max - min));\n    }\n  }\nelse if ((cc[-1] & XCL_MAP) !=\
    \ 0)\n  {\n  OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n#ifdef SUPPORT_UNICODE\n\
    \  unicode_status |= XCLASS_CHAR_SAVED;\n#endif /* SUPPORT_UNICODE */\n  if (!optimize_class(common,\
    \ (const sljit_u8 *)cc, FALSE, TRUE, list))\n    {\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    jump = NULL;\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH\
    \ == 8 */\n      jump = CMP(SLJIT_GREATER, TMP1, 0, SLJIT_IMM, 255);\n\n    OP2(SLJIT_AND,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, 0x7);\n    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM,\
    \ 3);\n    OP1(SLJIT_MOV_U8, TMP1, 0, SLJIT_MEM1(TMP1), (sljit_sw)cc);\n    OP2(SLJIT_SHL,\
    \ TMP2, 0, SLJIT_IMM, 1, TMP2, 0);\n    OP2U(SLJIT_AND | SLJIT_SET_Z, TMP1, 0,\
    \ TMP2, 0);\n    add_jump(compiler, list, JUMP(SLJIT_NOT_ZERO));\n\n#if PCRE2_CODE_UNIT_WIDTH\
    \ == 8\n    if (common->utf)\n#endif /* PCRE2_CODE_UNIT_WIDTH == 8 */\n      JUMPHERE(jump);\n\
    \    }\n\n  OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n  cc += 32 / sizeof(PCRE2_UCHAR);\n\
    \  }\n\n#ifdef SUPPORT_UNICODE\nif (unicode_status & XCLASS_NEEDS_UCD)\n  {\n\
    \  if ((unicode_status & (XCLASS_SAVE_CHAR | XCLASS_CHAR_SAVED)) == XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, RETURN_ADDR, 0, TMP1, 0);\n\n#if PCRE2_CODE_UNIT_WIDTH ==\
    \ 32\n  if (!common->utf)\n    {\n    jump = CMP(SLJIT_LESS, TMP1, 0, SLJIT_IMM,\
    \ MAX_UTF_CODE_POINT + 1);\n    OP1(SLJIT_MOV, TMP1, 0, SLJIT_IMM, UNASSIGNED_UTF_CHAR);\n\
    \    JUMPHERE(jump);\n    }\n#endif /* PCRE2_CODE_UNIT_WIDTH == 32 */\n\n  OP2(SLJIT_LSHR,\
    \ TMP2, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2,\
    \ 0, SLJIT_IMM, 1);\n  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_stage1));\n\
    \  OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BLOCK_MASK);\n  OP2(SLJIT_SHL,\
    \ TMP2, 0, TMP2, 0, SLJIT_IMM, UCD_BLOCK_SHIFT);\n  OP2(SLJIT_ADD, TMP1, 0, TMP1,\
    \ 0, TMP2, 0);\n  OP1(SLJIT_MOV, TMP2, 0, SLJIT_IMM, (sljit_sw)PRIV(ucd_stage2));\n\
    \  OP1(SLJIT_MOV_U16, TMP2, 0, SLJIT_MEM2(TMP2, TMP1), 1);\n  OP2(SLJIT_SHL, TMP1,\
    \ 0, TMP2, 0, SLJIT_IMM, 3);\n  OP2(SLJIT_SHL, TMP2, 0, TMP2, 0, SLJIT_IMM, 2);\n\
    \  OP2(SLJIT_ADD, TMP2, 0, TMP2, 0, TMP1, 0);\n\n  ccbegin = cc;\n\n  if (unicode_status\
    \ & XCLASS_HAS_BIDICL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2),\
    \ (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n\
    \    OP2(SLJIT_LSHR, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BIDICLASS_SHIFT);\n\n  \
    \  while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n        {\n\
    \        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else if (*cc\
    \ == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n \
    \       GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n        SLJIT_ASSERT(*cc\
    \ == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n        if (*cc == PT_BIDICL)\n\
    \          {\n          compares--;\n          invertcmp = (compares == 0 && list\
    \ != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n          jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]);\n\
    \          add_jump(compiler, compares > 0 ? list : backtracks, jump);\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_BOOL)\n    {\n    OP1(SLJIT_MOV_U16, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ bprops));\n    OP2(SLJIT_AND, TMP1, 0, TMP1, 0, SLJIT_IMM, UCD_BPROPS_MASK);\n\
    \    OP2(SLJIT_SHL, TMP1, 0, TMP1, 0, SLJIT_IMM, 2);\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_BOOL)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            invertcmp ^= 0x1;\n\n          OP2U(SLJIT_AND32\
    \ | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_boolprop_sets) + (cc[1]\
    \ >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n     \
    \     }\n        cc += 2;\n        }\n      }\n\n    cc = ccbegin;\n    }\n\n\
    \  if (unicode_status & XCLASS_HAS_SCRIPT)\n    {\n    OP1(SLJIT_MOV_U8, TMP1,\
    \ 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records) + SLJIT_OFFSETOF(ucd_record,\
    \ script));\n\n    while (*cc != XCL_END)\n      {\n      if (*cc == XCL_SINGLE)\n\
    \        {\n        cc ++;\n        GETCHARINCTEST(c, cc);\n        }\n      else\
    \ if (*cc == XCL_RANGE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        GETCHARINCTEST(c, cc);\n        }\n      else\n        {\n   \
    \     SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n        cc++;\n  \
    \      switch (*cc)\n          {\n          case PT_SCX:\n          if (cc[-1]\
    \ == XCL_NOTPROP)\n            break;\n          /* Fall through */ \n\n     \
    \     case PT_SC:\n          compares--;\n          invertcmp = (compares == 0\
    \ && list != backtracks);\n          if (cc[-1] == XCL_NOTPROP)\n            invertcmp\
    \ ^= 0x1;\n\n          add_jump(compiler, compares > 0 ? list : backtracks, CMP(SLJIT_EQUAL\
    \ ^ invertcmp, TMP1, 0, SLJIT_IMM, (int)cc[1]));\n          }\n        cc += 2;\n\
    \        }\n      }\n\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_HAS_SCRIPT_EXTENSION)\n\
    \    {\n    OP1(SLJIT_MOV_U16, TMP1, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, scriptx_bidiclass));\n    OP2(SLJIT_AND, TMP1,\
    \ 0, TMP1, 0, SLJIT_IMM, UCD_SCRIPTX_MASK);\n    OP2(SLJIT_SHL, TMP1, 0, TMP1,\
    \ 0, SLJIT_IMM, 2);\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_NOTPROP)\n\
    \      {\n      if (unicode_status & XCLASS_HAS_TYPE)\n        {\n        if (unicode_status\
    \ & XCLASS_SAVE_CHAR)\n          {\n          OP1(SLJIT_MOV, SLJIT_MEM1(SLJIT_SP),\
    \ LOCALS0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0;\n\
    \          }\n        else\n          {\n          OP1(SLJIT_MOV, RETURN_ADDR,\
    \ 0, TMP2, 0);\n          unicode_status |= XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR;\n\
    \          }\n        }\n      OP1(SLJIT_MOV_U8, TMP2, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, script));\n      }\n\n    while (*cc != XCL_END)\n\
    \      {\n      if (*cc == XCL_SINGLE)\n        {\n        cc ++;\n        GETCHARINCTEST(c,\
    \ cc);\n        }\n      else if (*cc == XCL_RANGE)\n        {\n        cc ++;\n\
    \        GETCHARINCTEST(c, cc);\n        GETCHARINCTEST(c, cc);\n        }\n \
    \     else\n        {\n        SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n\
    \        cc++;\n        if (*cc == PT_SCX)\n          {\n          compares--;\n\
    \          invertcmp = (compares == 0 && list != backtracks);\n\n          jump\
    \ = NULL;\n          if (cc[-1] == XCL_NOTPROP)\n            {\n            jump\
    \ = CMP(SLJIT_EQUAL, TMP2, 0, SLJIT_IMM, (int)cc[1]);\n            if (invertcmp)\n\
    \              {\n              add_jump(compiler, backtracks, jump);\n      \
    \        jump = NULL;\n              }\n            invertcmp ^= 0x1;\n      \
    \      }\n\n          OP2U(SLJIT_AND32 | SLJIT_SET_Z, SLJIT_MEM1(TMP1), (sljit_sw)(PRIV(ucd_script_sets)\
    \ + (cc[1] >> 5)), SLJIT_IMM, (sljit_sw)1 << (cc[1] & 0x1f));\n          add_jump(compiler,\
    \ compares > 0 ? list : backtracks, JUMP(SLJIT_NOT_ZERO ^ invertcmp));\n\n   \
    \       if (jump != NULL)\n            JUMPHERE(jump);\n          }\n        cc\
    \ += 2;\n        }\n      }\n\n    if (unicode_status & XCLASS_SCRIPT_EXTENSION_RESTORE_LOCALS0)\n\
    \      OP1(SLJIT_MOV, TMP2, 0, SLJIT_MEM1(SLJIT_SP), LOCALS0);\n    else if (unicode_status\
    \ & XCLASS_SCRIPT_EXTENSION_RESTORE_RETURN_ADDR)\n      OP1(SLJIT_MOV, TMP2, 0,\
    \ RETURN_ADDR, 0);\n    cc = ccbegin;\n    }\n\n  if (unicode_status & XCLASS_SAVE_CHAR)\n\
    \    OP1(SLJIT_MOV, TMP1, 0, RETURN_ADDR, 0);\n\n  if (unicode_status & XCLASS_HAS_TYPE)\n\
    \    {\n    if (unicode_status & XCLASS_SAVE_CHAR)\n      typereg = RETURN_ADDR;\n\
    \n    OP1(SLJIT_MOV_U8, typereg, 0, SLJIT_MEM1(TMP2), (sljit_sw)PRIV(ucd_records)\
    \ + SLJIT_OFFSETOF(ucd_record, chartype));\n    }\n  }\n#endif /* SUPPORT_UNICODE\
    \ */\n\n/* Generating code. */\ncharoffset = 0;\nnumberofcmps = 0;\n#ifdef SUPPORT_UNICODE\n\
    typeoffset = 0;\n#endif /* SUPPORT_UNICODE */\n\nwhile (*cc != XCL_END)\n  {\n\
    \  compares--;\n  invertcmp = (compares == 0 && list != backtracks);\n  jump =\
    \ NULL;\n\n  if (*cc == XCL_SINGLE)\n    {\n    cc ++;\n    GETCHARINCTEST(c,\
    \ cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE || *cc == XCL_RANGE))\n\
    \      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(numberofcmps == 0 ? SLJIT_MOV : SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      numberofcmps++;\n      }\n    else if (numberofcmps\
    \ > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(c\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      numberofcmps = 0;\n   \
    \   }\n    else\n      {\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(c - charoffset));\n      numberofcmps = 0;\n      }\n    }\n  else\
    \ if (*cc == XCL_RANGE)\n    {\n    cc ++;\n    GETCHARINCTEST(c, cc);\n    SET_CHAR_OFFSET(c);\n\
    \    GETCHARINCTEST(c, cc);\n\n    if (numberofcmps < 3 && (*cc == XCL_SINGLE\
    \ || *cc == XCL_RANGE))\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(numberofcmps\
    \ == 0 ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n      numberofcmps++;\n\
    \      }\n    else if (numberofcmps > 0)\n      {\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n      OP_FLAGS(SLJIT_OR |\
    \ SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^\
    \ invertcmp);\n      numberofcmps = 0;\n      }\n    else\n      {\n      jump\
    \ = CMP(SLJIT_LESS_EQUAL ^ invertcmp, TMP1, 0, SLJIT_IMM, (sljit_sw)(c - charoffset));\n\
    \      numberofcmps = 0;\n      }\n    }\n#ifdef SUPPORT_UNICODE\n  else\n   \
    \ {\n    SLJIT_ASSERT(*cc == XCL_PROP || *cc == XCL_NOTPROP);\n    if (*cc ==\
    \ XCL_NOTPROP)\n      invertcmp ^= 0x1;\n    cc++;\n    switch(*cc)\n      {\n\
    \      case PT_ANY:\n      if (!invertcmp)\n        jump = JUMP(SLJIT_JUMP);\n\
    \      break;\n\n      case PT_LAMP:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg,\
    \ 0, SLJIT_IMM, ucp_Lu - typeoffset);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0, SLJIT_IMM, ucp_Ll - typeoffset);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ typereg, 0, SLJIT_IMM, ucp_Lt - typeoffset);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n   \
    \   break;\n\n      case PT_GC:\n      c = PRIV(ucp_typerange)[(int)cc[1] * 2];\n\
    \      SET_TYPE_OFFSET(c);\n      jump = CMP(SLJIT_LESS_EQUAL ^ invertcmp, typereg,\
    \ 0, SLJIT_IMM, PRIV(ucp_typerange)[(int)cc[1] * 2 + 1] - c);\n      break;\n\n\
    \      case PT_PC:\n      jump = CMP(SLJIT_EQUAL ^ invertcmp, typereg, 0, SLJIT_IMM,\
    \ (int)cc[1] - typeoffset);\n      break;\n\n      case PT_SC:\n      case PT_SCX:\n\
    \      case PT_BOOL:\n      case PT_BIDICL:\n      compares++;\n      /* Do nothing.\
    \ */\n      break;\n\n      case PT_SPACE:\n      case PT_PXSPACE:\n      SET_CHAR_OFFSET(9);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0xd - 0x9);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x85 - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ 0x180e - 0x9);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_TYPE_OFFSET(ucp_Zl);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Zs -\
    \ ucp_Zl);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n      break;\n\n      case PT_WORD:\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_UNDERSCORE\
    \ - charoffset));\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      /*\
    \ Fall through. */\n\n      case PT_ALNUM:\n      SET_TYPE_OFFSET(ucp_Ll);\n \
    \     OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, typereg, 0, SLJIT_IMM, ucp_Lu - ucp_Ll);\n\
    \      OP_FLAGS((*cc == PT_ALNUM) ? SLJIT_MOV : SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \      SET_TYPE_OFFSET(ucp_Nd);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_No - ucp_Nd);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_CLIST:\n      other_cases = PRIV(ucd_caseless_sets)\
    \ + cc[1];\n\n      /* At least three characters are required.\n         Otherwise\
    \ this case would be handled by the normal code path. */\n      SLJIT_ASSERT(other_cases[0]\
    \ != NOTACHAR && other_cases[1] != NOTACHAR && other_cases[2] != NOTACHAR);\n\
    \      SLJIT_ASSERT(other_cases[0] < other_cases[1] && other_cases[1] < other_cases[2]);\n\
    \n      /* Optimizing character pairs, if their difference is power of 2. */\n\
    \      if (is_powerof2(other_cases[1] ^ other_cases[0]))\n        {\n        if\
    \ (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0, SLJIT_IMM, other_cases[1]\
    \ ^ other_cases[0]);\n        else\n          {\n          OP2(SLJIT_ADD, TMP2,\
    \ 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n          OP2(SLJIT_OR, TMP2,\
    \ 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n          }\n    \
    \    OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[1]);\n    \
    \    OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n        other_cases += 2;\n \
    \       }\n      else if (is_powerof2(other_cases[2] ^ other_cases[1]))\n    \
    \    {\n        if (charoffset == 0)\n          OP2(SLJIT_OR, TMP2, 0, TMP1, 0,\
    \ SLJIT_IMM, other_cases[2] ^ other_cases[1]);\n        else\n          {\n  \
    \        OP2(SLJIT_ADD, TMP2, 0, TMP1, 0, SLJIT_IMM, (sljit_sw)charoffset);\n\
    \          OP2(SLJIT_OR, TMP2, 0, TMP2, 0, SLJIT_IMM, other_cases[1] ^ other_cases[0]);\n\
    \          }\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP2, 0, SLJIT_IMM, other_cases[2]);\n\
    \        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(other_cases[0] - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((other_cases[3] == NOTACHAR) ? SLJIT_SET_Z : 0),\
    \ TMP2, 0, SLJIT_EQUAL);\n\n        other_cases += 3;\n        }\n      else\n\
    \        {\n        OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++\
    \ - charoffset));\n        OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_EQUAL);\n      \
    \  }\n\n      while (*other_cases != NOTACHAR)\n        {\n        OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(*other_cases++ - charoffset));\n\
    \        OP_FLAGS(SLJIT_OR | ((*other_cases == NOTACHAR) ? SLJIT_SET_Z : 0), TMP2,\
    \ 0, SLJIT_EQUAL);\n        }\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      case PT_UCNC:\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1,\
    \ 0, SLJIT_IMM, (sljit_sw)(CHAR_DOLLAR_SIGN - charoffset));\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM,\
    \ (sljit_sw)(CHAR_COMMERCIAL_AT - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2,\
    \ 0, SLJIT_EQUAL);\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, (sljit_sw)(CHAR_GRAVE_ACCENT\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      SET_CHAR_OFFSET(0xa0);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, (sljit_sw)(0xd7ff\
    \ - charoffset));\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_LESS_EQUAL);\n    \
    \  SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER_EQUAL, TMP1,\
    \ 0, SLJIT_IMM, 0xe000 - 0);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z, TMP2, 0,\
    \ SLJIT_GREATER_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n    \
    \  break;\n\n      case PT_PXGRAPH:\n      /* C and Z groups are the farthest\
    \ two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB | SLJIT_SET_GREATER,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_GREATER);\n\n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM,\
    \ ucp_Cf - ucp_Ll);\n\n      /* In case of ucp_Cf, we overwrite the result. */\n\
    \      SET_CHAR_OFFSET(0x2066);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      OP2U(SLJIT_SUB | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n\
    \      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z,\
    \ TMP1, 0, SLJIT_IMM, 0x180e - 0x2066);\n      OP_FLAGS(SLJIT_OR, TMP2, 0, SLJIT_EQUAL);\n\
    \n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO ^ invertcmp, TMP2, 0, SLJIT_IMM,\
    \ 0);\n      break;\n\n      case PT_PXPRINT:\n      /* C and Z groups are the\
    \ farthest two groups. */\n      SET_TYPE_OFFSET(ucp_Ll);\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_GREATER, typereg, 0, SLJIT_IMM, ucp_So - ucp_Ll);\n      OP_FLAGS(SLJIT_MOV,\
    \ TMP2, 0, SLJIT_GREATER);\n\n      OP2U(SLJIT_SUB | SLJIT_SET_Z, typereg, 0,\
    \ SLJIT_IMM, ucp_Zs - ucp_Ll);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_NOT_EQUAL);\n\
    \n      jump = CMP(SLJIT_NOT_EQUAL, typereg, 0, SLJIT_IMM, ucp_Cf - ucp_Ll);\n\
    \n      /* In case of ucp_Cf, we overwrite the result. */\n      SET_CHAR_OFFSET(0x2066);\n\
    \      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL, TMP1, 0, SLJIT_IMM, 0x2069 - 0x2066);\n\
    \      OP_FLAGS(SLJIT_MOV, TMP2, 0, SLJIT_LESS_EQUAL);\n\n      OP2U(SLJIT_SUB\
    \ | SLJIT_SET_Z, TMP1, 0, SLJIT_IMM, 0x061c - 0x2066);\n      OP_FLAGS(SLJIT_OR,\
    \ TMP2, 0, SLJIT_EQUAL);\n\n      JUMPHERE(jump);\n      jump = CMP(SLJIT_ZERO\
    \ ^ invertcmp, TMP2, 0, SLJIT_IMM, 0);\n      break;\n\n      case PT_PXPUNCT:\n\
    \      SET_TYPE_OFFSET(ucp_Sc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_So - ucp_Sc);\n      OP_FLAGS(SLJIT_MOV, TMP2, 0,\
    \ SLJIT_LESS_EQUAL);\n\n      SET_CHAR_OFFSET(0);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ TMP1, 0, SLJIT_IMM, 0x7f);\n      OP_FLAGS(SLJIT_AND, TMP2, 0, SLJIT_LESS_EQUAL);\n\
    \n      SET_TYPE_OFFSET(ucp_Pc);\n      OP2U(SLJIT_SUB | SLJIT_SET_LESS_EQUAL,\
    \ typereg, 0, SLJIT_IMM, ucp_Ps - ucp_Pc);\n      OP_FLAGS(SLJIT_OR | SLJIT_SET_Z,\
    \ TMP2, 0, SLJIT_LESS_EQUAL);\n      jump = JUMP(SLJIT_NOT_ZERO ^ invertcmp);\n\
    \      break;\n\n      default:\n      SLJIT_UNREACHABLE();\n      break;\n  \
    \    }\n    cc += 2;\n    }\n#endif /* SUPPORT_UNICODE */\n\n  if (jump != NULL)\n\
    \    add_jump(compiler, compares > 0 ? list : backtracks, jump);\n  }\n\nif (found\
    \ != NULL)\n  set_jumps(found, LABEL());\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 195264
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
