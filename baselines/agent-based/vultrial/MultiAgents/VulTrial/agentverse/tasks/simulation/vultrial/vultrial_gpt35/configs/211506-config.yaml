agents:
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nint ZEXPORT\
    \ inflate(strm, flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state\
    \ FAR *state;\n    z_const unsigned char FAR *next;    /* next input */\n    unsigned\
    \ char FAR *put;     /* next output */\n    unsigned have, left;        /* available\
    \ input and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned\
    \ bits;              /* bits in bit buffer */\n    unsigned in, out;         \
    \  /* save starting available input and output */\n    unsigned copy;        \
    \      /* number of stored or match bytes to copy */\n    unsigned char FAR *from;\
    \    /* where to copy match bytes from */\n    code here;                  /*\
    \ current decoding table entry */\n    code last;                  /* parent table\
    \ entry */\n    unsigned len;               /* length to copy for repeats, bits\
    \ to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n\
    \    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n\
    #endif\n    static const unsigned short order[19] = /* permutation of code lengths\
    \ */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\
    \n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in\
    \ == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state\
    \ = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode\
    \ = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n\
    \    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n\
    \            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n\
    \                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n\
    \            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n \
    \               if (state->wbits == 0)\n                    state->wbits = 15;\n\
    \                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check,\
    \ hold);\n                INITBITS();\n                state->mode = FLAGS;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->done = -1;\n            if (!(state->wrap & 1) ||\
    \   /* check if zlib header allowed */\n#else\n            if (\n#endif\n    \
    \            ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg\
    \ = (char *)\"incorrect header check\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (BITS(4) != Z_DEFLATED)\
    \ {\n                strm->msg = (char *)\"unknown compression method\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n    \
    \        DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits\
    \ == 0)\n                state->wbits = len;\n            if (len > 15 || len\
    \ > state->wbits) {\n                strm->msg = (char *)\"invalid window size\"\
    ;\n                state->mode = BAD;\n                break;\n            }\n\
    \            state->dmax = 1U << len;\n            state->flags = 0;         \
    \      /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib\
    \ header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL,\
    \ 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n\
    \            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n\
    \            state->flags = (int)(hold);\n            if ((state->flags & 0xff)\
    \ != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression\
    \ method\";\n                state->mode = BAD;\n                break;\n    \
    \        }\n            if (state->flags & 0xe000) {\n                strm->msg\
    \ = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags\
    \ & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n\
    \            INITBITS();\n            state->mode = TIME;\n                /*\
    \ fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if\
    \ (state->head != Z_NULL)\n                state->head->time = hold;\n       \
    \     if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check,\
    \ hold);\n            INITBITS();\n            state->mode = OS;\n           \
    \     /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n       \
    \     if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold\
    \ & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n\
    \            if ((state->flags & 0x0200) && (state->wrap & 4))\n             \
    \   CRC2(state->check, hold);\n            INITBITS();\n            state->mode\
    \ = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n         \
    \   if (state->flags & 0x0400) {\n                NEEDBITS(16);\n            \
    \    state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n\
    \                    state->head->extra_len = (unsigned)hold;\n              \
    \  if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check,\
    \ hold);\n                INITBITS();\n            }\n            else if (state->head\
    \ != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode\
    \ = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n         \
    \   if (state->flags & 0x0400) {\n                copy = state->length;\n    \
    \            if (copy > have) copy = have;\n                if (copy) {\n    \
    \                if (state->head != Z_NULL &&\n                        state->head->extra\
    \ != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n\
    \                        zmemcpy(state->head->extra + len, next,\n           \
    \                     len + copy > state->head->extra_max ?\n                \
    \                state->head->extra_max - len : copy);\n                    }\n\
    \                    if ((state->flags & 0x0200) && (state->wrap & 4))\n     \
    \                   state->check = crc32(state->check, next, copy);\n        \
    \            have -= copy;\n                    next += copy;\n              \
    \      state->length -= copy;\n                }\n                if (state->length)\
    \ goto inf_leave;\n            }\n            state->length = 0;\n           \
    \ state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n\
    \            if (state->flags & 0x0800) {\n                if (have == 0) goto\
    \ inf_leave;\n                copy = 0;\n                do {\n              \
    \      len = (unsigned)(next[copy++]);\n                    if (state->head !=\
    \ Z_NULL &&\n                            state->head->name != Z_NULL &&\n    \
    \                        state->length < state->head->name_max)\n            \
    \            state->head->name[state->length++] = (Bytef)len;\n              \
    \  } while (len && copy < have);\n                if ((state->flags & 0x0200)\
    \ && (state->wrap & 4))\n                    state->check = crc32(state->check,\
    \ next, copy);\n                have -= copy;\n                next += copy;\n\
    \                if (len) goto inf_leave;\n            }\n            else if\
    \ (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n     \
    \       state->length = 0;\n            state->mode = COMMENT;\n             \
    \   /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000)\
    \ {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n\
    \                do {\n                    len = (unsigned)(next[copy++]);\n \
    \                   if (state->head != Z_NULL &&\n                           \
    \ state->head->comment != Z_NULL &&\n                            state->length\
    \ < state->head->comm_max)\n                        state->head->comment[state->length++]\
    \ = (Bytef)len;\n                } while (len && copy < have);\n             \
    \   if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check\
    \ = crc32(state->check, next, copy);\n                have -= copy;\n        \
    \        next += copy;\n                if (len) goto inf_leave;\n           \
    \ }\n            else if (state->head != Z_NULL)\n                state->head->comment\
    \ = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n\
    \        case HCRC:\n            if (state->flags & 0x0200) {\n              \
    \  NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check\
    \ & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\"\
    ;\n                    state->mode = BAD;\n                    break;\n      \
    \          }\n                INITBITS();\n            }\n            if (state->head\
    \ != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9)\
    \ & 1);\n                state->head->done = 1;\n            }\n            strm->adler\
    \ = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \          break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n \
    \           strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n\
    \            state->mode = DICT;\n                /* fallthrough */\n        case\
    \ DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n\
    \                return Z_NEED_DICT;\n            }\n            strm->adler =\
    \ state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \              /* fallthrough */\n        case TYPE:\n            if (flush ==\
    \ Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough\
    \ */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n\
    \                state->mode = CHECK;\n                break;\n            }\n\
    \            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n\
    \            switch (BITS(2)) {\n            case 0:                         \
    \    /* stored block */\n                Tracev((stderr, \"inflate:     stored\
    \ block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n\
    \                state->mode = STORED;\n                break;\n            case\
    \ 1:                             /* fixed block */\n                fixedtables(state);\n\
    \                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n  \
    \                      state->last ? \" (last)\" : \"\"));\n                state->mode\
    \ = LEN_;             /* decode codes */\n                if (flush == Z_TREES)\
    \ {\n                    DROPBITS(2);\n                    goto inf_leave;\n \
    \               }\n                break;\n            case 2:               \
    \              /* dynamic block */\n                Tracev((stderr, \"inflate:\
    \     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\"\
    \ : \"\"));\n                state->mode = TABLE;\n                break;\n  \
    \          case 3:\n                strm->msg = (char *)\"invalid block type\"\
    ;\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n\
    \            break;\n        case STORED:\n            BYTEBITS();           \
    \              /* go to byte boundary */\n            NEEDBITS(32);\n        \
    \    if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg\
    \ = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            state->length = (unsigned)hold\
    \ & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\"\
    ,\n                    state->length));\n            INITBITS();\n           \
    \ state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n  \
    \              /* fallthrough */\n        case COPY_:\n            state->mode\
    \ = COPY;\n                /* fallthrough */\n        case COPY:\n           \
    \ copy = state->length;\n            if (copy) {\n                if (copy > have)\
    \ copy = have;\n                if (copy > left) copy = left;\n              \
    \  if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n\
    \                have -= copy;\n                next += copy;\n              \
    \  left -= copy;\n                put += copy;\n                state->length\
    \ -= copy;\n                break;\n            }\n            Tracev((stderr,\
    \ \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n     \
    \       break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen\
    \ = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5)\
    \ + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n  \
    \          DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen\
    \ > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many\
    \ length or distance symbols\";\n                state->mode = BAD;\n        \
    \        break;\n            }\n#endif\n            Tracev((stderr, \"inflate:\
    \       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode\
    \ = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n     \
    \       while (state->have < state->ncode) {\n                NEEDBITS(3);\n \
    \               state->lens[order[state->have++]] = (unsigned short)BITS(3);\n\
    \                DROPBITS(3);\n            }\n            while (state->have <\
    \ 19)\n                state->lens[order[state->have++]] = 0;\n            state->next\
    \ = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n\
    \            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens,\
    \ 19, &(state->next),\n                                &(state->lenbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid code lengths\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\
    \            state->have = 0;\n            state->mode = CODELENS;\n         \
    \       /* fallthrough */\n        case CODELENS:\n            while (state->have\
    \ < state->nlen + state->ndist) {\n                for (;;) {\n              \
    \      here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits)\
    \ <= bits) break;\n                    PULLBYTE();\n                }\n      \
    \          if (here.val < 16) {\n                    DROPBITS(here.bits);\n  \
    \                  state->lens[state->have++] = here.val;\n                }\n\
    \                else {\n                    if (here.val == 16) {\n         \
    \               NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n\
    \                        if (state->have == 0) {\n                           \
    \ strm->msg = (char *)\"invalid bit length repeat\";\n                       \
    \     state->mode = BAD;\n                            break;\n               \
    \         }\n                        len = state->lens[state->have - 1];\n   \
    \                     copy = 3 + BITS(2);\n                        DROPBITS(2);\n\
    \                    }\n                    else if (here.val == 17) {\n     \
    \                   NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n\
    \                        len = 0;\n                        copy = 3 + BITS(3);\n\
    \                        DROPBITS(3);\n                    }\n               \
    \     else {\n                        NEEDBITS(here.bits + 7);\n             \
    \           DROPBITS(here.bits);\n                        len = 0;\n         \
    \               copy = 11 + BITS(7);\n                        DROPBITS(7);\n \
    \                   }\n                    if (state->have + copy > state->nlen\
    \ + state->ndist) {\n                        strm->msg = (char *)\"invalid bit\
    \ length repeat\";\n                        state->mode = BAD;\n             \
    \           break;\n                    }\n                    while (copy--)\n\
    \                        state->lens[state->have++] = (unsigned short)len;\n \
    \               }\n            }\n\n            /* handle error breaks in while\
    \ */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block\
    \ code (better have one) */\n            if (state->lens[256] == 0) {\n      \
    \          strm->msg = (char *)\"invalid code -- missing end-of-block\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n\n  \
    \          /* build code tables -- note: do not change the lenbits or distbits\n\
    \               values here (9 and 6) without reading the comments in inftrees.h\n\
    \               concerning the ENOUGH constants, which depend on those values\
    \ */\n            state->next = state->codes;\n            state->lencode = (const\
    \ code FAR *)(state->next);\n            state->lenbits = 9;\n            ret\
    \ = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n          \
    \                      &(state->lenbits), state->work);\n            if (ret)\
    \ {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n  \
    \              state->mode = BAD;\n                break;\n            }\n   \
    \         state->distcode = (const code FAR *)(state->next);\n            state->distbits\
    \ = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n\
    \                            &(state->next), &(state->distbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid distances\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n     \
    \       state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n\
    \                /* fallthrough */\n        case LEN_:\n            state->mode\
    \ = LEN;\n                /* fallthrough */\n        case LEN:\n            if\
    \ (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm,\
    \ out);\n                LOAD();\n                if (state->mode == TYPE)\n \
    \                   state->back = -1;\n                break;\n            }\n\
    \            state->back = 0;\n            for (;;) {\n                here =\
    \ state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits)\
    \ <= bits) break;\n                PULLBYTE();\n            }\n            if\
    \ (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n       \
    \         for (;;) {\n                    here = state->lencode[last.val +\n \
    \                           (BITS(last.bits + last.op) >> last.bits)];\n     \
    \               if ((unsigned)(last.bits + here.bits) <= bits) break;\n      \
    \              PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            state->length = (unsigned)here.val;\n\
    \            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val\
    \ >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal\
    \ '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\"\
    , here.val));\n                state->mode = LIT;\n                break;\n  \
    \          }\n            if (here.op & 32) {\n                Tracevv((stderr,\
    \ \"inflate:         end of block\\n\"));\n                state->back = -1;\n\
    \                state->mode = TYPE;\n                break;\n            }\n\
    \            if (here.op & 64) {\n                strm->msg = (char *)\"invalid\
    \ literal/length code\";\n                state->mode = BAD;\n               \
    \ break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n\
    \            state->mode = LENEXT;\n                /* fallthrough */\n      \
    \  case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n\
    \                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n            Tracevv((stderr,\
    \ \"inflate:         length %u\\n\", state->length));\n            state->was\
    \ = state->length;\n            state->mode = DIST;\n                /* fallthrough\
    \ */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n\
    \                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n\
    \            }\n            if ((here.op & 0xf0) == 0) {\n                last\
    \ = here;\n                for (;;) {\n                    here = state->distcode[last.val\
    \ +\n                            (BITS(last.bits + last.op) >> last.bits)];\n\
    \                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n \
    \                   PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            if (here.op & 64) {\n    \
    \            strm->msg = (char *)\"invalid distance code\";\n                state->mode\
    \ = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n\
    \            state->extra = (unsigned)(here.op) & 15;\n            state->mode\
    \ = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n     \
    \       if (state->extra) {\n                NEEDBITS(state->extra);\n       \
    \         state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n\
    \            if (state->offset > state->dmax) {\n                strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                state->mode = BAD;\n \
    \               break;\n            }\n#endif\n            Tracevv((stderr, \"\
    inflate:         distance %u\\n\", state->offset));\n            state->mode =\
    \ MATCH;\n                /* fallthrough */\n        case MATCH:\n           \
    \ if (left == 0) goto inf_leave;\n            copy = out - left;\n           \
    \ if (state->offset > copy) {         /* copy from window */\n               \
    \ copy = state->offset - copy;\n                if (copy > state->whave) {\n \
    \                   if (state->sane) {\n                        strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                        state->mode =\
    \ BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\
    \                    Trace((stderr, \"inflate.c too far\\n\"));\n            \
    \        copy -= state->whave;\n                    if (copy > state->length)\
    \ copy = state->length;\n                    if (copy > left) copy = left;\n \
    \                   left -= copy;\n                    state->length -= copy;\n\
    \                    do {\n                        *put++ = 0;\n             \
    \       } while (--copy);\n                    if (state->length == 0) state->mode\
    \ = LEN;\n                    break;\n#endif\n                }\n            \
    \    if (copy > state->wnext) {\n                    copy -= state->wnext;\n \
    \                   from = state->window + (state->wsize - copy);\n          \
    \      }\n                else\n                    from = state->window + (state->wnext\
    \ - copy);\n                if (copy > state->length) copy = state->length;\n\
    \            }\n            else {                              /* copy from output\
    \ */\n                from = put - state->offset;\n                copy = state->length;\n\
    \            }\n            if (copy > left) copy = left;\n            left -=\
    \ copy;\n            state->length -= copy;\n            do {\n              \
    \  *put++ = *from++;\n            } while (--copy);\n            if (state->length\
    \ == 0) state->mode = LEN;\n            break;\n        case LIT:\n          \
    \  if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n\
    \            left--;\n            state->mode = LEN;\n            break;\n   \
    \     case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n\
    \                out -= left;\n                strm->total_out += out;\n     \
    \           state->total += out;\n                if ((state->wrap & 4) && out)\n\
    \                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check,\
    \ put - out, out);\n                out = left;\n                if ((state->wrap\
    \ & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n\
    \                     ZSWAP32(hold)) != state->check) {\n                    strm->msg\
    \ = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\
    \            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n           \
    \     /* fallthrough */\n        case LENGTH:\n            if (state->wrap &&\
    \ state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap\
    \ & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg\
    \ = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\
    \            }\n#endif\n            state->mode = DONE;\n                /* fallthrough\
    \ */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\
    \        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\
    \        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n    \
    \            /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n\
    \        }\n\n    /*\n       Return from inflate(), updating the total counts\
    \ and the check value.\n       If there was no progress during the inflate() call,\
    \ return a buffer\n       error.  Call updatewindow() to create and/or update\
    \ the window state.\n       Note: a memory error from inflate() is non-recoverable.\n\
    \     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out\
    \ && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n\
    \        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n  \
    \          state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n  \
    \  in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n\
    \    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap &\
    \ 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check,\
    \ strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last\
    \ ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n     \
    \                 (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n \
    \   if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n       \
    \ ret = Z_BUF_ERROR;\n    return ret;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nint ZEXPORT inflate(strm,\
    \ flush)\nz_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n\
    \    z_const unsigned char FAR *next;    /* next input */\n    unsigned char FAR\
    \ *put;     /* next output */\n    unsigned have, left;        /* available input\
    \ and output */\n    unsigned long hold;         /* bit buffer */\n    unsigned\
    \ bits;              /* bits in bit buffer */\n    unsigned in, out;         \
    \  /* save starting available input and output */\n    unsigned copy;        \
    \      /* number of stored or match bytes to copy */\n    unsigned char FAR *from;\
    \    /* where to copy match bytes from */\n    code here;                  /*\
    \ current decoding table entry */\n    code last;                  /* parent table\
    \ entry */\n    unsigned len;               /* length to copy for repeats, bits\
    \ to drop */\n    int ret;                    /* return code */\n#ifdef GUNZIP\n\
    \    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */\n\
    #endif\n    static const unsigned short order[19] = /* permutation of code lengths\
    \ */\n        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\
    \n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in\
    \ == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state\
    \ = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode\
    \ = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n\
    \    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n\
    \            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n\
    \                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n\
    \            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n \
    \               if (state->wbits == 0)\n                    state->wbits = 15;\n\
    \                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check,\
    \ hold);\n                INITBITS();\n                state->mode = FLAGS;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->done = -1;\n            if (!(state->wrap & 1) ||\
    \   /* check if zlib header allowed */\n#else\n            if (\n#endif\n    \
    \            ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg\
    \ = (char *)\"incorrect header check\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (BITS(4) != Z_DEFLATED)\
    \ {\n                strm->msg = (char *)\"unknown compression method\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n    \
    \        DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits\
    \ == 0)\n                state->wbits = len;\n            if (len > 15 || len\
    \ > state->wbits) {\n                strm->msg = (char *)\"invalid window size\"\
    ;\n                state->mode = BAD;\n                break;\n            }\n\
    \            state->dmax = 1U << len;\n            state->flags = 0;         \
    \      /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib\
    \ header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL,\
    \ 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n\
    \            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n\
    \            state->flags = (int)(hold);\n            if ((state->flags & 0xff)\
    \ != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression\
    \ method\";\n                state->mode = BAD;\n                break;\n    \
    \        }\n            if (state->flags & 0xe000) {\n                strm->msg\
    \ = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags\
    \ & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n\
    \            INITBITS();\n            state->mode = TIME;\n                /*\
    \ fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if\
    \ (state->head != Z_NULL)\n                state->head->time = hold;\n       \
    \     if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check,\
    \ hold);\n            INITBITS();\n            state->mode = OS;\n           \
    \     /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n       \
    \     if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold\
    \ & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n\
    \            if ((state->flags & 0x0200) && (state->wrap & 4))\n             \
    \   CRC2(state->check, hold);\n            INITBITS();\n            state->mode\
    \ = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n         \
    \   if (state->flags & 0x0400) {\n                NEEDBITS(16);\n            \
    \    state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n\
    \                    state->head->extra_len = (unsigned)hold;\n              \
    \  if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check,\
    \ hold);\n                INITBITS();\n            }\n            else if (state->head\
    \ != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode\
    \ = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n         \
    \   if (state->flags & 0x0400) {\n                copy = state->length;\n    \
    \            if (copy > have) copy = have;\n                if (copy) {\n    \
    \                if (state->head != Z_NULL &&\n                        state->head->extra\
    \ != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n\
    \                        zmemcpy(state->head->extra + len, next,\n           \
    \                     len + copy > state->head->extra_max ?\n                \
    \                state->head->extra_max - len : copy);\n                    }\n\
    \                    if ((state->flags & 0x0200) && (state->wrap & 4))\n     \
    \                   state->check = crc32(state->check, next, copy);\n        \
    \            have -= copy;\n                    next += copy;\n              \
    \      state->length -= copy;\n                }\n                if (state->length)\
    \ goto inf_leave;\n            }\n            state->length = 0;\n           \
    \ state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n\
    \            if (state->flags & 0x0800) {\n                if (have == 0) goto\
    \ inf_leave;\n                copy = 0;\n                do {\n              \
    \      len = (unsigned)(next[copy++]);\n                    if (state->head !=\
    \ Z_NULL &&\n                            state->head->name != Z_NULL &&\n    \
    \                        state->length < state->head->name_max)\n            \
    \            state->head->name[state->length++] = (Bytef)len;\n              \
    \  } while (len && copy < have);\n                if ((state->flags & 0x0200)\
    \ && (state->wrap & 4))\n                    state->check = crc32(state->check,\
    \ next, copy);\n                have -= copy;\n                next += copy;\n\
    \                if (len) goto inf_leave;\n            }\n            else if\
    \ (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n     \
    \       state->length = 0;\n            state->mode = COMMENT;\n             \
    \   /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000)\
    \ {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n\
    \                do {\n                    len = (unsigned)(next[copy++]);\n \
    \                   if (state->head != Z_NULL &&\n                           \
    \ state->head->comment != Z_NULL &&\n                            state->length\
    \ < state->head->comm_max)\n                        state->head->comment[state->length++]\
    \ = (Bytef)len;\n                } while (len && copy < have);\n             \
    \   if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check\
    \ = crc32(state->check, next, copy);\n                have -= copy;\n        \
    \        next += copy;\n                if (len) goto inf_leave;\n           \
    \ }\n            else if (state->head != Z_NULL)\n                state->head->comment\
    \ = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n\
    \        case HCRC:\n            if (state->flags & 0x0200) {\n              \
    \  NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check\
    \ & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\"\
    ;\n                    state->mode = BAD;\n                    break;\n      \
    \          }\n                INITBITS();\n            }\n            if (state->head\
    \ != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9)\
    \ & 1);\n                state->head->done = 1;\n            }\n            strm->adler\
    \ = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \          break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n \
    \           strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n\
    \            state->mode = DICT;\n                /* fallthrough */\n        case\
    \ DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n\
    \                return Z_NEED_DICT;\n            }\n            strm->adler =\
    \ state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \              /* fallthrough */\n        case TYPE:\n            if (flush ==\
    \ Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough\
    \ */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n\
    \                state->mode = CHECK;\n                break;\n            }\n\
    \            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n\
    \            switch (BITS(2)) {\n            case 0:                         \
    \    /* stored block */\n                Tracev((stderr, \"inflate:     stored\
    \ block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n\
    \                state->mode = STORED;\n                break;\n            case\
    \ 1:                             /* fixed block */\n                fixedtables(state);\n\
    \                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n  \
    \                      state->last ? \" (last)\" : \"\"));\n                state->mode\
    \ = LEN_;             /* decode codes */\n                if (flush == Z_TREES)\
    \ {\n                    DROPBITS(2);\n                    goto inf_leave;\n \
    \               }\n                break;\n            case 2:               \
    \              /* dynamic block */\n                Tracev((stderr, \"inflate:\
    \     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\"\
    \ : \"\"));\n                state->mode = TABLE;\n                break;\n  \
    \          case 3:\n                strm->msg = (char *)\"invalid block type\"\
    ;\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n\
    \            break;\n        case STORED:\n            BYTEBITS();           \
    \              /* go to byte boundary */\n            NEEDBITS(32);\n        \
    \    if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg\
    \ = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            state->length = (unsigned)hold\
    \ & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\"\
    ,\n                    state->length));\n            INITBITS();\n           \
    \ state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n  \
    \              /* fallthrough */\n        case COPY_:\n            state->mode\
    \ = COPY;\n                /* fallthrough */\n        case COPY:\n           \
    \ copy = state->length;\n            if (copy) {\n                if (copy > have)\
    \ copy = have;\n                if (copy > left) copy = left;\n              \
    \  if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n\
    \                have -= copy;\n                next += copy;\n              \
    \  left -= copy;\n                put += copy;\n                state->length\
    \ -= copy;\n                break;\n            }\n            Tracev((stderr,\
    \ \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n     \
    \       break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen\
    \ = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5)\
    \ + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n  \
    \          DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen\
    \ > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many\
    \ length or distance symbols\";\n                state->mode = BAD;\n        \
    \        break;\n            }\n#endif\n            Tracev((stderr, \"inflate:\
    \       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode\
    \ = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n     \
    \       while (state->have < state->ncode) {\n                NEEDBITS(3);\n \
    \               state->lens[order[state->have++]] = (unsigned short)BITS(3);\n\
    \                DROPBITS(3);\n            }\n            while (state->have <\
    \ 19)\n                state->lens[order[state->have++]] = 0;\n            state->next\
    \ = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n\
    \            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens,\
    \ 19, &(state->next),\n                                &(state->lenbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid code lengths\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\
    \            state->have = 0;\n            state->mode = CODELENS;\n         \
    \       /* fallthrough */\n        case CODELENS:\n            while (state->have\
    \ < state->nlen + state->ndist) {\n                for (;;) {\n              \
    \      here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits)\
    \ <= bits) break;\n                    PULLBYTE();\n                }\n      \
    \          if (here.val < 16) {\n                    DROPBITS(here.bits);\n  \
    \                  state->lens[state->have++] = here.val;\n                }\n\
    \                else {\n                    if (here.val == 16) {\n         \
    \               NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n\
    \                        if (state->have == 0) {\n                           \
    \ strm->msg = (char *)\"invalid bit length repeat\";\n                       \
    \     state->mode = BAD;\n                            break;\n               \
    \         }\n                        len = state->lens[state->have - 1];\n   \
    \                     copy = 3 + BITS(2);\n                        DROPBITS(2);\n\
    \                    }\n                    else if (here.val == 17) {\n     \
    \                   NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n\
    \                        len = 0;\n                        copy = 3 + BITS(3);\n\
    \                        DROPBITS(3);\n                    }\n               \
    \     else {\n                        NEEDBITS(here.bits + 7);\n             \
    \           DROPBITS(here.bits);\n                        len = 0;\n         \
    \               copy = 11 + BITS(7);\n                        DROPBITS(7);\n \
    \                   }\n                    if (state->have + copy > state->nlen\
    \ + state->ndist) {\n                        strm->msg = (char *)\"invalid bit\
    \ length repeat\";\n                        state->mode = BAD;\n             \
    \           break;\n                    }\n                    while (copy--)\n\
    \                        state->lens[state->have++] = (unsigned short)len;\n \
    \               }\n            }\n\n            /* handle error breaks in while\
    \ */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block\
    \ code (better have one) */\n            if (state->lens[256] == 0) {\n      \
    \          strm->msg = (char *)\"invalid code -- missing end-of-block\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n\n  \
    \          /* build code tables -- note: do not change the lenbits or distbits\n\
    \               values here (9 and 6) without reading the comments in inftrees.h\n\
    \               concerning the ENOUGH constants, which depend on those values\
    \ */\n            state->next = state->codes;\n            state->lencode = (const\
    \ code FAR *)(state->next);\n            state->lenbits = 9;\n            ret\
    \ = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n          \
    \                      &(state->lenbits), state->work);\n            if (ret)\
    \ {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n  \
    \              state->mode = BAD;\n                break;\n            }\n   \
    \         state->distcode = (const code FAR *)(state->next);\n            state->distbits\
    \ = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n\
    \                            &(state->next), &(state->distbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid distances\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n     \
    \       state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n\
    \                /* fallthrough */\n        case LEN_:\n            state->mode\
    \ = LEN;\n                /* fallthrough */\n        case LEN:\n            if\
    \ (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm,\
    \ out);\n                LOAD();\n                if (state->mode == TYPE)\n \
    \                   state->back = -1;\n                break;\n            }\n\
    \            state->back = 0;\n            for (;;) {\n                here =\
    \ state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits)\
    \ <= bits) break;\n                PULLBYTE();\n            }\n            if\
    \ (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n       \
    \         for (;;) {\n                    here = state->lencode[last.val +\n \
    \                           (BITS(last.bits + last.op) >> last.bits)];\n     \
    \               if ((unsigned)(last.bits + here.bits) <= bits) break;\n      \
    \              PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            state->length = (unsigned)here.val;\n\
    \            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val\
    \ >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal\
    \ '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\"\
    , here.val));\n                state->mode = LIT;\n                break;\n  \
    \          }\n            if (here.op & 32) {\n                Tracevv((stderr,\
    \ \"inflate:         end of block\\n\"));\n                state->back = -1;\n\
    \                state->mode = TYPE;\n                break;\n            }\n\
    \            if (here.op & 64) {\n                strm->msg = (char *)\"invalid\
    \ literal/length code\";\n                state->mode = BAD;\n               \
    \ break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n\
    \            state->mode = LENEXT;\n                /* fallthrough */\n      \
    \  case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n\
    \                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n            Tracevv((stderr,\
    \ \"inflate:         length %u\\n\", state->length));\n            state->was\
    \ = state->length;\n            state->mode = DIST;\n                /* fallthrough\
    \ */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n\
    \                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n\
    \            }\n            if ((here.op & 0xf0) == 0) {\n                last\
    \ = here;\n                for (;;) {\n                    here = state->distcode[last.val\
    \ +\n                            (BITS(last.bits + last.op) >> last.bits)];\n\
    \                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n \
    \                   PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            if (here.op & 64) {\n    \
    \            strm->msg = (char *)\"invalid distance code\";\n                state->mode\
    \ = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n\
    \            state->extra = (unsigned)(here.op) & 15;\n            state->mode\
    \ = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n     \
    \       if (state->extra) {\n                NEEDBITS(state->extra);\n       \
    \         state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n\
    \            if (state->offset > state->dmax) {\n                strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                state->mode = BAD;\n \
    \               break;\n            }\n#endif\n            Tracevv((stderr, \"\
    inflate:         distance %u\\n\", state->offset));\n            state->mode =\
    \ MATCH;\n                /* fallthrough */\n        case MATCH:\n           \
    \ if (left == 0) goto inf_leave;\n            copy = out - left;\n           \
    \ if (state->offset > copy) {         /* copy from window */\n               \
    \ copy = state->offset - copy;\n                if (copy > state->whave) {\n \
    \                   if (state->sane) {\n                        strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                        state->mode =\
    \ BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\
    \                    Trace((stderr, \"inflate.c too far\\n\"));\n            \
    \        copy -= state->whave;\n                    if (copy > state->length)\
    \ copy = state->length;\n                    if (copy > left) copy = left;\n \
    \                   left -= copy;\n                    state->length -= copy;\n\
    \                    do {\n                        *put++ = 0;\n             \
    \       } while (--copy);\n                    if (state->length == 0) state->mode\
    \ = LEN;\n                    break;\n#endif\n                }\n            \
    \    if (copy > state->wnext) {\n                    copy -= state->wnext;\n \
    \                   from = state->window + (state->wsize - copy);\n          \
    \      }\n                else\n                    from = state->window + (state->wnext\
    \ - copy);\n                if (copy > state->length) copy = state->length;\n\
    \            }\n            else {                              /* copy from output\
    \ */\n                from = put - state->offset;\n                copy = state->length;\n\
    \            }\n            if (copy > left) copy = left;\n            left -=\
    \ copy;\n            state->length -= copy;\n            do {\n              \
    \  *put++ = *from++;\n            } while (--copy);\n            if (state->length\
    \ == 0) state->mode = LEN;\n            break;\n        case LIT:\n          \
    \  if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n\
    \            left--;\n            state->mode = LEN;\n            break;\n   \
    \     case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n\
    \                out -= left;\n                strm->total_out += out;\n     \
    \           state->total += out;\n                if ((state->wrap & 4) && out)\n\
    \                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check,\
    \ put - out, out);\n                out = left;\n                if ((state->wrap\
    \ & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n\
    \                     ZSWAP32(hold)) != state->check) {\n                    strm->msg\
    \ = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\
    \            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n           \
    \     /* fallthrough */\n        case LENGTH:\n            if (state->wrap &&\
    \ state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap\
    \ & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg\
    \ = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\
    \            }\n#endif\n            state->mode = DONE;\n                /* fallthrough\
    \ */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\
    \        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\
    \        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n    \
    \            /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n\
    \        }\n\n    /*\n       Return from inflate(), updating the total counts\
    \ and the check value.\n       If there was no progress during the inflate() call,\
    \ return a buffer\n       error.  Call updatewindow() to create and/or update\
    \ the window state.\n       Note: a memory error from inflate() is non-recoverable.\n\
    \     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out\
    \ && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n\
    \        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n  \
    \          state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n  \
    \  in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n\
    \    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap &\
    \ 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check,\
    \ strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last\
    \ ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n     \
    \                 (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n \
    \   if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n       \
    \ ret = Z_BUF_ERROR;\n    return ret;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nint ZEXPORT inflate(strm, flush)\nz_streamp\
    \ strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const unsigned\
    \ char FAR *next;    /* next input */\n    unsigned char FAR *put;     /* next\
    \ output */\n    unsigned have, left;        /* available input and output */\n\
    \    unsigned long hold;         /* bit buffer */\n    unsigned bits;        \
    \      /* bits in bit buffer */\n    unsigned in, out;           /* save starting\
    \ available input and output */\n    unsigned copy;              /* number of\
    \ stored or match bytes to copy */\n    unsigned char FAR *from;    /* where to\
    \ copy match bytes from */\n    code here;                  /* current decoding\
    \ table entry */\n    code last;                  /* parent table entry */\n \
    \   unsigned len;               /* length to copy for repeats, bits to drop */\n\
    \    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned\
    \ char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n  \
    \  static const unsigned short order[19] = /* permutation of code lengths */\n\
    \        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\
    \n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in\
    \ == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state\
    \ = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode\
    \ = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n\
    \    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n\
    \            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n\
    \                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n\
    \            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n \
    \               if (state->wbits == 0)\n                    state->wbits = 15;\n\
    \                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check,\
    \ hold);\n                INITBITS();\n                state->mode = FLAGS;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->done = -1;\n            if (!(state->wrap & 1) ||\
    \   /* check if zlib header allowed */\n#else\n            if (\n#endif\n    \
    \            ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg\
    \ = (char *)\"incorrect header check\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (BITS(4) != Z_DEFLATED)\
    \ {\n                strm->msg = (char *)\"unknown compression method\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n    \
    \        DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits\
    \ == 0)\n                state->wbits = len;\n            if (len > 15 || len\
    \ > state->wbits) {\n                strm->msg = (char *)\"invalid window size\"\
    ;\n                state->mode = BAD;\n                break;\n            }\n\
    \            state->dmax = 1U << len;\n            state->flags = 0;         \
    \      /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib\
    \ header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL,\
    \ 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n\
    \            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n\
    \            state->flags = (int)(hold);\n            if ((state->flags & 0xff)\
    \ != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression\
    \ method\";\n                state->mode = BAD;\n                break;\n    \
    \        }\n            if (state->flags & 0xe000) {\n                strm->msg\
    \ = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags\
    \ & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n\
    \            INITBITS();\n            state->mode = TIME;\n                /*\
    \ fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if\
    \ (state->head != Z_NULL)\n                state->head->time = hold;\n       \
    \     if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check,\
    \ hold);\n            INITBITS();\n            state->mode = OS;\n           \
    \     /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n       \
    \     if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold\
    \ & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n\
    \            if ((state->flags & 0x0200) && (state->wrap & 4))\n             \
    \   CRC2(state->check, hold);\n            INITBITS();\n            state->mode\
    \ = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n         \
    \   if (state->flags & 0x0400) {\n                NEEDBITS(16);\n            \
    \    state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n\
    \                    state->head->extra_len = (unsigned)hold;\n              \
    \  if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check,\
    \ hold);\n                INITBITS();\n            }\n            else if (state->head\
    \ != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode\
    \ = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n         \
    \   if (state->flags & 0x0400) {\n                copy = state->length;\n    \
    \            if (copy > have) copy = have;\n                if (copy) {\n    \
    \                if (state->head != Z_NULL &&\n                        state->head->extra\
    \ != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n\
    \                        zmemcpy(state->head->extra + len, next,\n           \
    \                     len + copy > state->head->extra_max ?\n                \
    \                state->head->extra_max - len : copy);\n                    }\n\
    \                    if ((state->flags & 0x0200) && (state->wrap & 4))\n     \
    \                   state->check = crc32(state->check, next, copy);\n        \
    \            have -= copy;\n                    next += copy;\n              \
    \      state->length -= copy;\n                }\n                if (state->length)\
    \ goto inf_leave;\n            }\n            state->length = 0;\n           \
    \ state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n\
    \            if (state->flags & 0x0800) {\n                if (have == 0) goto\
    \ inf_leave;\n                copy = 0;\n                do {\n              \
    \      len = (unsigned)(next[copy++]);\n                    if (state->head !=\
    \ Z_NULL &&\n                            state->head->name != Z_NULL &&\n    \
    \                        state->length < state->head->name_max)\n            \
    \            state->head->name[state->length++] = (Bytef)len;\n              \
    \  } while (len && copy < have);\n                if ((state->flags & 0x0200)\
    \ && (state->wrap & 4))\n                    state->check = crc32(state->check,\
    \ next, copy);\n                have -= copy;\n                next += copy;\n\
    \                if (len) goto inf_leave;\n            }\n            else if\
    \ (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n     \
    \       state->length = 0;\n            state->mode = COMMENT;\n             \
    \   /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000)\
    \ {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n\
    \                do {\n                    len = (unsigned)(next[copy++]);\n \
    \                   if (state->head != Z_NULL &&\n                           \
    \ state->head->comment != Z_NULL &&\n                            state->length\
    \ < state->head->comm_max)\n                        state->head->comment[state->length++]\
    \ = (Bytef)len;\n                } while (len && copy < have);\n             \
    \   if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check\
    \ = crc32(state->check, next, copy);\n                have -= copy;\n        \
    \        next += copy;\n                if (len) goto inf_leave;\n           \
    \ }\n            else if (state->head != Z_NULL)\n                state->head->comment\
    \ = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n\
    \        case HCRC:\n            if (state->flags & 0x0200) {\n              \
    \  NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check\
    \ & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\"\
    ;\n                    state->mode = BAD;\n                    break;\n      \
    \          }\n                INITBITS();\n            }\n            if (state->head\
    \ != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9)\
    \ & 1);\n                state->head->done = 1;\n            }\n            strm->adler\
    \ = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \          break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n \
    \           strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n\
    \            state->mode = DICT;\n                /* fallthrough */\n        case\
    \ DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n\
    \                return Z_NEED_DICT;\n            }\n            strm->adler =\
    \ state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \              /* fallthrough */\n        case TYPE:\n            if (flush ==\
    \ Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough\
    \ */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n\
    \                state->mode = CHECK;\n                break;\n            }\n\
    \            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n\
    \            switch (BITS(2)) {\n            case 0:                         \
    \    /* stored block */\n                Tracev((stderr, \"inflate:     stored\
    \ block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n\
    \                state->mode = STORED;\n                break;\n            case\
    \ 1:                             /* fixed block */\n                fixedtables(state);\n\
    \                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n  \
    \                      state->last ? \" (last)\" : \"\"));\n                state->mode\
    \ = LEN_;             /* decode codes */\n                if (flush == Z_TREES)\
    \ {\n                    DROPBITS(2);\n                    goto inf_leave;\n \
    \               }\n                break;\n            case 2:               \
    \              /* dynamic block */\n                Tracev((stderr, \"inflate:\
    \     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\"\
    \ : \"\"));\n                state->mode = TABLE;\n                break;\n  \
    \          case 3:\n                strm->msg = (char *)\"invalid block type\"\
    ;\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n\
    \            break;\n        case STORED:\n            BYTEBITS();           \
    \              /* go to byte boundary */\n            NEEDBITS(32);\n        \
    \    if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg\
    \ = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            state->length = (unsigned)hold\
    \ & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\"\
    ,\n                    state->length));\n            INITBITS();\n           \
    \ state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n  \
    \              /* fallthrough */\n        case COPY_:\n            state->mode\
    \ = COPY;\n                /* fallthrough */\n        case COPY:\n           \
    \ copy = state->length;\n            if (copy) {\n                if (copy > have)\
    \ copy = have;\n                if (copy > left) copy = left;\n              \
    \  if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n\
    \                have -= copy;\n                next += copy;\n              \
    \  left -= copy;\n                put += copy;\n                state->length\
    \ -= copy;\n                break;\n            }\n            Tracev((stderr,\
    \ \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n     \
    \       break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen\
    \ = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5)\
    \ + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n  \
    \          DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen\
    \ > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many\
    \ length or distance symbols\";\n                state->mode = BAD;\n        \
    \        break;\n            }\n#endif\n            Tracev((stderr, \"inflate:\
    \       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode\
    \ = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n     \
    \       while (state->have < state->ncode) {\n                NEEDBITS(3);\n \
    \               state->lens[order[state->have++]] = (unsigned short)BITS(3);\n\
    \                DROPBITS(3);\n            }\n            while (state->have <\
    \ 19)\n                state->lens[order[state->have++]] = 0;\n            state->next\
    \ = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n\
    \            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens,\
    \ 19, &(state->next),\n                                &(state->lenbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid code lengths\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\
    \            state->have = 0;\n            state->mode = CODELENS;\n         \
    \       /* fallthrough */\n        case CODELENS:\n            while (state->have\
    \ < state->nlen + state->ndist) {\n                for (;;) {\n              \
    \      here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits)\
    \ <= bits) break;\n                    PULLBYTE();\n                }\n      \
    \          if (here.val < 16) {\n                    DROPBITS(here.bits);\n  \
    \                  state->lens[state->have++] = here.val;\n                }\n\
    \                else {\n                    if (here.val == 16) {\n         \
    \               NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n\
    \                        if (state->have == 0) {\n                           \
    \ strm->msg = (char *)\"invalid bit length repeat\";\n                       \
    \     state->mode = BAD;\n                            break;\n               \
    \         }\n                        len = state->lens[state->have - 1];\n   \
    \                     copy = 3 + BITS(2);\n                        DROPBITS(2);\n\
    \                    }\n                    else if (here.val == 17) {\n     \
    \                   NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n\
    \                        len = 0;\n                        copy = 3 + BITS(3);\n\
    \                        DROPBITS(3);\n                    }\n               \
    \     else {\n                        NEEDBITS(here.bits + 7);\n             \
    \           DROPBITS(here.bits);\n                        len = 0;\n         \
    \               copy = 11 + BITS(7);\n                        DROPBITS(7);\n \
    \                   }\n                    if (state->have + copy > state->nlen\
    \ + state->ndist) {\n                        strm->msg = (char *)\"invalid bit\
    \ length repeat\";\n                        state->mode = BAD;\n             \
    \           break;\n                    }\n                    while (copy--)\n\
    \                        state->lens[state->have++] = (unsigned short)len;\n \
    \               }\n            }\n\n            /* handle error breaks in while\
    \ */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block\
    \ code (better have one) */\n            if (state->lens[256] == 0) {\n      \
    \          strm->msg = (char *)\"invalid code -- missing end-of-block\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n\n  \
    \          /* build code tables -- note: do not change the lenbits or distbits\n\
    \               values here (9 and 6) without reading the comments in inftrees.h\n\
    \               concerning the ENOUGH constants, which depend on those values\
    \ */\n            state->next = state->codes;\n            state->lencode = (const\
    \ code FAR *)(state->next);\n            state->lenbits = 9;\n            ret\
    \ = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n          \
    \                      &(state->lenbits), state->work);\n            if (ret)\
    \ {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n  \
    \              state->mode = BAD;\n                break;\n            }\n   \
    \         state->distcode = (const code FAR *)(state->next);\n            state->distbits\
    \ = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n\
    \                            &(state->next), &(state->distbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid distances\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n     \
    \       state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n\
    \                /* fallthrough */\n        case LEN_:\n            state->mode\
    \ = LEN;\n                /* fallthrough */\n        case LEN:\n            if\
    \ (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm,\
    \ out);\n                LOAD();\n                if (state->mode == TYPE)\n \
    \                   state->back = -1;\n                break;\n            }\n\
    \            state->back = 0;\n            for (;;) {\n                here =\
    \ state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits)\
    \ <= bits) break;\n                PULLBYTE();\n            }\n            if\
    \ (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n       \
    \         for (;;) {\n                    here = state->lencode[last.val +\n \
    \                           (BITS(last.bits + last.op) >> last.bits)];\n     \
    \               if ((unsigned)(last.bits + here.bits) <= bits) break;\n      \
    \              PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            state->length = (unsigned)here.val;\n\
    \            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val\
    \ >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal\
    \ '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\"\
    , here.val));\n                state->mode = LIT;\n                break;\n  \
    \          }\n            if (here.op & 32) {\n                Tracevv((stderr,\
    \ \"inflate:         end of block\\n\"));\n                state->back = -1;\n\
    \                state->mode = TYPE;\n                break;\n            }\n\
    \            if (here.op & 64) {\n                strm->msg = (char *)\"invalid\
    \ literal/length code\";\n                state->mode = BAD;\n               \
    \ break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n\
    \            state->mode = LENEXT;\n                /* fallthrough */\n      \
    \  case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n\
    \                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n            Tracevv((stderr,\
    \ \"inflate:         length %u\\n\", state->length));\n            state->was\
    \ = state->length;\n            state->mode = DIST;\n                /* fallthrough\
    \ */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n\
    \                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n\
    \            }\n            if ((here.op & 0xf0) == 0) {\n                last\
    \ = here;\n                for (;;) {\n                    here = state->distcode[last.val\
    \ +\n                            (BITS(last.bits + last.op) >> last.bits)];\n\
    \                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n \
    \                   PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            if (here.op & 64) {\n    \
    \            strm->msg = (char *)\"invalid distance code\";\n                state->mode\
    \ = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n\
    \            state->extra = (unsigned)(here.op) & 15;\n            state->mode\
    \ = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n     \
    \       if (state->extra) {\n                NEEDBITS(state->extra);\n       \
    \         state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n\
    \            if (state->offset > state->dmax) {\n                strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                state->mode = BAD;\n \
    \               break;\n            }\n#endif\n            Tracevv((stderr, \"\
    inflate:         distance %u\\n\", state->offset));\n            state->mode =\
    \ MATCH;\n                /* fallthrough */\n        case MATCH:\n           \
    \ if (left == 0) goto inf_leave;\n            copy = out - left;\n           \
    \ if (state->offset > copy) {         /* copy from window */\n               \
    \ copy = state->offset - copy;\n                if (copy > state->whave) {\n \
    \                   if (state->sane) {\n                        strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                        state->mode =\
    \ BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\
    \                    Trace((stderr, \"inflate.c too far\\n\"));\n            \
    \        copy -= state->whave;\n                    if (copy > state->length)\
    \ copy = state->length;\n                    if (copy > left) copy = left;\n \
    \                   left -= copy;\n                    state->length -= copy;\n\
    \                    do {\n                        *put++ = 0;\n             \
    \       } while (--copy);\n                    if (state->length == 0) state->mode\
    \ = LEN;\n                    break;\n#endif\n                }\n            \
    \    if (copy > state->wnext) {\n                    copy -= state->wnext;\n \
    \                   from = state->window + (state->wsize - copy);\n          \
    \      }\n                else\n                    from = state->window + (state->wnext\
    \ - copy);\n                if (copy > state->length) copy = state->length;\n\
    \            }\n            else {                              /* copy from output\
    \ */\n                from = put - state->offset;\n                copy = state->length;\n\
    \            }\n            if (copy > left) copy = left;\n            left -=\
    \ copy;\n            state->length -= copy;\n            do {\n              \
    \  *put++ = *from++;\n            } while (--copy);\n            if (state->length\
    \ == 0) state->mode = LEN;\n            break;\n        case LIT:\n          \
    \  if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n\
    \            left--;\n            state->mode = LEN;\n            break;\n   \
    \     case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n\
    \                out -= left;\n                strm->total_out += out;\n     \
    \           state->total += out;\n                if ((state->wrap & 4) && out)\n\
    \                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check,\
    \ put - out, out);\n                out = left;\n                if ((state->wrap\
    \ & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n\
    \                     ZSWAP32(hold)) != state->check) {\n                    strm->msg\
    \ = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\
    \            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n           \
    \     /* fallthrough */\n        case LENGTH:\n            if (state->wrap &&\
    \ state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap\
    \ & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg\
    \ = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\
    \            }\n#endif\n            state->mode = DONE;\n                /* fallthrough\
    \ */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\
    \        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\
    \        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n    \
    \            /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n\
    \        }\n\n    /*\n       Return from inflate(), updating the total counts\
    \ and the check value.\n       If there was no progress during the inflate() call,\
    \ return a buffer\n       error.  Call updatewindow() to create and/or update\
    \ the window state.\n       Note: a memory error from inflate() is non-recoverable.\n\
    \     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out\
    \ && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n\
    \        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n  \
    \          state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n  \
    \  in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n\
    \    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap &\
    \ 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check,\
    \ strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last\
    \ ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n     \
    \                 (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n \
    \   if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n       \
    \ ret = Z_BUF_ERROR;\n    return ret;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-3.5-turbo
    model: gpt-3.5-turbo
    model_type: gpt-3.5-turbo
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nint ZEXPORT inflate(strm, flush)\n\
    z_streamp strm;\nint flush;\n{\n    struct inflate_state FAR *state;\n    z_const\
    \ unsigned char FAR *next;    /* next input */\n    unsigned char FAR *put;  \
    \   /* next output */\n    unsigned have, left;        /* available input and\
    \ output */\n    unsigned long hold;         /* bit buffer */\n    unsigned bits;\
    \              /* bits in bit buffer */\n    unsigned in, out;           /* save\
    \ starting available input and output */\n    unsigned copy;              /* number\
    \ of stored or match bytes to copy */\n    unsigned char FAR *from;    /* where\
    \ to copy match bytes from */\n    code here;                  /* current decoding\
    \ table entry */\n    code last;                  /* parent table entry */\n \
    \   unsigned len;               /* length to copy for repeats, bits to drop */\n\
    \    int ret;                    /* return code */\n#ifdef GUNZIP\n    unsigned\
    \ char hbuf[4];      /* buffer for gzip header crc calculation */\n#endif\n  \
    \  static const unsigned short order[19] = /* permutation of code lengths */\n\
    \        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\
    \n    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||\n        (strm->next_in\
    \ == Z_NULL && strm->avail_in != 0))\n        return Z_STREAM_ERROR;\n\n    state\
    \ = (struct inflate_state FAR *)strm->state;\n    if (state->mode == TYPE) state->mode\
    \ = TYPEDO;      /* skip check */\n    LOAD();\n    in = have;\n    out = left;\n\
    \    ret = Z_OK;\n    for (;;)\n        switch (state->mode) {\n        case HEAD:\n\
    \            if (state->wrap == 0) {\n                state->mode = TYPEDO;\n\
    \                break;\n            }\n            NEEDBITS(16);\n#ifdef GUNZIP\n\
    \            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */\n \
    \               if (state->wbits == 0)\n                    state->wbits = 15;\n\
    \                state->check = crc32(0L, Z_NULL, 0);\n                CRC2(state->check,\
    \ hold);\n                INITBITS();\n                state->mode = FLAGS;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->done = -1;\n            if (!(state->wrap & 1) ||\
    \   /* check if zlib header allowed */\n#else\n            if (\n#endif\n    \
    \            ((BITS(8) << 8) + (hold >> 8)) % 31) {\n                strm->msg\
    \ = (char *)\"incorrect header check\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (BITS(4) != Z_DEFLATED)\
    \ {\n                strm->msg = (char *)\"unknown compression method\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n    \
    \        DROPBITS(4);\n            len = BITS(4) + 8;\n            if (state->wbits\
    \ == 0)\n                state->wbits = len;\n            if (len > 15 || len\
    \ > state->wbits) {\n                strm->msg = (char *)\"invalid window size\"\
    ;\n                state->mode = BAD;\n                break;\n            }\n\
    \            state->dmax = 1U << len;\n            state->flags = 0;         \
    \      /* indicate zlib header */\n            Tracev((stderr, \"inflate:   zlib\
    \ header ok\\n\"));\n            strm->adler = state->check = adler32(0L, Z_NULL,\
    \ 0);\n            state->mode = hold & 0x200 ? DICTID : TYPE;\n            INITBITS();\n\
    \            break;\n#ifdef GUNZIP\n        case FLAGS:\n            NEEDBITS(16);\n\
    \            state->flags = (int)(hold);\n            if ((state->flags & 0xff)\
    \ != Z_DEFLATED) {\n                strm->msg = (char *)\"unknown compression\
    \ method\";\n                state->mode = BAD;\n                break;\n    \
    \        }\n            if (state->flags & 0xe000) {\n                strm->msg\
    \ = (char *)\"unknown header flags set\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            if (state->head != Z_NULL)\n\
    \                state->head->text = (int)((hold >> 8) & 1);\n            if ((state->flags\
    \ & 0x0200) && (state->wrap & 4))\n                CRC2(state->check, hold);\n\
    \            INITBITS();\n            state->mode = TIME;\n                /*\
    \ fallthrough */\n        case TIME:\n            NEEDBITS(32);\n            if\
    \ (state->head != Z_NULL)\n                state->head->time = hold;\n       \
    \     if ((state->flags & 0x0200) && (state->wrap & 4))\n                CRC4(state->check,\
    \ hold);\n            INITBITS();\n            state->mode = OS;\n           \
    \     /* fallthrough */\n        case OS:\n            NEEDBITS(16);\n       \
    \     if (state->head != Z_NULL) {\n                state->head->xflags = (int)(hold\
    \ & 0xff);\n                state->head->os = (int)(hold >> 8);\n            }\n\
    \            if ((state->flags & 0x0200) && (state->wrap & 4))\n             \
    \   CRC2(state->check, hold);\n            INITBITS();\n            state->mode\
    \ = EXLEN;\n                /* fallthrough */\n        case EXLEN:\n         \
    \   if (state->flags & 0x0400) {\n                NEEDBITS(16);\n            \
    \    state->length = (unsigned)(hold);\n                if (state->head != Z_NULL)\n\
    \                    state->head->extra_len = (unsigned)hold;\n              \
    \  if ((state->flags & 0x0200) && (state->wrap & 4))\n                    CRC2(state->check,\
    \ hold);\n                INITBITS();\n            }\n            else if (state->head\
    \ != Z_NULL)\n                state->head->extra = Z_NULL;\n            state->mode\
    \ = EXTRA;\n                /* fallthrough */\n        case EXTRA:\n         \
    \   if (state->flags & 0x0400) {\n                copy = state->length;\n    \
    \            if (copy > have) copy = have;\n                if (copy) {\n    \
    \                if (state->head != Z_NULL &&\n                        state->head->extra\
    \ != Z_NULL) {\n                        len = state->head->extra_len - state->length;\n\
    \                        zmemcpy(state->head->extra + len, next,\n           \
    \                     len + copy > state->head->extra_max ?\n                \
    \                state->head->extra_max - len : copy);\n                    }\n\
    \                    if ((state->flags & 0x0200) && (state->wrap & 4))\n     \
    \                   state->check = crc32(state->check, next, copy);\n        \
    \            have -= copy;\n                    next += copy;\n              \
    \      state->length -= copy;\n                }\n                if (state->length)\
    \ goto inf_leave;\n            }\n            state->length = 0;\n           \
    \ state->mode = NAME;\n                /* fallthrough */\n        case NAME:\n\
    \            if (state->flags & 0x0800) {\n                if (have == 0) goto\
    \ inf_leave;\n                copy = 0;\n                do {\n              \
    \      len = (unsigned)(next[copy++]);\n                    if (state->head !=\
    \ Z_NULL &&\n                            state->head->name != Z_NULL &&\n    \
    \                        state->length < state->head->name_max)\n            \
    \            state->head->name[state->length++] = (Bytef)len;\n              \
    \  } while (len && copy < have);\n                if ((state->flags & 0x0200)\
    \ && (state->wrap & 4))\n                    state->check = crc32(state->check,\
    \ next, copy);\n                have -= copy;\n                next += copy;\n\
    \                if (len) goto inf_leave;\n            }\n            else if\
    \ (state->head != Z_NULL)\n                state->head->name = Z_NULL;\n     \
    \       state->length = 0;\n            state->mode = COMMENT;\n             \
    \   /* fallthrough */\n        case COMMENT:\n            if (state->flags & 0x1000)\
    \ {\n                if (have == 0) goto inf_leave;\n                copy = 0;\n\
    \                do {\n                    len = (unsigned)(next[copy++]);\n \
    \                   if (state->head != Z_NULL &&\n                           \
    \ state->head->comment != Z_NULL &&\n                            state->length\
    \ < state->head->comm_max)\n                        state->head->comment[state->length++]\
    \ = (Bytef)len;\n                } while (len && copy < have);\n             \
    \   if ((state->flags & 0x0200) && (state->wrap & 4))\n                    state->check\
    \ = crc32(state->check, next, copy);\n                have -= copy;\n        \
    \        next += copy;\n                if (len) goto inf_leave;\n           \
    \ }\n            else if (state->head != Z_NULL)\n                state->head->comment\
    \ = Z_NULL;\n            state->mode = HCRC;\n                /* fallthrough */\n\
    \        case HCRC:\n            if (state->flags & 0x0200) {\n              \
    \  NEEDBITS(16);\n                if ((state->wrap & 4) && hold != (state->check\
    \ & 0xffff)) {\n                    strm->msg = (char *)\"header crc mismatch\"\
    ;\n                    state->mode = BAD;\n                    break;\n      \
    \          }\n                INITBITS();\n            }\n            if (state->head\
    \ != Z_NULL) {\n                state->head->hcrc = (int)((state->flags >> 9)\
    \ & 1);\n                state->head->done = 1;\n            }\n            strm->adler\
    \ = state->check = crc32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \          break;\n#endif\n        case DICTID:\n            NEEDBITS(32);\n \
    \           strm->adler = state->check = ZSWAP32(hold);\n            INITBITS();\n\
    \            state->mode = DICT;\n                /* fallthrough */\n        case\
    \ DICT:\n            if (state->havedict == 0) {\n                RESTORE();\n\
    \                return Z_NEED_DICT;\n            }\n            strm->adler =\
    \ state->check = adler32(0L, Z_NULL, 0);\n            state->mode = TYPE;\n  \
    \              /* fallthrough */\n        case TYPE:\n            if (flush ==\
    \ Z_BLOCK || flush == Z_TREES) goto inf_leave;\n                /* fallthrough\
    \ */\n        case TYPEDO:\n            if (state->last) {\n                BYTEBITS();\n\
    \                state->mode = CHECK;\n                break;\n            }\n\
    \            NEEDBITS(3);\n            state->last = BITS(1);\n            DROPBITS(1);\n\
    \            switch (BITS(2)) {\n            case 0:                         \
    \    /* stored block */\n                Tracev((stderr, \"inflate:     stored\
    \ block%s\\n\",\n                        state->last ? \" (last)\" : \"\"));\n\
    \                state->mode = STORED;\n                break;\n            case\
    \ 1:                             /* fixed block */\n                fixedtables(state);\n\
    \                Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n  \
    \                      state->last ? \" (last)\" : \"\"));\n                state->mode\
    \ = LEN_;             /* decode codes */\n                if (flush == Z_TREES)\
    \ {\n                    DROPBITS(2);\n                    goto inf_leave;\n \
    \               }\n                break;\n            case 2:               \
    \              /* dynamic block */\n                Tracev((stderr, \"inflate:\
    \     dynamic codes block%s\\n\",\n                        state->last ? \" (last)\"\
    \ : \"\"));\n                state->mode = TABLE;\n                break;\n  \
    \          case 3:\n                strm->msg = (char *)\"invalid block type\"\
    ;\n                state->mode = BAD;\n            }\n            DROPBITS(2);\n\
    \            break;\n        case STORED:\n            BYTEBITS();           \
    \              /* go to byte boundary */\n            NEEDBITS(32);\n        \
    \    if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {\n                strm->msg\
    \ = (char *)\"invalid stored block lengths\";\n                state->mode = BAD;\n\
    \                break;\n            }\n            state->length = (unsigned)hold\
    \ & 0xffff;\n            Tracev((stderr, \"inflate:       stored length %u\\n\"\
    ,\n                    state->length));\n            INITBITS();\n           \
    \ state->mode = COPY_;\n            if (flush == Z_TREES) goto inf_leave;\n  \
    \              /* fallthrough */\n        case COPY_:\n            state->mode\
    \ = COPY;\n                /* fallthrough */\n        case COPY:\n           \
    \ copy = state->length;\n            if (copy) {\n                if (copy > have)\
    \ copy = have;\n                if (copy > left) copy = left;\n              \
    \  if (copy == 0) goto inf_leave;\n                zmemcpy(put, next, copy);\n\
    \                have -= copy;\n                next += copy;\n              \
    \  left -= copy;\n                put += copy;\n                state->length\
    \ -= copy;\n                break;\n            }\n            Tracev((stderr,\
    \ \"inflate:       stored end\\n\"));\n            state->mode = TYPE;\n     \
    \       break;\n        case TABLE:\n            NEEDBITS(14);\n            state->nlen\
    \ = BITS(5) + 257;\n            DROPBITS(5);\n            state->ndist = BITS(5)\
    \ + 1;\n            DROPBITS(5);\n            state->ncode = BITS(4) + 4;\n  \
    \          DROPBITS(4);\n#ifndef PKZIP_BUG_WORKAROUND\n            if (state->nlen\
    \ > 286 || state->ndist > 30) {\n                strm->msg = (char *)\"too many\
    \ length or distance symbols\";\n                state->mode = BAD;\n        \
    \        break;\n            }\n#endif\n            Tracev((stderr, \"inflate:\
    \       table sizes ok\\n\"));\n            state->have = 0;\n            state->mode\
    \ = LENLENS;\n                /* fallthrough */\n        case LENLENS:\n     \
    \       while (state->have < state->ncode) {\n                NEEDBITS(3);\n \
    \               state->lens[order[state->have++]] = (unsigned short)BITS(3);\n\
    \                DROPBITS(3);\n            }\n            while (state->have <\
    \ 19)\n                state->lens[order[state->have++]] = 0;\n            state->next\
    \ = state->codes;\n            state->lencode = (const code FAR *)(state->next);\n\
    \            state->lenbits = 7;\n            ret = inflate_table(CODES, state->lens,\
    \ 19, &(state->next),\n                                &(state->lenbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid code lengths\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\
    \            state->have = 0;\n            state->mode = CODELENS;\n         \
    \       /* fallthrough */\n        case CODELENS:\n            while (state->have\
    \ < state->nlen + state->ndist) {\n                for (;;) {\n              \
    \      here = state->lencode[BITS(state->lenbits)];\n                    if ((unsigned)(here.bits)\
    \ <= bits) break;\n                    PULLBYTE();\n                }\n      \
    \          if (here.val < 16) {\n                    DROPBITS(here.bits);\n  \
    \                  state->lens[state->have++] = here.val;\n                }\n\
    \                else {\n                    if (here.val == 16) {\n         \
    \               NEEDBITS(here.bits + 2);\n                        DROPBITS(here.bits);\n\
    \                        if (state->have == 0) {\n                           \
    \ strm->msg = (char *)\"invalid bit length repeat\";\n                       \
    \     state->mode = BAD;\n                            break;\n               \
    \         }\n                        len = state->lens[state->have - 1];\n   \
    \                     copy = 3 + BITS(2);\n                        DROPBITS(2);\n\
    \                    }\n                    else if (here.val == 17) {\n     \
    \                   NEEDBITS(here.bits + 3);\n                        DROPBITS(here.bits);\n\
    \                        len = 0;\n                        copy = 3 + BITS(3);\n\
    \                        DROPBITS(3);\n                    }\n               \
    \     else {\n                        NEEDBITS(here.bits + 7);\n             \
    \           DROPBITS(here.bits);\n                        len = 0;\n         \
    \               copy = 11 + BITS(7);\n                        DROPBITS(7);\n \
    \                   }\n                    if (state->have + copy > state->nlen\
    \ + state->ndist) {\n                        strm->msg = (char *)\"invalid bit\
    \ length repeat\";\n                        state->mode = BAD;\n             \
    \           break;\n                    }\n                    while (copy--)\n\
    \                        state->lens[state->have++] = (unsigned short)len;\n \
    \               }\n            }\n\n            /* handle error breaks in while\
    \ */\n            if (state->mode == BAD) break;\n\n            /* check for end-of-block\
    \ code (better have one) */\n            if (state->lens[256] == 0) {\n      \
    \          strm->msg = (char *)\"invalid code -- missing end-of-block\";\n   \
    \             state->mode = BAD;\n                break;\n            }\n\n  \
    \          /* build code tables -- note: do not change the lenbits or distbits\n\
    \               values here (9 and 6) without reading the comments in inftrees.h\n\
    \               concerning the ENOUGH constants, which depend on those values\
    \ */\n            state->next = state->codes;\n            state->lencode = (const\
    \ code FAR *)(state->next);\n            state->lenbits = 9;\n            ret\
    \ = inflate_table(LENS, state->lens, state->nlen, &(state->next),\n          \
    \                      &(state->lenbits), state->work);\n            if (ret)\
    \ {\n                strm->msg = (char *)\"invalid literal/lengths set\";\n  \
    \              state->mode = BAD;\n                break;\n            }\n   \
    \         state->distcode = (const code FAR *)(state->next);\n            state->distbits\
    \ = 6;\n            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,\n\
    \                            &(state->next), &(state->distbits), state->work);\n\
    \            if (ret) {\n                strm->msg = (char *)\"invalid distances\
    \ set\";\n                state->mode = BAD;\n                break;\n       \
    \     }\n            Tracev((stderr, \"inflate:       codes ok\\n\"));\n     \
    \       state->mode = LEN_;\n            if (flush == Z_TREES) goto inf_leave;\n\
    \                /* fallthrough */\n        case LEN_:\n            state->mode\
    \ = LEN;\n                /* fallthrough */\n        case LEN:\n            if\
    \ (have >= 6 && left >= 258) {\n                RESTORE();\n                inflate_fast(strm,\
    \ out);\n                LOAD();\n                if (state->mode == TYPE)\n \
    \                   state->back = -1;\n                break;\n            }\n\
    \            state->back = 0;\n            for (;;) {\n                here =\
    \ state->lencode[BITS(state->lenbits)];\n                if ((unsigned)(here.bits)\
    \ <= bits) break;\n                PULLBYTE();\n            }\n            if\
    \ (here.op && (here.op & 0xf0) == 0) {\n                last = here;\n       \
    \         for (;;) {\n                    here = state->lencode[last.val +\n \
    \                           (BITS(last.bits + last.op) >> last.bits)];\n     \
    \               if ((unsigned)(last.bits + here.bits) <= bits) break;\n      \
    \              PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            state->length = (unsigned)here.val;\n\
    \            if ((int)(here.op) == 0) {\n                Tracevv((stderr, here.val\
    \ >= 0x20 && here.val < 0x7f ?\n                        \"inflate:         literal\
    \ '%c'\\n\" :\n                        \"inflate:         literal 0x%02x\\n\"\
    , here.val));\n                state->mode = LIT;\n                break;\n  \
    \          }\n            if (here.op & 32) {\n                Tracevv((stderr,\
    \ \"inflate:         end of block\\n\"));\n                state->back = -1;\n\
    \                state->mode = TYPE;\n                break;\n            }\n\
    \            if (here.op & 64) {\n                strm->msg = (char *)\"invalid\
    \ literal/length code\";\n                state->mode = BAD;\n               \
    \ break;\n            }\n            state->extra = (unsigned)(here.op) & 15;\n\
    \            state->mode = LENEXT;\n                /* fallthrough */\n      \
    \  case LENEXT:\n            if (state->extra) {\n                NEEDBITS(state->extra);\n\
    \                state->length += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n            Tracevv((stderr,\
    \ \"inflate:         length %u\\n\", state->length));\n            state->was\
    \ = state->length;\n            state->mode = DIST;\n                /* fallthrough\
    \ */\n        case DIST:\n            for (;;) {\n                here = state->distcode[BITS(state->distbits)];\n\
    \                if ((unsigned)(here.bits) <= bits) break;\n                PULLBYTE();\n\
    \            }\n            if ((here.op & 0xf0) == 0) {\n                last\
    \ = here;\n                for (;;) {\n                    here = state->distcode[last.val\
    \ +\n                            (BITS(last.bits + last.op) >> last.bits)];\n\
    \                    if ((unsigned)(last.bits + here.bits) <= bits) break;\n \
    \                   PULLBYTE();\n                }\n                DROPBITS(last.bits);\n\
    \                state->back += last.bits;\n            }\n            DROPBITS(here.bits);\n\
    \            state->back += here.bits;\n            if (here.op & 64) {\n    \
    \            strm->msg = (char *)\"invalid distance code\";\n                state->mode\
    \ = BAD;\n                break;\n            }\n            state->offset = (unsigned)here.val;\n\
    \            state->extra = (unsigned)(here.op) & 15;\n            state->mode\
    \ = DISTEXT;\n                /* fallthrough */\n        case DISTEXT:\n     \
    \       if (state->extra) {\n                NEEDBITS(state->extra);\n       \
    \         state->offset += BITS(state->extra);\n                DROPBITS(state->extra);\n\
    \                state->back += state->extra;\n            }\n#ifdef INFLATE_STRICT\n\
    \            if (state->offset > state->dmax) {\n                strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                state->mode = BAD;\n \
    \               break;\n            }\n#endif\n            Tracevv((stderr, \"\
    inflate:         distance %u\\n\", state->offset));\n            state->mode =\
    \ MATCH;\n                /* fallthrough */\n        case MATCH:\n           \
    \ if (left == 0) goto inf_leave;\n            copy = out - left;\n           \
    \ if (state->offset > copy) {         /* copy from window */\n               \
    \ copy = state->offset - copy;\n                if (copy > state->whave) {\n \
    \                   if (state->sane) {\n                        strm->msg = (char\
    \ *)\"invalid distance too far back\";\n                        state->mode =\
    \ BAD;\n                        break;\n                    }\n#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\
    \                    Trace((stderr, \"inflate.c too far\\n\"));\n            \
    \        copy -= state->whave;\n                    if (copy > state->length)\
    \ copy = state->length;\n                    if (copy > left) copy = left;\n \
    \                   left -= copy;\n                    state->length -= copy;\n\
    \                    do {\n                        *put++ = 0;\n             \
    \       } while (--copy);\n                    if (state->length == 0) state->mode\
    \ = LEN;\n                    break;\n#endif\n                }\n            \
    \    if (copy > state->wnext) {\n                    copy -= state->wnext;\n \
    \                   from = state->window + (state->wsize - copy);\n          \
    \      }\n                else\n                    from = state->window + (state->wnext\
    \ - copy);\n                if (copy > state->length) copy = state->length;\n\
    \            }\n            else {                              /* copy from output\
    \ */\n                from = put - state->offset;\n                copy = state->length;\n\
    \            }\n            if (copy > left) copy = left;\n            left -=\
    \ copy;\n            state->length -= copy;\n            do {\n              \
    \  *put++ = *from++;\n            } while (--copy);\n            if (state->length\
    \ == 0) state->mode = LEN;\n            break;\n        case LIT:\n          \
    \  if (left == 0) goto inf_leave;\n            *put++ = (unsigned char)(state->length);\n\
    \            left--;\n            state->mode = LEN;\n            break;\n   \
    \     case CHECK:\n            if (state->wrap) {\n                NEEDBITS(32);\n\
    \                out -= left;\n                strm->total_out += out;\n     \
    \           state->total += out;\n                if ((state->wrap & 4) && out)\n\
    \                    strm->adler = state->check =\n                        UPDATE_CHECK(state->check,\
    \ put - out, out);\n                out = left;\n                if ((state->wrap\
    \ & 4) && (\n#ifdef GUNZIP\n                     state->flags ? hold :\n#endif\n\
    \                     ZSWAP32(hold)) != state->check) {\n                    strm->msg\
    \ = (char *)\"incorrect data check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\
    \            }\n#ifdef GUNZIP\n            state->mode = LENGTH;\n           \
    \     /* fallthrough */\n        case LENGTH:\n            if (state->wrap &&\
    \ state->flags) {\n                NEEDBITS(32);\n                if ((state->wrap\
    \ & 4) && hold != (state->total & 0xffffffff)) {\n                    strm->msg\
    \ = (char *)\"incorrect length check\";\n                    state->mode = BAD;\n\
    \                    break;\n                }\n                INITBITS();\n\
    \                Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\
    \            }\n#endif\n            state->mode = DONE;\n                /* fallthrough\
    \ */\n        case DONE:\n            ret = Z_STREAM_END;\n            goto inf_leave;\n\
    \        case BAD:\n            ret = Z_DATA_ERROR;\n            goto inf_leave;\n\
    \        case MEM:\n            return Z_MEM_ERROR;\n        case SYNC:\n    \
    \            /* fallthrough */\n        default:\n            return Z_STREAM_ERROR;\n\
    \        }\n\n    /*\n       Return from inflate(), updating the total counts\
    \ and the check value.\n       If there was no progress during the inflate() call,\
    \ return a buffer\n       error.  Call updatewindow() to create and/or update\
    \ the window state.\n       Note: a memory error from inflate() is non-recoverable.\n\
    \     */\n  inf_leave:\n    RESTORE();\n    if (state->wsize || (out != strm->avail_out\
    \ && state->mode < BAD &&\n            (state->mode < CHECK || flush != Z_FINISH)))\n\
    \        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {\n  \
    \          state->mode = MEM;\n            return Z_MEM_ERROR;\n        }\n  \
    \  in -= strm->avail_in;\n    out -= strm->avail_out;\n    strm->total_in += in;\n\
    \    strm->total_out += out;\n    state->total += out;\n    if ((state->wrap &\
    \ 4) && out)\n        strm->adler = state->check =\n            UPDATE_CHECK(state->check,\
    \ strm->next_out - out, out);\n    strm->data_type = (int)state->bits + (state->last\
    \ ? 64 : 0) +\n                      (state->mode == TYPE ? 128 : 0) +\n     \
    \                 (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);\n \
    \   if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)\n       \
    \ ret = Z_BUF_ERROR;\n    return ret;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 211506
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
