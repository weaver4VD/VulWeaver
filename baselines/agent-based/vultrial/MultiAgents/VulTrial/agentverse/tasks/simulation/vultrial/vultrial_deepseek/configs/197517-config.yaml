agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id,\
    \ size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned\
    \ char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash,\
    \ size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error\
    \ = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig\
    \ = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t\
    \ pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat,\
    \ data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32],\
    \ cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len\
    \ = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL)\
    \ {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n\
    \        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n \
    \       break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL ||\
    \ !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error,\
    \ json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n\
    \      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n\
    \        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char\
    \ *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key))))\
    \ {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if\
    \ (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"\
    sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n\
    \          } else {\n            message = msprintf(\"attStmt map element %d key\
    \ is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n\
    \            json_array_append_new(j_error, json_string(message));\n         \
    \   o_free(message);\n            break;\n          }\n        } else {\n    \
    \      message = msprintf(\"attStmt map element %d key is not a string\", i);\n\
    \          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n\
    \          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c)\
    \ || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"\
    CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert\
    \ = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n\
    \      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert,\
    \ &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n\
    \        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\"\
    ) != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK)\
    \ {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate\
    \ authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by)\
    \ >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority:\
    \ %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n\
    \          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to\
    \ get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey,\
    \ cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error\
    \ importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"\
    check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n  \
    \      break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256,\
    \ cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n\
    \        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len,\
    \ cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n     \
    \   break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data,\
    \ o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n\
    \        json_array_append_new(j_error, json_string(\"Internal error\"));\n  \
    \      y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw\
    \ client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig))\
    \ {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"\
    ));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n\
    \      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n   \
    \   \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n\
    \      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n\
    \      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n\
    \      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n \
    \     data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n    \
    \  // Let's verify sig over data_signed\n      data.data = data_signed;\n    \
    \  data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n\
    \      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey,\
    \ GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n  \
    \  \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\"\
    , \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return\
    \ = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64,\
    \ cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n\
    \    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n\
    \    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f\
    \ - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\"\
    , \"result\", G_ERROR);\n  }\n  return j_return;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nstatic json_t * check_attestation_fido_u2f(json_t\
    \ * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned\
    \ char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len,\
    \ cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const\
    \ unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n\
    \  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n\
    \  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n \
    \ gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature,\
    \ cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32],\
    \ cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len\
    \ = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL)\
    \ {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n\
    \        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n \
    \       break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL ||\
    \ !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error,\
    \ json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n\
    \      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n\
    \        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char\
    \ *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key))))\
    \ {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if\
    \ (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"\
    sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n\
    \          } else {\n            message = msprintf(\"attStmt map element %d key\
    \ is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n\
    \            json_array_append_new(j_error, json_string(message));\n         \
    \   o_free(message);\n            break;\n          }\n        } else {\n    \
    \      message = msprintf(\"attStmt map element %d key is not a string\", i);\n\
    \          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n\
    \          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c)\
    \ || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"\
    CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert\
    \ = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n\
    \      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert,\
    \ &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n\
    \        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\"\
    ) != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK)\
    \ {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate\
    \ authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by)\
    \ >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority:\
    \ %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n\
    \          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to\
    \ get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey,\
    \ cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error\
    \ importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"\
    check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n  \
    \      break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256,\
    \ cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n\
    \        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len,\
    \ cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n     \
    \   break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data,\
    \ o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n\
    \        json_array_append_new(j_error, json_string(\"Internal error\"));\n  \
    \      y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw\
    \ client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig))\
    \ {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"\
    ));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n\
    \      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n   \
    \   \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n\
    \      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n\
    \      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n\
    \      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n \
    \     data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n    \
    \  // Let's verify sig over data_signed\n      data.data = data_signed;\n    \
    \  data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n\
    \      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey,\
    \ GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n  \
    \  \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\"\
    , \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return\
    \ = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64,\
    \ cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n\
    \    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n\
    \    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f\
    \ - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\"\
    , \"result\", G_ERROR);\n  }\n  return j_return;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nstatic json_t * check_attestation_fido_u2f(json_t * j_params, unsigned\
    \ char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t\
    \ cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt,\
    \ unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data)\
    \ {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL,\
    \ * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message\
    \ = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n\
    \  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char\
    \ data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n\
    \  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len =\
    \ 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n     \
    \ if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"\
    check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n\
    \      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n \
    \       break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL ||\
    \ !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error,\
    \ json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n\
    \      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n\
    \        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char\
    \ *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key))))\
    \ {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if\
    \ (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"\
    sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n\
    \          } else {\n            message = msprintf(\"attStmt map element %d key\
    \ is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n\
    \            json_array_append_new(j_error, json_string(message));\n         \
    \   o_free(message);\n            break;\n          }\n        } else {\n    \
    \      message = msprintf(\"attStmt map element %d key is not a string\", i);\n\
    \          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n\
    \          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c)\
    \ || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"\
    CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert\
    \ = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n\
    \      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert,\
    \ &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n\
    \        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\"\
    ) != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK)\
    \ {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate\
    \ authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by)\
    \ >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority:\
    \ %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n\
    \          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to\
    \ get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey,\
    \ cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error\
    \ importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"\
    check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n  \
    \      break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256,\
    \ cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n\
    \        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len,\
    \ cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n     \
    \   break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data,\
    \ o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n\
    \        json_array_append_new(j_error, json_string(\"Internal error\"));\n  \
    \      y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw\
    \ client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig))\
    \ {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"\
    ));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n\
    \      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n   \
    \   \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n\
    \      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n\
    \      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n\
    \      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n \
    \     data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n    \
    \  // Let's verify sig over data_signed\n      data.data = data_signed;\n    \
    \  data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n\
    \      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey,\
    \ GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n  \
    \  \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\"\
    , \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return\
    \ = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64,\
    \ cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n\
    \    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n\
    \    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f\
    \ - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\"\
    , \"result\", G_ERROR);\n  }\n  return j_return;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nstatic json_t * check_attestation_fido_u2f(json_t\
    \ * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned\
    \ char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len,\
    \ cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const\
    \ unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n\
    \  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n\
    \  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n \
    \ gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature,\
    \ cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32],\
    \ cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len\
    \ = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL)\
    \ {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n\
    \        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error,\
    \ json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n \
    \       break;\n      }\n      \n      // Step 1\n      if (att_stmt == NULL ||\
    \ !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {\n        json_array_append_new(j_error,\
    \ json_string(\"CBOR map value 'attStmt' invalid format\"));\n        break;\n\
    \      }\n      for (i=0; i<2; i++) {\n        key = cbor_map_handle(att_stmt)[i].key;\n\
    \        if (cbor_isa_string(key)) {\n          if (0 == o_strncmp((const char\
    \ *)cbor_string_handle(key), \"x5c\", MIN(o_strlen(\"x5c\"), cbor_string_length(key))))\
    \ {\n            x5c = cbor_map_handle(att_stmt)[i].value;\n          } else if\
    \ (0 == o_strncmp((const char *)cbor_string_handle(key), \"sig\", MIN(o_strlen(\"\
    sig\"), cbor_string_length(key)))) {\n            sig = cbor_map_handle(att_stmt)[i].value;\n\
    \          } else {\n            message = msprintf(\"attStmt map element %d key\
    \ is not valid: '%.*s'\", i, cbor_string_length(key), cbor_string_handle(key));\n\
    \            json_array_append_new(j_error, json_string(message));\n         \
    \   o_free(message);\n            break;\n          }\n        } else {\n    \
    \      message = msprintf(\"attStmt map element %d key is not a string\", i);\n\
    \          json_array_append_new(j_error, json_string(message));\n          o_free(message);\n\
    \          break;\n        }\n      }\n      if (x5c == NULL || !cbor_isa_array(x5c)\
    \ || cbor_array_size(x5c) != 1) {\n        json_array_append_new(j_error, json_string(\"\
    CBOR map value 'x5c' invalid format\"));\n        break;\n      }\n      att_cert\
    \ = cbor_array_get(x5c, 0);\n      cert_dat.data = cbor_bytestring_handle(att_cert);\n\
    \      cert_dat.size = cbor_bytestring_length(att_cert);\n      if ((ret = gnutls_x509_crt_import(cert,\
    \ &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d\", ret);\n\
    \        break;\n      }\n      if (json_object_get(j_params, \"root-ca-list\"\
    ) != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK)\
    \ {\n        json_array_append_new(j_error, json_string(\"Unrecognized certificate\
    \ authority\"));\n        if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by)\
    \ >= 0) {\n          message = msprintf(\"Unrecognized certificate autohority:\
    \ %.*s\", cert_issued_by.size, cert_issued_by.data);\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - %s\", message);\n          o_free(message);\n\
    \          gnutls_free(cert_issued_by.data);\n        } else {\n          y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Unrecognized certificate autohority (unable to\
    \ get issuer dn)\");\n        }\n        break;\n      }\n      if ((ret = gnutls_pubkey_import_x509(pubkey,\
    \ cert, 0)) < 0) {\n        json_array_append_new(j_error, json_string(\"Error\
    \ importing x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"\
    check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d\", ret);\n  \
    \      break;\n      }\n      if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256,\
    \ cert_export, &cert_export_len)) < 0) {\n        json_array_append_new(j_error,\
    \ json_string(\"Error exporting x509 certificate\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d\", ret);\n\
    \        break;\n      }\n      if (!o_base64_encode(cert_export, cert_export_len,\
    \ cert_export_b64, &cert_export_b64_len)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_DEBUG,\
    \ \"check_attestation_fido_u2f - Error o_base64_encode cert_export\");\n     \
    \   break;\n      }\n      if (!generate_digest_raw(digest_SHA256, client_data,\
    \ o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n\
    \        json_array_append_new(j_error, json_string(\"Internal error\"));\n  \
    \      y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw\
    \ client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig))\
    \ {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"\
    ));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n\
    \      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n   \
    \   \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n\
    \      data_signed_offset+=client_data_hash_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ credential_id, credential_id_len);\n      data_signed_offset+=credential_id_len;\n\
    \      \n      data_signed[data_signed_offset] = 0x04;\n      data_signed_offset++;\n\
    \      \n      memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);\n \
    \     data_signed_offset+=cert_x_len;\n      \n      memcpy(data_signed+data_signed_offset,\
    \ cert_y, cert_y_len);\n      data_signed_offset+=cert_y_len;\n        \n    \
    \  // Let's verify sig over data_signed\n      data.data = data_signed;\n    \
    \  data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n\
    \      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey,\
    \ GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error,\
    \ json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n  \
    \  \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\"\
    , \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return\
    \ = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64,\
    \ cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n\
    \    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {\n      cbor_decref(&att_cert);\n\
    \    }\n    \n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f\
    \ - Error allocating resources for j_error\");\n    j_return = json_pack(\"{si}\"\
    , \"result\", G_ERROR);\n  }\n  return j_return;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 197517
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
