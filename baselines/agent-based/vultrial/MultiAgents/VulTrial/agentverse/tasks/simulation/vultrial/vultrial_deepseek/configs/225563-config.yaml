agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\n  void\
    \ Compute(OpKernelContext* context) override {\n    typedef Eigen::Map<const Eigen::Matrix<T,\
    \ Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef\
    \ Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        EigenMatrixMap;\n\
    \n    constexpr int tensor_in_and_out_dims = 4;\n\n    const Tensor& tensor_in\
    \ = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,\n\
    \                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n\
    \n    std::vector<int> input_size(tensor_in_and_out_dims);\n    std::vector<int>\
    \ output_size(tensor_in_and_out_dims);\n    for (int i = 0; i < tensor_in_and_out_dims;\
    \ ++i) {\n      input_size[i] = tensor_in.dim_size(i);\n\n      OP_REQUIRES(\n\
    \          context, input_size[i] >= pooling_ratio_[i],\n          errors::InvalidArgument(\"\
    Pooling ratio is higher than input \"\n                                  \"dimension\
    \ size for dimension \",\n                                  i, \". Input dim size:\
    \ \", input_size[i],\n                                  \" pooling ratio: \",\
    \ pooling_ratio_[i]));\n    }\n    // Output size.\n    for (int i = 0; i < tensor_in_and_out_dims;\
    \ ++i) {\n      // This must match the same logic in the shape function in\n \
    \     // core/ops/nn_ops.cc.\n      output_size[i] =\n          static_cast<int>(std::floor(input_size[i]\
    \ / pooling_ratio_[i]));\n      DCHECK_GT(output_size[i], 0);\n    }\n\n    //\
    \ Generate pooling sequence.\n    std::vector<int64_t> height_cum_seq;\n    std::vector<int64_t>\
    \ width_cum_seq;\n    GuardedPhiloxRandom generator;\n    generator.Init(seed_,\
    \ seed2_);\n    height_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n\
    \                                             &generator, pseudo_random_);\n \
    \   width_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n \
    \                                           &generator, pseudo_random_);\n\n \
    \   // Prepare output.\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\
    \ context->allocate_output(\n                                0,\n            \
    \                    TensorShape({output_size[0], output_size[1],\n          \
    \                                   output_size[2], output_size[3]}),\n      \
    \                          &output_tensor));\n    Tensor* output_height_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            1, TensorShape({static_cast<int64_t>(height_cum_seq.size())}),\n\
    \            &output_height_seq_tensor));\n    Tensor* output_width_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            2, TensorShape({static_cast<int64_t>(width_cum_seq.size())}),\n \
    \           &output_width_seq_tensor));\n\n    ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(),\
    \ input_size[3],\n                               input_size[2] * input_size[1]\
    \ * input_size[0]);\n\n    EigenMatrixMap out_mat(output_tensor->flat<T>().data(),\
    \ output_size[3],\n                           output_size[2] * output_size[1]\
    \ * output_size[0]);\n\n    // Initializes the output tensor with MIN<T>.\n  \
    \  output_tensor->flat<T>().setConstant(Eigen::NumTraits<T>::lowest());\n\n  \
    \  auto output_height_seq_flat = output_height_seq_tensor->flat<int64_t>();\n\
    \    auto output_width_seq_flat = output_width_seq_tensor->flat<int64_t>();\n\n\
    \    // Set output tensors.\n    for (int i = 0; i < height_cum_seq.size(); ++i)\
    \ {\n      output_height_seq_flat(i) = height_cum_seq[i];\n    }\n\n    for (int\
    \ i = 0; i < width_cum_seq.size(); ++i) {\n      output_width_seq_flat(i) = width_cum_seq[i];\n\
    \    }\n\n    // For both input and output,\n    // 0: batch\n    // 1: height\
    \ / row\n    // 2: width / col\n    // 3: depth / channel\n    const int64_t height_max\
    \ = input_size[1] - 1;\n    const int64_t width_max = input_size[2] - 1;\n   \
    \ for (int64_t b = 0; b < input_size[0]; ++b) {\n      // height sequence.\n \
    \     for (int64_t hs = 0; hs < height_cum_seq.size() - 1; ++hs) {\n        //\
    \ height start and end.\n        const int64_t height_start = height_cum_seq[hs];\n\
    \        int64_t height_end =\n            overlapping_ ? height_cum_seq[hs +\
    \ 1] : height_cum_seq[hs + 1] - 1;\n        height_end = std::min(height_end,\
    \ height_max);\n\n        // width sequence.\n        for (int64_t ws = 0; ws\
    \ < width_cum_seq.size() - 1; ++ws) {\n          const int64_t out_offset =\n\
    \              (b * output_size[1] + hs) * output_size[2] + ws;\n          //\
    \ width start and end.\n          const int64_t width_start = width_cum_seq[ws];\n\
    \          int64_t width_end =\n              overlapping_ ? width_cum_seq[ws\
    \ + 1] : width_cum_seq[ws + 1] - 1;\n          width_end = std::min(width_end,\
    \ width_max);\n          for (int64_t h = height_start; h <= height_end; ++h)\
    \ {\n            for (int64_t w = width_start; w <= width_end; ++w) {\n      \
    \        const int64_t in_offset =\n                  (b * input_size[1] + h)\
    \ * input_size[2] + w;\n              out_mat.col(out_offset) =\n            \
    \      out_mat.col(out_offset).cwiseMax(in_mat.col(in_offset));\n            }\n\
    \          }\n        }\n      }\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\n  void Compute(OpKernelContext*\
    \ context) override {\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic,\
    \ Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<T,\
    \ Eigen::Dynamic, Eigen::Dynamic>>\n        EigenMatrixMap;\n\n    constexpr int\
    \ tensor_in_and_out_dims = 4;\n\n    const Tensor& tensor_in = context->input(0);\n\
    \    OP_REQUIRES(context, tensor_in.dims() == tensor_in_and_out_dims,\n      \
    \          errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n\n\
    \    std::vector<int> input_size(tensor_in_and_out_dims);\n    std::vector<int>\
    \ output_size(tensor_in_and_out_dims);\n    for (int i = 0; i < tensor_in_and_out_dims;\
    \ ++i) {\n      input_size[i] = tensor_in.dim_size(i);\n\n      OP_REQUIRES(\n\
    \          context, input_size[i] >= pooling_ratio_[i],\n          errors::InvalidArgument(\"\
    Pooling ratio is higher than input \"\n                                  \"dimension\
    \ size for dimension \",\n                                  i, \". Input dim size:\
    \ \", input_size[i],\n                                  \" pooling ratio: \",\
    \ pooling_ratio_[i]));\n    }\n    // Output size.\n    for (int i = 0; i < tensor_in_and_out_dims;\
    \ ++i) {\n      // This must match the same logic in the shape function in\n \
    \     // core/ops/nn_ops.cc.\n      output_size[i] =\n          static_cast<int>(std::floor(input_size[i]\
    \ / pooling_ratio_[i]));\n      DCHECK_GT(output_size[i], 0);\n    }\n\n    //\
    \ Generate pooling sequence.\n    std::vector<int64_t> height_cum_seq;\n    std::vector<int64_t>\
    \ width_cum_seq;\n    GuardedPhiloxRandom generator;\n    generator.Init(seed_,\
    \ seed2_);\n    height_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n\
    \                                             &generator, pseudo_random_);\n \
    \   width_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n \
    \                                           &generator, pseudo_random_);\n\n \
    \   // Prepare output.\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\
    \ context->allocate_output(\n                                0,\n            \
    \                    TensorShape({output_size[0], output_size[1],\n          \
    \                                   output_size[2], output_size[3]}),\n      \
    \                          &output_tensor));\n    Tensor* output_height_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            1, TensorShape({static_cast<int64_t>(height_cum_seq.size())}),\n\
    \            &output_height_seq_tensor));\n    Tensor* output_width_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            2, TensorShape({static_cast<int64_t>(width_cum_seq.size())}),\n \
    \           &output_width_seq_tensor));\n\n    ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(),\
    \ input_size[3],\n                               input_size[2] * input_size[1]\
    \ * input_size[0]);\n\n    EigenMatrixMap out_mat(output_tensor->flat<T>().data(),\
    \ output_size[3],\n                           output_size[2] * output_size[1]\
    \ * output_size[0]);\n\n    // Initializes the output tensor with MIN<T>.\n  \
    \  output_tensor->flat<T>().setConstant(Eigen::NumTraits<T>::lowest());\n\n  \
    \  auto output_height_seq_flat = output_height_seq_tensor->flat<int64_t>();\n\
    \    auto output_width_seq_flat = output_width_seq_tensor->flat<int64_t>();\n\n\
    \    // Set output tensors.\n    for (int i = 0; i < height_cum_seq.size(); ++i)\
    \ {\n      output_height_seq_flat(i) = height_cum_seq[i];\n    }\n\n    for (int\
    \ i = 0; i < width_cum_seq.size(); ++i) {\n      output_width_seq_flat(i) = width_cum_seq[i];\n\
    \    }\n\n    // For both input and output,\n    // 0: batch\n    // 1: height\
    \ / row\n    // 2: width / col\n    // 3: depth / channel\n    const int64_t height_max\
    \ = input_size[1] - 1;\n    const int64_t width_max = input_size[2] - 1;\n   \
    \ for (int64_t b = 0; b < input_size[0]; ++b) {\n      // height sequence.\n \
    \     for (int64_t hs = 0; hs < height_cum_seq.size() - 1; ++hs) {\n        //\
    \ height start and end.\n        const int64_t height_start = height_cum_seq[hs];\n\
    \        int64_t height_end =\n            overlapping_ ? height_cum_seq[hs +\
    \ 1] : height_cum_seq[hs + 1] - 1;\n        height_end = std::min(height_end,\
    \ height_max);\n\n        // width sequence.\n        for (int64_t ws = 0; ws\
    \ < width_cum_seq.size() - 1; ++ws) {\n          const int64_t out_offset =\n\
    \              (b * output_size[1] + hs) * output_size[2] + ws;\n          //\
    \ width start and end.\n          const int64_t width_start = width_cum_seq[ws];\n\
    \          int64_t width_end =\n              overlapping_ ? width_cum_seq[ws\
    \ + 1] : width_cum_seq[ws + 1] - 1;\n          width_end = std::min(width_end,\
    \ width_max);\n          for (int64_t h = height_start; h <= height_end; ++h)\
    \ {\n            for (int64_t w = width_start; w <= width_end; ++w) {\n      \
    \        const int64_t in_offset =\n                  (b * input_size[1] + h)\
    \ * input_size[2] + w;\n              out_mat.col(out_offset) =\n            \
    \      out_mat.col(out_offset).cwiseMax(in_mat.col(in_offset));\n            }\n\
    \          }\n        }\n      }\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\n  void Compute(OpKernelContext* context) override {\n    typedef Eigen::Map<const\
    \ Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n        ConstEigenMatrixMap;\n\
    \    typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n  \
    \      EigenMatrixMap;\n\n    constexpr int tensor_in_and_out_dims = 4;\n\n  \
    \  const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims()\
    \ == tensor_in_and_out_dims,\n                errors::InvalidArgument(\"tensor_in\
    \ must be 4-dimensional\"));\n\n    std::vector<int> input_size(tensor_in_and_out_dims);\n\
    \    std::vector<int> output_size(tensor_in_and_out_dims);\n    for (int i = 0;\
    \ i < tensor_in_and_out_dims; ++i) {\n      input_size[i] = tensor_in.dim_size(i);\n\
    \n      OP_REQUIRES(\n          context, input_size[i] >= pooling_ratio_[i],\n\
    \          errors::InvalidArgument(\"Pooling ratio is higher than input \"\n \
    \                                 \"dimension size for dimension \",\n       \
    \                           i, \". Input dim size: \", input_size[i],\n      \
    \                            \" pooling ratio: \", pooling_ratio_[i]));\n    }\n\
    \    // Output size.\n    for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n\
    \      // This must match the same logic in the shape function in\n      // core/ops/nn_ops.cc.\n\
    \      output_size[i] =\n          static_cast<int>(std::floor(input_size[i] /\
    \ pooling_ratio_[i]));\n      DCHECK_GT(output_size[i], 0);\n    }\n\n    // Generate\
    \ pooling sequence.\n    std::vector<int64_t> height_cum_seq;\n    std::vector<int64_t>\
    \ width_cum_seq;\n    GuardedPhiloxRandom generator;\n    generator.Init(seed_,\
    \ seed2_);\n    height_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n\
    \                                             &generator, pseudo_random_);\n \
    \   width_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n \
    \                                           &generator, pseudo_random_);\n\n \
    \   // Prepare output.\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\
    \ context->allocate_output(\n                                0,\n            \
    \                    TensorShape({output_size[0], output_size[1],\n          \
    \                                   output_size[2], output_size[3]}),\n      \
    \                          &output_tensor));\n    Tensor* output_height_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            1, TensorShape({static_cast<int64_t>(height_cum_seq.size())}),\n\
    \            &output_height_seq_tensor));\n    Tensor* output_width_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            2, TensorShape({static_cast<int64_t>(width_cum_seq.size())}),\n \
    \           &output_width_seq_tensor));\n\n    ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(),\
    \ input_size[3],\n                               input_size[2] * input_size[1]\
    \ * input_size[0]);\n\n    EigenMatrixMap out_mat(output_tensor->flat<T>().data(),\
    \ output_size[3],\n                           output_size[2] * output_size[1]\
    \ * output_size[0]);\n\n    // Initializes the output tensor with MIN<T>.\n  \
    \  output_tensor->flat<T>().setConstant(Eigen::NumTraits<T>::lowest());\n\n  \
    \  auto output_height_seq_flat = output_height_seq_tensor->flat<int64_t>();\n\
    \    auto output_width_seq_flat = output_width_seq_tensor->flat<int64_t>();\n\n\
    \    // Set output tensors.\n    for (int i = 0; i < height_cum_seq.size(); ++i)\
    \ {\n      output_height_seq_flat(i) = height_cum_seq[i];\n    }\n\n    for (int\
    \ i = 0; i < width_cum_seq.size(); ++i) {\n      output_width_seq_flat(i) = width_cum_seq[i];\n\
    \    }\n\n    // For both input and output,\n    // 0: batch\n    // 1: height\
    \ / row\n    // 2: width / col\n    // 3: depth / channel\n    const int64_t height_max\
    \ = input_size[1] - 1;\n    const int64_t width_max = input_size[2] - 1;\n   \
    \ for (int64_t b = 0; b < input_size[0]; ++b) {\n      // height sequence.\n \
    \     for (int64_t hs = 0; hs < height_cum_seq.size() - 1; ++hs) {\n        //\
    \ height start and end.\n        const int64_t height_start = height_cum_seq[hs];\n\
    \        int64_t height_end =\n            overlapping_ ? height_cum_seq[hs +\
    \ 1] : height_cum_seq[hs + 1] - 1;\n        height_end = std::min(height_end,\
    \ height_max);\n\n        // width sequence.\n        for (int64_t ws = 0; ws\
    \ < width_cum_seq.size() - 1; ++ws) {\n          const int64_t out_offset =\n\
    \              (b * output_size[1] + hs) * output_size[2] + ws;\n          //\
    \ width start and end.\n          const int64_t width_start = width_cum_seq[ws];\n\
    \          int64_t width_end =\n              overlapping_ ? width_cum_seq[ws\
    \ + 1] : width_cum_seq[ws + 1] - 1;\n          width_end = std::min(width_end,\
    \ width_max);\n          for (int64_t h = height_start; h <= height_end; ++h)\
    \ {\n            for (int64_t w = width_start; w <= width_end; ++w) {\n      \
    \        const int64_t in_offset =\n                  (b * input_size[1] + h)\
    \ * input_size[2] + w;\n              out_mat.col(out_offset) =\n            \
    \      out_mat.col(out_offset).cwiseMax(in_mat.col(in_offset));\n            }\n\
    \          }\n        }\n      }\n    }\n  }"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\n  void Compute(OpKernelContext* context)\
    \ override {\n    typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>\n\
    \        ConstEigenMatrixMap;\n    typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic,\
    \ Eigen::Dynamic>>\n        EigenMatrixMap;\n\n    constexpr int tensor_in_and_out_dims\
    \ = 4;\n\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context,\
    \ tensor_in.dims() == tensor_in_and_out_dims,\n                errors::InvalidArgument(\"\
    tensor_in must be 4-dimensional\"));\n\n    std::vector<int> input_size(tensor_in_and_out_dims);\n\
    \    std::vector<int> output_size(tensor_in_and_out_dims);\n    for (int i = 0;\
    \ i < tensor_in_and_out_dims; ++i) {\n      input_size[i] = tensor_in.dim_size(i);\n\
    \n      OP_REQUIRES(\n          context, input_size[i] >= pooling_ratio_[i],\n\
    \          errors::InvalidArgument(\"Pooling ratio is higher than input \"\n \
    \                                 \"dimension size for dimension \",\n       \
    \                           i, \". Input dim size: \", input_size[i],\n      \
    \                            \" pooling ratio: \", pooling_ratio_[i]));\n    }\n\
    \    // Output size.\n    for (int i = 0; i < tensor_in_and_out_dims; ++i) {\n\
    \      // This must match the same logic in the shape function in\n      // core/ops/nn_ops.cc.\n\
    \      output_size[i] =\n          static_cast<int>(std::floor(input_size[i] /\
    \ pooling_ratio_[i]));\n      DCHECK_GT(output_size[i], 0);\n    }\n\n    // Generate\
    \ pooling sequence.\n    std::vector<int64_t> height_cum_seq;\n    std::vector<int64_t>\
    \ width_cum_seq;\n    GuardedPhiloxRandom generator;\n    generator.Init(seed_,\
    \ seed2_);\n    height_cum_seq = GeneratePoolingSequence(input_size[1], output_size[1],\n\
    \                                             &generator, pseudo_random_);\n \
    \   width_cum_seq = GeneratePoolingSequence(input_size[2], output_size[2],\n \
    \                                           &generator, pseudo_random_);\n\n \
    \   // Prepare output.\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\
    \ context->allocate_output(\n                                0,\n            \
    \                    TensorShape({output_size[0], output_size[1],\n          \
    \                                   output_size[2], output_size[3]}),\n      \
    \                          &output_tensor));\n    Tensor* output_height_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            1, TensorShape({static_cast<int64_t>(height_cum_seq.size())}),\n\
    \            &output_height_seq_tensor));\n    Tensor* output_width_seq_tensor\
    \ = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n\
    \            2, TensorShape({static_cast<int64_t>(width_cum_seq.size())}),\n \
    \           &output_width_seq_tensor));\n\n    ConstEigenMatrixMap in_mat(tensor_in.flat<T>().data(),\
    \ input_size[3],\n                               input_size[2] * input_size[1]\
    \ * input_size[0]);\n\n    EigenMatrixMap out_mat(output_tensor->flat<T>().data(),\
    \ output_size[3],\n                           output_size[2] * output_size[1]\
    \ * output_size[0]);\n\n    // Initializes the output tensor with MIN<T>.\n  \
    \  output_tensor->flat<T>().setConstant(Eigen::NumTraits<T>::lowest());\n\n  \
    \  auto output_height_seq_flat = output_height_seq_tensor->flat<int64_t>();\n\
    \    auto output_width_seq_flat = output_width_seq_tensor->flat<int64_t>();\n\n\
    \    // Set output tensors.\n    for (int i = 0; i < height_cum_seq.size(); ++i)\
    \ {\n      output_height_seq_flat(i) = height_cum_seq[i];\n    }\n\n    for (int\
    \ i = 0; i < width_cum_seq.size(); ++i) {\n      output_width_seq_flat(i) = width_cum_seq[i];\n\
    \    }\n\n    // For both input and output,\n    // 0: batch\n    // 1: height\
    \ / row\n    // 2: width / col\n    // 3: depth / channel\n    const int64_t height_max\
    \ = input_size[1] - 1;\n    const int64_t width_max = input_size[2] - 1;\n   \
    \ for (int64_t b = 0; b < input_size[0]; ++b) {\n      // height sequence.\n \
    \     for (int64_t hs = 0; hs < height_cum_seq.size() - 1; ++hs) {\n        //\
    \ height start and end.\n        const int64_t height_start = height_cum_seq[hs];\n\
    \        int64_t height_end =\n            overlapping_ ? height_cum_seq[hs +\
    \ 1] : height_cum_seq[hs + 1] - 1;\n        height_end = std::min(height_end,\
    \ height_max);\n\n        // width sequence.\n        for (int64_t ws = 0; ws\
    \ < width_cum_seq.size() - 1; ++ws) {\n          const int64_t out_offset =\n\
    \              (b * output_size[1] + hs) * output_size[2] + ws;\n          //\
    \ width start and end.\n          const int64_t width_start = width_cum_seq[ws];\n\
    \          int64_t width_end =\n              overlapping_ ? width_cum_seq[ws\
    \ + 1] : width_cum_seq[ws + 1] - 1;\n          width_end = std::min(width_end,\
    \ width_max);\n          for (int64_t h = height_start; h <= height_end; ++h)\
    \ {\n            for (int64_t w = width_start; w <= width_end; ++w) {\n      \
    \        const int64_t in_offset =\n                  (b * input_size[1] + h)\
    \ * input_size[2] + w;\n              out_mat.col(out_offset) =\n            \
    \      out_mat.col(out_offset).cwiseMax(in_mat.col(in_offset));\n            }\n\
    \          }\n        }\n      }\n    }\n  }"
  verbose: true
environment:
  env_type: judge
  id_save: 225563
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
