agents:
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nspell_suggest(int\
    \ count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n\
    \    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\t\
    c;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\
    \tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen\
    \ = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\
    \n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell\
    \ = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\
    \treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected\
    \ text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum\
    \ != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen\
    \ = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen\
    \ = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\t\
    end_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n\
    \    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    ||\
    \ curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts\
    \ after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor =\
    \ prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\
    \t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p,\
    \ curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile\
    \ (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p,\
    \ curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\
    \tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and\
    \ its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap\
    \ = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make\
    \ a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n\
    \    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit\
    \ to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n\
    \    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit\
    \ = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug,\
    \ limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len ==\
    \ 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\t\
    if (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"),\
    \ (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t\
    // When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\
    \tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\
    \tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left\
    \ = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change\
    \ \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\
    \tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now\
    \ the rabbit from the high hat: Avoid showing the\n\t    // untranslated message\
    \ rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\"\
    ,\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\
    \tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0;\
    \ i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    //\
    \ The suggested word may replace only part of the bad word, add\n\t    // the\
    \ not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t   \
    \ if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\
    \t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen\
    \ - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i +\
    \ 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\
    \t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE,\
    \ \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word\
    \ may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\
    \t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\
    \t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t\
    \    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags\
    \ & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score,\
    \ stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\
    \t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff\
    \ + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\
    \t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\
    \tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\
    \tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid\
    \ more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n\
    \    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor()\
    \ == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\
    \tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen\
    \ > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the\
    \ remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\
    \t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\
    \t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen\
    \ or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace\
    \ the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\
    \tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p,\
    \ line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr\
    \ + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t  \
    \  ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p\
    \ + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\
    \n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p,\
    \ FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum,\
    \ c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\n\
    skip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nspell_suggest(int\
    \ count)\n{\n    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n\
    \    char_u\twcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\t\
    c;\n    suginfo_T\tsug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\
    \tneed_cap;\n    int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen\
    \ = 0;\n    int\t\tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\
    \n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell\
    \ = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\
    \treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected\
    \ text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum\
    \ != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen\
    \ = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen\
    \ = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\t\
    end_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n\
    \    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    ||\
    \ curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts\
    \ after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor =\
    \ prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\
    \t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p,\
    \ curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile\
    \ (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p,\
    \ curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\
    \tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and\
    \ its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap\
    \ = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make\
    \ a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n\
    \    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit\
    \ to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n\
    \    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit\
    \ = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug,\
    \ limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len ==\
    \ 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\t\
    if (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"),\
    \ (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t\
    // When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\
    \tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\
    \tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left\
    \ = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change\
    \ \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\
    \tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now\
    \ the rabbit from the high hat: Avoid showing the\n\t    // untranslated message\
    \ rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\"\
    ,\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\
    \tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0;\
    \ i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    //\
    \ The suggested word may replace only part of the bad word, add\n\t    // the\
    \ not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t   \
    \ if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\
    \t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen\
    \ - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i +\
    \ 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\
    \t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE,\
    \ \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word\
    \ may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\
    \t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\
    \t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t\
    \    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags\
    \ & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score,\
    \ stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\
    \t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff\
    \ + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\
    \t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\
    \tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\
    \tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid\
    \ more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n\
    \    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor()\
    \ == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\
    \tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen\
    \ > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the\
    \ remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\
    \t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\
    \t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen\
    \ or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace\
    \ the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\
    \tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p,\
    \ line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr\
    \ + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t  \
    \  ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p\
    \ + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\
    \n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p,\
    \ FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum,\
    \ c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\n\
    skip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nspell_suggest(int count)\n{\n    char_u\t\
    *line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\twcopy[MAXWLEN\
    \ + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\tsug;\n\
    \    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n    int\t\
    \tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\tmsg_scroll_save\
    \ = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\n    if (!curwin->w_p_spell)\n\
    \    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell = TRUE;\n    }\n\n \
    \   if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\
    \treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected\
    \ text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum\
    \ != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen\
    \ = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen\
    \ = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\t\
    end_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n\
    \    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    ||\
    \ curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts\
    \ after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor =\
    \ prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\
    \t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p,\
    \ curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile\
    \ (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p,\
    \ curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\
    \tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and\
    \ its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap\
    \ = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make\
    \ a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n\
    \    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit\
    \ to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n\
    \    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit\
    \ = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug,\
    \ limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len ==\
    \ 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\t\
    if (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"),\
    \ (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t\
    // When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\
    \tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\
    \tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left\
    \ = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change\
    \ \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\
    \tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now\
    \ the rabbit from the high hat: Avoid showing the\n\t    // untranslated message\
    \ rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\"\
    ,\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\
    \tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0;\
    \ i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    //\
    \ The suggested word may replace only part of the bad word, add\n\t    // the\
    \ not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t   \
    \ if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\
    \t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen\
    \ - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i +\
    \ 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\
    \t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE,\
    \ \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word\
    \ may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\
    \t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\
    \t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t\
    \    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags\
    \ & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score,\
    \ stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\
    \t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff\
    \ + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\
    \t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\
    \tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\
    \tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid\
    \ more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n\
    \    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor()\
    \ == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\
    \tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen\
    \ > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the\
    \ remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\
    \t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\
    \t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen\
    \ or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace\
    \ the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\
    \tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p,\
    \ line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr\
    \ + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t  \
    \  ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p\
    \ + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\
    \n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p,\
    \ FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum,\
    \ c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\n\
    skip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nspell_suggest(int count)\n{\n\
    \    char_u\t*line;\n    pos_T\tprev_cursor = curwin->w_cursor;\n    char_u\t\
    wcopy[MAXWLEN + 2];\n    char_u\t*p;\n    int\t\ti;\n    int\t\tc;\n    suginfo_T\t\
    sug;\n    suggest_T\t*stp;\n    int\t\tmouse_used;\n    int\t\tneed_cap;\n   \
    \ int\t\tlimit;\n    int\t\tselected = count;\n    int\t\tbadlen = 0;\n    int\t\
    \tmsg_scroll_save = msg_scroll;\n    int\t\two_spell_save = curwin->w_p_spell;\n\
    \n    if (!curwin->w_p_spell)\n    {\n\tdid_set_spelllang(curwin);\n\tcurwin->w_p_spell\
    \ = TRUE;\n    }\n\n    if (*curwin->w_s->b_p_spl == NUL)\n    {\n\temsg(_(e_spell_checking_is_not_possible));\n\
    \treturn;\n    }\n\n    if (VIsual_active)\n    {\n\t// Use the Visually selected\
    \ text as the bad word.  But reject\n\t// a multi-line selection.\n\tif (curwin->w_cursor.lnum\
    \ != VIsual.lnum)\n\t{\n\t    vim_beep(BO_SPELL);\n\t    return;\n\t}\n\tbadlen\
    \ = (int)curwin->w_cursor.col - (int)VIsual.col;\n\tif (badlen < 0)\n\t    badlen\
    \ = -badlen;\n\telse\n\t    curwin->w_cursor.col = VIsual.col;\n\t++badlen;\n\t\
    end_visual_mode();\n    }\n    // Find the start of the badly spelled word.\n\
    \    else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0\n\t    ||\
    \ curwin->w_cursor.col > prev_cursor.col)\n    {\n\t// No bad word or it starts\
    \ after the cursor: use the word under the\n\t// cursor.\n\tcurwin->w_cursor =\
    \ prev_cursor;\n\tline = ml_get_curline();\n\tp = line + curwin->w_cursor.col;\n\
    \t// Backup to before start of word.\n\twhile (p > line && spell_iswordp_nmw(p,\
    \ curwin))\n\t    MB_PTR_BACK(line, p);\n\t// Forward to start of word.\n\twhile\
    \ (*p != NUL && !spell_iswordp_nmw(p, curwin))\n\t    MB_PTR_ADV(p);\n\n\tif (!spell_iswordp_nmw(p,\
    \ curwin))\t\t// No word found.\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n\
    \tcurwin->w_cursor.col = (colnr_T)(p - line);\n    }\n\n    // Get the word and\
    \ its length.\n\n    // Figure out if the word should be capitalised.\n    need_cap\
    \ = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n    // Make\
    \ a copy of current line since autocommands may free the line.\n    line = vim_strsave(ml_get_curline());\n\
    \    if (line == NULL)\n\tgoto skip;\n\n    // Get the list of suggestions.  Limit\
    \ to 'lines' - 2 or the number in\n    // 'spellsuggest', whatever is smaller.\n\
    \    if (sps_limit > (int)Rows - 2)\n\tlimit = (int)Rows - 2;\n    else\n\tlimit\
    \ = sps_limit;\n    spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug,\
    \ limit,\n\t\t\t\t\t\t\tTRUE, need_cap, TRUE);\n\n    if (sug.su_ga.ga_len ==\
    \ 0)\n\tmsg(_(\"Sorry, no suggestions\"));\n    else if (count > 0)\n    {\n\t\
    if (count > sug.su_ga.ga_len)\n\t    smsg(_(\"Sorry, only %ld suggestions\"),\
    \ (long)sug.su_ga.ga_len);\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\t\
    // When 'rightleft' is set the list is drawn right-left.\n\tcmdmsg_rl = curwin->w_p_rl;\n\
    \tif (cmdmsg_rl)\n\t    msg_col = Columns - 1;\n#endif\n\n\t// List the suggestions.\n\
    \tmsg_start();\n\tmsg_row = Rows - 1;\t// for when 'cmdheight' > 1\n\tlines_left\
    \ = Rows;\t// avoid more prompt\n\tvim_snprintf((char *)IObuff, IOSIZE, _(\"Change\
    \ \\\"%.*s\\\" to:\"),\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n#ifdef FEAT_RIGHTLEFT\n\
    \tif (cmdmsg_rl && STRNCMP(IObuff, \"Change\", 6) == 0)\n\t{\n\t    // And now\
    \ the rabbit from the high hat: Avoid showing the\n\t    // untranslated message\
    \ rightleft.\n\t    vim_snprintf((char *)IObuff, IOSIZE, \":ot \\\"%.*s\\\" egnahC\"\
    ,\n\t\t\t\t\t\tsug.su_badlen, sug.su_badptr);\n\t}\n#endif\n\tmsg_puts((char *)IObuff);\n\
    \tmsg_clr_eos();\n\tmsg_putchar('\\n');\n\n\tmsg_scroll = TRUE;\n\tfor (i = 0;\
    \ i < sug.su_ga.ga_len; ++i)\n\t{\n\t    stp = &SUG(sug.su_ga, i);\n\n\t    //\
    \ The suggested word may replace only part of the bad word, add\n\t    // the\
    \ not replaced part.\n\t    vim_strncpy(wcopy, stp->st_word, MAXWLEN);\n\t   \
    \ if (sug.su_badlen > stp->st_orglen)\n\t\tvim_strncpy(wcopy + stp->st_wordlen,\n\
    \t\t\t\t\t       sug.su_badptr + stp->st_orglen,\n\t\t\t\t\t      sug.su_badlen\
    \ - stp->st_orglen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d\", i +\
    \ 1);\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\trl_mirror(IObuff);\n#endif\n\
    \t    msg_puts((char *)IObuff);\n\n\t    vim_snprintf((char *)IObuff, IOSIZE,\
    \ \" \\\"%s\\\"\", wcopy);\n\t    msg_puts((char *)IObuff);\n\n\t    // The word\
    \ may replace more than \"su_badlen\".\n\t    if (sug.su_badlen < stp->st_orglen)\n\
    \t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, _(\" < \\\"%.*s\\\"\"),\n\t\t\
    \t\t\t       stp->st_orglen, sug.su_badptr);\n\t\tmsg_puts((char *)IObuff);\n\t\
    \    }\n\n\t    if (p_verbose > 0)\n\t    {\n\t\t// Add the score.\n\t\tif (sps_flags\
    \ & (SPS_DOUBLE | SPS_BEST))\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%s%d - %d)\",\n\t\t\tstp->st_salscore ? \"s \" : \"\",\n\t\t\tstp->st_score,\
    \ stp->st_altscore);\n\t\telse\n\t\t    vim_snprintf((char *)IObuff, IOSIZE, \"\
    \ (%d)\",\n\t\t\t    stp->st_score);\n#ifdef FEAT_RIGHTLEFT\n\t\tif (cmdmsg_rl)\n\
    \t\t    // Mirror the numbers, but keep the leading space.\n\t\t    rl_mirror(IObuff\
    \ + 1);\n#endif\n\t\tmsg_advance(30);\n\t\tmsg_puts((char *)IObuff);\n\t    }\n\
    \t    msg_putchar('\\n');\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\tcmdmsg_rl = FALSE;\n\
    \tmsg_col = 0;\n#endif\n\t// Ask for choice.\n\tselected = prompt_for_number(&mouse_used);\n\
    \tif (mouse_used)\n\t    selected -= lines_left;\n\tlines_left = Rows;\t\t// avoid\
    \ more prompt\n\t// don't delay for 'smd' in normal_cmd()\n\tmsg_scroll = msg_scroll_save;\n\
    \    }\n\n    if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor()\
    \ == OK)\n    {\n\t// Save the from and to text for :spellrepall.\n\tVIM_CLEAR(repl_from);\n\
    \tVIM_CLEAR(repl_to);\n\n\tstp = &SUG(sug.su_ga, selected - 1);\n\tif (sug.su_badlen\
    \ > stp->st_orglen)\n\t{\n\t    // Replacing less than \"su_badlen\", append the\
    \ remainder to\n\t    // repl_to.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ sug.su_badlen);\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%s%.*s\", stp->st_word,\n\
    \t\t    sug.su_badlen - stp->st_orglen,\n\t\t\t\t\t      sug.su_badptr + stp->st_orglen);\n\
    \t    repl_to = vim_strsave(IObuff);\n\t}\n\telse\n\t{\n\t    // Replacing su_badlen\
    \ or more, use the whole word.\n\t    repl_from = vim_strnsave(sug.su_badptr,\
    \ stp->st_orglen);\n\t    repl_to = vim_strsave(stp->st_word);\n\t}\n\n\t// Replace\
    \ the word.\n\tp = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1);\n\
    \tif (p != NULL)\n\t{\n\t    c = (int)(sug.su_badptr - line);\n\t    mch_memmove(p,\
    \ line, c);\n\t    STRCPY(p + c, stp->st_word);\n\t    STRCAT(p, sug.su_badptr\
    \ + stp->st_orglen);\n\n\t    // For redo we use a change-word command.\n\t  \
    \  ResetRedobuff();\n\t    AppendToRedobuff((char_u *)\"ciw\");\n\t    AppendToRedobuffLit(p\
    \ + c,\n\t\t\t    stp->st_wordlen + sug.su_badlen - stp->st_orglen);\n\t    AppendCharToRedobuff(ESC);\n\
    \n\t    // \"p\" may be freed here\n\t    ml_replace(curwin->w_cursor.lnum, p,\
    \ FALSE);\n\t    curwin->w_cursor.col = c;\n\n\t    changed_bytes(curwin->w_cursor.lnum,\
    \ c);\n\t}\n    }\n    else\n\tcurwin->w_cursor = prev_cursor;\n\n    spell_find_cleanup(&sug);\n\
    skip:\n    vim_free(line);\n    curwin->w_p_spell = wo_spell_save;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 213515
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
