agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nparse_command_modifiers(\n\
    \texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t \
    \   skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start =\
    \ NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon =\
    \ FALSE;\n    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range\
    \ = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\
    \n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically\
    \ inserted Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\"\
    \ in Visual mode works without having to move the\n\t// range to after the modififiers.\
    \ The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then\
    \ put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start\
    \ = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more\
    \ command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile\
    \ (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if\
    \ (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\
    \t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd\
    \ == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie,\
    \ getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\
    \t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd\
    \ = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break; \
    \ // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif\
    \ (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at\
    \ a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd,\
    \ '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t\
    \    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\
    \t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\
    \t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod,\
    \ FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\
    \t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In\
    \ Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\
    \t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member\
    \ = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\
    \tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s);\
    \ ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n\
    \ != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\
    \t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3,\
    \ TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n\
    #endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\
    \tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4,\
    \ TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\
    \t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case\
    \ 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t\
    \    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\t\
    if (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags\
    \ |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\
    \n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u\
    \  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\
    \t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\
    \t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat#\
    \ cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script\
    \ || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if\
    \ (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\t\
    p = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\
    \t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\
    \t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\
    \t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t   \
    \ else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p,\
    \ &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL ||\
    \ *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\t\
    cmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\
    \t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\
    \t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\
    \t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\
    \t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case\
    \ 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t\
    \       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\
    \t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\"\
    , 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t\
    *errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\t\
    return FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t\
    \    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\
    \n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\
    \t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t\
    }\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\
    \t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd\
    \ == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but\
    \ not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t \
    \   cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case\
    \ 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\
    \t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t  \
    \  ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr\
    \ == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\
    \telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t\
    \    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\
    \t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\
    \t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\
    \tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\
    \n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t\
    {\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\
    \tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p,\
    \ eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\
    \t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\",\
    \ 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t  \
    \  // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose\
    \ = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose\
    \ = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\t\
    break;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\
    \t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\
    \t    // Since the modifiers have been parsed put the colon on top of the\n\t\
    \    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after\
    \ the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\
    \n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"\
    mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\
    \t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start,\
    \ len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\
    \tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -=\
    \ 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t\
    \    // No modifiers, move the pointer back.\n\t    // Special case: change empty\
    \ command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\"\
    ;\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\t\
    eap->cmd = (char_u *)\"+\";\n\n    return OK;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nparse_command_modifiers(\n\t\
    exarg_T\t    *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t   \
    \ skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n\
    \    int\t    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n\
    \    int\t    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\
    \n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n  \
    \  if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted\
    \ Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual\
    \ mode works without having to move the\n\t// range to after the modififiers.\
    \ The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then\
    \ put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start\
    \ = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more\
    \ command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile\
    \ (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if\
    \ (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\
    \t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd\
    \ == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie,\
    \ getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\
    \t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd\
    \ = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break; \
    \ // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif\
    \ (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at\
    \ a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd,\
    \ '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t\
    \    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\
    \t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\
    \t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod,\
    \ FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\
    \t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In\
    \ Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\
    \t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member\
    \ = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\
    \tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s);\
    \ ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n\
    \ != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\
    \t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3,\
    \ TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n\
    #endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\
    \tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4,\
    \ TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\
    \t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case\
    \ 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t\
    \    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\t\
    if (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags\
    \ |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\
    \n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u\
    \  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\
    \t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\
    \t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat#\
    \ cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script\
    \ || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if\
    \ (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\t\
    p = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\
    \t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\
    \t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\
    \t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t   \
    \ else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p,\
    \ &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL ||\
    \ *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\t\
    cmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\
    \t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\
    \t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\
    \t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\
    \t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case\
    \ 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t\
    \       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\
    \t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\"\
    , 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t\
    *errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\t\
    return FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t\
    \    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\
    \n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\
    \t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t\
    }\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\
    \t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd\
    \ == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but\
    \ not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t \
    \   cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case\
    \ 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\
    \t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t  \
    \  ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr\
    \ == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\
    \telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t\
    \    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\
    \t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\
    \t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\
    \tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\
    \n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t\
    {\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\
    \tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p,\
    \ eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\
    \t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\",\
    \ 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t  \
    \  // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose\
    \ = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose\
    \ = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\t\
    break;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\
    \t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\
    \t    // Since the modifiers have been parsed put the colon on top of the\n\t\
    \    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after\
    \ the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\
    \n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"\
    mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\
    \t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start,\
    \ len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\
    \tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -=\
    \ 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t\
    \    // No modifiers, move the pointer back.\n\t    // Special case: change empty\
    \ command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\"\
    ;\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\t\
    eap->cmd = (char_u *)\"+\";\n\n    return OK;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nparse_command_modifiers(\n\texarg_T\t    *eap,\n\tchar\t    **errormsg,\n\
    \tcmdmod_T    *cmod,\n\tint\t    skip_only)\n{\n    char_u  *orig_cmd = eap->cmd;\n\
    \    char_u  *cmd_start = NULL;\n    int\t    use_plus_cmd = FALSE;\n    int\t\
    \    starts_with_colon = FALSE;\n    int\t    vim9script = in_vim9script();\n\
    \    int\t    has_visual_range = FALSE;\n\n    CLEAR_POINTER(cmod);\n    cmod->cmod_flags\
    \ = sticky_cmdmod_flags;\n\n    if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n  \
    \  {\n\t// The automatically inserted Visual area range is skipped, so that\n\t\
    // typing \":cmdmod cmd\" in Visual mode works without having to move the\n\t\
    // range to after the modififiers. The command will be\n\t// \"'<,'>cmdmod cmd\"\
    , parse \"cmdmod cmd\" and then put back \"'<,'>\"\n\t// before \"cmd\" below.\n\
    \teap->cmd += 5;\n\tcmd_start = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\
    \n    // Repeat until no more command modifiers are found.\n    for (;;)\n   \
    \ {\n\tchar_u  *p;\n\n\twhile (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd\
    \ == ':')\n\t{\n\t    if (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t\
    \    ++eap->cmd;\n\t}\n\n\t// in ex mode, an empty command (after modifiers) works\
    \ like :+\n\tif (*eap->cmd == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline,\
    \ eap->cookie, getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie,\
    \ getexline))\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\
    {\n\t    use_plus_cmd = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\
    \t    break;  // no modifiers following\n\t}\n\n\t// ignore comment and empty\
    \ lines\n\tif (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment\
    \ ends at a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd,\
    \ '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t\
    \    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\
    \t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\
    \t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod,\
    \ FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\
    \t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In\
    \ Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\
    \t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member\
    \ = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\
    \tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s);\
    \ ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n\
    \ != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\
    \t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3,\
    \ TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n\
    #endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\
    \tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4,\
    \ TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\
    \t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case\
    \ 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t\
    \    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\t\
    if (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags\
    \ |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\
    \n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u\
    \  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\
    \t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\
    \t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat#\
    \ cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script\
    \ || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if\
    \ (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\t\
    p = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\
    \t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\
    \t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\
    \t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t   \
    \ else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p,\
    \ &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL ||\
    \ *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\t\
    cmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\
    \t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\
    \t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\
    \t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\
    \t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case\
    \ 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t\
    \       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\
    \t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\"\
    , 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t\
    *errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\t\
    return FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t\
    \    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\
    \n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\
    \t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t\
    }\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\
    \t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd\
    \ == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but\
    \ not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t \
    \   cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case\
    \ 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\
    \t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t  \
    \  ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr\
    \ == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\
    \telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t\
    \    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\
    \t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\
    \t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\
    \tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\
    \n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t\
    {\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\
    \tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p,\
    \ eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\
    \t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\",\
    \ 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t  \
    \  // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose\
    \ = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose\
    \ = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\t\
    break;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\
    \t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\
    \t    // Since the modifiers have been parsed put the colon on top of the\n\t\
    \    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after\
    \ the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\
    \n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"\
    mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\
    \t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start,\
    \ len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\
    \tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -=\
    \ 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t\
    \    // No modifiers, move the pointer back.\n\t    // Special case: change empty\
    \ command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\"\
    ;\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\t\
    eap->cmd = (char_u *)\"+\";\n\n    return OK;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nparse_command_modifiers(\n\texarg_T\t   \
    \ *eap,\n\tchar\t    **errormsg,\n\tcmdmod_T    *cmod,\n\tint\t    skip_only)\n\
    {\n    char_u  *orig_cmd = eap->cmd;\n    char_u  *cmd_start = NULL;\n    int\t\
    \    use_plus_cmd = FALSE;\n    int\t    starts_with_colon = FALSE;\n    int\t\
    \    vim9script = in_vim9script();\n    int\t    has_visual_range = FALSE;\n\n\
    \    CLEAR_POINTER(cmod);\n    cmod->cmod_flags = sticky_cmdmod_flags;\n\n   \
    \ if (STRNCMP(eap->cmd, \"'<,'>\", 5) == 0)\n    {\n\t// The automatically inserted\
    \ Visual area range is skipped, so that\n\t// typing \":cmdmod cmd\" in Visual\
    \ mode works without having to move the\n\t// range to after the modififiers.\
    \ The command will be\n\t// \"'<,'>cmdmod cmd\", parse \"cmdmod cmd\" and then\
    \ put back \"'<,'>\"\n\t// before \"cmd\" below.\n\teap->cmd += 5;\n\tcmd_start\
    \ = eap->cmd;\n\thas_visual_range = TRUE;\n    }\n\n    // Repeat until no more\
    \ command modifiers are found.\n    for (;;)\n    {\n\tchar_u  *p;\n\n\twhile\
    \ (*eap->cmd == ' ' || *eap->cmd == '\\t' || *eap->cmd == ':')\n\t{\n\t    if\
    \ (*eap->cmd == ':')\n\t\tstarts_with_colon = TRUE;\n\t    ++eap->cmd;\n\t}\n\n\
    \t// in ex mode, an empty command (after modifiers) works like :+\n\tif (*eap->cmd\
    \ == NUL && exmode_active\n\t\t   && (getline_equal(eap->getline, eap->cookie,\
    \ getexmodeline)\n\t\t       || getline_equal(eap->getline, eap->cookie, getexline))\n\
    \t\t\t&& curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t{\n\t    use_plus_cmd\
    \ = TRUE;\n\t    if (!skip_only)\n\t\tex_pressedreturn = TRUE;\n\t    break; \
    \ // no modifiers following\n\t}\n\n\t// ignore comment and empty lines\n\tif\
    \ (comment_start(eap->cmd, starts_with_colon))\n\t{\n\t    // a comment ends at\
    \ a NL\n\t    if (eap->nextcmd == NULL)\n\t    {\n\t\teap->nextcmd = vim_strchr(eap->cmd,\
    \ '\\n');\n\t\tif (eap->nextcmd != NULL)\n\t\t    ++eap->nextcmd;\n\t    }\n\t\
    \    if (vim9script && has_cmdmod(cmod, FALSE))\n\t\t*errormsg = _(e_command_modifier_without_command);\n\
    \t    return FAIL;\n\t}\n\tif (*eap->cmd == NUL)\n\t{\n\t    if (!skip_only)\n\
    \t    {\n\t\tex_pressedreturn = TRUE;\n\t\tif (vim9script && has_cmdmod(cmod,\
    \ FALSE))\n\t\t    *errormsg = _(e_command_modifier_without_command);\n\t    }\n\
    \t    return FAIL;\n\t}\n\n\tp = skip_range(eap->cmd, TRUE, NULL);\n\n\t// In\
    \ Vim9 script a variable can shadow a command modifier:\n\t//   verbose = 123\n\
    \t//   verbose += 123\n\t//   silent! verbose = func()\n\t//   verbose.member\
    \ = 2\n\t//   verbose[expr] = 2\n\t// But not:\n\t//   verbose [a, b] = list\n\
    \tif (vim9script)\n\t{\n\t    char_u *s, *n;\n\n\t    for (s = eap->cmd; ASCII_ISALPHA(*s);\
    \ ++s)\n\t\t;\n\t    n = skipwhite(s);\n\t    if (*n == '.' || *n == '=' || (*n\
    \ != NUL && n[1] == '=')\n\t\t    || *s == '[')\n\t\tbreak;\n\t}\n\n\tswitch (*p)\n\
    \t{\n\t    // When adding an entry, also modify cmd_exists().\n\t    case 'a':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"aboveleft\", 3))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\n\t    case 'b':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"belowright\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_split |= WSP_BELOW;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_opt(&eap->cmd, \"browse\", 3,\
    \ TRUE))\n\t\t\t{\n#ifdef FEAT_BROWSE_CMD\n\t\t\t    cmod->cmod_flags |= CMOD_BROWSE;\n\
    #endif\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"botright\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_BOT;\n\t\t\
    \tcontinue;\n\n\t    case 'c':\tif (!checkforcmd_opt(&eap->cmd, \"confirm\", 4,\
    \ TRUE))\n\t\t\t    break;\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\
    \t\t\tcmod->cmod_flags |= CMOD_CONFIRM;\n#endif\n\t\t\tcontinue;\n\n\t    case\
    \ 'k':\tif (checkforcmd_noparen(&eap->cmd, \"keepmarks\", 3))\n\t\t\t{\n\t\t\t\
    \    cmod->cmod_flags |= CMOD_KEEPMARKS;\n\t\t\t    continue;\n\t\t\t}\n\t\t\t\
    if (checkforcmd_noparen(&eap->cmd, \"keepalt\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags\
    \ |= CMOD_KEEPALT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"keeppatterns\", 5))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_KEEPPATTERNS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"keepjumps\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_KEEPJUMPS;\n\t\t\tcontinue;\n\
    \n\t    case 'f':\t// only accept \":filter {pat} cmd\"\n\t\t\t{\n\t\t\t    char_u\
    \  *reg_pat;\n\t\t\t    char_u  *nulp = NULL;\n\t\t\t    int\t    c = 0;\n\n\t\
    \t\t    if (!checkforcmd_noparen(&p, \"filter\", 4)\n\t\t\t\t    || *p == NUL\n\
    \t\t\t\t    || (ends_excmd(*p)\n#ifdef FEAT_EVAL\n\t\t\t\t\t// in \":filter #pat#\
    \ cmd\" # does not\n\t\t\t\t\t// start a comment\n\t\t\t\t     && (!vim9script\
    \ || VIM_ISWHITE(p[1]))\n#endif\n\t\t\t\t     ))\n\t\t\t\tbreak;\n\t\t\t    if\
    \ (*p == '!')\n\t\t\t    {\n\t\t\t\tcmod->cmod_filter_force = TRUE;\n\t\t\t\t\
    p = skipwhite(p + 1);\n\t\t\t\tif (*p == NUL || ends_excmd(*p))\n\t\t\t\t    break;\n\
    \t\t\t    }\n#ifdef FEAT_EVAL\n\t\t\t    // Avoid that \"filter(arg)\" is recognized.\n\
    \t\t\t    if (vim9script && !VIM_ISWHITE(p[-1]))\n\t\t\t\tbreak;\n#endif\n\t\t\
    \t    if (skip_only)\n\t\t\t\tp = skip_vimgrep_pat(p, NULL, NULL);\n\t\t\t   \
    \ else\n\t\t\t\t// NOTE: This puts a NUL after the pattern.\n\t\t\t\tp = skip_vimgrep_pat_ext(p,\
    \ &reg_pat, NULL,\n\t\t\t\t\t\t\t\t    &nulp, &c);\n\t\t\t    if (p == NULL ||\
    \ *p == NUL)\n\t\t\t\tbreak;\n\t\t\t    if (!skip_only)\n\t\t\t    {\n\t\t\t\t\
    cmod->cmod_filter_regmatch.regprog =\n\t\t\t\t\t\tvim_regcomp(reg_pat, RE_MAGIC);\n\
    \t\t\t\tif (cmod->cmod_filter_regmatch.regprog == NULL)\n\t\t\t\t    break;\n\t\
    \t\t\t// restore the character overwritten by NUL\n\t\t\t\tif (nulp != NULL)\n\
    \t\t\t\t    *nulp = c;\n\t\t\t    }\n\t\t\t    eap->cmd = p;\n\t\t\t    continue;\n\
    \t\t\t}\n\n\t\t\t// \":hide\" and \":hide | cmd\" are not modifiers\n\t    case\
    \ 'h':\tif (p != eap->cmd || !checkforcmd_noparen(&p, \"hide\", 3)\n\t\t\t\t\t\
    \       || *p == NUL || ends_excmd(*p))\n\t\t\t    break;\n\t\t\teap->cmd = p;\n\
    \t\t\tcmod->cmod_flags |= CMOD_HIDE;\n\t\t\tcontinue;\n\n\t    case 'l':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"lockmarks\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_LOCKMARKS;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (checkforcmd_noparen(&eap->cmd, \"legacy\"\
    , 3))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p, eap->cmd))\n\t\t\t    {\n\t\t\t\t\
    *errormsg =\n\t\t\t\t      _(e_legacy_must_be_followed_by_command);\n\t\t\t\t\
    return FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_LEGACY;\n\t\t\t\
    \    continue;\n\t\t\t}\n\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"leftabove\"\
    , 5))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_ABOVE;\n\t\t\tcontinue;\n\
    \n\t    case 'n':\tif (checkforcmd_noparen(&eap->cmd, \"noautocmd\", 3))\n\t\t\
    \t{\n\t\t\t    cmod->cmod_flags |= CMOD_NOAUTOCMD;\n\t\t\t    continue;\n\t\t\t\
    }\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"noswapfile\", 3))\n\t\t\t    break;\n\
    \t\t\tcmod->cmod_flags |= CMOD_NOSWAPFILE;\n\t\t\tcontinue;\n\n\t    case 'r':\t\
    if (!checkforcmd_noparen(&eap->cmd, \"rightbelow\", 6))\n\t\t\t    break;\n\t\t\
    \tcmod->cmod_split |= WSP_BELOW;\n\t\t\tcontinue;\n\n\t    case 's':\tif (checkforcmd_noparen(&eap->cmd,\
    \ \"sandbox\", 3))\n\t\t\t{\n\t\t\t    cmod->cmod_flags |= CMOD_SANDBOX;\n\t\t\
    \t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd, \"silent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_SILENT;\n\t\t\tif (*eap->cmd\
    \ == '!' && !VIM_ISWHITE(eap->cmd[-1]))\n\t\t\t{\n\t\t\t    // \":silent!\", but\
    \ not \"silent !cmd\"\n\t\t\t    eap->cmd = skipwhite(eap->cmd + 1);\n\t\t\t \
    \   cmod->cmod_flags |= CMOD_ERRSILENT;\n\t\t\t}\n\t\t\tcontinue;\n\n\t    case\
    \ 't':\tif (checkforcmd_noparen(&p, \"tab\", 3))\n\t\t\t{\n\t\t\t    if (!skip_only)\n\
    \t\t\t    {\n\t\t\t\tlong tabnr = get_address(eap, &eap->cmd,\n\t\t\t\t\t\t  \
    \  ADDR_TABS, eap->skip,\n\t\t\t\t\t\t    skip_only, FALSE, 1);\n\t\t\t\tif (tabnr\
    \ == MAXLNUM)\n\t\t\t\t    cmod->cmod_tab = tabpage_index(curtab) + 1;\n\t\t\t\
    \telse\n\t\t\t\t{\n\t\t\t\t    if (tabnr < 0 || tabnr > LAST_TAB_NR)\n\t\t\t\t\
    \    {\n\t\t\t\t\t*errormsg = _(e_invalid_range);\n\t\t\t\t\treturn FAIL;\n\t\t\
    \t\t    }\n\t\t\t\t    cmod->cmod_tab = tabnr + 1;\n\t\t\t\t}\n\t\t\t    }\n\t\
    \t\t    eap->cmd = p;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&eap->cmd,\
    \ \"topleft\", 2))\n\t\t\t    break;\n\t\t\tcmod->cmod_split |= WSP_TOP;\n\t\t\
    \tcontinue;\n\n\t    case 'u':\tif (!checkforcmd_noparen(&eap->cmd, \"unsilent\"\
    , 3))\n\t\t\t    break;\n\t\t\tcmod->cmod_flags |= CMOD_UNSILENT;\n\t\t\tcontinue;\n\
    \n\t    case 'v':\tif (checkforcmd_noparen(&eap->cmd, \"vertical\", 4))\n\t\t\t\
    {\n\t\t\t    cmod->cmod_split |= WSP_VERT;\n\t\t\t    continue;\n\t\t\t}\n\t\t\
    \tif (checkforcmd_noparen(&eap->cmd, \"vim9cmd\", 4))\n\t\t\t{\n\t\t\t    if (ends_excmd2(p,\
    \ eap->cmd))\n\t\t\t    {\n\t\t\t\t*errormsg =\n\t\t\t\t      _(e_vim9cmd_must_be_followed_by_command);\n\
    \t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    cmod->cmod_flags |= CMOD_VIM9CMD;\n\
    \t\t\t    continue;\n\t\t\t}\n\t\t\tif (!checkforcmd_noparen(&p, \"verbose\",\
    \ 4))\n\t\t\t    break;\n\t\t\tif (vim_isdigit(*eap->cmd))\n\t\t\t{\n\t\t\t  \
    \  // zero means not set, one is verbose == 0, etc.\n\t\t\t    cmod->cmod_verbose\
    \ = atoi((char *)eap->cmd) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    cmod->cmod_verbose\
    \ = 2;  // default: verbose == 1\n\t\t\teap->cmd = p;\n\t\t\tcontinue;\n\t}\n\t\
    break;\n    }\n\n    if (has_visual_range)\n    {\n\tif (eap->cmd > cmd_start)\n\
    \t{\n\t    // Move the '<,'> range to after the modifiers and insert a colon.\n\
    \t    // Since the modifiers have been parsed put the colon on top of the\n\t\
    \    // space: \"'<,'>mod cmd\" -> \"mod:'<,'>cmd\n\t    // Put eap->cmd after\
    \ the colon.\n\t    if (use_plus_cmd)\n\t    {\n\t\tsize_t len = STRLEN(cmd_start);\n\
    \n\t\t// Special case: empty command uses \"+\":\n\t\t//  \"'<,'>mods\" -> \"\
    mods *+\n\t\t//  Use \"*\" instead of \"'<,'>\" to avoid the command getting\n\
    \t\t//  longer, in case is was allocated.\n\t\tmch_memmove(orig_cmd, cmd_start,\
    \ len);\n\t\tSTRCPY(orig_cmd + len, \" *+\");\n\t    }\n\t    else\n\t    {\n\t\
    \tmch_memmove(cmd_start - 5, cmd_start, eap->cmd - cmd_start);\n\t\teap->cmd -=\
    \ 5;\n\t\tmch_memmove(eap->cmd - 1, \":'<,'>\", 6);\n\t    }\n\t}\n\telse\n\t\
    \    // No modifiers, move the pointer back.\n\t    // Special case: change empty\
    \ command to \"+\".\n\t    if (use_plus_cmd)\n\t\teap->cmd = (char_u *)\"'<,'>+\"\
    ;\n\t    else\n\t\teap->cmd = orig_cmd;\n    }\n    else if (use_plus_cmd)\n\t\
    eap->cmd = (char_u *)\"+\";\n\n    return OK;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 379334
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
