agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\ngif_internal_decode_frame(gif_animation\
    \ *gif,\n                          unsigned int frame,\n                     \
    \     bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned\
    \ char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int\
    \ width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size,\
    \ interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data\
    \ = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n \
    \       ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n\
    \        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned\
    \ char colour;\n\n        /* If the GIF has no frame data, frame holders will\
    \ not be allocated in\n         * gif_initialise() */\n        if (gif->frames\
    \ == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n   \
    \     /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display\
    \ == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure\
    \ the frame is in range to decode */\n        if (frame > gif->frame_count_partial)\
    \ {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done\
    \ if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame\
    \ == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n   \
    \     /* Get the start of our frame data and the end of the GIF data */\n    \
    \    gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end\
    \ = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\
    \n        /*\n         * Ensure there is a minimal amount of data to proceed.\
    \  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte\
    \ gif trailer\n         */\n        if (gif_bytes < 12) {\n                return\
    \ GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position\
    \ */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position\
    \ = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have\
    \ allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif))\
    \ != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n     \
    \   gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image\
    \ descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes\
    \ < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n     \
    \           goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image\
    \ Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n \
    \        *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n\
    \         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\t\
    CHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n     \
    \    *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\
    \t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n     \
    \    */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value\
    \ = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\
    \        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3]\
    \ | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n \
    \       height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking\
    \ - shouldn't ever happen except unless the data has\n         * been modified\
    \ since initialisation.\n         */\n        if ((offset_x + width > gif->width)\
    \ ||\n            (offset_y + height > gif->height)) {\n                return_value\
    \ = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n\
    \        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size\
    \ = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\
    \n        /* Advance data pointer to next block either colour table or image\n\
    \         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK)\
    \ {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n       \
    \                 return_value = GIF_INSUFFICIENT_FRAME_DATA;\n              \
    \          goto gif_decode_frame_exit;\n                }\n                colour_table\
    \ = gif->local_colour_table;\n                if (!clear_image) {\n          \
    \              for (index = 0; index < colour_table_size; index++) {\n       \
    \                         /* Gif colour map contents are r,g,b.\n            \
    \                     *\n                                 * We want to pack them\
    \ bytewise into the\n                                 * colour table, such that\
    \ the red component\n                                 * is in byte 0 and the alpha\
    \ component is in\n                                 * byte 3.\n              \
    \                   */\n                                unsigned char *entry =\n\
    \                                        (unsigned char *) &colour_table[index];\n\
    \n                                entry[0] = gif_data[0];\t/* r */\n         \
    \                       entry[1] = gif_data[1];\t/* g */\n                   \
    \             entry[2] = gif_data[2];\t/* b */\n                             \
    \   entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n\
    \                        }\n                } else {\n                       \
    \ gif_data += 3 * colour_table_size;\n                }\n                gif_bytes\
    \ = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n\
    \        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes\
    \ < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n      \
    \          goto gif_decode_frame_exit;\n        }\n\n        /* check for an end\
    \ marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value\
    \ = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n      \
    \  /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n\
    \        }\n\n        /* If we are clearing the image we just clear, if not decode\
    \ */\n        if (!clear_image) {\n                lzw_result res;\n         \
    \       const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\
    \n                /* Ensure we have enough data for a 1-byte LZW code size +\n\
    \                 * 1-byte gif trailer\n                 */\n                if\
    \ (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n\
    \                        goto gif_decode_frame_exit;\n                }\n\n  \
    \              /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n\
    \                 * we're finished\n                 */\n                if ((gif_bytes\
    \ == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value\
    \ = GIF_OK;\n                        goto gif_decode_frame_exit;\n           \
    \     }\n\n                /* If the previous frame's disposal method requires\
    \ we restore\n                 * the background colour or this is the first frame,\
    \ clear\n                 * the frame data\n                 */\n            \
    \    if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n      \
    \                  memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n\
    \                               gif->width * gif->height * sizeof(int));\n   \
    \                     gif->decoded_frame = frame;\n                        /*\
    \ The line below would fill the image with its\n                         * background\
    \ color, but because GIFs support\n                         * transparency we\
    \ likely wouldn't want to do that. */\n                        /* memset((char*)frame_data,\
    \ colour_table[gif->background_index], gif->width * gif->height * sizeof(int));\
    \ */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame\
    \ - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value\
    \ = gif_internal_decode_frame(gif,\n                                         \
    \                        (frame - 1),\n                                      \
    \                           true);\n                        if (return_value !=\
    \ GIF_OK) {\n                                goto gif_decode_frame_exit;\n   \
    \                     }\n\n                } else if ((frame != 0) &&\n      \
    \                     (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE))\
    \ {\n                        /*\n                         * If the previous frame's\
    \ disposal method requires we\n                         * restore the previous\
    \ image, find the last image set\n                         * to \"do not dispose\"\
    \ and get that frame data\n                         */\n                     \
    \   int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame\
    \ >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method\
    \ == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n\
    \                        }\n\n                        /* If we don't find one,\
    \ clear the frame data */\n                        if (last_undisposed_frame ==\
    \ -1) {\n                                /* see notes above on transparency\n\
    \                                 * vs. background color\n                   \
    \              */\n                                memset((char*)frame_data,\n\
    \                                       GIF_TRANSPARENT_COLOUR,\n            \
    \                           gif->width * gif->height * sizeof(int));\n       \
    \                 } else {\n                                return_value = gif_internal_decode_frame(gif,\
    \ last_undisposed_frame, false);\n                                if (return_value\
    \ != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n\
    \                                }\n                                /* Get this\
    \ frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \                                if (!frame_data) {\n                        \
    \                return GIF_INSUFFICIENT_MEMORY;\n                           \
    \     }\n                        }\n                }\n                gif->decoded_frame\
    \ = frame;\n                gif->buffer_position = (gif_data - gif->gif_data)\
    \ + 1;\n\n                /* Initialise the LZW decoding */\n                res\
    \ = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                           \
    \     gif->buffer_size, gif->buffer_position,\n                              \
    \  gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK)\
    \ {\n                        return gif_error_from_lzw(res);\n               \
    \ }\n\n                /* Decompress the data */\n                for (y = 0;\
    \ y < height; y++) {\n                        if (interlace) {\n             \
    \                   decode_y = gif_interlaced_line(height, y) + offset_y;\n  \
    \                      } else {\n                                decode_y = y\
    \ + offset_y;\n                        }\n                        frame_scanline\
    \ = frame_data + offset_x + (decode_y * gif->width);\n\n                     \
    \   /* Rather than decoding pixel by pixel, we try to burst\n                \
    \         * out streams of data to remove the need for end-of\n              \
    \           * data checks every pixel.\n                         */\n        \
    \                x = width;\n                        while (x > 0) {\n       \
    \                         burst_bytes = (stack_pos - stack_base);\n          \
    \                      if (burst_bytes > 0) {\n                              \
    \          if (burst_bytes > x) {\n                                          \
    \      burst_bytes = x;\n                                        }\n         \
    \                               x -= burst_bytes;\n                          \
    \              while (burst_bytes-- > 0) {\n                                 \
    \               colour = *--stack_pos;\n                                     \
    \           if (((gif->frames[frame].transparency) &&\n                      \
    \                               (colour != gif->frames[frame].transparency_index))\
    \ ||\n                                                    (!gif->frames[frame].transparency))\
    \ {\n                                                        *frame_scanline =\
    \ colour_table[colour];\n                                                }\n \
    \                                               frame_scanline++;\n          \
    \                              }\n                                } else {\n \
    \                                       res = lzw_decode(gif->lzw_ctx, &stack_pos);\n\
    \                                        if (res != LZW_OK) {\n              \
    \                                  /* Unexpected end of frame, try to recover\
    \ */\n                                                if (res == LZW_OK_EOD) {\n\
    \                                                        return_value = GIF_OK;\n\
    \                                                } else {\n                  \
    \                                      return_value = gif_error_from_lzw(res);\n\
    \                                                }\n                         \
    \                       goto gif_decode_frame_exit;\n                        \
    \                }\n                                }\n                      \
    \  }\n                }\n        } else {\n                /* Clear our frame\
    \ */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR)\
    \ {\n                        for (y = 0; y < height; y++) {\n                \
    \                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n\
    \                                if (gif->frames[frame].transparency) {\n    \
    \                                    memset(frame_scanline,\n                \
    \                               GIF_TRANSPARENT_COLOUR,\n                    \
    \                           width * 4);\n                                } else\
    \ {\n                                        memset(frame_scanline,\n        \
    \                                       colour_table[gif->background_index],\n\
    \                                               width * 4);\n                \
    \                }\n                        }\n                }\n        }\n\
    gif_decode_frame_exit:\n\n        /* Check if we should test for optimisation\
    \ */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque)\
    \ {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n\
    \                } else {\n                        gif->frames[frame].opaque =\
    \ false;\n                }\n                gif->frames[frame].virgin = false;\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n       \
    \         gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n         \
    \       gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n\
    \        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\
    \n        return return_value;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\ngif_internal_decode_frame(gif_animation\
    \ *gif,\n                          unsigned int frame,\n                     \
    \     bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned\
    \ char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int\
    \ width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size,\
    \ interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data\
    \ = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n \
    \       ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n\
    \        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned\
    \ char colour;\n\n        /* If the GIF has no frame data, frame holders will\
    \ not be allocated in\n         * gif_initialise() */\n        if (gif->frames\
    \ == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n   \
    \     /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display\
    \ == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure\
    \ the frame is in range to decode */\n        if (frame > gif->frame_count_partial)\
    \ {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done\
    \ if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame\
    \ == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n   \
    \     /* Get the start of our frame data and the end of the GIF data */\n    \
    \    gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end\
    \ = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\
    \n        /*\n         * Ensure there is a minimal amount of data to proceed.\
    \  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte\
    \ gif trailer\n         */\n        if (gif_bytes < 12) {\n                return\
    \ GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position\
    \ */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position\
    \ = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have\
    \ allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif))\
    \ != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n     \
    \   gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image\
    \ descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes\
    \ < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n     \
    \           goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image\
    \ Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n \
    \        *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n\
    \         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\t\
    CHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n     \
    \    *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\
    \t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n     \
    \    */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value\
    \ = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\
    \        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3]\
    \ | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n \
    \       height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking\
    \ - shouldn't ever happen except unless the data has\n         * been modified\
    \ since initialisation.\n         */\n        if ((offset_x + width > gif->width)\
    \ ||\n            (offset_y + height > gif->height)) {\n                return_value\
    \ = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n\
    \        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size\
    \ = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\
    \n        /* Advance data pointer to next block either colour table or image\n\
    \         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK)\
    \ {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n       \
    \                 return_value = GIF_INSUFFICIENT_FRAME_DATA;\n              \
    \          goto gif_decode_frame_exit;\n                }\n                colour_table\
    \ = gif->local_colour_table;\n                if (!clear_image) {\n          \
    \              for (index = 0; index < colour_table_size; index++) {\n       \
    \                         /* Gif colour map contents are r,g,b.\n            \
    \                     *\n                                 * We want to pack them\
    \ bytewise into the\n                                 * colour table, such that\
    \ the red component\n                                 * is in byte 0 and the alpha\
    \ component is in\n                                 * byte 3.\n              \
    \                   */\n                                unsigned char *entry =\n\
    \                                        (unsigned char *) &colour_table[index];\n\
    \n                                entry[0] = gif_data[0];\t/* r */\n         \
    \                       entry[1] = gif_data[1];\t/* g */\n                   \
    \             entry[2] = gif_data[2];\t/* b */\n                             \
    \   entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n\
    \                        }\n                } else {\n                       \
    \ gif_data += 3 * colour_table_size;\n                }\n                gif_bytes\
    \ = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n\
    \        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes\
    \ < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n      \
    \          goto gif_decode_frame_exit;\n        }\n\n        /* check for an end\
    \ marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value\
    \ = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n      \
    \  /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n\
    \        }\n\n        /* If we are clearing the image we just clear, if not decode\
    \ */\n        if (!clear_image) {\n                lzw_result res;\n         \
    \       const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\
    \n                /* Ensure we have enough data for a 1-byte LZW code size +\n\
    \                 * 1-byte gif trailer\n                 */\n                if\
    \ (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n\
    \                        goto gif_decode_frame_exit;\n                }\n\n  \
    \              /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n\
    \                 * we're finished\n                 */\n                if ((gif_bytes\
    \ == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value\
    \ = GIF_OK;\n                        goto gif_decode_frame_exit;\n           \
    \     }\n\n                /* If the previous frame's disposal method requires\
    \ we restore\n                 * the background colour or this is the first frame,\
    \ clear\n                 * the frame data\n                 */\n            \
    \    if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n      \
    \                  memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n\
    \                               gif->width * gif->height * sizeof(int));\n   \
    \                     gif->decoded_frame = frame;\n                        /*\
    \ The line below would fill the image with its\n                         * background\
    \ color, but because GIFs support\n                         * transparency we\
    \ likely wouldn't want to do that. */\n                        /* memset((char*)frame_data,\
    \ colour_table[gif->background_index], gif->width * gif->height * sizeof(int));\
    \ */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame\
    \ - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value\
    \ = gif_internal_decode_frame(gif,\n                                         \
    \                        (frame - 1),\n                                      \
    \                           true);\n                        if (return_value !=\
    \ GIF_OK) {\n                                goto gif_decode_frame_exit;\n   \
    \                     }\n\n                } else if ((frame != 0) &&\n      \
    \                     (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE))\
    \ {\n                        /*\n                         * If the previous frame's\
    \ disposal method requires we\n                         * restore the previous\
    \ image, find the last image set\n                         * to \"do not dispose\"\
    \ and get that frame data\n                         */\n                     \
    \   int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame\
    \ >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method\
    \ == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n\
    \                        }\n\n                        /* If we don't find one,\
    \ clear the frame data */\n                        if (last_undisposed_frame ==\
    \ -1) {\n                                /* see notes above on transparency\n\
    \                                 * vs. background color\n                   \
    \              */\n                                memset((char*)frame_data,\n\
    \                                       GIF_TRANSPARENT_COLOUR,\n            \
    \                           gif->width * gif->height * sizeof(int));\n       \
    \                 } else {\n                                return_value = gif_internal_decode_frame(gif,\
    \ last_undisposed_frame, false);\n                                if (return_value\
    \ != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n\
    \                                }\n                                /* Get this\
    \ frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \                                if (!frame_data) {\n                        \
    \                return GIF_INSUFFICIENT_MEMORY;\n                           \
    \     }\n                        }\n                }\n                gif->decoded_frame\
    \ = frame;\n                gif->buffer_position = (gif_data - gif->gif_data)\
    \ + 1;\n\n                /* Initialise the LZW decoding */\n                res\
    \ = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                           \
    \     gif->buffer_size, gif->buffer_position,\n                              \
    \  gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK)\
    \ {\n                        return gif_error_from_lzw(res);\n               \
    \ }\n\n                /* Decompress the data */\n                for (y = 0;\
    \ y < height; y++) {\n                        if (interlace) {\n             \
    \                   decode_y = gif_interlaced_line(height, y) + offset_y;\n  \
    \                      } else {\n                                decode_y = y\
    \ + offset_y;\n                        }\n                        frame_scanline\
    \ = frame_data + offset_x + (decode_y * gif->width);\n\n                     \
    \   /* Rather than decoding pixel by pixel, we try to burst\n                \
    \         * out streams of data to remove the need for end-of\n              \
    \           * data checks every pixel.\n                         */\n        \
    \                x = width;\n                        while (x > 0) {\n       \
    \                         burst_bytes = (stack_pos - stack_base);\n          \
    \                      if (burst_bytes > 0) {\n                              \
    \          if (burst_bytes > x) {\n                                          \
    \      burst_bytes = x;\n                                        }\n         \
    \                               x -= burst_bytes;\n                          \
    \              while (burst_bytes-- > 0) {\n                                 \
    \               colour = *--stack_pos;\n                                     \
    \           if (((gif->frames[frame].transparency) &&\n                      \
    \                               (colour != gif->frames[frame].transparency_index))\
    \ ||\n                                                    (!gif->frames[frame].transparency))\
    \ {\n                                                        *frame_scanline =\
    \ colour_table[colour];\n                                                }\n \
    \                                               frame_scanline++;\n          \
    \                              }\n                                } else {\n \
    \                                       res = lzw_decode(gif->lzw_ctx, &stack_pos);\n\
    \                                        if (res != LZW_OK) {\n              \
    \                                  /* Unexpected end of frame, try to recover\
    \ */\n                                                if (res == LZW_OK_EOD) {\n\
    \                                                        return_value = GIF_OK;\n\
    \                                                } else {\n                  \
    \                                      return_value = gif_error_from_lzw(res);\n\
    \                                                }\n                         \
    \                       goto gif_decode_frame_exit;\n                        \
    \                }\n                                }\n                      \
    \  }\n                }\n        } else {\n                /* Clear our frame\
    \ */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR)\
    \ {\n                        for (y = 0; y < height; y++) {\n                \
    \                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n\
    \                                if (gif->frames[frame].transparency) {\n    \
    \                                    memset(frame_scanline,\n                \
    \                               GIF_TRANSPARENT_COLOUR,\n                    \
    \                           width * 4);\n                                } else\
    \ {\n                                        memset(frame_scanline,\n        \
    \                                       colour_table[gif->background_index],\n\
    \                                               width * 4);\n                \
    \                }\n                        }\n                }\n        }\n\
    gif_decode_frame_exit:\n\n        /* Check if we should test for optimisation\
    \ */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque)\
    \ {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n\
    \                } else {\n                        gif->frames[frame].opaque =\
    \ false;\n                }\n                gif->frames[frame].virgin = false;\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n       \
    \         gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n         \
    \       gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n\
    \        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\
    \n        return return_value;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\ngif_internal_decode_frame(gif_animation *gif,\n                   \
    \       unsigned int frame,\n                          bool clear_image)\n{\n\
    \        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n\
    \        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n\
    \        unsigned int flags, colour_table_size, interlace;\n        unsigned int\
    \ *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n\
    \        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n\
    \        unsigned int return_value = 0;\n        unsigned int x, y, decode_y,\
    \ burst_bytes;\n        register unsigned char colour;\n\n        /* If the GIF\
    \ has no frame data, frame holders will not be allocated in\n         * gif_initialise()\
    \ */\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n\
    \        }\n\n        /* Ensure this frame is supposed to be decoded */\n    \
    \    if (gif->frames[frame].display == false) {\n                return GIF_OK;\n\
    \        }\n\n        /* Ensure the frame is in range to decode */\n        if\
    \ (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n\
    \        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image)\
    \ &&\n            ((int)frame == gif->decoded_frame)) {\n                return\
    \ GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end\
    \ of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n\
    \        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data\
    \ to proceed.  The shortest\n         * block of data is a 10-byte image descriptor\
    \ + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n         \
    \       return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the\
    \ buffer position */\n        save_buffer_position = gif->buffer_position;\n \
    \       gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any\
    \ extensions because they have allready been processed */\n        if ((return_value\
    \ = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n\
    \        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n     \
    \   gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data\
    \ for the 10-byte image descriptor + 1-byte\n         * gif trailer\n        \
    \ */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n\
    \                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte\
    \ Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n\
    \         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top\
    \ Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n    \
    \     *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table\
    \ Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n\
    \         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour\
    \ Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n    \
    \            return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n\
    \        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y\
    \ = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6]\
    \ << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary\
    \ checking - shouldn't ever happen except unless the data has\n         * been\
    \ modified since initialisation.\n         */\n        if ((offset_x + width >\
    \ gif->width) ||\n            (offset_y + height > gif->height)) {\n         \
    \       return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n\
    \        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n \
    \       colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n     \
    \   interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer\
    \ to next block either colour table or image\n         * data.\n         */\n\
    \        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n      \
    \  /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n\
    \                if (gif_bytes < (int)(3 * colour_table_size)) {\n           \
    \             return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                  \
    \      goto gif_decode_frame_exit;\n                }\n                colour_table\
    \ = gif->local_colour_table;\n                if (!clear_image) {\n          \
    \              for (index = 0; index < colour_table_size; index++) {\n       \
    \                         /* Gif colour map contents are r,g,b.\n            \
    \                     *\n                                 * We want to pack them\
    \ bytewise into the\n                                 * colour table, such that\
    \ the red component\n                                 * is in byte 0 and the alpha\
    \ component is in\n                                 * byte 3.\n              \
    \                   */\n                                unsigned char *entry =\n\
    \                                        (unsigned char *) &colour_table[index];\n\
    \n                                entry[0] = gif_data[0];\t/* r */\n         \
    \                       entry[1] = gif_data[1];\t/* g */\n                   \
    \             entry[2] = gif_data[2];\t/* b */\n                             \
    \   entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n\
    \                        }\n                } else {\n                       \
    \ gif_data += 3 * colour_table_size;\n                }\n                gif_bytes\
    \ = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n\
    \        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes\
    \ < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n      \
    \          goto gif_decode_frame_exit;\n        }\n\n        /* check for an end\
    \ marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value\
    \ = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n      \
    \  /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n\
    \        }\n\n        /* If we are clearing the image we just clear, if not decode\
    \ */\n        if (!clear_image) {\n                lzw_result res;\n         \
    \       const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\
    \n                /* Ensure we have enough data for a 1-byte LZW code size +\n\
    \                 * 1-byte gif trailer\n                 */\n                if\
    \ (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n\
    \                        goto gif_decode_frame_exit;\n                }\n\n  \
    \              /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n\
    \                 * we're finished\n                 */\n                if ((gif_bytes\
    \ == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value\
    \ = GIF_OK;\n                        goto gif_decode_frame_exit;\n           \
    \     }\n\n                /* If the previous frame's disposal method requires\
    \ we restore\n                 * the background colour or this is the first frame,\
    \ clear\n                 * the frame data\n                 */\n            \
    \    if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n      \
    \                  memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n\
    \                               gif->width * gif->height * sizeof(int));\n   \
    \                     gif->decoded_frame = frame;\n                        /*\
    \ The line below would fill the image with its\n                         * background\
    \ color, but because GIFs support\n                         * transparency we\
    \ likely wouldn't want to do that. */\n                        /* memset((char*)frame_data,\
    \ colour_table[gif->background_index], gif->width * gif->height * sizeof(int));\
    \ */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame\
    \ - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value\
    \ = gif_internal_decode_frame(gif,\n                                         \
    \                        (frame - 1),\n                                      \
    \                           true);\n                        if (return_value !=\
    \ GIF_OK) {\n                                goto gif_decode_frame_exit;\n   \
    \                     }\n\n                } else if ((frame != 0) &&\n      \
    \                     (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE))\
    \ {\n                        /*\n                         * If the previous frame's\
    \ disposal method requires we\n                         * restore the previous\
    \ image, find the last image set\n                         * to \"do not dispose\"\
    \ and get that frame data\n                         */\n                     \
    \   int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame\
    \ >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method\
    \ == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n\
    \                        }\n\n                        /* If we don't find one,\
    \ clear the frame data */\n                        if (last_undisposed_frame ==\
    \ -1) {\n                                /* see notes above on transparency\n\
    \                                 * vs. background color\n                   \
    \              */\n                                memset((char*)frame_data,\n\
    \                                       GIF_TRANSPARENT_COLOUR,\n            \
    \                           gif->width * gif->height * sizeof(int));\n       \
    \                 } else {\n                                return_value = gif_internal_decode_frame(gif,\
    \ last_undisposed_frame, false);\n                                if (return_value\
    \ != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n\
    \                                }\n                                /* Get this\
    \ frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \                                if (!frame_data) {\n                        \
    \                return GIF_INSUFFICIENT_MEMORY;\n                           \
    \     }\n                        }\n                }\n                gif->decoded_frame\
    \ = frame;\n                gif->buffer_position = (gif_data - gif->gif_data)\
    \ + 1;\n\n                /* Initialise the LZW decoding */\n                res\
    \ = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                           \
    \     gif->buffer_size, gif->buffer_position,\n                              \
    \  gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK)\
    \ {\n                        return gif_error_from_lzw(res);\n               \
    \ }\n\n                /* Decompress the data */\n                for (y = 0;\
    \ y < height; y++) {\n                        if (interlace) {\n             \
    \                   decode_y = gif_interlaced_line(height, y) + offset_y;\n  \
    \                      } else {\n                                decode_y = y\
    \ + offset_y;\n                        }\n                        frame_scanline\
    \ = frame_data + offset_x + (decode_y * gif->width);\n\n                     \
    \   /* Rather than decoding pixel by pixel, we try to burst\n                \
    \         * out streams of data to remove the need for end-of\n              \
    \           * data checks every pixel.\n                         */\n        \
    \                x = width;\n                        while (x > 0) {\n       \
    \                         burst_bytes = (stack_pos - stack_base);\n          \
    \                      if (burst_bytes > 0) {\n                              \
    \          if (burst_bytes > x) {\n                                          \
    \      burst_bytes = x;\n                                        }\n         \
    \                               x -= burst_bytes;\n                          \
    \              while (burst_bytes-- > 0) {\n                                 \
    \               colour = *--stack_pos;\n                                     \
    \           if (((gif->frames[frame].transparency) &&\n                      \
    \                               (colour != gif->frames[frame].transparency_index))\
    \ ||\n                                                    (!gif->frames[frame].transparency))\
    \ {\n                                                        *frame_scanline =\
    \ colour_table[colour];\n                                                }\n \
    \                                               frame_scanline++;\n          \
    \                              }\n                                } else {\n \
    \                                       res = lzw_decode(gif->lzw_ctx, &stack_pos);\n\
    \                                        if (res != LZW_OK) {\n              \
    \                                  /* Unexpected end of frame, try to recover\
    \ */\n                                                if (res == LZW_OK_EOD) {\n\
    \                                                        return_value = GIF_OK;\n\
    \                                                } else {\n                  \
    \                                      return_value = gif_error_from_lzw(res);\n\
    \                                                }\n                         \
    \                       goto gif_decode_frame_exit;\n                        \
    \                }\n                                }\n                      \
    \  }\n                }\n        } else {\n                /* Clear our frame\
    \ */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR)\
    \ {\n                        for (y = 0; y < height; y++) {\n                \
    \                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n\
    \                                if (gif->frames[frame].transparency) {\n    \
    \                                    memset(frame_scanline,\n                \
    \                               GIF_TRANSPARENT_COLOUR,\n                    \
    \                           width * 4);\n                                } else\
    \ {\n                                        memset(frame_scanline,\n        \
    \                                       colour_table[gif->background_index],\n\
    \                                               width * 4);\n                \
    \                }\n                        }\n                }\n        }\n\
    gif_decode_frame_exit:\n\n        /* Check if we should test for optimisation\
    \ */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque)\
    \ {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n\
    \                } else {\n                        gif->frames[frame].opaque =\
    \ false;\n                }\n                gif->frames[frame].virgin = false;\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n       \
    \         gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n         \
    \       gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n\
    \        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\
    \n        return return_value;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\ngif_internal_decode_frame(gif_animation *gif,\n\
    \                          unsigned int frame,\n                          bool\
    \ clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char\
    \ *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width,\
    \ height, offset_x, offset_y;\n        unsigned int flags, colour_table_size,\
    \ interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data\
    \ = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n \
    \       ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n\
    \        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned\
    \ char colour;\n\n        /* If the GIF has no frame data, frame holders will\
    \ not be allocated in\n         * gif_initialise() */\n        if (gif->frames\
    \ == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n   \
    \     /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display\
    \ == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure\
    \ the frame is in range to decode */\n        if (frame > gif->frame_count_partial)\
    \ {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done\
    \ if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame\
    \ == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n   \
    \     /* Get the start of our frame data and the end of the GIF data */\n    \
    \    gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end\
    \ = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\
    \n        /*\n         * Ensure there is a minimal amount of data to proceed.\
    \  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte\
    \ gif trailer\n         */\n        if (gif_bytes < 12) {\n                return\
    \ GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position\
    \ */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position\
    \ = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have\
    \ allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif))\
    \ != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n     \
    \   gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image\
    \ descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes\
    \ < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n     \
    \           goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image\
    \ Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n \
    \        *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n\
    \         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\t\
    CHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n     \
    \    *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\
    \t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n     \
    \    */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value\
    \ = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\
    \        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3]\
    \ | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n \
    \       height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking\
    \ - shouldn't ever happen except unless the data has\n         * been modified\
    \ since initialisation.\n         */\n        if ((offset_x + width > gif->width)\
    \ ||\n            (offset_y + height > gif->height)) {\n                return_value\
    \ = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n\
    \        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size\
    \ = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\
    \n        /* Advance data pointer to next block either colour table or image\n\
    \         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end\
    \ - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK)\
    \ {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n       \
    \                 return_value = GIF_INSUFFICIENT_FRAME_DATA;\n              \
    \          goto gif_decode_frame_exit;\n                }\n                colour_table\
    \ = gif->local_colour_table;\n                if (!clear_image) {\n          \
    \              for (index = 0; index < colour_table_size; index++) {\n       \
    \                         /* Gif colour map contents are r,g,b.\n            \
    \                     *\n                                 * We want to pack them\
    \ bytewise into the\n                                 * colour table, such that\
    \ the red component\n                                 * is in byte 0 and the alpha\
    \ component is in\n                                 * byte 3.\n              \
    \                   */\n                                unsigned char *entry =\n\
    \                                        (unsigned char *) &colour_table[index];\n\
    \n                                entry[0] = gif_data[0];\t/* r */\n         \
    \                       entry[1] = gif_data[1];\t/* g */\n                   \
    \             entry[2] = gif_data[2];\t/* b */\n                             \
    \   entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n\
    \                        }\n                } else {\n                       \
    \ gif_data += 3 * colour_table_size;\n                }\n                gif_bytes\
    \ = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n\
    \        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes\
    \ < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n      \
    \          goto gif_decode_frame_exit;\n        }\n\n        /* check for an end\
    \ marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value\
    \ = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n      \
    \  /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n\
    \        }\n\n        /* If we are clearing the image we just clear, if not decode\
    \ */\n        if (!clear_image) {\n                lzw_result res;\n         \
    \       const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\
    \n                /* Ensure we have enough data for a 1-byte LZW code size +\n\
    \                 * 1-byte gif trailer\n                 */\n                if\
    \ (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n\
    \                        goto gif_decode_frame_exit;\n                }\n\n  \
    \              /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n\
    \                 * we're finished\n                 */\n                if ((gif_bytes\
    \ == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value\
    \ = GIF_OK;\n                        goto gif_decode_frame_exit;\n           \
    \     }\n\n                /* If the previous frame's disposal method requires\
    \ we restore\n                 * the background colour or this is the first frame,\
    \ clear\n                 * the frame data\n                 */\n            \
    \    if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n      \
    \                  memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n\
    \                               gif->width * gif->height * sizeof(int));\n   \
    \                     gif->decoded_frame = frame;\n                        /*\
    \ The line below would fill the image with its\n                         * background\
    \ color, but because GIFs support\n                         * transparency we\
    \ likely wouldn't want to do that. */\n                        /* memset((char*)frame_data,\
    \ colour_table[gif->background_index], gif->width * gif->height * sizeof(int));\
    \ */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame\
    \ - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value\
    \ = gif_internal_decode_frame(gif,\n                                         \
    \                        (frame - 1),\n                                      \
    \                           true);\n                        if (return_value !=\
    \ GIF_OK) {\n                                goto gif_decode_frame_exit;\n   \
    \                     }\n\n                } else if ((frame != 0) &&\n      \
    \                     (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE))\
    \ {\n                        /*\n                         * If the previous frame's\
    \ disposal method requires we\n                         * restore the previous\
    \ image, find the last image set\n                         * to \"do not dispose\"\
    \ and get that frame data\n                         */\n                     \
    \   int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame\
    \ >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method\
    \ == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n\
    \                        }\n\n                        /* If we don't find one,\
    \ clear the frame data */\n                        if (last_undisposed_frame ==\
    \ -1) {\n                                /* see notes above on transparency\n\
    \                                 * vs. background color\n                   \
    \              */\n                                memset((char*)frame_data,\n\
    \                                       GIF_TRANSPARENT_COLOUR,\n            \
    \                           gif->width * gif->height * sizeof(int));\n       \
    \                 } else {\n                                return_value = gif_internal_decode_frame(gif,\
    \ last_undisposed_frame, false);\n                                if (return_value\
    \ != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n\
    \                                }\n                                /* Get this\
    \ frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n\
    \                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n\
    \                                if (!frame_data) {\n                        \
    \                return GIF_INSUFFICIENT_MEMORY;\n                           \
    \     }\n                        }\n                }\n                gif->decoded_frame\
    \ = frame;\n                gif->buffer_position = (gif_data - gif->gif_data)\
    \ + 1;\n\n                /* Initialise the LZW decoding */\n                res\
    \ = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                           \
    \     gif->buffer_size, gif->buffer_position,\n                              \
    \  gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK)\
    \ {\n                        return gif_error_from_lzw(res);\n               \
    \ }\n\n                /* Decompress the data */\n                for (y = 0;\
    \ y < height; y++) {\n                        if (interlace) {\n             \
    \                   decode_y = gif_interlaced_line(height, y) + offset_y;\n  \
    \                      } else {\n                                decode_y = y\
    \ + offset_y;\n                        }\n                        frame_scanline\
    \ = frame_data + offset_x + (decode_y * gif->width);\n\n                     \
    \   /* Rather than decoding pixel by pixel, we try to burst\n                \
    \         * out streams of data to remove the need for end-of\n              \
    \           * data checks every pixel.\n                         */\n        \
    \                x = width;\n                        while (x > 0) {\n       \
    \                         burst_bytes = (stack_pos - stack_base);\n          \
    \                      if (burst_bytes > 0) {\n                              \
    \          if (burst_bytes > x) {\n                                          \
    \      burst_bytes = x;\n                                        }\n         \
    \                               x -= burst_bytes;\n                          \
    \              while (burst_bytes-- > 0) {\n                                 \
    \               colour = *--stack_pos;\n                                     \
    \           if (((gif->frames[frame].transparency) &&\n                      \
    \                               (colour != gif->frames[frame].transparency_index))\
    \ ||\n                                                    (!gif->frames[frame].transparency))\
    \ {\n                                                        *frame_scanline =\
    \ colour_table[colour];\n                                                }\n \
    \                                               frame_scanline++;\n          \
    \                              }\n                                } else {\n \
    \                                       res = lzw_decode(gif->lzw_ctx, &stack_pos);\n\
    \                                        if (res != LZW_OK) {\n              \
    \                                  /* Unexpected end of frame, try to recover\
    \ */\n                                                if (res == LZW_OK_EOD) {\n\
    \                                                        return_value = GIF_OK;\n\
    \                                                } else {\n                  \
    \                                      return_value = gif_error_from_lzw(res);\n\
    \                                                }\n                         \
    \                       goto gif_decode_frame_exit;\n                        \
    \                }\n                                }\n                      \
    \  }\n                }\n        } else {\n                /* Clear our frame\
    \ */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR)\
    \ {\n                        for (y = 0; y < height; y++) {\n                \
    \                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n\
    \                                if (gif->frames[frame].transparency) {\n    \
    \                                    memset(frame_scanline,\n                \
    \                               GIF_TRANSPARENT_COLOUR,\n                    \
    \                           width * 4);\n                                } else\
    \ {\n                                        memset(frame_scanline,\n        \
    \                                       colour_table[gif->background_index],\n\
    \                                               width * 4);\n                \
    \                }\n                        }\n                }\n        }\n\
    gif_decode_frame_exit:\n\n        /* Check if we should test for optimisation\
    \ */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque)\
    \ {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n\
    \                } else {\n                        gif->frames[frame].opaque =\
    \ false;\n                }\n                gif->frames[frame].virgin = false;\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n       \
    \         gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n\
    \        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n         \
    \       gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n\
    \        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\
    \n        return return_value;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 293496
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
