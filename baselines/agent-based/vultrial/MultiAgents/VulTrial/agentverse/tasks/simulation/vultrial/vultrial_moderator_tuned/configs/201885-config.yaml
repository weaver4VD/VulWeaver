agents:
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nregmatch(\n\
    \    char_u\t*scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t   \
    \ // timeout limit or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout\
    \ or NULL\n{\n  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n \
    \ regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n\
    #ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\"\
    \ and \"backpos\" empty.  They are allocated and freed in\n  // bt_regexec_both()\
    \ to reduce malloc()/free() calls.\n  regstack.ga_len = 0;\n  backpos.ga_len =\
    \ 0;\n\n  // Repeat until \"regstack\" is empty.\n  for (;;)\n  {\n    // Some\
    \ patterns may take a long time to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    //\
    \ Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n\
    \    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\
    \tmch_errmsg(\"(\\n\");\n    }\n#endif\n\n    // Repeat for items that can be\
    \ matched sequentially, without using the\n    // regstack.\n    for (;;)\n  \
    \  {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\
    \t}\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a 100 times to avoid\
    \ overhead.\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\
    \t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t\
    \    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\
    \tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char\
    \ *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t  \
    \  if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\t\tmch_errmsg(_(\"External\
    \ submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"\
    \    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char\
    \ *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t\
    \    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\top = OP(scan);\n\t\
    // Check for character class with NL added.\n\tif (!rex.reg_line_lbr && WITH_NL(op)\
    \ && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\
    \t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) &&\
    \ *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t \
    \ if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\
    \t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t \
    \   if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t \
    \ case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t\
    \  case RE_BOF:\n\t    // We're not at the beginning of the file when below the\
    \ first\n\t    // line where we started, not at the start of the line or we\n\t\
    \    // didn't start at the first line of the buffer.\n\t    if (rex.lnum != 0\
    \ || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum\
    \ > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_EOF:\n\t    if\
    \ (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\
    \n\t  case CURSOR:\n\t    // Check if the buffer is in a window and compare the\n\
    \t    // rex.reg_win->w_cursor position to the match position.\n\t    if (rex.reg_win\
    \ == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\
    \t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\
    \t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_MARK:\n\t    // Compare\
    \ the mark position to the match position.\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\
    \t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf,\
    \ mark, FALSE);\n\t\tif (pos == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum\
    \ <= 0)   // mark isn't set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\
    \t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\
    \t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t\
    \    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col\
    \ < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp !=\
    \ '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp\
    \ != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\
    \    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI\
    \ || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\
    \t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input\
    \ - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win\
    \ == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line))\
    \ + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\\
    <word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\
    \t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\
    \n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class\
    \ = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t\
    \    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class()\
    \ == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\
    \t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input\
    \ > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t \
    \   status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>;\
    \ rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match\
    \ at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t  \
    \  {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous\
    \ char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\
    \t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t||\
    \ prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\
    \t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\
    \t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\
    \t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t\
    \  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\t\
    status = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t\
    \  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input)\
    \ || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input,\
    \ rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if\
    \ (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t \
    \   else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL\
    \ || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if\
    \ (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if\
    \ (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if\
    \ (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if\
    \ (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if\
    \ (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if\
    \ (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if\
    \ (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if\
    \ (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\
    \n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif\
    \ (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t\
    \      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\
    \t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works;\
    \ happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if\
    \ (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t//\
    \ matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need\
    \ to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\
    \t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\
    \t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t\
    \    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\
    \t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\
    \t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t \
    \   {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored,\
    \ which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\
    \t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\
    \trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case\
    \ ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan),\
    \ c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\
    i, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\
    \t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling\
    \ the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status\
    \ = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\
    \t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing\
    \ char is given match at any\n\t\t    // position where that composing char appears.\n\
    \t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\
    \t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input\
    \ + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include\
    \ all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input +\
    \ i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t\
    }\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\
    \t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input\
    \ += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case\
    \ RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\
    \t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\
    \t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t\
    \    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we\
    \ need to check if we don't keep\n\t\t// looping without matching any input. \
    \ The second and later\n\t\t// times a BACK is encountered it fails if the input\
    \ is still\n\t\t// at the same position as the previous time.\n\t\t// The positions\
    \ are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\"\
    , the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\
    for (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\
    \tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK,\
    \ make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\
    \tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again,\
    \ it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan\
    \ = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\
    \t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\
    \n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos,\
    \ &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\\
    zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t\
    \  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN +\
    \ 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\
    \t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after\
    \ \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\
    \t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef\
    \ FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\
    \t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN\
    \ + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\
    \t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE\
    \ + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE +\
    \ 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case\
    \ MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\
    \t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status\
    \ = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply\
    \ continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\
    #ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE +\
    \ 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case\
    \ ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\
    \t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE,\
    \ scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t\
    \    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\
    \t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the\
    \ result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF\
    \ + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t\
    \  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF\
    \ + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\
    \t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\
    \t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\
    \t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t   \
    \ }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in\
    \ the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\
    \t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status\
    \ = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t\
    {\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum\
    \ < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\t\
    len = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum\
    \ == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t\
    \    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\
    \t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line +\
    \ rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\t\
    status = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation:\
    \ Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\
    \t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\
    \t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\
    \t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\
    \t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input\
    \ += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t\
    \  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\
    \t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\
    \t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif\
    \ (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t\
    {\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\
    \t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\
    \t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set:\
    \ Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\
    \t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t\
    // Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus =\
    \ RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\
    \t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\
    \t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\
    \t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\
    \t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\
    \t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"\
    BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t\
    \  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX\
    \ + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX\
    \ + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX\
    \ + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\
    \t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\
    \t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no]\
    \ : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\
    \trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext =\
    \ OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t\
    \    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching\
    \ some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range\
    \ is the normal way around, use longest match\n\t\t    if (brace_count[no] <=\
    \ brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\
    \t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t\
    \    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t\
    \    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when\
    \ done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards,\
    \ use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t\
    \    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\
    \t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t\
    }\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case\
    \ STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid\
    \ useless match attempts when we know\n\t\t// what character comes next.\n\t\t\
    if (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t   \
    \ if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic\
    \ = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\
    \t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op !=\
    \ BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval\
    \ = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t\
    \    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching\
    \ as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching\
    \ at least the\n\t\t// minimal number (since the range is backwards, that's also\n\
    \t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\t\
    if (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif\
    \ (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >=\
    \ rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match\
    \ what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t\
    \    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len\
    \ >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\
    \t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T))\
    \ == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len\
    \ += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\
    \t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t\
    \    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1)\
    \ = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\
    \t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\
    \n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH,\
    \ scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\
    \trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\
    \t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\
    \t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra\
    \ positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\
    \    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus\
    \ = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T))\
    \ == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len +=\
    \ sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp\
    \ == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save\
    \ the subexpr to be able to restore them\n\t\t    // when there is a match but\
    \ we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t   \
    \ rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    //\
    \ First try if what follows matches.  If it does then we\n\t\t    // check the\
    \ behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t\
    \    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status\
    \ = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL ||\
    \ !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\
    \t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t\
    \    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\
    \t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\
    \n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t\
    \    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\
    \t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the\
    \ inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner\
    \ loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n\
    \    // If there is something on the regstack execute the code for the state.\n\
    \    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len\
    \ > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data\
    \ + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t\
    \    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\
    \t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when\
    \ there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\
    \t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch\
    \ matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status\
    \ != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\
    \t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\
    \t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more\
    \ branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan\
    \ = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan\
    \ = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\
    --brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There\
    \ was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after\
    \ \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t   \
    \ if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case\
    \ RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no\
    \ match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match\
    \ one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\
    \t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus\
    \ = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the\
    \ state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT,\
    \ we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the\
    \ next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no\
    \ != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan =\
    \ regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\
    \t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.\
    \  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t\
    // position in the input.  This must be done at every\n\t\t// position in the\
    \ input and checking if the match ends at\n\t\t// the current position.\n\n\t\t\
    // save the position after the found match for next\n\t\treg_save(&(((regbehind_T\
    \ *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with\
    \ operand at the current\n\t\t// position.  Go back one character until we find\
    \ the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line\
    \ (for multi-line matching).\n\t\t// Set behind_pos to where the match should\
    \ end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T\
    \ *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\
    \n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\
    \t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH &&\
    \ reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where\
    \ \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\
    \t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\
    \t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want\
    \ a match.  Need to restore the\n\t\t    // subexpr, because what follows matched,\
    \ so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that\
    \ doesn't end where we want it: Go\n\t\t// back one character.  May go to previous\
    \ line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\
    \t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\
    \t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\
    \t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col\
    \ >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col\
    \ == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\
    \t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\
    \t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\
    \t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\
    \t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\
    \n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\
    \t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\
    \t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t  \
    \  else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\
    \t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr)\
    \ > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\
    \t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status ==\
    \ RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\
    \t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\
    \t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos\
    \ = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\
    \t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\
    \t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t\
    \    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr\
    \ if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status\
    \ == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\
    \t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp)\
    \ - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\
    \t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried\
    \ once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t   \
    \ reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a\
    \ position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\
    \t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state\
    \ == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't\
    \ or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count\
    \ < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t\
    \    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum\
    \ == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\
    \t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t\
    // Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line\
    \ == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\
    \t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line,\
    \ rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards,\
    \ use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\
    \t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\
    \t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan),\
    \ 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\
    \t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t\
    \    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input\
    \ == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\
    \t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\
    \t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\
    \t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\
    \t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t//\
    \ continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\
    \t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\
    \n    // May need to continue with the inner loop, starting at \"scan\".\n   \
    \ if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something\
    \ failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n  \
    \  {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble --\
    \ normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n\
    #ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status\
    \ == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n\
    \  // NOTREACHED\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nregmatch(\n    char_u\t\
    *scan,\t\t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit\
    \ or NULL\n    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n\
    \  char_u\t*next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n\
    \  int\t\tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n\
    \  int\t\ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.\
    \  They are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free()\
    \ calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"\
    regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time\
    \ to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with\
    \ CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n\
    \    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n\
    #endif\n\n    // Repeat for items that can be matched sequentially, without using\
    \ the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\
    \t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check\
    \ for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count\
    \ == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t \
    \   {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\
    \t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\
    \t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n\
    # ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\
    \t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP;\
    \ i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i]\
    \ != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\
    \\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\
    \top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr\
    \ && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <=\
    \ rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr\
    \ && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\
    \telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\
    \t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t\
    \  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus\
    \ = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus\
    \ = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning\
    \ of the file when below the first\n\t    // line where we started, not at the\
    \ start of the line or we\n\t    // didn't start at the first line of the buffer.\n\
    \t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI\
    \ && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\
    \t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window\
    \ and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\
    \t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\
    \t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\
    \t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\
    \n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\
    \t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\
    \t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos\
    \ == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't\
    \ set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\
    \t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\
    \t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t   \
    \ if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col\
    \ < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp !=\
    \ '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp\
    \ != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\
    \    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI\
    \ || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\
    \t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input\
    \ - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win\
    \ == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line))\
    \ + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\\
    <word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\
    \t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\
    \n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class\
    \ = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t\
    \    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class()\
    \ == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\
    \t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input\
    \ > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t \
    \   status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>;\
    \ rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match\
    \ at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t  \
    \  {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous\
    \ char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\
    \t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t||\
    \ prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\
    \t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\
    \t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\
    \t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t\
    \  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\t\
    status = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t\
    \  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input)\
    \ || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input,\
    \ rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if\
    \ (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t \
    \   else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL\
    \ || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if\
    \ (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if\
    \ (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if\
    \ (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if\
    \ (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if\
    \ (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if\
    \ (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if\
    \ (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if\
    \ (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\
    \n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif\
    \ (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t\
    \      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\
    \t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works;\
    \ happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if\
    \ (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t//\
    \ matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need\
    \ to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\
    \t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\
    \t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t\
    \    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\
    \t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\
    \t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t \
    \   {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored,\
    \ which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\
    \t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\
    \trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case\
    \ ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan),\
    \ c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\
    i, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\
    \t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling\
    \ the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status\
    \ = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\
    \t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing\
    \ char is given match at any\n\t\t    // position where that composing char appears.\n\
    \t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\
    \t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input\
    \ + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include\
    \ all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input +\
    \ i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t\
    }\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\
    \t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input\
    \ += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case\
    \ RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\
    \t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\
    \t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t\
    \    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we\
    \ need to check if we don't keep\n\t\t// looping without matching any input. \
    \ The second and later\n\t\t// times a BACK is encountered it fails if the input\
    \ is still\n\t\t// at the same position as the previous time.\n\t\t// The positions\
    \ are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\"\
    , the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\
    for (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\
    \tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK,\
    \ make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\
    \tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again,\
    \ it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan\
    \ = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\
    \t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\
    \n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos,\
    \ &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\\
    zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t\
    \  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN +\
    \ 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\
    \t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after\
    \ \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\
    \t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef\
    \ FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\
    \t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN\
    \ + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\
    \t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE\
    \ + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE +\
    \ 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case\
    \ MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\
    \t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status\
    \ = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply\
    \ continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\
    #ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE +\
    \ 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case\
    \ ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\
    \t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE,\
    \ scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t\
    \    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\
    \t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the\
    \ result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF\
    \ + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t\
    \  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF\
    \ + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\
    \t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\
    \t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\
    \t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t   \
    \ }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in\
    \ the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\
    \t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status\
    \ = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t\
    {\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum\
    \ < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\t\
    len = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum\
    \ == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t\
    \    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\
    \t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line +\
    \ rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\t\
    status = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation:\
    \ Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\
    \t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\
    \t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\
    \t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\
    \t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input\
    \ += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t\
    \  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\
    \t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\
    \t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif\
    \ (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t\
    {\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\
    \t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\
    \t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set:\
    \ Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\
    \t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t\
    // Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus =\
    \ RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\
    \t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\
    \t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\
    \t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\
    \t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\
    \t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"\
    BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t\
    \  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX\
    \ + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX\
    \ + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX\
    \ + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\
    \t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\
    \t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no]\
    \ : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\
    \trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext =\
    \ OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t\
    \    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching\
    \ some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range\
    \ is the normal way around, use longest match\n\t\t    if (brace_count[no] <=\
    \ brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\
    \t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t\
    \    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t\
    \    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when\
    \ done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards,\
    \ use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t\
    \    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\
    \t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t\
    }\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case\
    \ STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid\
    \ useless match attempts when we know\n\t\t// what character comes next.\n\t\t\
    if (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t   \
    \ if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic\
    \ = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\
    \t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op !=\
    \ BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval\
    \ = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t\
    \    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching\
    \ as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching\
    \ at least the\n\t\t// minimal number (since the range is backwards, that's also\n\
    \t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\t\
    if (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif\
    \ (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >=\
    \ rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match\
    \ what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t\
    \    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len\
    \ >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\
    \t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T))\
    \ == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len\
    \ += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\
    \t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t\
    \    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1)\
    \ = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\
    \t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\
    \n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH,\
    \ scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\
    \trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\
    \t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\
    \t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra\
    \ positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\
    \    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus\
    \ = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T))\
    \ == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len +=\
    \ sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp\
    \ == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save\
    \ the subexpr to be able to restore them\n\t\t    // when there is a match but\
    \ we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t   \
    \ rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    //\
    \ First try if what follows matches.  If it does then we\n\t\t    // check the\
    \ behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t\
    \    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status\
    \ = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL ||\
    \ !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\
    \t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t\
    \    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\
    \t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\
    \n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t\
    \    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\
    \t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the\
    \ inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner\
    \ loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n\
    \    // If there is something on the regstack execute the code for the state.\n\
    \    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len\
    \ > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data\
    \ + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t\
    \    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\
    \t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when\
    \ there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\
    \t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch\
    \ matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status\
    \ != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\
    \t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\
    \t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more\
    \ branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan\
    \ = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan\
    \ = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\
    --brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There\
    \ was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after\
    \ \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t   \
    \ if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case\
    \ RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no\
    \ match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match\
    \ one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\
    \t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus\
    \ = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the\
    \ state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT,\
    \ we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the\
    \ next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no\
    \ != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan =\
    \ regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\
    \t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.\
    \  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t\
    // position in the input.  This must be done at every\n\t\t// position in the\
    \ input and checking if the match ends at\n\t\t// the current position.\n\n\t\t\
    // save the position after the found match for next\n\t\treg_save(&(((regbehind_T\
    \ *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with\
    \ operand at the current\n\t\t// position.  Go back one character until we find\
    \ the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line\
    \ (for multi-line matching).\n\t\t// Set behind_pos to where the match should\
    \ end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T\
    \ *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\
    \n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\
    \t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH &&\
    \ reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where\
    \ \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\
    \t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\
    \t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want\
    \ a match.  Need to restore the\n\t\t    // subexpr, because what follows matched,\
    \ so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that\
    \ doesn't end where we want it: Go\n\t\t// back one character.  May go to previous\
    \ line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\
    \t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\
    \t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\
    \t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col\
    \ >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col\
    \ == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\
    \t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\
    \t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\
    \t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\
    \t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\
    \n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\
    \t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\
    \t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t  \
    \  else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\
    \t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr)\
    \ > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\
    \t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status ==\
    \ RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\
    \t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\
    \t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos\
    \ = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\
    \t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\
    \t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t\
    \    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr\
    \ if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status\
    \ == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\
    \t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp)\
    \ - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\
    \t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried\
    \ once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t   \
    \ reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a\
    \ position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\
    \t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state\
    \ == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't\
    \ or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count\
    \ < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t\
    \    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum\
    \ == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\
    \t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t\
    // Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line\
    \ == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\
    \t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line,\
    \ rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards,\
    \ use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\
    \t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\
    \t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan),\
    \ 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\
    \t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t\
    \    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input\
    \ == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\
    \t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\
    \t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\
    \t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\
    \t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t//\
    \ continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\
    \t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\
    \n    // May need to continue with the inner loop, starting at \"scan\".\n   \
    \ if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something\
    \ failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n  \
    \  {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble --\
    \ normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n\
    #ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status\
    \ == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n\
    \  // NOTREACHED\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    model: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    model_type: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nregmatch(\n    char_u\t*scan,\t\t    //\
    \ Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n \
    \   int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t*next;\t\
    \t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n\
    \  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\t\
    tm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They are\
    \ allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free() calls.\n\
    \  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"regstack\"\
    \ is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time to match,\
    \ e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with CTRL-C.\n\
    \    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n\
    \    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n\
    #endif\n\n    // Repeat for items that can be matched sequentially, without using\
    \ the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\
    \t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check\
    \ for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count\
    \ == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t \
    \   {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\
    \t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\
    \t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n\
    # ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\
    \t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP;\
    \ i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i]\
    \ != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\
    \\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\
    \top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr\
    \ && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <=\
    \ rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr\
    \ && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\
    \telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\
    \t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t\
    \  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus\
    \ = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus\
    \ = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning\
    \ of the file when below the first\n\t    // line where we started, not at the\
    \ start of the line or we\n\t    // didn't start at the first line of the buffer.\n\
    \t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI\
    \ && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\
    \t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window\
    \ and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\
    \t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\
    \t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\
    \t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\
    \n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\
    \t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\
    \t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos\
    \ == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't\
    \ set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\
    \t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\
    \t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t   \
    \ if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col\
    \ < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp !=\
    \ '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp\
    \ != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\
    \    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI\
    \ || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\
    \t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input\
    \ - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win\
    \ == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line))\
    \ + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\\
    <word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\
    \t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\
    \n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class\
    \ = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t\
    \    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class()\
    \ == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\
    \t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input\
    \ > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t \
    \   status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>;\
    \ rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match\
    \ at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t  \
    \  {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous\
    \ char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\
    \t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t||\
    \ prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\
    \t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\
    \t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\
    \t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t\
    \  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\t\
    status = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t\
    \  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input)\
    \ || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input,\
    \ rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if\
    \ (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t \
    \   else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL\
    \ || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if\
    \ (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if\
    \ (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if\
    \ (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if\
    \ (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if\
    \ (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if\
    \ (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if\
    \ (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if\
    \ (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\
    \n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif\
    \ (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t\
    \      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\
    \t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works;\
    \ happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if\
    \ (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t//\
    \ matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need\
    \ to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\
    \t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\
    \t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t\
    \    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\
    \t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\
    \t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t \
    \   {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored,\
    \ which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\
    \t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\
    \trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case\
    \ ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan),\
    \ c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\
    i, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\
    \t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling\
    \ the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status\
    \ = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\
    \t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing\
    \ char is given match at any\n\t\t    // position where that composing char appears.\n\
    \t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\
    \t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input\
    \ + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include\
    \ all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input +\
    \ i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t\
    }\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\
    \t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input\
    \ += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case\
    \ RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\
    \t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\
    \t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t\
    \    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we\
    \ need to check if we don't keep\n\t\t// looping without matching any input. \
    \ The second and later\n\t\t// times a BACK is encountered it fails if the input\
    \ is still\n\t\t// at the same position as the previous time.\n\t\t// The positions\
    \ are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\"\
    , the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\
    for (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\
    \tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK,\
    \ make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\
    \tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again,\
    \ it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan\
    \ = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\
    \t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\
    \n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos,\
    \ &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\\
    zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t\
    \  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN +\
    \ 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\
    \t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after\
    \ \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\
    \t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef\
    \ FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\
    \t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN\
    \ + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\
    \t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE\
    \ + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE +\
    \ 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case\
    \ MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\
    \t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status\
    \ = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply\
    \ continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\
    #ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE +\
    \ 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case\
    \ ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\
    \t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE,\
    \ scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t\
    \    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\
    \t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the\
    \ result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF\
    \ + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t\
    \  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF\
    \ + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\
    \t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\
    \t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\
    \t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t   \
    \ }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in\
    \ the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\
    \t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status\
    \ = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t\
    {\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum\
    \ < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\t\
    len = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum\
    \ == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t\
    \    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\
    \t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line +\
    \ rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\t\
    status = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation:\
    \ Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\
    \t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\
    \t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\
    \t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\
    \t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input\
    \ += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t\
    \  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\
    \t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\
    \t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif\
    \ (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t\
    {\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\
    \t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\
    \t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set:\
    \ Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\
    \t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t\
    // Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus =\
    \ RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\
    \t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\
    \t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\
    \t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\
    \t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\
    \t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"\
    BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t\
    \  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX\
    \ + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX\
    \ + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX\
    \ + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\
    \t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\
    \t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no]\
    \ : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\
    \trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext =\
    \ OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t\
    \    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching\
    \ some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range\
    \ is the normal way around, use longest match\n\t\t    if (brace_count[no] <=\
    \ brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\
    \t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t\
    \    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t\
    \    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when\
    \ done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards,\
    \ use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t\
    \    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\
    \t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t\
    }\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case\
    \ STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid\
    \ useless match attempts when we know\n\t\t// what character comes next.\n\t\t\
    if (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t   \
    \ if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic\
    \ = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\
    \t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op !=\
    \ BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval\
    \ = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t\
    \    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching\
    \ as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching\
    \ at least the\n\t\t// minimal number (since the range is backwards, that's also\n\
    \t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\t\
    if (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif\
    \ (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >=\
    \ rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match\
    \ what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t\
    \    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len\
    \ >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\
    \t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T))\
    \ == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len\
    \ += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\
    \t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t\
    \    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1)\
    \ = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\
    \t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\
    \n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH,\
    \ scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\
    \trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\
    \t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\
    \t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra\
    \ positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\
    \    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus\
    \ = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T))\
    \ == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len +=\
    \ sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp\
    \ == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save\
    \ the subexpr to be able to restore them\n\t\t    // when there is a match but\
    \ we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t   \
    \ rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    //\
    \ First try if what follows matches.  If it does then we\n\t\t    // check the\
    \ behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t\
    \    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status\
    \ = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL ||\
    \ !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\
    \t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t\
    \    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\
    \t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\
    \n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t\
    \    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\
    \t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the\
    \ inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner\
    \ loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n\
    \    // If there is something on the regstack execute the code for the state.\n\
    \    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len\
    \ > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data\
    \ + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t\
    \    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\
    \t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when\
    \ there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\
    \t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch\
    \ matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status\
    \ != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\
    \t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\
    \t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more\
    \ branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan\
    \ = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan\
    \ = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\
    --brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There\
    \ was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after\
    \ \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t   \
    \ if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case\
    \ RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no\
    \ match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match\
    \ one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\
    \t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus\
    \ = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the\
    \ state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT,\
    \ we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the\
    \ next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no\
    \ != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan =\
    \ regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\
    \t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.\
    \  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t\
    // position in the input.  This must be done at every\n\t\t// position in the\
    \ input and checking if the match ends at\n\t\t// the current position.\n\n\t\t\
    // save the position after the found match for next\n\t\treg_save(&(((regbehind_T\
    \ *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with\
    \ operand at the current\n\t\t// position.  Go back one character until we find\
    \ the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line\
    \ (for multi-line matching).\n\t\t// Set behind_pos to where the match should\
    \ end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T\
    \ *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\
    \n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\
    \t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH &&\
    \ reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where\
    \ \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\
    \t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\
    \t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want\
    \ a match.  Need to restore the\n\t\t    // subexpr, because what follows matched,\
    \ so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that\
    \ doesn't end where we want it: Go\n\t\t// back one character.  May go to previous\
    \ line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\
    \t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\
    \t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\
    \t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col\
    \ >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col\
    \ == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\
    \t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\
    \t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\
    \t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\
    \t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\
    \n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\
    \t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\
    \t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t  \
    \  else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\
    \t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr)\
    \ > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\
    \t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status ==\
    \ RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\
    \t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\
    \t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos\
    \ = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\
    \t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\
    \t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t\
    \    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr\
    \ if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status\
    \ == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\
    \t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp)\
    \ - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\
    \t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried\
    \ once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t   \
    \ reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a\
    \ position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\
    \t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state\
    \ == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't\
    \ or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count\
    \ < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t\
    \    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum\
    \ == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\
    \t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t\
    // Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line\
    \ == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\
    \t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line,\
    \ rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards,\
    \ use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\
    \t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\
    \t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan),\
    \ 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\
    \t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t\
    \    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input\
    \ == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\
    \t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\
    \t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\
    \t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\
    \t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t//\
    \ continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\
    \t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\
    \n    // May need to continue with the inner loop, starting at \"scan\".\n   \
    \ if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something\
    \ failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n  \
    \  {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble --\
    \ normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n\
    #ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status\
    \ == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n\
    \  // NOTREACHED\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nregmatch(\n    char_u\t*scan,\t\
    \t    // Current node.\n    proftime_T\t*tm UNUSED,\t    // timeout limit or NULL\n\
    \    int\t\t*timed_out UNUSED)  // flag set on timeout or NULL\n{\n  char_u\t\
    *next;\t\t// Next node.\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\
    \tno;\n  int\t\tstatus;\t\t// one of the RA_ values:\n#ifdef FEAT_RELTIME\n  int\t\
    \ttm_count = 0;\n#endif\n\n  // Make \"regstack\" and \"backpos\" empty.  They\
    \ are allocated and freed in\n  // bt_regexec_both() to reduce malloc()/free()\
    \ calls.\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n\n  // Repeat until \"\
    regstack\" is empty.\n  for (;;)\n  {\n    // Some patterns may take a long time\
    \ to match, e.g., \"\\([a-z]\\+\\)\\+Q\".\n    // Allow interrupting them with\
    \ CTRL-C.\n    fast_breakcheck();\n\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n\
    \    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n\
    #endif\n\n    // Repeat for items that can be matched sequentially, without using\
    \ the\n    // regstack.\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\
    \t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\t// Check\
    \ for timeout once in a 100 times to avoid overhead.\n\tif (tm != NULL && ++tm_count\
    \ == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t \
    \   {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\
    \t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n\n#ifdef DEBUG\n\tif (regnarrate)\n\
    \t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n\
    # ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\n\
    \t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP;\
    \ i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i]\
    \ != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\
    \\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\n\
    \top = OP(scan);\n\t// Check for character class with NL added.\n\tif (!rex.reg_line_lbr\
    \ && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <=\
    \ rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr\
    \ && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\
    \telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\
    \t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t\
    \  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus\
    \ = RA_NOMATCH;\n\t    break;\n\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus\
    \ = RA_NOMATCH;\n\t    break;\n\n\t  case RE_BOF:\n\t    // We're not at the beginning\
    \ of the file when below the first\n\t    // line where we started, not at the\
    \ start of the line or we\n\t    // didn't start at the first line of the buffer.\n\
    \t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI\
    \ && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\
    \t    break;\n\n\t  case CURSOR:\n\t    // Check if the buffer is in a window\
    \ and compare the\n\t    // rex.reg_win->w_cursor position to the match position.\n\
    \t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\
    \t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\
    \t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\
    \n\t  case RE_MARK:\n\t    // Compare the mark position to the match position.\n\
    \t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\
    \t\tpos_T\t*pos;\n\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (pos\
    \ == NULL\t\t     // mark doesn't exist\n\t\t\t|| pos->lnum <= 0)   // mark isn't\
    \ set in reg_buf\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\
    \t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\
    \t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t   \
    \ if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col\
    \ < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp !=\
    \ '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp\
    \ != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\
    \    }\n\t    break;\n\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_LNUM:\n\t    if (!REG_MULTI\
    \ || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\
    \t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input\
    \ - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case\
    \ RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win\
    \ == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line))\
    \ + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case BOW:\t// \\\
    <word; rex.input points to w\n\t    if (c == NUL)\t// Can't match at end of line\n\
    \t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\
    \n\t\t// Get class of current and previous char (if it exists).\n\t\tthis_class\
    \ = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t\
    \    status = RA_NOMATCH;  // not on a word at all\n\t\telse if (reg_prev_class()\
    \ == this_class)\n\t\t    status = RA_NOMATCH;  // previous char is in same word\n\
    \t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input\
    \ > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t \
    \   status = RA_NOMATCH;\n\t    }\n\t    break;\n\n\t  case EOW:\t// word\\>;\
    \ rex.input points after d\n\t    if (rex.input == rex.line)    // Can't match\
    \ at start of line\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t  \
    \  {\n\t\tint this_class, prev_class;\n\n\t\t// Get class of current and previous\
    \ char (if it exists).\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\
    \t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t||\
    \ prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\
    \t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\
    \t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\
    \t\t    status = RA_NOMATCH;\n\t    }\n\t    break; // Matched with EOW\n\n\t\
    \  case ANY:\n\t    // ANY does not match new lines.\n\t    if (c == NUL)\n\t\t\
    status = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t\
    \  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input)\
    \ || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input,\
    \ rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case SFNAME:\n\t    if\
    \ (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t \
    \   else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\
    \t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\
    \t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWHITE:\n\t    if (c == NUL\
    \ || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NDIGIT:\n\t    if\
    \ (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEX:\n\t    if\
    \ (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NOCTAL:\n\t    if\
    \ (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NWORD:\n\t    if\
    \ (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NHEAD:\n\t    if\
    \ (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NALPHA:\n\t    if\
    \ (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NLOWER:\n\t    if\
    \ (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\
    \t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\n\t  case NUPPER:\n\t    if\
    \ (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\
    \n\t\topnd = OPERAND(scan);\n\t\t// Inline the first byte, for speed.\n\t\tif\
    \ (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t\
    \      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\
    \t\telse if (*opnd == NUL)\n\t\t{\n\t\t    // match empty string always works;\
    \ happens when \"~\" is\n\t\t    // empty.\n\t\t}\n\t\telse\n\t\t{\n\t\t    if\
    \ (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t//\
    \ matched a single byte above\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Need\
    \ to match first byte again for multi-byte.\n\t\t\tlen = (int)STRLEN(opnd);\n\t\
    \t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\
    \t\t    }\n\t\t    // Check for following composing character, unless %C\n\t\t\
    \    // follows (skips over all composing chars).\n\t\t    if (status != RA_NOMATCH\n\
    \t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\
    \t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t \
    \   {\n\t\t\t// raaron: This code makes a composing character get\n\t\t\t// ignored,\
    \ which is the correct behavior (sometimes)\n\t\t\t// for voweled Hebrew texts.\n\
    \t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\
    \trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\n\t  case ANYOF:\n\t  case\
    \ ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan),\
    \ c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\
    \t    break;\n\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\t\
    i, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\n\t\topnd = OPERAND(scan);\n\
    \t\t// Safety check (just in case 'encoding' was changed since\n\t\t// compiling\
    \ the program).\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status\
    \ = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\
    \t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    // When only a composing\
    \ char is given match at any\n\t\t    // position where that composing char appears.\n\
    \t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\
    \t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input\
    \ + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    // Include\
    \ all following composing chars.\n\t\t\t    len = i + utfc_ptr2len(rex.input +\
    \ i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t\
    }\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\
    \t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input\
    \ += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case\
    \ RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\t// Skip composing characters.\n\
    \t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\
    \t    }\n\t    break;\n\n\t  case NOTHING:\n\t    break;\n\n\t  case BACK:\n\t\
    \    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\n\t\t// When we run into BACK we\
    \ need to check if we don't keep\n\t\t// looping without matching any input. \
    \ The second and later\n\t\t// times a BACK is encountered it fails if the input\
    \ is still\n\t\t// at the same position as the previous time.\n\t\t// The positions\
    \ are stored in \"backpos\" and found by the\n\t\t// current value of \"scan\"\
    , the position in the RE program.\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\
    for (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\
    \tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    // First time at this BACK,\
    \ make room to store the pos.\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\
    \tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\t// get \"ga_data\" again,\
    \ it may have changed\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan\
    \ = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\
    \t\t    // Still at same position as last time, fail.\n\t\t    status = RA_NOMATCH;\n\
    \n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos,\
    \ &backpos);\n\t    }\n\t    break;\n\n\t  case MOPEN + 0:   // Match start: \\\
    zs\n\t  case MOPEN + 1:   // \\(\n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t\
    \  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN +\
    \ 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\
    \t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n\n\t  case NOPEN:\t    // \\%(\n\t  case NCLOSE:\t    // \\) after\
    \ \\%(\n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\
    \t\t// We simply continue and handle the result when done.\n\t\tbreak;\n\n#ifdef\
    \ FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\
    \t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN\
    \ + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\
    \t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp ==\
    \ NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\
    \t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\
    \t\t    // We simply continue and handle the result when done.\n\t\t}\n\t    }\n\
    \t    break;\n#endif\n\n\t  case MCLOSE + 0:  // Match end: \\ze\n\t  case MCLOSE\
    \ + 1:  // \\)\n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE +\
    \ 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case\
    \ MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\
    \t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status\
    \ = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t    // We simply\
    \ continue and handle the result when done.\n\t\t}\n\t    }\n\t    break;\n\n\
    #ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  // \\) after \\z(\n\t  case ZCLOSE +\
    \ 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case\
    \ ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\
    \t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE,\
    \ scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t\
    \    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\
    \t\t\t\t\t\t      &reg_endzp[no]);\n\t\t    // We simply continue and handle the\
    \ result when done.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BACKREF\
    \ + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t\
    \  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF\
    \ + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\n\t\tno = op - BACKREF;\n\
    \t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t// Single-line regexp\n\t\t{\n\t\
    \t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\
    \t\t\t// Backref was not set: Match an empty string.\n\t\t\tlen = 0;\n\t\t   \
    \ }\n\t\t    else\n\t\t    {\n\t\t\t// Compare current input with back-ref in\
    \ the same\n\t\t\t// line.\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\
    \t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status\
    \ = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t// Multi-line regexp\n\t\t\
    {\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum\
    \ < 0)\n\t\t    {\n\t\t\t// Backref was not set: Match an empty string.\n\t\t\t\
    len = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum\
    \ == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t\
    \    // Compare back-ref within the current line.\n\t\t\t    len = rex.reg_endpos[no].col\n\
    \t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line +\
    \ rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\t\
    status = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Messy situation:\
    \ Need to compare between two\n\t\t\t    // lines.\n\t\t\t    int r = match_with_backref(\n\
    \t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\
    \t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\
    \t\t\t\t\t    &len);\n\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\
    \t}\n\t\t    }\n\t\t}\n\n\t\t// Matched the backref, skip over it.\n\t\trex.input\
    \ += len;\n\t    }\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t\
    \  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\
    \t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\
    \t    {\n\t\tint\tlen;\n\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif\
    \ (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t\
    {\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\
    \t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\
    \t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Backref was not set:\
    \ Match an empty string.\n\t\t}\n\t    }\n\t    break;\n#endif\n\n\t  case BRANCH:\n\
    \t    {\n\t\tif (OP(next) != BRANCH) // No choice.\n\t\t    next = OPERAND(scan);\t\
    // Avoid recursion.\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus =\
    \ RA_BREAK;\t// rest is below\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_LIMITS:\n\
    \t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\
    \t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\
    \t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\
    \t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\
    \t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"\
    BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\n\t\
    \  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX\
    \ + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX\
    \ + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX\
    \ + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\
    \t++brace_count[no];\n\n\t\t// If not matched enough times yet, try one more\n\
    \t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no]\
    \ : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\
    \t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\
    \trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext =\
    \ OPERAND(scan);\n\t\t\t// We continue and handle the result when done.\n\t\t\
    \    }\n\t\t    break;\n\t\t}\n\n\t\t// If matched enough times, may try matching\
    \ some more\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    // Range\
    \ is the normal way around, use longest match\n\t\t    if (brace_count[no] <=\
    \ brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\
    \t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t\
    \    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t\
    \    next = OPERAND(scan);\n\t\t\t    // We continue and handle the result when\
    \ done.\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Range is backwards,\
    \ use shortest match first\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t\
    \    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\
    \t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    // We continue and handle the result when done.\n\t\t\t\
    }\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\t  case BRACE_SIMPLE:\n\t  case\
    \ STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\n\t\t// Lookahead to avoid\
    \ useless match attempts when we know\n\t\t// what character comes next.\n\t\t\
    if (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t   \
    \ if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic\
    \ = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\
    \t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op !=\
    \ BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval\
    \ = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t\
    \    rst.maxval = bl_maxval;\n\t\t}\n\n\t\t// When maxval > minval, try matching\
    \ as much as possible, up\n\t\t// to maxval.  When maxval < minval, try matching\
    \ at least the\n\t\t// minimal number (since the range is backwards, that's also\n\
    \t\t// maxval!).\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\t\
    if (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif\
    \ (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >=\
    \ rst.maxval)\n\t\t{\n\t\t    // It could match.  Prepare for trying to match\
    \ what\n\t\t    // follows.  The code is below.  Parameters are stored in\n\t\t\
    \    // a regstar_T on the regstack.\n\t\t    if ((long)((unsigned)regstack.ga_len\
    \ >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\
    \t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T))\
    \ == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len\
    \ += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\
    \t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t\
    \    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1)\
    \ = rst;\n\t\t\t    status = RA_BREAK;\t    // skip the restore bits\n\t\t\t}\n\
    \t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\n\t    }\n\t    break;\n\
    \n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH,\
    \ scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\
    \trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\
    \t\t// We continue and handle the result when done.\n\t    }\n\t    break;\n\n\
    \t  case BEHIND:\n\t  case NOBEHIND:\n\t    // Need a bit of room to store extra\
    \ positions.\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\
    \    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus\
    \ = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T))\
    \ == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len +=\
    \ sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp\
    \ == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    // Need to save\
    \ the subexpr to be able to restore them\n\t\t    // when there is a match but\
    \ we don't use it.\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\n\t\t   \
    \ rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    //\
    \ First try if what follows matches.  If it does then we\n\t\t    // check the\
    \ behind match by looping.\n\t\t}\n\t    }\n\t    break;\n\n\t  case BHPOS:\n\t\
    \    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input\
    \ - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status\
    \ = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\
    \tstatus = RA_NOMATCH;\n\t    break;\n\n\t  case NEWL:\n\t    if ((c != NUL ||\
    \ !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\
    \t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t\
    \    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\
    \t    break;\n\n\t  case END:\n\t    status = RA_MATCH;\t// Success!\n\t    break;\n\
    \n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t\
    \    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\
    \t    break;\n\t  }\n\t}\n\n\t// If we can't continue sequentially, break the\
    \ inner loop.\n\tif (status != RA_CONT)\n\t    break;\n\n\t// Continue in inner\
    \ loop, advance to next item.\n\tscan = next;\n\n    } // end of inner loop\n\n\
    \    // If there is something on the regstack execute the code for the state.\n\
    \    // If the state is popped then loop and use the older state.\n    while (regstack.ga_len\
    \ > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data\
    \ + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t\
    \    // Result is passed on as-is, simply pop the state.\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_MOPEN:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\
    \t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_MCLOSE:\n\t    // Pop the state.  Restore pointers when\
    \ there is no match.\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave,\
    \ &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t\
    \    regstack_pop(&scan);\n\t    break;\n\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\
    \t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n\
    #endif\n\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\t// this branch\
    \ matched, use it\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status\
    \ != RA_BREAK)\n\t\t{\n\t\t    // After a non-matching branch: try next one.\n\
    \t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\
    \t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    // no more\
    \ branches, didn't find a match\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t    // Prepare to try a branch.\n\t\t    rp->rs_scan\
    \ = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan\
    \ = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_BRCPLX_MORE:\n\
    \t    // Pop the state.  Restore pointers when there is no match.\n\t    if (status\
    \ == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\
    --brace_count[rp->rs_no];\t// decrement match count\n\t    }\n\t    regstack_pop(&scan);\n\
    \t    break;\n\n\t  case RS_BRCPLX_LONG:\n\t    // Pop the state.  Restore pointers\
    \ when there is no match.\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\t// There\
    \ was no match, but we did find enough matches.\n\t\treg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\t// continue with the items after\
    \ \"\\{}\"\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t   \
    \ if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\n\t  case\
    \ RS_BRCPLX_SHORT:\n\t    // Pop the state.  Restore pointers when there is no\
    \ match.\n\t    if (status == RA_NOMATCH)\n\t\t// There was no match, try to match\
    \ one more item.\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\
    \t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus\
    \ = RA_CONT;\n\t    }\n\t    break;\n\n\t  case RS_NOMATCH:\n\t    // Pop the\
    \ state.  If the operand matches for NOMATCH or\n\t    // doesn't match for MATCH/SUBPAT,\
    \ we fail.  Otherwise backup,\n\t    // except for SUBPAT, and continue with the\
    \ next item.\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\
    \t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no\
    \ != SUBPAT)\t// zero-width\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan =\
    \ regnext(scan);\n\t    break;\n\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\
    \t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\t// The stuff after BEHIND/NOBEHIND matches.\
    \  Now try if\n\t\t// the behind part does (not) match before the current\n\t\t\
    // position in the input.  This must be done at every\n\t\t// position in the\
    \ input and checking if the match ends at\n\t\t// the current position.\n\n\t\t\
    // save the position after the found match for next\n\t\treg_save(&(((regbehind_T\
    \ *)rp) - 1)->save_after, &backpos);\n\n\t\t// Start looking for a match with\
    \ operand at the current\n\t\t// position.  Go back one character until we find\
    \ the\n\t\t// result, hitting the start of the line or the previous\n\t\t// line\
    \ (for multi-line matching).\n\t\t// Set behind_pos to where the match should\
    \ end, BHPOS\n\t\t// will match it.  Save the current value.\n\t\t(((regbehind_T\
    \ *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\
    \n\t\trp->rs_state = RS_BEHIND2;\n\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\
    \t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\n\t  case RS_BEHIND2:\n\
    \t    // Looping for BEHIND / NOBEHIND match.\n\t    if (status == RA_MATCH &&\
    \ reg_save_equal(&behind_pos))\n\t    {\n\t\t// found a match that ends where\
    \ \"next\" started\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\
    \t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\
    \t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    // But we didn't want\
    \ a match.  Need to restore the\n\t\t    // subexpr, because what follows matched,\
    \ so they have\n\t\t    // been set.\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\
    \t    }\n\t    else\n\t    {\n\t\tlong limit;\n\n\t\t// No match or a match that\
    \ doesn't end where we want it: Go\n\t\t// back one character.  May go to previous\
    \ line once.\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\
    \t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\
    \t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\
    \t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col\
    \ >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col\
    \ == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\
    \t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\
    \t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\
    \t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\
    \t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\
    \n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\
    \t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\
    \t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\
    \t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t  \
    \  else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\
    \t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr)\
    \ > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\
    \t\t    // Advanced, prepare for finding match again.\n\t\t    reg_restore(&rp->rs_un.regsave,\
    \ &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status ==\
    \ RA_MATCH)\n\t\t    {\n\t\t\t// We did match, so subexpr may have been changed,\n\
    \t\t\t// need to restore them for the next try.\n\t\t\tstatus = RA_NOMATCH;\n\t\
    \t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t\
    {\n\t\t    // Can't advance.  For NOBEHIND that's a match.\n\t\t    behind_pos\
    \ = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\
    \t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\
    \t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t\
    \    {\n\t\t\t// We do want a proper match.  Need to restore the\n\t\t\t// subexpr\
    \ if we had a match, because they may have\n\t\t\t// been set.\n\t\t\tif (status\
    \ == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T\
    \ *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\n\t  case RS_STAR_LONG:\n\
    \t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp)\
    \ - 1;\n\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\
    \t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\n\t\t// Tried\
    \ once already, restore input pointers.\n\t\tif (status != RA_BREAK)\n\t\t   \
    \ reg_restore(&rp->rs_un.regsave, &backpos);\n\n\t\t// Repeat until we found a\
    \ position where it could match.\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\
    \t\t    {\n\t\t\t// Tried first position already, advance.\n\t\t\tif (rp->rs_state\
    \ == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    // Trying for longest match, but couldn't\
    \ or\n\t\t\t    // didn't match -- back up one char.\n\t\t\t    if (--rst->count\
    \ < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t\
    \    {\n\t\t\t\t// backup to last char of previous line\n\t\t\t\tif (rex.lnum\
    \ == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\
    \t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\t\
    // Just in case regrepeat() didn't count\n\t\t\t\t// right.\n\t\t\t\tif (rex.line\
    \ == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\
    \t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line,\
    \ rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // Range is backwards,\
    \ use shortest match first.\n\t\t\t    // Careful: maxval and minval are exchanged!\n\
    \t\t\t    // Couldn't or didn't match: try advancing one\n\t\t\t    // char.\n\
    \t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan),\
    \ 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\
    \t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\n\t\t\
    \    // If it could match, try it.\n\t\t    if (rst->nextb == NUL || *rex.input\
    \ == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\
    \t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\
    \t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\
    \t\t{\n\t\t    // Failed.\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len\
    \ -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\
    \t}\n\n\t// If we want to continue the inner loop or didn't pop a state\n\t//\
    \ continue matching loop\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\
    \t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n\
    \n    // May need to continue with the inner loop, starting at \"scan\".\n   \
    \ if (status == RA_CONT)\n\tcontinue;\n\n    // If the regstack is empty or something\
    \ failed we are done.\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n  \
    \  {\n\tif (scan == NULL)\n\t{\n\t    // We get here only if there's trouble --\
    \ normally \"case END\" is\n\t    // the terminating point.\n\t    iemsg(_(e_corrupted_regexp_program));\n\
    #ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status\
    \ == RA_MATCH);\n    }\n\n  } // End of loop until the regstack is empty.\n\n\
    \  // NOTREACHED\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 201885
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
