agents:
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n\
    {\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message)\
    \ \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info);\
    \ \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info);\
    \ \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\
    \n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n\
    \    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n\
    \    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\
    \n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo\
    \ *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\
    \n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\
    \n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag\
    \ = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n  \
    \  interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation\
    \ = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format\
    \ = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n\
    \    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\
    \n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\
    \n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  assert(exception !=\
    \ (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\
    \  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"\
    %s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n\
    \  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n\
    \    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n \
    \   TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity\
    \ == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\"\
    );\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n\
    \      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank\
    \ images for subimage specification (e.g. image.tif[4].\n        We need to check\
    \ the number of directores because it is possible that\n        the subimage(s)\
    \ are stored in the photoshop profile.\n      */\n      if (image_info->scene\
    \ < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i <\
    \ (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff)\
    \ != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n \
    \             {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n\
    \            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n\
    \                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n\
    \          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse);\
    \ */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width)\
    \ != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n\
    \        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) !=\
    \ 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans)\
    \ != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP)\
    \ || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample\
    \ > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n\
    \      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n\
    \      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n\
    \    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n\
    \        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n   \
    \     break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n\
    \      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n  \
    \    }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\"\
    ,\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n\
    \      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry:\
    \ %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n\
    \        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits\
    \ per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"\
    ));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n\
    \    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\"\
    ,\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian\
    \ == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n\
    \    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"\
    tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n  \
    \      image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n\
    \    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n\
    \    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n\
    \    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG)\
    \ &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n\
    \    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n   \
    \   {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"\
    tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n       \
    \ (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n\
    \    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option\
    \ == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n\
    \      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans)\
    \ == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n\
    \      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans)\
    \ == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n\
    \        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n\
    \      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans)\
    \ == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n \
    \         image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n\
    \          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans)\
    \ == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n\
    \            image->chromaticity.white_point.y=chromaticity[1];\n          }\n\
    \      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n\
    \            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n\
    \            image->chromaticity.green_primary.y=chromaticity[3];\n          \
    \  image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n\
    \          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION\
    \ > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag)\
    \ == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"\
    CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n\
    \      case COMPRESSION_NONE: image->compression=NoCompression; break;\n     \
    \ case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n    \
    \  case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n\
    \      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n\
    #if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\
    \n           int\n             tiff_status;\n\n           uint16\n           \
    \  horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n\
    \             &vertical);\n           if (tiff_status == 1)\n             {\n\
    \               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\"\
    ,\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"\
    jpeg:sampling-factor\",\n                 sampling_factor);\n               (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors:\
    \ %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n\
    \      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n\
    #if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression;\
    \ break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression;\
    \ break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n\
    \      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n\
    #if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression;\
    \ break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\
    \ image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression;\
    \ break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric\
    \ == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n\
    \      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n\
    \        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n\
    \            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans)\
    \ == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n\
    \      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\
    \n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap\
    \ = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n\
    \          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n\
    \          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n \
    \         {\n            if ((red_colormap != (uint16 *) NULL) &&\n          \
    \      (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap\
    \ != (uint16 *) NULL))\n              {\n                range=255;  /* might\
    \ be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >=\
    \ 256) ||\n                      (blue_colormap[i] >= 256))\n                \
    \    {\n                      range=65535;\n                      break;\n   \
    \                 }\n                for (i=0; i < (ssize_t) image->colors; i++)\n\
    \                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n\
    \                    QuantumRange*red_colormap[i])/range);\n                 \
    \ image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n\
    \                  image->colormap[i].blue=ClampToQuantum(((double)\n        \
    \            QuantumRange*blue_colormap[i])/range);\n                }\n     \
    \         }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n\
    \      {\n        if (image_info->number_scenes != 0)\n          if (image->scene\
    \ >= (image_info->scene+image_info->number_scenes-1))\n            break;\n  \
    \      goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n\
    \    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n\
    \      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory\
    \ for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n\
    \    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n    \
    \  status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if\
    \ (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n\
    \    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n\
    \    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n\
    \    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n\
    \        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n\
    \      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples\
    \ == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric\
    \ == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n\
    \        else\n          for (i=0; i < extra_samples; i++)\n          {\n    \
    \        image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n\
    \              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n\
    \                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n\
    \              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n\
    \                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n\
    \                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\"\
    );\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n\
    \      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n\
    \    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip)\
    \ == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void)\
    \ FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n\
    \        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n     \
    \   method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n\
    \          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff)\
    \ != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\
    \n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n      \
    \      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"\
    ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns)\
    \ == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows)\
    \ == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\"\
    );\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV)\
    \ ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n\
    \    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n\
    \        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n\
    \    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n\
    \      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n\
    \    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"\
    CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n\
    \    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info\
    \ == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void)\
    \ ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n\
    \    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n\
    \    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n      \
    \    pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n\
    \        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class\
    \ == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n           \
    \ else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n \
    \               GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel\
    \ > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n\
    \            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n           \
    \   extra_samples-3,0);\n            if (image->matte != MagickFalse)\n      \
    \        {\n                quantum_type=RGBAQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \              }\n            if (image->colorspace == CMYKColorspace)\n     \
    \         {\n                quantum_type=CMYKQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \                if (image->matte != MagickFalse)\n                  {\n     \
    \               quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t)\
    \ samples_per_pixel+\n                      extra_samples-5,0);\n            \
    \      }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7)\
    \ >>\n              3));\n            if (status == MagickFalse)\n           \
    \   ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     \
    \     }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n   \
    \   {\n        /*\n          Convert YCC TIFF image.\n        */\n        for\
    \ (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n          \
    \  status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n\
    \            *magick_restrict q;\n\n          ssize_t\n            x;\n\n    \
    \      unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char\
    \ *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n\
    \          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n \
    \             135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned\
    \ char)*(p+3)));\n            q++;\n            p+=4;\n          }\n         \
    \ if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n       \
    \         image->rows);\n              if (status == MagickFalse)\n          \
    \      break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n\
    \      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\
    \n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n\
    \          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n\
    \        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    \        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n       \
    \   sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n\
    \          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n\
    \        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n       \
    \ stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n\
    \        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n        \
    \  size_t\n            rows_remaining;\n\n          switch (i)\n          {\n\
    \            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n\
    \            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n \
    \           {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace\
    \ == CMYKColorspace)\n                quantum_type=BlackQuantum;\n           \
    \   break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n\
    \            default: break;\n          }\n          rows_remaining=0;\n     \
    \     for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n\
    \              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \            if (q == (PixelPacket *) NULL)\n              break;\n          \
    \  if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n\
    \                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n\
    \                  break;\n                rows_remaining=rows_per_strip;\n  \
    \              if ((y+rows_per_strip) > (ssize_t) image->rows)\n             \
    \     rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n\
    \                p=strip_pixels;\n                strip_id++;\n              }\n\
    \            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n          \
    \    quantum_info,quantum_type,p,exception);\n            p+=stride;\n       \
    \     rows_remaining--;\n            if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n              break;\n            if (image->previous == (Image\
    \ *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ y,\n                  image->rows);\n                if (status == MagickFalse)\n\
    \                  break;\n              }\n          }\n         if ((samples_per_pixel\
    \ > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n\
    \        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n\
    \        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned\
    \ char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n\
    \          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\
    \n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns)\
    \ != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n\
    \          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType)\
    \ columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n\
    \          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n\
    \          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *)\
    \ NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n      \
    \  for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch\
    \ (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum;\
    \ break;\n            case 2: quantum_type=BlueQuantum; break;\n            case\
    \ 3:\n            {\n              quantum_type=AlphaQuantum;\n              if\
    \ (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n\
    \              break;\n            }\n            case 4: quantum_type=AlphaQuantum;\
    \ break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t)\
    \ image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n\
    \            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n\
    \            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n\
    \            for (x=0; x < (ssize_t) image->columns; x+=columns)\n           \
    \ {\n              size_t\n                columns_remaining,\n              \
    \  row;\n\n              columns_remaining=image->columns-x;\n              if\
    \ ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n\
    \              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n\
    \                0,i);\n              if (tiff_status == -1)\n               \
    \ break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining;\
    \ row++)\n              {\n                PixelPacket\n                  *magick_restrict\
    \ q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n\
    \                  exception);\n                if (q == (PixelPacket *) NULL)\n\
    \                  break;\n                (void) ImportQuantumPixels(image,(CacheView\
    \ *) NULL,\n                  quantum_info,quantum_type,p,exception);\n      \
    \          p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                  break;\n              }\n            }\n\
    \          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        tile_pixels=(unsigned\
    \ char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n    \
    \  case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n    \
    \      *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\
    \n        uint32\n          *pixels;\n\n        /*\n          Convert generic\
    \ TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n     \
    \   generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n      \
    \  if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n\
    \        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n\
    \          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n\
    \          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n\
    \            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n\
    \        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n\
    \            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n\
    \          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n       \
    \     SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n     \
    \       SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n \
    \           SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n\
    \            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n\
    \            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned\
    \ char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n   \
    \       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n           \
    \ break;\n          if (image->previous == (Image *) NULL)\n            {\n  \
    \            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n\
    \                image->rows);\n              if (status == MagickFalse)\n   \
    \             break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n\
    \        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info\
    \ != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\
    \    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n\
    \      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n\
    \    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n\
    \        if (bits_per_sample == 1)\n          image->type=BilevelType;\n     \
    \ }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n\
    \    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate\
    \ next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n       \
    \   image->scene);\n        if (status == MagickFalse)\n          break;\n   \
    \   }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n\
    \  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene\
    \ >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n\
    \    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it.\n\n<code>:\nstatic Image *ReadTIFFImage(const\
    \ ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels\
    \  32\n#define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info\
    \ != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info);\
    \ \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info);\
    \ \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\
    \n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n\
    \    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n\
    \    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\
    \n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo\
    \ *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\
    \n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\
    \n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag\
    \ = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n  \
    \  interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation\
    \ = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format\
    \ = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n\
    \    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\
    \n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\
    \n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  assert(exception !=\
    \ (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\
    \  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"\
    %s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n\
    \  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n\
    \    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n \
    \   TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity\
    \ == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\"\
    );\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n\
    \      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank\
    \ images for subimage specification (e.g. image.tif[4].\n        We need to check\
    \ the number of directores because it is possible that\n        the subimage(s)\
    \ are stored in the photoshop profile.\n      */\n      if (image_info->scene\
    \ < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i <\
    \ (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff)\
    \ != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n \
    \             {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n\
    \            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n\
    \                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n\
    \          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse);\
    \ */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width)\
    \ != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n\
    \        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) !=\
    \ 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans)\
    \ != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP)\
    \ || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample\
    \ > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n\
    \      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n\
    \      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n\
    \    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n\
    \        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n   \
    \     break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n\
    \      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n  \
    \    }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\"\
    ,\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n\
    \      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry:\
    \ %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n\
    \        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits\
    \ per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"\
    ));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n\
    \    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\"\
    ,\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian\
    \ == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n\
    \    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"\
    tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n  \
    \      image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n\
    \    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n\
    \    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n\
    \    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG)\
    \ &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n\
    \    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n   \
    \   {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"\
    tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n       \
    \ (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n\
    \    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option\
    \ == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n\
    \      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans)\
    \ == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n\
    \      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans)\
    \ == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n\
    \        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n\
    \      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans)\
    \ == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n \
    \         image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n\
    \          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans)\
    \ == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n\
    \            image->chromaticity.white_point.y=chromaticity[1];\n          }\n\
    \      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n\
    \            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n\
    \            image->chromaticity.green_primary.y=chromaticity[3];\n          \
    \  image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n\
    \          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION\
    \ > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag)\
    \ == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"\
    CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n\
    \      case COMPRESSION_NONE: image->compression=NoCompression; break;\n     \
    \ case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n    \
    \  case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n\
    \      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n\
    #if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\
    \n           int\n             tiff_status;\n\n           uint16\n           \
    \  horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n\
    \             &vertical);\n           if (tiff_status == 1)\n             {\n\
    \               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\"\
    ,\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"\
    jpeg:sampling-factor\",\n                 sampling_factor);\n               (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors:\
    \ %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n\
    \      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n\
    #if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression;\
    \ break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression;\
    \ break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n\
    \      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n\
    #if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression;\
    \ break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\
    \ image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression;\
    \ break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric\
    \ == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n\
    \      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n\
    \        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n\
    \            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans)\
    \ == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n\
    \      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\
    \n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap\
    \ = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n\
    \          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n\
    \          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n \
    \         {\n            if ((red_colormap != (uint16 *) NULL) &&\n          \
    \      (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap\
    \ != (uint16 *) NULL))\n              {\n                range=255;  /* might\
    \ be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >=\
    \ 256) ||\n                      (blue_colormap[i] >= 256))\n                \
    \    {\n                      range=65535;\n                      break;\n   \
    \                 }\n                for (i=0; i < (ssize_t) image->colors; i++)\n\
    \                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n\
    \                    QuantumRange*red_colormap[i])/range);\n                 \
    \ image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n\
    \                  image->colormap[i].blue=ClampToQuantum(((double)\n        \
    \            QuantumRange*blue_colormap[i])/range);\n                }\n     \
    \         }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n\
    \      {\n        if (image_info->number_scenes != 0)\n          if (image->scene\
    \ >= (image_info->scene+image_info->number_scenes-1))\n            break;\n  \
    \      goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n\
    \    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n\
    \      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory\
    \ for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n\
    \    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n    \
    \  status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if\
    \ (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n\
    \    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n\
    \    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n\
    \    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n\
    \        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n\
    \      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples\
    \ == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric\
    \ == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n\
    \        else\n          for (i=0; i < extra_samples; i++)\n          {\n    \
    \        image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n\
    \              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n\
    \                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n\
    \              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n\
    \                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n\
    \                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\"\
    );\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n\
    \      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n\
    \    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip)\
    \ == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void)\
    \ FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n\
    \        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n     \
    \   method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n\
    \          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff)\
    \ != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\
    \n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n      \
    \      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"\
    ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns)\
    \ == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows)\
    \ == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\"\
    );\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV)\
    \ ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n\
    \    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n\
    \        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n\
    \    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n\
    \      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n\
    \    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"\
    CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n\
    \    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info\
    \ == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void)\
    \ ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n\
    \    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n\
    \    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n      \
    \    pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n\
    \        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class\
    \ == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n           \
    \ else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n \
    \               GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel\
    \ > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n\
    \            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n           \
    \   extra_samples-3,0);\n            if (image->matte != MagickFalse)\n      \
    \        {\n                quantum_type=RGBAQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \              }\n            if (image->colorspace == CMYKColorspace)\n     \
    \         {\n                quantum_type=CMYKQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \                if (image->matte != MagickFalse)\n                  {\n     \
    \               quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t)\
    \ samples_per_pixel+\n                      extra_samples-5,0);\n            \
    \      }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7)\
    \ >>\n              3));\n            if (status == MagickFalse)\n           \
    \   ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     \
    \     }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n   \
    \   {\n        /*\n          Convert YCC TIFF image.\n        */\n        for\
    \ (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n          \
    \  status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n\
    \            *magick_restrict q;\n\n          ssize_t\n            x;\n\n    \
    \      unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char\
    \ *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n\
    \          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n \
    \             135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned\
    \ char)*(p+3)));\n            q++;\n            p+=4;\n          }\n         \
    \ if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n       \
    \         image->rows);\n              if (status == MagickFalse)\n          \
    \      break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n\
    \      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\
    \n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n\
    \          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n\
    \        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    \        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n       \
    \   sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n\
    \          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n\
    \        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n       \
    \ stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n\
    \        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n        \
    \  size_t\n            rows_remaining;\n\n          switch (i)\n          {\n\
    \            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n\
    \            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n \
    \           {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace\
    \ == CMYKColorspace)\n                quantum_type=BlackQuantum;\n           \
    \   break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n\
    \            default: break;\n          }\n          rows_remaining=0;\n     \
    \     for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n\
    \              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \            if (q == (PixelPacket *) NULL)\n              break;\n          \
    \  if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n\
    \                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n\
    \                  break;\n                rows_remaining=rows_per_strip;\n  \
    \              if ((y+rows_per_strip) > (ssize_t) image->rows)\n             \
    \     rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n\
    \                p=strip_pixels;\n                strip_id++;\n              }\n\
    \            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n          \
    \    quantum_info,quantum_type,p,exception);\n            p+=stride;\n       \
    \     rows_remaining--;\n            if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n              break;\n            if (image->previous == (Image\
    \ *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ y,\n                  image->rows);\n                if (status == MagickFalse)\n\
    \                  break;\n              }\n          }\n         if ((samples_per_pixel\
    \ > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n\
    \        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n\
    \        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned\
    \ char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n\
    \          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\
    \n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns)\
    \ != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n\
    \          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType)\
    \ columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n\
    \          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n\
    \          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *)\
    \ NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n      \
    \  for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch\
    \ (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum;\
    \ break;\n            case 2: quantum_type=BlueQuantum; break;\n            case\
    \ 3:\n            {\n              quantum_type=AlphaQuantum;\n              if\
    \ (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n\
    \              break;\n            }\n            case 4: quantum_type=AlphaQuantum;\
    \ break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t)\
    \ image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n\
    \            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n\
    \            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n\
    \            for (x=0; x < (ssize_t) image->columns; x+=columns)\n           \
    \ {\n              size_t\n                columns_remaining,\n              \
    \  row;\n\n              columns_remaining=image->columns-x;\n              if\
    \ ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n\
    \              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n\
    \                0,i);\n              if (tiff_status == -1)\n               \
    \ break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining;\
    \ row++)\n              {\n                PixelPacket\n                  *magick_restrict\
    \ q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n\
    \                  exception);\n                if (q == (PixelPacket *) NULL)\n\
    \                  break;\n                (void) ImportQuantumPixels(image,(CacheView\
    \ *) NULL,\n                  quantum_info,quantum_type,p,exception);\n      \
    \          p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                  break;\n              }\n            }\n\
    \          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        tile_pixels=(unsigned\
    \ char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n    \
    \  case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n    \
    \      *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\
    \n        uint32\n          *pixels;\n\n        /*\n          Convert generic\
    \ TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n     \
    \   generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n      \
    \  if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n\
    \        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n\
    \          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n\
    \          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n\
    \            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n\
    \        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n\
    \            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n\
    \          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n       \
    \     SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n     \
    \       SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n \
    \           SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n\
    \            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n\
    \            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned\
    \ char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n   \
    \       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n           \
    \ break;\n          if (image->previous == (Image *) NULL)\n            {\n  \
    \            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n\
    \                image->rows);\n              if (status == MagickFalse)\n   \
    \             break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n\
    \        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info\
    \ != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\
    \    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n\
    \      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n\
    \    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n\
    \        if (bits_per_sample == 1)\n          image->type=BilevelType;\n     \
    \ }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n\
    \    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate\
    \ next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n       \
    \   image->scene);\n        if (status == MagickFalse)\n          break;\n   \
    \   }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n\
    \  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene\
    \ >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n\
    \    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies.\n\
    \n<code>:\nstatic Image *ReadTIFFImage(const ImageInfo *image_info,\n  ExceptionInfo\
    \ *exception)\n{\n#define MaxPixelChannels  32\n#define ThrowTIFFException(severity,message)\
    \ \\\n{ \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info);\
    \ \\\n  if (quantum_info != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info);\
    \ \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\
    \n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n\
    \    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n\
    \    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\
    \n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo\
    \ *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\
    \n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\
    \n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag\
    \ = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n  \
    \  interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation\
    \ = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format\
    \ = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n\
    \    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\
    \n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\
    \n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  assert(exception !=\
    \ (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\
    \  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"\
    %s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n\
    \  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n\
    \    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n \
    \   TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity\
    \ == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\"\
    );\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n\
    \      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank\
    \ images for subimage specification (e.g. image.tif[4].\n        We need to check\
    \ the number of directores because it is possible that\n        the subimage(s)\
    \ are stored in the photoshop profile.\n      */\n      if (image_info->scene\
    \ < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i <\
    \ (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff)\
    \ != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n \
    \             {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n\
    \            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n\
    \                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n\
    \          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse);\
    \ */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width)\
    \ != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n\
    \        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) !=\
    \ 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans)\
    \ != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP)\
    \ || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample\
    \ > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n\
    \      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n\
    \      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n\
    \    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n\
    \        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n   \
    \     break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n\
    \      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n  \
    \    }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\"\
    ,\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n\
    \      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry:\
    \ %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n\
    \        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits\
    \ per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"\
    ));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n\
    \    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\"\
    ,\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian\
    \ == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n\
    \    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"\
    tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n  \
    \      image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n\
    \    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n\
    \    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n\
    \    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG)\
    \ &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n\
    \    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n   \
    \   {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"\
    tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n       \
    \ (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n\
    \    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option\
    \ == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n\
    \      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans)\
    \ == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n\
    \      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans)\
    \ == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n\
    \        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n\
    \      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans)\
    \ == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n \
    \         image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n\
    \          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans)\
    \ == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n\
    \            image->chromaticity.white_point.y=chromaticity[1];\n          }\n\
    \      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n\
    \            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n\
    \            image->chromaticity.green_primary.y=chromaticity[3];\n          \
    \  image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n\
    \          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION\
    \ > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag)\
    \ == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"\
    CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n\
    \      case COMPRESSION_NONE: image->compression=NoCompression; break;\n     \
    \ case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n    \
    \  case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n\
    \      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n\
    #if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\
    \n           int\n             tiff_status;\n\n           uint16\n           \
    \  horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n\
    \             &vertical);\n           if (tiff_status == 1)\n             {\n\
    \               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\"\
    ,\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"\
    jpeg:sampling-factor\",\n                 sampling_factor);\n               (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors:\
    \ %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n\
    \      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n\
    #if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression;\
    \ break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression;\
    \ break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n\
    \      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n\
    #if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression;\
    \ break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\
    \ image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression;\
    \ break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric\
    \ == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n\
    \      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n\
    \        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n\
    \            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans)\
    \ == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n\
    \      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\
    \n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap\
    \ = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n\
    \          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n\
    \          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n \
    \         {\n            if ((red_colormap != (uint16 *) NULL) &&\n          \
    \      (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap\
    \ != (uint16 *) NULL))\n              {\n                range=255;  /* might\
    \ be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >=\
    \ 256) ||\n                      (blue_colormap[i] >= 256))\n                \
    \    {\n                      range=65535;\n                      break;\n   \
    \                 }\n                for (i=0; i < (ssize_t) image->colors; i++)\n\
    \                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n\
    \                    QuantumRange*red_colormap[i])/range);\n                 \
    \ image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n\
    \                  image->colormap[i].blue=ClampToQuantum(((double)\n        \
    \            QuantumRange*blue_colormap[i])/range);\n                }\n     \
    \         }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n\
    \      {\n        if (image_info->number_scenes != 0)\n          if (image->scene\
    \ >= (image_info->scene+image_info->number_scenes-1))\n            break;\n  \
    \      goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n\
    \    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n\
    \      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory\
    \ for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n\
    \    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n    \
    \  status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if\
    \ (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n\
    \    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n\
    \    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n\
    \    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n\
    \        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n\
    \      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples\
    \ == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric\
    \ == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n\
    \        else\n          for (i=0; i < extra_samples; i++)\n          {\n    \
    \        image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n\
    \              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n\
    \                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n\
    \              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n\
    \                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n\
    \                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\"\
    );\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n\
    \      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n\
    \    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip)\
    \ == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void)\
    \ FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n\
    \        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n     \
    \   method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n\
    \          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff)\
    \ != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\
    \n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n      \
    \      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"\
    ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns)\
    \ == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows)\
    \ == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\"\
    );\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV)\
    \ ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n\
    \    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n\
    \        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n\
    \    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n\
    \      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n\
    \    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"\
    CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n\
    \    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info\
    \ == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void)\
    \ ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n\
    \    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n\
    \    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n      \
    \    pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n\
    \        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class\
    \ == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n           \
    \ else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n \
    \               GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel\
    \ > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n\
    \            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n           \
    \   extra_samples-3,0);\n            if (image->matte != MagickFalse)\n      \
    \        {\n                quantum_type=RGBAQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \              }\n            if (image->colorspace == CMYKColorspace)\n     \
    \         {\n                quantum_type=CMYKQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \                if (image->matte != MagickFalse)\n                  {\n     \
    \               quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t)\
    \ samples_per_pixel+\n                      extra_samples-5,0);\n            \
    \      }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7)\
    \ >>\n              3));\n            if (status == MagickFalse)\n           \
    \   ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     \
    \     }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n   \
    \   {\n        /*\n          Convert YCC TIFF image.\n        */\n        for\
    \ (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n          \
    \  status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n\
    \            *magick_restrict q;\n\n          ssize_t\n            x;\n\n    \
    \      unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char\
    \ *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n\
    \          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n \
    \             135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned\
    \ char)*(p+3)));\n            q++;\n            p+=4;\n          }\n         \
    \ if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n       \
    \         image->rows);\n              if (status == MagickFalse)\n          \
    \      break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n\
    \      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\
    \n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n\
    \          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n\
    \        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    \        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n       \
    \   sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n\
    \          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n\
    \        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n       \
    \ stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n\
    \        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n        \
    \  size_t\n            rows_remaining;\n\n          switch (i)\n          {\n\
    \            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n\
    \            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n \
    \           {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace\
    \ == CMYKColorspace)\n                quantum_type=BlackQuantum;\n           \
    \   break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n\
    \            default: break;\n          }\n          rows_remaining=0;\n     \
    \     for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n\
    \              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \            if (q == (PixelPacket *) NULL)\n              break;\n          \
    \  if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n\
    \                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n\
    \                  break;\n                rows_remaining=rows_per_strip;\n  \
    \              if ((y+rows_per_strip) > (ssize_t) image->rows)\n             \
    \     rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n\
    \                p=strip_pixels;\n                strip_id++;\n              }\n\
    \            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n          \
    \    quantum_info,quantum_type,p,exception);\n            p+=stride;\n       \
    \     rows_remaining--;\n            if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n              break;\n            if (image->previous == (Image\
    \ *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ y,\n                  image->rows);\n                if (status == MagickFalse)\n\
    \                  break;\n              }\n          }\n         if ((samples_per_pixel\
    \ > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n\
    \        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n\
    \        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned\
    \ char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n\
    \          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\
    \n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns)\
    \ != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n\
    \          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType)\
    \ columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n\
    \          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n\
    \          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *)\
    \ NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n      \
    \  for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch\
    \ (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum;\
    \ break;\n            case 2: quantum_type=BlueQuantum; break;\n            case\
    \ 3:\n            {\n              quantum_type=AlphaQuantum;\n              if\
    \ (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n\
    \              break;\n            }\n            case 4: quantum_type=AlphaQuantum;\
    \ break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t)\
    \ image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n\
    \            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n\
    \            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n\
    \            for (x=0; x < (ssize_t) image->columns; x+=columns)\n           \
    \ {\n              size_t\n                columns_remaining,\n              \
    \  row;\n\n              columns_remaining=image->columns-x;\n              if\
    \ ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n\
    \              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n\
    \                0,i);\n              if (tiff_status == -1)\n               \
    \ break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining;\
    \ row++)\n              {\n                PixelPacket\n                  *magick_restrict\
    \ q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n\
    \                  exception);\n                if (q == (PixelPacket *) NULL)\n\
    \                  break;\n                (void) ImportQuantumPixels(image,(CacheView\
    \ *) NULL,\n                  quantum_info,quantum_type,p,exception);\n      \
    \          p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                  break;\n              }\n            }\n\
    \          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        tile_pixels=(unsigned\
    \ char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n    \
    \  case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n    \
    \      *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\
    \n        uint32\n          *pixels;\n\n        /*\n          Convert generic\
    \ TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n     \
    \   generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n      \
    \  if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n\
    \        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n\
    \          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n\
    \          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n\
    \            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n\
    \        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n\
    \            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n\
    \          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n       \
    \     SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n     \
    \       SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n \
    \           SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n\
    \            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n\
    \            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned\
    \ char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n   \
    \       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n           \
    \ break;\n          if (image->previous == (Image *) NULL)\n            {\n  \
    \            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n\
    \                image->rows);\n              if (status == MagickFalse)\n   \
    \             break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n\
    \        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info\
    \ != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\
    \    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n\
    \      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n\
    \    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n\
    \        if (bits_per_sample == 1)\n          image->type=BilevelType;\n     \
    \ }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n\
    \    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate\
    \ next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n       \
    \   image->scene);\n        if (status == MagickFalse)\n          break;\n   \
    \   }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n\
    \  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene\
    \ >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n\
    \    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: deepseek-reasoner
    model: deepseek-reasoner
    model_type: deepseek-reasoner
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality.\n\n<code>:\nstatic Image *ReadTIFFImage(const ImageInfo\
    \ *image_info,\n  ExceptionInfo *exception)\n{\n#define MaxPixelChannels  32\n\
    #define ThrowTIFFException(severity,message) \\\n{ \\\n  if (pixel_info != (MemoryInfo\
    \ *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (quantum_info\
    \ != (QuantumInfo *) NULL) \\\n    quantum_info=DestroyQuantumInfo(quantum_info);\
    \ \\\n  TIFFClose(tiff); \\\n  ThrowReaderException(severity,message); \\\n}\n\
    \n  const char\n    *option;\n\n  float\n    *chromaticity = (float *) NULL,\n\
    \    x_position,\n    y_position,\n    x_resolution,\n    y_resolution;\n\n  Image\n\
    \    *image;\n\n  int\n    tiff_status = 0;\n\n  MagickBooleanType\n    more_frames;\n\
    \n  MagickStatusType\n    status;\n\n  MemoryInfo\n    *pixel_info = (MemoryInfo\
    \ *) NULL;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumType\n    quantum_type;\n\
    \n  size_t\n    number_pixels;\n\n  ssize_t\n    i,\n    scanline_size,\n    y;\n\
    \n  TIFF\n    *tiff;\n\n  TIFFMethodType\n    method;\n\n  uint16\n    compress_tag\
    \ = 0,\n    bits_per_sample = 0,\n    endian = 0,\n    extra_samples = 0,\n  \
    \  interlace = 0,\n    max_sample_value = 0,\n    min_sample_value = 0,\n    orientation\
    \ = 0,\n    pages = 0,\n    photometric = 0,\n    *sample_info = NULL,\n    sample_format\
    \ = 0,\n    samples_per_pixel = 0,\n    units = 0,\n    value = 0;\n\n  uint32\n\
    \    height,\n    rows_per_strip,\n    width;\n\n  unsigned char\n    *pixels;\n\
    \n  void\n    *sans[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };\n\
    \n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  assert(exception !=\
    \ (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\
    \  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"\
    %s\",\n      image_info->filename);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  (void) SetMagickThreadValue(tiff_exception,exception);\n\
    \  tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,\n\
    \    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,\n \
    \   TIFFUnmapBlob);\n  if (tiff == (TIFF *) NULL)\n    {\n      if (exception->severity\
    \ == UndefinedException)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\"\
    );\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (exception->severity > ErrorException)\n    {\n      TIFFClose(tiff);\n\
    \      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n\
    \  if (image_info->number_scenes != 0)\n    {\n      /*\n        Generate blank\
    \ images for subimage specification (e.g. image.tif[4].\n        We need to check\
    \ the number of directores because it is possible that\n        the subimage(s)\
    \ are stored in the photoshop profile.\n      */\n      if (image_info->scene\
    \ < (size_t)TIFFNumberOfDirectories(tiff))\n        {\n          for (i=0; i <\
    \ (ssize_t) image_info->scene; i++)\n          {\n            status=TIFFReadDirectory(tiff)\
    \ != 0 ? MagickTrue : MagickFalse;\n            if (status == MagickFalse)\n \
    \             {\n                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            AcquireNextImage(image_info,image);\n\
    \            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n\
    \                TIFFClose(tiff);\n                image=DestroyImageList(image);\n\
    \                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n\
    \          }\n        }\n    }\n  more_frames=MagickTrue;\n  do\n  {\n    /* TIFFPrintDirectory(tiff,stdout,MagickFalse);\
    \ */\n    photometric=PHOTOMETRIC_RGB;\n    if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width)\
    \ != 1) ||\n        (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||\n\
    \        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) !=\
    \ 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans)\
    \ != 1) ||\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans)\
    \ != 1))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    ImproperImageHeader\");\n      }\n    if (((sample_format != SAMPLEFORMAT_IEEEFP)\
    \ || (bits_per_sample != 64)) &&\n        ((bits_per_sample <= 0) || (bits_per_sample\
    \ > 32)))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    UnsupportedBitsPerPixel\");\n      }\n    if (samples_per_pixel > MaxPixelChannels)\n\
    \      {\n        TIFFClose(tiff);\n        ThrowReaderException(CorruptImageError,\"\
    MaximumChannelsExceeded\");\n      }\n    if (sample_format == SAMPLEFORMAT_IEEEFP)\n\
    \      (void) SetImageProperty(image,\"quantum:format\",\"floating-point\");\n\
    \    switch (photometric)\n    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n\
    \        (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\");\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\");\n   \
    \     break;\n      }\n      case PHOTOMETRIC_PALETTE:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"palette\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_RGB:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"RGB\");\n        break;\n      }\n      case PHOTOMETRIC_CIELAB:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_LOGL:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\");\n        break;\n\
    \      }\n      case PHOTOMETRIC_LOGLUV:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"LOGLUV\");\n        break;\n      }\n#if defined(PHOTOMETRIC_MASK)\n\
    \      case PHOTOMETRIC_MASK:\n      {\n        (void) SetImageProperty(image,\"\
    tiff:photometric\",\"MASK\");\n        break;\n      }\n#endif\n      case PHOTOMETRIC_SEPARATED:\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:photometric\",\"separated\"\
    );\n        break;\n      }\n      case PHOTOMETRIC_YCBCR:\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:photometric\",\"YCBCR\");\n        break;\n  \
    \    }\n      default:\n      {\n        (void) SetImageProperty(image,\"tiff:photometric\"\
    ,\"unknown\");\n        break;\n      }\n    }\n    if (image->debug != MagickFalse)\n\
    \      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry:\
    \ %ux%u\",\n          (unsigned int) width,(unsigned int) height);\n        (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",\n          interlace);\n\
    \        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"Bits\
    \ per sample: %u\",bits_per_sample);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Min sample value: %u\",min_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n\
    \          \"Max sample value: %u\",max_sample_value);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"\
    Photometric \"\n          \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\"\
    ));\n      }\n    image->columns=(size_t) width;\n    image->rows=(size_t) height;\n\
    \    image->depth=(size_t) bits_per_sample;\n    if (image->debug != MagickFalse)\n\
    \      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\"\
    ,\n        (double) image->depth);\n    image->endian=MSBEndian;\n    if (endian\
    \ == FILLORDER_LSB2MSB)\n      image->endian=LSBEndian;\n#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)\n\
    \    if (TIFFIsBigEndian(tiff) == 0)\n      {\n        (void) SetImageProperty(image,\"\
    tiff:endian\",\"lsb\");\n        image->endian=LSBEndian;\n      }\n    else\n\
    \      {\n        (void) SetImageProperty(image,\"tiff:endian\",\"msb\");\n  \
    \      image->endian=MSBEndian;\n      }\n#endif\n    if ((photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      image->colorspace=GRAYColorspace;\n\
    \    if (photometric == PHOTOMETRIC_SEPARATED)\n      image->colorspace=CMYKColorspace;\n\
    \    if (photometric == PHOTOMETRIC_CIELAB)\n      image->colorspace=LabColorspace;\n\
    \    if ((photometric == PHOTOMETRIC_YCBCR) &&\n        (compress_tag != COMPRESSION_OJPEG)\
    \ &&\n        (compress_tag != COMPRESSION_JPEG))\n      image->colorspace=YCbCrColorspace;\n\
    \    status=TIFFGetProfiles(tiff,image);\n    if (status == MagickFalse)\n   \
    \   {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=TIFFGetProperties(tiff,image);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    option=GetImageOption(image_info,\"\
    tiff:exif-properties\");\n    if ((option == (const char *) NULL) ||\n       \
    \ (IsMagickTrue(option) != MagickFalse))\n      (void) TIFFGetEXIFProperties(tiff,image);\n\
    \    option=GetImageOption(image_info,\"tiff:gps-properties\");\n    if ((option\
    \ == (const char *) NULL) ||\n        (IsMagickTrue(option) != MagickFalse))\n\
    \      (void) TIFFGetGPSProperties(tiff,image);\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans)\
    \ == 1))\n      {\n        image->x_resolution=x_resolution;\n        image->y_resolution=y_resolution;\n\
    \      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans)\
    \ == 1)\n      {\n        if (units == RESUNIT_INCH)\n          image->units=PixelsPerInchResolution;\n\
    \        if (units == RESUNIT_CENTIMETER)\n          image->units=PixelsPerCentimeterResolution;\n\
    \      }\n    if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans)\
    \ == 1) &&\n        (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans)\
    \ == 1))\n      {\n        image->page.x=CastDoubleToLong(ceil(x_position*\n \
    \         image->x_resolution-0.5));\n        image->page.y=CastDoubleToLong(ceil(y_position*\n\
    \          image->y_resolution-0.5));\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans)\
    \ == 1)\n      image->orientation=(OrientationType) orientation;\n    if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.white_point.x=chromaticity[0];\n\
    \            image->chromaticity.white_point.y=chromaticity[1];\n          }\n\
    \      }\n    if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity)\
    \ == 1)\n      {\n        if ((chromaticity != (float *) NULL) && (*chromaticity\
    \ != 0.0))\n          {\n            image->chromaticity.red_primary.x=chromaticity[0];\n\
    \            image->chromaticity.red_primary.y=chromaticity[1];\n            image->chromaticity.green_primary.x=chromaticity[2];\n\
    \            image->chromaticity.green_primary.y=chromaticity[3];\n          \
    \  image->chromaticity.blue_primary.x=chromaticity[4];\n            image->chromaticity.blue_primary.y=chromaticity[5];\n\
    \          }\n      }\n#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION\
    \ > 20040919)\n    if ((compress_tag != COMPRESSION_NONE) &&\n        (TIFFIsCODECConfigured(compress_tag)\
    \ == 0))\n      {\n        TIFFClose(tiff);\n        ThrowReaderException(CoderError,\"\
    CompressNotSupported\");\n      }\n#endif\n    switch (compress_tag)\n    {\n\
    \      case COMPRESSION_NONE: image->compression=NoCompression; break;\n     \
    \ case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;\n    \
    \  case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;\n\
    \      case COMPRESSION_JPEG:\n      {\n         image->compression=JPEGCompression;\n\
    #if defined(JPEG_SUPPORT)\n         {\n           char\n             sampling_factor[MaxTextExtent];\n\
    \n           int\n             tiff_status;\n\n           uint16\n           \
    \  horizontal,\n             vertical;\n\n           tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,\n\
    \             &vertical);\n           if (tiff_status == 1)\n             {\n\
    \               (void) FormatLocaleString(sampling_factor,MaxTextExtent,\"%dx%d\"\
    ,\n                 horizontal,vertical);\n               (void) SetImageProperty(image,\"\
    jpeg:sampling-factor\",\n                 sampling_factor);\n               (void)\
    \ LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"Sampling Factors:\
    \ %s\",sampling_factor);\n             }\n         }\n#endif\n        break;\n\
    \      }\n      case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;\n\
    #if defined(COMPRESSION_LZMA)\n      case COMPRESSION_LZMA: image->compression=LZMACompression;\
    \ break;\n#endif\n      case COMPRESSION_LZW: image->compression=LZWCompression;\
    \ break;\n      case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;\n\
    \      case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;\n\
    #if defined(COMPRESSION_WEBP)\n      case COMPRESSION_WEBP: image->compression=WebPCompression;\
    \ break;\n#endif\n#if defined(COMPRESSION_ZSTD)\n      case COMPRESSION_ZSTD:\
    \ image->compression=ZstdCompression; break;\n#endif\n      default: image->compression=RLECompression;\
    \ break;\n    }\n    quantum_info=(QuantumInfo *) NULL;\n    if ((photometric\
    \ == PHOTOMETRIC_PALETTE) &&\n        (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))\n\
    \      {\n        size_t\n          colors;\n\n        colors=(size_t) GetQuantumRange(bits_per_sample)+1;\n\
    \        if (AcquireImageColormap(image,colors) == MagickFalse)\n          {\n\
    \            TIFFClose(tiff);\n            ThrowReaderException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n          }\n      }\n    if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans)\
    \ == 1)\n      image->scene=value;\n    if (image->storage_class == PseudoClass)\n\
    \      {\n        int\n          tiff_status;\n\n        size_t\n          range;\n\
    \n        uint16\n          *blue_colormap = (uint16 *) NULL,\n          *green_colormap\
    \ = (uint16 *) NULL,\n          *red_colormap = (uint16 *) NULL;\n\n        /*\n\
    \          Initialize colormap.\n        */\n        tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,\n\
    \          &green_colormap,&blue_colormap);\n        if (tiff_status == 1)\n \
    \         {\n            if ((red_colormap != (uint16 *) NULL) &&\n          \
    \      (green_colormap != (uint16 *) NULL) &&\n                (blue_colormap\
    \ != (uint16 *) NULL))\n              {\n                range=255;  /* might\
    \ be old style 8-bit colormap */\n                for (i=0; i < (ssize_t) image->colors;\
    \ i++)\n                  if ((red_colormap[i] >= 256) || (green_colormap[i] >=\
    \ 256) ||\n                      (blue_colormap[i] >= 256))\n                \
    \    {\n                      range=65535;\n                      break;\n   \
    \                 }\n                for (i=0; i < (ssize_t) image->colors; i++)\n\
    \                {\n                  image->colormap[i].red=ClampToQuantum(((double)\n\
    \                    QuantumRange*red_colormap[i])/range);\n                 \
    \ image->colormap[i].green=ClampToQuantum(((double)\n                    QuantumRange*green_colormap[i])/range);\n\
    \                  image->colormap[i].blue=ClampToQuantum(((double)\n        \
    \            QuantumRange*blue_colormap[i])/range);\n                }\n     \
    \         }\n          }\n      }\n    if (image_info->ping != MagickFalse)\n\
    \      {\n        if (image_info->number_scenes != 0)\n          if (image->scene\
    \ >= (image_info->scene+image_info->number_scenes-1))\n            break;\n  \
    \      goto next_tiff_frame;\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n\
    \    if (status == MagickFalse)\n      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    status=SetImageColorspace(image,image->colorspace);\n\
    \    status&=ResetImagePixels(image,exception);\n    if (status == MagickFalse)\n\
    \      {\n        TIFFClose(tiff);\n        InheritException(exception,&image->exception);\n\
    \        return(DestroyImageList(image));\n      }\n    /*\n      Allocate memory\
    \ for the image and pixel buffer.\n    */\n    quantum_info=AcquireQuantumInfo(image_info,image);\n\
    \    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    if (sample_format == SAMPLEFORMAT_UINT)\n    \
    \  status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);\n    if\
    \ (sample_format == SAMPLEFORMAT_INT)\n      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);\n\
    \    if (sample_format == SAMPLEFORMAT_IEEEFP)\n      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n\
    \    if (status == MagickFalse)\n      ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n    status=MagickTrue;\n    switch (photometric)\n\
    \    {\n      case PHOTOMETRIC_MINISBLACK:\n      {\n        quantum_info->min_is_white=MagickFalse;\n\
    \        break;\n      }\n      case PHOTOMETRIC_MINISWHITE:\n      {\n      \
    \  quantum_info->min_is_white=MagickTrue;\n        break;\n      }\n      default:\n\
    \        break;\n    }\n    extra_samples=0;\n    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,\n\
    \      &sample_info,sans);\n    if (tiff_status == 1)\n      {\n        (void)\
    \ SetImageProperty(image,\"tiff:alpha\",\"unspecified\");\n        if (extra_samples\
    \ == 0)\n          {\n            if ((samples_per_pixel == 4) && (photometric\
    \ == PHOTOMETRIC_RGB))\n              image->matte=MagickTrue;\n          }\n\
    \        else\n          for (i=0; i < extra_samples; i++)\n          {\n    \
    \        image->matte=MagickTrue;\n            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)\n\
    \              {\n                SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);\n\
    \                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\");\n\
    \              }\n            else\n              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)\n\
    \                {\n                  SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);\n\
    \                  (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\"\
    );\n                }\n          }\n      }\n    if (image->matte != MagickFalse)\n\
    \      (void) SetImageAlphaChannel(image,OpaqueAlphaChannel);\n    method=ReadGenericMethod;\n\
    \    rows_per_strip=(uint32) image->rows;\n    if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip)\
    \ == 1)\n      {\n        char\n          value[MaxTextExtent];\n\n        (void)\
    \ FormatLocaleString(value,MaxTextExtent,\"%u\",(unsigned int)\n          rows_per_strip);\n\
    \        (void) SetImageProperty(image,\"tiff:rows-per-strip\",value);\n     \
    \   method=ReadStripMethod;\n        if (rows_per_strip > (uint32) image->rows)\n\
    \          rows_per_strip=(uint32) image->rows;\n      }\n    if (TIFFIsTiled(tiff)\
    \ != MagickFalse)\n      {\n        uint32\n          columns,\n          rows;\n\
    \n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||\n      \
    \      (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n          ThrowTIFFException(CoderError,\"\
    ImageIsNotTiled\");\n        if ((AcquireMagickResource(WidthResource,columns)\
    \ == MagickFalse) ||\n            (AcquireMagickResource(HeightResource,rows)\
    \ == MagickFalse))\n          ThrowTIFFException(ImageError,\"WidthOrHeightExceedsLimit\"\
    );\n        method=ReadTileMethod;\n      }\n    if ((photometric == PHOTOMETRIC_LOGLUV)\
    \ ||\n        (compress_tag == COMPRESSION_CCITTFAX3))\n      method=ReadGenericMethod;\n\
    \    if (image->compression == JPEGCompression)\n      method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,\n\
    \        samples_per_pixel);\n    quantum_info->endian=LSBEndian;\n    scanline_size=TIFFScanlineSize(tiff);\n\
    \    if (scanline_size <= 0)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    number_pixels=MagickMax((MagickSizeType) image->columns*samples_per_pixel*\n\
    \      pow(2.0,ceil(log(bits_per_sample)/log(2.0))),image->columns*\n      rows_per_strip);\n\
    \    if ((double) scanline_size > 1.5*number_pixels)\n      ThrowTIFFException(CorruptImageError,\"\
    CorruptImage\");\n    number_pixels=MagickMax((MagickSizeType) scanline_size,number_pixels);\n\
    \    pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));\n    if (pixel_info\
    \ == (MemoryInfo *) NULL)\n      ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void)\
    \ ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));\n    quantum_type=GrayQuantum;\n\
    \    if (image->storage_class == PseudoClass)\n      quantum_type=IndexQuantum;\n\
    \    if (interlace != PLANARCONFIG_SEPARATE)\n      {\n        size_t\n      \
    \    pad;\n\n        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);\n\
    \        if (image->matte != MagickFalse)\n          {\n            if (image->storage_class\
    \ == PseudoClass)\n              quantum_type=IndexAlphaQuantum;\n           \
    \ else\n              quantum_type=samples_per_pixel == 1 ? AlphaQuantum :\n \
    \               GrayAlphaQuantum;\n          }\n        if ((samples_per_pixel\
    \ > 2) && (interlace != PLANARCONFIG_SEPARATE))\n          {\n            quantum_type=RGBQuantum;\n\
    \            pad=(size_t) MagickMax((ssize_t) samples_per_pixel+\n           \
    \   extra_samples-3,0);\n            if (image->matte != MagickFalse)\n      \
    \        {\n                quantum_type=RGBAQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \              }\n            if (image->colorspace == CMYKColorspace)\n     \
    \         {\n                quantum_type=CMYKQuantum;\n                pad=(size_t)\
    \ MagickMax((ssize_t) samples_per_pixel+\n                  extra_samples-4,0);\n\
    \                if (image->matte != MagickFalse)\n                  {\n     \
    \               quantum_type=CMYKAQuantum;\n                    pad=(size_t) MagickMax((ssize_t)\
    \ samples_per_pixel+\n                      extra_samples-5,0);\n            \
    \      }\n              }\n            status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7)\
    \ >>\n              3));\n            if (status == MagickFalse)\n           \
    \   ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n     \
    \     }\n      }\n    switch (method)\n    {\n      case ReadYCCKMethod:\n   \
    \   {\n        /*\n          Convert YCC TIFF image.\n        */\n        for\
    \ (y=0; y < (ssize_t) image->rows; y++)\n        {\n          int\n          \
    \  status;\n\n          IndexPacket\n            *indexes;\n\n          PixelPacket\n\
    \            *magick_restrict q;\n\n          ssize_t\n            x;\n\n    \
    \      unsigned char\n            *p;\n\n          status=TIFFReadPixels(tiff,0,y,(char\
    \ *) pixels);\n          if (status == -1)\n            break;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n\
    \          p=pixels;\n          for (x=0; x < (ssize_t) image->columns; x++)\n\
    \          {\n            SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.402*(double) *(p+2))-179.456)));\n            SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p-\n              (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+\n \
    \             135.45984)));\n            SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double)\
    \ *p+\n              (1.772*(double) *(p+1))-226.816)));\n            SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned\
    \ char)*(p+3)));\n            q++;\n            p+=4;\n          }\n         \
    \ if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n\
    \          if (image->previous == (Image *) NULL)\n            {\n           \
    \   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n       \
    \         image->rows);\n              if (status == MagickFalse)\n          \
    \      break;\n            }\n        }\n        break;\n      }\n      case ReadStripMethod:\n\
    \      {\n        unsigned char\n          *p;\n\n        size_t\n          extent;\n\
    \n        ssize_t\n          stride,\n          strip_id;\n\n        tsize_t\n\
    \          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n\
    \        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*((image->depth+7)/8)*(samples_per_pixel+1)*TIFFStripSize(tiff);\n\
    \        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n       \
    \   sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n\
    \          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n\
    \        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n       \
    \ stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n\
    \        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n        \
    \  size_t\n            rows_remaining;\n\n          switch (i)\n          {\n\
    \            case 0: break;\n            case 1: quantum_type=GreenQuantum; break;\n\
    \            case 2: quantum_type=BlueQuantum; break;\n            case 3:\n \
    \           {\n              quantum_type=AlphaQuantum;\n              if (image->colorspace\
    \ == CMYKColorspace)\n                quantum_type=BlackQuantum;\n           \
    \   break;\n            }\n            case 4: quantum_type=AlphaQuantum; break;\n\
    \            default: break;\n          }\n          rows_remaining=0;\n     \
    \     for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            PixelPacket\n\
    \              *magick_restrict q;\n\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\
    \            if (q == (PixelPacket *) NULL)\n              break;\n          \
    \  if (rows_remaining == 0)\n              {\n                strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,\n\
    \                  TIFFStripSize(tiff));\n                if (strip_size == -1)\n\
    \                  break;\n                rows_remaining=rows_per_strip;\n  \
    \              if ((y+rows_per_strip) > (ssize_t) image->rows)\n             \
    \     rows_remaining=(rows_per_strip-(y+rows_per_strip-\n                    image->rows));\n\
    \                p=strip_pixels;\n                strip_id++;\n              }\n\
    \            (void) ImportQuantumPixels(image,(CacheView *) NULL,\n          \
    \    quantum_info,quantum_type,p,exception);\n            p+=stride;\n       \
    \     rows_remaining--;\n            if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n              break;\n            if (image->previous == (Image\
    \ *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ y,\n                  image->rows);\n                if (status == MagickFalse)\n\
    \                  break;\n              }\n          }\n         if ((samples_per_pixel\
    \ > 1) && (interlace != PLANARCONFIG_SEPARATE))\n            break;\n        }\n\
    \        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);\n\
    \        break;\n      }\n      case ReadTileMethod:\n      {\n        unsigned\
    \ char\n          *p;\n\n        size_t\n          extent;\n\n        uint32\n\
    \          columns,\n          rows;\n\n        unsigned char\n          *tile_pixels;\n\
    \n        /*\n          Convert tiled TIFF image.\n        */\n        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns)\
    \ != 1) ||\n            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))\n\
    \          ThrowTIFFException(CoderError,\"ImageIsNotTiled\");\n        number_pixels=(MagickSizeType)\
    \ columns*rows;\n        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        extent=4*(samples_per_pixel+1)*MagickMax(rows*TIFFTileRowSize(tiff),\n\
    \          TIFFTileSize(tiff));\n        tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n\
    \          sizeof(*tile_pixels));\n        if (tile_pixels == (unsigned char *)\
    \ NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        (void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));\n      \
    \  for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          switch\
    \ (i)\n          {\n            case 0: break;\n            case 1: quantum_type=GreenQuantum;\
    \ break;\n            case 2: quantum_type=BlueQuantum; break;\n            case\
    \ 3:\n            {\n              quantum_type=AlphaQuantum;\n              if\
    \ (image->colorspace == CMYKColorspace)\n                quantum_type=BlackQuantum;\n\
    \              break;\n            }\n            case 4: quantum_type=AlphaQuantum;\
    \ break;\n            default: break;\n          }\n          for (y=0; y < (ssize_t)\
    \ image->rows; y+=rows)\n          {\n            ssize_t\n              x;\n\n\
    \            size_t\n              rows_remaining;\n\n            rows_remaining=image->rows-y;\n\
    \            if ((ssize_t) (y+rows) < (ssize_t) image->rows)\n              rows_remaining=rows;\n\
    \            for (x=0; x < (ssize_t) image->columns; x+=columns)\n           \
    \ {\n              size_t\n                columns_remaining,\n              \
    \  row;\n\n              columns_remaining=image->columns-x;\n              if\
    \ ((ssize_t) (x+columns) < (ssize_t) image->columns)\n                columns_remaining=columns;\n\
    \              tiff_status=TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,\n\
    \                0,i);\n              if (tiff_status == -1)\n               \
    \ break;\n              p=tile_pixels;\n              for (row=0; row < rows_remaining;\
    \ row++)\n              {\n                PixelPacket\n                  *magick_restrict\
    \ q;\n\n                q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,\n\
    \                  exception);\n                if (q == (PixelPacket *) NULL)\n\
    \                  break;\n                (void) ImportQuantumPixels(image,(CacheView\
    \ *) NULL,\n                  quantum_info,quantum_type,p,exception);\n      \
    \          p+=TIFFTileRowSize(tiff);\n                if (SyncAuthenticPixels(image,exception)\
    \ == MagickFalse)\n                  break;\n              }\n            }\n\
    \          }\n          if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))\n\
    \            break;\n          if (image->previous == (Image *) NULL)\n      \
    \      {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\
    \ i,\n                samples_per_pixel);\n              if (status == MagickFalse)\n\
    \                break;\n            }\n        }\n        tile_pixels=(unsigned\
    \ char *) RelinquishMagickMemory(tile_pixels);\n        break;\n      }\n    \
    \  case ReadGenericMethod:\n      default:\n      {\n        MemoryInfo\n    \
    \      *generic_info = (MemoryInfo *) NULL;\n\n        uint32\n          *p;\n\
    \n        uint32\n          *pixels;\n\n        /*\n          Convert generic\
    \ TIFF image.\n        */\n        if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels))\
    \ != MagickFalse)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\"\
    );\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n     \
    \   generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));\n      \
    \  if (generic_info == (MemoryInfo *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"\
    MemoryAllocationFailed\");\n        pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);\n\
    \        tiff_status=TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)\n\
    \          image->rows,(uint32 *) pixels,0);\n        if (tiff_status == -1)\n\
    \          {\n            generic_info=RelinquishVirtualMemory(generic_info);\n\
    \            break;\n          }\n        p=pixels+(image->columns*image->rows)-1;\n\
    \        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n\
    \            x;\n\n          PixelPacket\n            *magick_restrict q;\n\n\
    \          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n   \
    \       if (q == (PixelPacket *) NULL)\n            break;\n          q+=image->columns-1;\n\
    \          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n       \
    \     SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));\n     \
    \       SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));\n \
    \           SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));\n\
    \            if (image->matte == MagickFalse)\n              SetPixelOpacity(q,OpaqueOpacity);\n\
    \            else\n              SetPixelAlpha(q,ScaleCharToQuantum((unsigned\
    \ char) TIFFGetA(*p)));\n            p--;\n            q--;\n          }\n   \
    \       if (SyncAuthenticPixels(image,exception) == MagickFalse)\n           \
    \ break;\n          if (image->previous == (Image *) NULL)\n            {\n  \
    \            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n\
    \                image->rows);\n              if (status == MagickFalse)\n   \
    \             break;\n            }\n        }\n        generic_info=RelinquishVirtualMemory(generic_info);\n\
    \        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n\
    \    SetQuantumImageType(image,quantum_type);\n  next_tiff_frame:\n    if (quantum_info\
    \ != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n\
    \    if (tiff_status == -1)\n      {\n        status=MagickFalse;\n        break;\n\
    \      }\n    if (photometric == PHOTOMETRIC_CIELAB)\n      DecodeLabImage(image,exception);\n\
    \    if ((photometric == PHOTOMETRIC_LOGL) ||\n        (photometric == PHOTOMETRIC_MINISBLACK)\
    \ ||\n        (photometric == PHOTOMETRIC_MINISWHITE))\n      {\n        image->type=GrayscaleType;\n\
    \        if (bits_per_sample == 1)\n          image->type=BilevelType;\n     \
    \ }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes\
    \ != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n\
    \        break;\n    more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;\n\
    \    if (more_frames != MagickFalse)\n      {\n        /*\n          Allocate\
    \ next image structure.\n        */\n        AcquireNextImage(image_info,image);\n\
    \        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n     \
    \       status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n\
    \        status=SetImageProgress(image,LoadImagesTag,image->scene-1,\n       \
    \   image->scene);\n        if (status == MagickFalse)\n          break;\n   \
    \   }\n  } while ((status != MagickFalse) && (more_frames != MagickFalse));\n\
    \  TIFFClose(tiff);\n  if ((image_info->number_scenes != 0) &&\n      (image_info->scene\
    \ >= GetImageListLength(image)))\n    status=MagickFalse;\n  if (status == MagickFalse)\n\
    \    return(DestroyImageList(image));\n  TIFFReadPhotoshopLayers(image_info,image,exception);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 452391
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\u2019s entry.\n- `response_type`: 'refutation' if you believe this\
    \ concern is unfounded, or 'mitigation' if you acknowledge it and propose a workable\
    \ solution.\n- `reason`: A concise explanation of why the vulnerability is refuted\
    \ or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\u2019s identified vulnerabilities\
    \ and the Code Author\u2019s responses, \nprovide a single JSON object with two\
    \ fields:\n- `researcher_summary`: A concise summary of the vulnerabilities and\
    \ reasoning presented by the Security Researcher.\n- `author_summary`: A concise\
    \ summary of the Code Author\u2019s counterarguments or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\u2019\
    s summary and <code> (if needed, the original arguments), \nproduce a JSON array\
    \ of verdicts for each vulnerability identified by the Security Researcher. Each\
    \ object in the array should include:\n- `vulnerability`: The same name as given\
    \ by the Security Researcher.\n- `decision`: One of 'valid', 'invalid', or 'partially\
    \ valid'.\n- `severity`: If valid or partially valid, assign a severity ('low',\
    \ 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`: Suggest\
    \ what should be done next (e.g., 'fix immediately', 'monitor', 'no action needed').\n\
    - `justification`: A brief explanation of why you reached this conclusion, considering\
    \ both the Security Researcher\u2019s and Code Author\u2019s perspectives.\n\n\
    You need to analyze the code and evaluate the reasoning provided by the Security\
    \ Researcher, Code Author, and Moderator. Do not automatically mark a decision\
    \ as 'valid' just because the Code Author refutes it, nor mark it as 'invalid'\
    \ because the Security Researcher claims a vulnerability exists. Instead, carefully\
    \ assess whether their reasoning aligns with the actual security implications\
    \ and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
