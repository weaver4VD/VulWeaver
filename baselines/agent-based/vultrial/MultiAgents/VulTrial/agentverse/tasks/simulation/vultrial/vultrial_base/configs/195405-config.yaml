agents:
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\nstatic\
    \ Image *ReadPCLImage(const ImageInfo *image_info,ExceptionInfo *exception)\n\
    {\n#define CropBox  \"CropBox\"\n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox\
    \  \"MediaBox\"\n#define RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n \
    \   command[MaxTextExtent],\n    *density,\n    filename[MaxTextExtent],\n   \
    \ geometry[MaxTextExtent],\n    *options,\n    input_filename[MaxTextExtent];\n\
    \n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\
    \n  ImageInfo\n    *read_info;\n\n  int\n    c;\n\n  MagickBooleanType\n    cmyk,\n\
    \    status;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n\
    \    page;\n\n  char\n    *p;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n\
    \    width;\n\n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo\
    \ *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug\
    \ != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\"\
    ,\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n\
    \  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image\
    \ file.\n  */\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n\
    \  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"\
    UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n\
    \      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n\
    \  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution\
    \ == 0.0) || (image->y_resolution == 0.0))\n    {\n      GeometryInfo\n      \
    \  geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n\
    \      if ((flags & RhoValue) != 0)\n        image->x_resolution=geometry_info.rho;\n\
    \      image->y_resolution=image->x_resolution;\n      if ((flags & SigmaValue)\
    \ != 0)\n        image->y_resolution=geometry_info.sigma;\n    }\n  /*\n    Determine\
    \ page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace\
    \ ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n\
    \  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n\
    \  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image);\
    \ c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *)\
    \ NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char)\
    \ c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command)\
    \ < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n\
    \      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK))\
    \ == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox))\
    \ == 0)\n      {\n        /*\n          Note region defined by crop box.\n   \
    \     */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\"\
    ,\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count\
    \ != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\"\
    ,\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if\
    \ (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n\
    \          Note region defined by media box.\n        */\n        count=(ssize_t)\
    \ sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf\
    \ %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n\
    \    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t)\
    \ floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n\
    \    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n\
    \  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width ==\
    \ 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  (void) FormatLocaleString(geometry,MaxTextExtent,\"%.20gx%.20g\",(double)\n\
    \    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n\
    \    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n\
    \     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\"\
    ,(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"\
    pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo\
    \ *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n\
    \    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"\
    %gx%g\",\n    image->x_resolution,image->y_resolution);\n  if (image_info->ping\
    \ != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\"\
    );\n  page.width=(size_t) floor((double) page.width*image->x_resolution/delta.x+\n\
    \    0.5);\n  page.height=(size_t) floor((double) page.height*image->y_resolution/delta.y+\n\
    \    0.5);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g\
    \ \",(double)\n     page.width,(double) page.height);\n  image=DestroyImage(image);\n\
    \  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes\
    \ != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MaxTextExtent,\"\
    -dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n\
    \      else\n        (void) FormatLocaleString(options,MaxTextExtent,\n      \
    \    \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n   \
    \       (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n\
    \      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\\
    0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n\
    \  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\n\
    \    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse\
    \ ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n\
    \    read_info->filename,input_filename);\n  options=DestroyString(options);\n\
    \  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n\
    \    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n\
    \  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n\
    \  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n  \
    \  ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"\
    BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,&image->exception);\n\
    \      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n\
    \          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n\
    \    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n  \
    \      image->magick_columns*=image->x_resolution/2.0;\n        image->magick_rows*=image->y_resolution/2.0;\n\
    \        image->columns*=image->x_resolution/2.0;\n        image->rows*=image->y_resolution/2.0;\n\
    \      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image\
    \ *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\nstatic Image *ReadPCLImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\
    \n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define\
    \ RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MaxTextExtent],\n\
    \    *density,\n    filename[MaxTextExtent],\n    geometry[MaxTextExtent],\n \
    \   *options,\n    input_filename[MaxTextExtent];\n\n  const DelegateInfo\n  \
    \  *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n\
    \    *read_info;\n\n  int\n    c;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\
    \n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n\
    \  char\n    *p;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\
    \n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug\
    \ != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\"\
    ,\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n\
    \  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image\
    \ file.\n  */\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n\
    \  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"\
    UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n\
    \      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n\
    \  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution\
    \ == 0.0) || (image->y_resolution == 0.0))\n    {\n      GeometryInfo\n      \
    \  geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n\
    \      if ((flags & RhoValue) != 0)\n        image->x_resolution=geometry_info.rho;\n\
    \      image->y_resolution=image->x_resolution;\n      if ((flags & SigmaValue)\
    \ != 0)\n        image->y_resolution=geometry_info.sigma;\n    }\n  /*\n    Determine\
    \ page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace\
    \ ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n\
    \  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n\
    \  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image);\
    \ c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *)\
    \ NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char)\
    \ c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command)\
    \ < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n\
    \      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK))\
    \ == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox))\
    \ == 0)\n      {\n        /*\n          Note region defined by crop box.\n   \
    \     */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\"\
    ,\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count\
    \ != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\"\
    ,\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if\
    \ (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n\
    \          Note region defined by media box.\n        */\n        count=(ssize_t)\
    \ sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf\
    \ %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n\
    \    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t)\
    \ floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n\
    \    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n\
    \  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width ==\
    \ 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  (void) FormatLocaleString(geometry,MaxTextExtent,\"%.20gx%.20g\",(double)\n\
    \    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n\
    \    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n\
    \     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\"\
    ,(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"\
    pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo\
    \ *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n\
    \    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"\
    %gx%g\",\n    image->x_resolution,image->y_resolution);\n  if (image_info->ping\
    \ != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\"\
    );\n  page.width=(size_t) floor((double) page.width*image->x_resolution/delta.x+\n\
    \    0.5);\n  page.height=(size_t) floor((double) page.height*image->y_resolution/delta.y+\n\
    \    0.5);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g\
    \ \",(double)\n     page.width,(double) page.height);\n  image=DestroyImage(image);\n\
    \  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes\
    \ != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MaxTextExtent,\"\
    -dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n\
    \      else\n        (void) FormatLocaleString(options,MaxTextExtent,\n      \
    \    \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n   \
    \       (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n\
    \      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\\
    0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n\
    \  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\n\
    \    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse\
    \ ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n\
    \    read_info->filename,input_filename);\n  options=DestroyString(options);\n\
    \  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n\
    \    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n\
    \  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n\
    \  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n  \
    \  ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"\
    BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,&image->exception);\n\
    \      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n\
    \          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n\
    \    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n  \
    \      image->magick_columns*=image->x_resolution/2.0;\n        image->magick_rows*=image->y_resolution/2.0;\n\
    \        image->columns*=image->x_resolution/2.0;\n        image->rows*=image->y_resolution/2.0;\n\
    \      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image\
    \ *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\nstatic Image *ReadPCLImage(const ImageInfo\
    \ *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\n#define\
    \ DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define RenderPCLText\
    \  \"  Rendering PCL...  \"\n\n  char\n    command[MaxTextExtent],\n    *density,\n\
    \    filename[MaxTextExtent],\n    geometry[MaxTextExtent],\n    *options,\n \
    \   input_filename[MaxTextExtent];\n\n  const DelegateInfo\n    *delegate_info;\n\
    \n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n    *read_info;\n\n \
    \ int\n    c;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\n  PointInfo\n\
    \    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n  char\n    *p;\n\
    \n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\n  ssize_t\n\
    \    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature\
    \ == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void)\
    \ LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n\
    \  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature\
    \ == MagickCoreSignature);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info);\n\
    \  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status\
    \ == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image\
    \ *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n\
    \  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"\
    UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n\
    \      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n\
    \  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution\
    \ == 0.0) || (image->y_resolution == 0.0))\n    {\n      GeometryInfo\n      \
    \  geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n\
    \      if ((flags & RhoValue) != 0)\n        image->x_resolution=geometry_info.rho;\n\
    \      image->y_resolution=image->x_resolution;\n      if ((flags & SigmaValue)\
    \ != 0)\n        image->y_resolution=geometry_info.sigma;\n    }\n  /*\n    Determine\
    \ page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace\
    \ ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n\
    \  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n\
    \  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image);\
    \ c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *)\
    \ NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char)\
    \ c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command)\
    \ < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n\
    \      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK))\
    \ == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox))\
    \ == 0)\n      {\n        /*\n          Note region defined by crop box.\n   \
    \     */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\"\
    ,\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count\
    \ != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\"\
    ,\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if\
    \ (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n\
    \          Note region defined by media box.\n        */\n        count=(ssize_t)\
    \ sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf\
    \ %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n\
    \    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t)\
    \ floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n\
    \    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n\
    \  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width ==\
    \ 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  (void) FormatLocaleString(geometry,MaxTextExtent,\"%.20gx%.20g\",(double)\n\
    \    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n\
    \    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n\
    \     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\"\
    ,(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"\
    pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo\
    \ *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n\
    \    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"\
    %gx%g\",\n    image->x_resolution,image->y_resolution);\n  if (image_info->ping\
    \ != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\"\
    );\n  page.width=(size_t) floor((double) page.width*image->x_resolution/delta.x+\n\
    \    0.5);\n  page.height=(size_t) floor((double) page.height*image->y_resolution/delta.y+\n\
    \    0.5);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g\
    \ \",(double)\n     page.width,(double) page.height);\n  image=DestroyImage(image);\n\
    \  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes\
    \ != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MaxTextExtent,\"\
    -dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n\
    \      else\n        (void) FormatLocaleString(options,MaxTextExtent,\n      \
    \    \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n   \
    \       (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n\
    \      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\\
    0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n\
    \  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\n\
    \    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse\
    \ ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n\
    \    read_info->filename,input_filename);\n  options=DestroyString(options);\n\
    \  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n\
    \    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n\
    \  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n\
    \  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n  \
    \  ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"\
    BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,&image->exception);\n\
    \      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n\
    \          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n\
    \    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n  \
    \      image->magick_columns*=image->x_resolution/2.0;\n        image->magick_rows*=image->y_resolution/2.0;\n\
    \        image->columns*=image->x_resolution/2.0;\n        image->rows*=image->y_resolution/2.0;\n\
    \      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image\
    \ *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\nstatic Image *ReadPCLImage(const\
    \ ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CropBox  \"CropBox\"\
    \n#define DeviceCMYK  \"DeviceCMYK\"\n#define MediaBox  \"MediaBox\"\n#define\
    \ RenderPCLText  \"  Rendering PCL...  \"\n\n  char\n    command[MaxTextExtent],\n\
    \    *density,\n    filename[MaxTextExtent],\n    geometry[MaxTextExtent],\n \
    \   *options,\n    input_filename[MaxTextExtent];\n\n  const DelegateInfo\n  \
    \  *delegate_info;\n\n  Image\n    *image,\n    *next_image;\n\n  ImageInfo\n\
    \    *read_info;\n\n  int\n    c;\n\n  MagickBooleanType\n    cmyk,\n    status;\n\
    \n  PointInfo\n    delta;\n\n  RectangleInfo\n    bounding_box,\n    page;\n\n\
    \  char\n    *p;\n\n  SegmentInfo\n    bounds;\n\n  size_t\n    height,\n    width;\n\
    \n  ssize_t\n    count;\n\n  assert(image_info != (const ImageInfo *) NULL);\n\
    \  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug\
    \ != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\"\
    ,\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n\
    \  assert(exception->signature == MagickCoreSignature);\n  /*\n    Open image\
    \ file.\n  */\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n\
    \  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n \
    \     return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n\
    \  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"\
    UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n\
    \      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n\
    \  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  if ((image->x_resolution\
    \ == 0.0) || (image->y_resolution == 0.0))\n    {\n      GeometryInfo\n      \
    \  geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n\
    \      if ((flags & RhoValue) != 0)\n        image->x_resolution=geometry_info.rho;\n\
    \      image->y_resolution=image->x_resolution;\n      if ((flags & SigmaValue)\
    \ != 0)\n        image->y_resolution=geometry_info.sigma;\n    }\n  /*\n    Determine\
    \ page geometry from the PCL media box.\n  */\n  cmyk=image->colorspace == CMYKColorspace\
    \ ? MagickTrue : MagickFalse;\n  count=0;\n  (void) memset(&bounding_box,0,sizeof(bounding_box));\n\
    \  (void) memset(&bounds,0,sizeof(bounds));\n  (void) memset(&page,0,sizeof(page));\n\
    \  (void) memset(command,0,sizeof(command));\n  p=command;\n  for (c=ReadBlobByte(image);\
    \ c != EOF; c=ReadBlobByte(image))\n  {\n    if (image_info->page != (char *)\
    \ NULL)\n      continue;\n    /*\n      Note PCL elements.\n    */\n    *p++=(char)\
    \ c;\n    if ((c != (int) '/') && (c != '\\n') &&\n        ((size_t) (p-command)\
    \ < (MaxTextExtent-1)))\n      continue;\n    *p='\\0';\n    p=command;\n    /*\n\
    \      Is this a CMYK document?\n    */\n    if (LocaleNCompare(DeviceCMYK,command,strlen(DeviceCMYK))\
    \ == 0)\n      cmyk=MagickTrue;\n    if (LocaleNCompare(CropBox,command,strlen(CropBox))\
    \ == 0)\n      {\n        /*\n          Note region defined by crop box.\n   \
    \     */\n        count=(ssize_t) sscanf(command,\"CropBox [%lf %lf %lf %lf\"\
    ,\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n        if (count\
    \ != 4)\n          count=(ssize_t) sscanf(command,\"CropBox[%lf %lf %lf %lf\"\
    ,\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n      }\n    if\
    \ (LocaleNCompare(MediaBox,command,strlen(MediaBox)) == 0)\n      {\n        /*\n\
    \          Note region defined by media box.\n        */\n        count=(ssize_t)\
    \ sscanf(command,\"MediaBox [%lf %lf %lf %lf\",\n          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \        if (count != 4)\n          count=(ssize_t) sscanf(command,\"MediaBox[%lf\
    \ %lf %lf %lf\",\n            &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);\n\
    \      }\n    if (count != 4)\n      continue;\n    /*\n      Set PCL render geometry.\n\
    \    */\n    width=(size_t) floor(bounds.x2-bounds.x1+0.5);\n    height=(size_t)\
    \ floor(bounds.y2-bounds.y1+0.5);\n    if (width > page.width)\n      page.width=width;\n\
    \    if (height > page.height)\n      page.height=height;\n  }\n  (void) CloseBlob(image);\n\
    \  /*\n    Render PCL with the GhostPCL delegate.\n  */\n  if ((page.width ==\
    \ 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  (void) FormatLocaleString(geometry,MaxTextExtent,\"%.20gx%.20g\",(double)\n\
    \    page.width,(double) page.height);\n  if (image_info->monochrome != MagickFalse)\n\
    \    delegate_info=GetDelegateInfo(\"pcl:mono\",(char *) NULL,exception);\n  else\n\
    \     if (cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"pcl:cmyk\"\
    ,(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"\
    pcl:color\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo\
    \ *) NULL)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n\
    \    }\n  if ((page.width == 0) || (page.height == 0))\n    (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n\
    \  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n\
    \  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MaxTextExtent,\"\
    %gx%g\",\n    image->x_resolution,image->y_resolution);\n  if (image_info->ping\
    \ != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\"\
    );\n  page.width=(size_t) floor((double) page.width*image->x_resolution/delta.x+\n\
    \    0.5);\n  page.height=(size_t) floor((double) page.height*image->y_resolution/delta.y+\n\
    \    0.5);\n  (void) FormatLocaleString(options,MaxTextExtent,\"-g%.20gx%.20g\
    \ \",(double)\n     page.width,(double) page.height);\n  image=DestroyImage(image);\n\
    \  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes\
    \ != 0)\n    {\n      if (read_info->number_scenes != 1)\n        (void) FormatLocaleString(options,MaxTextExtent,\"\
    -dLastPage=%.20g\",\n          (double) (read_info->scene+read_info->number_scenes));\n\
    \      else\n        (void) FormatLocaleString(options,MaxTextExtent,\n      \
    \    \"-dFirstPage=%.20g -dLastPage=%.20g\",(double) read_info->scene+1,\n   \
    \       (double) (read_info->scene+read_info->number_scenes));\n      read_info->number_scenes=0;\n\
    \      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\\
    0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);\n\
    \  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MaxTextExtent,\n\
    \    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse\
    \ ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,\n\
    \    read_info->filename,input_filename);\n  options=DestroyString(options);\n\
    \  density=DestroyString(density);\n  status=ExternalDelegateCommand(MagickFalse,read_info->verbose,command,\n\
    \    (char *) NULL,exception) != 0 ? MagickTrue : MagickFalse;\n  image=ReadImage(read_info,exception);\n\
    \  (void) RelinquishUniqueFileResource(read_info->filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n\
    \  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n  \
    \  ThrowReaderException(DelegateError,\"PCLDelegateFailed\");\n  if (LocaleCompare(image->magick,\"\
    BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(image,&image->exception);\n\
    \      if (cmyk_image != (Image *) NULL)\n        {\n          image=DestroyImageList(image);\n\
    \          image=cmyk_image;\n        }\n    }\n  do\n  {\n    (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n\
    \    image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n  \
    \      image->magick_columns*=image->x_resolution/2.0;\n        image->magick_rows*=image->y_resolution/2.0;\n\
    \        image->columns*=image->x_resolution/2.0;\n        image->rows*=image->y_resolution/2.0;\n\
    \      }\n    next_image=SyncNextImageInList(image);\n    if (next_image != (Image\
    \ *) NULL)\n      image=next_image;\n  } while (next_image != (Image *) NULL);\n\
    \  return(GetFirstImageInList(image));\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 195405
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 1
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
