agents:
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: security_researcher
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - code_author
  - moderator
  - review_board
  role_description: "You are the Security Researcher. Identify all potential security\
    \ vulnerabilities in the given <code> snippet. \nProvide your output as a JSON\
    \ array. Each element in the array represents one identified vulnerability and\
    \ should include:\n- `vulnerability`: A short name or description of the vulnerability.\n\
    - `reason`: A detailed explanation of why this is a vulnerability and how it could\
    \ be exploited.\n- `impact`: The potential consequences if this vulnerability\
    \ were exploited.\n\nNow please analyze the following code.\n\n<code>:\neval7(\n\
    \    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\
    \twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\
    \t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n   \
    \ char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n\
    \    int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n \
    \   /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n\
    \     * string and free a string that isn't there.\n     */\n    rettv->v_type\
    \ = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are\
    \ handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg,\
    \ in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if\
    \ (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n\
    #endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\
    \treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000\
    \ we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\t\
    semsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\
    \n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case\
    \ '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n\
    \    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret\
    \ = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"\
    -\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret\
    \ == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type\
    \ != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\
    \t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"\
    ':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal\
    \ string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg,\
    \ rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n\
    \    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n  \
    \  /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\
    \t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse\
    \ if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg,\
    \ rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\
    \n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key':\
    \ val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\
    \t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\
    \t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\
    \t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret\
    \ = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment\
    \ variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\
    \t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t\
    ++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\
    \t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script()\
    \ && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\
    \t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\
    \t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t\
    \    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n\
    \     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\t\
    if (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\
    \t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\
    \n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type\
    \ is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in\
    \ compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t\
    \    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\
    \t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\
    \t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t\
    {\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg,\
    \ rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg,\
    \ evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret ==\
    \ OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\
    \t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\
    \t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable\
    \ or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t\
    \ */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias\
    \ != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t\
    {\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t   \
    \ if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\
    \t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg))\
    \ == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\
    \t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t  \
    \  else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\
    \t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len\
    \ == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type\
    \ = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\
    \t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\"\
    , 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number\
    \ = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\
    \t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\
    \t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv,\
    \ NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t\
    \    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\
    \t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and\
    \ '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if\
    \ (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\
    \n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n\
    \     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret =\
    \ eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n \
    \   return ret;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: code_author
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - security_researcher
  - moderator
  - review_board
  role_description: "You are the Code Author of <code>. The Security Researcher has\
    \ presented a JSON array of alleged vulnerabilities. \nYou must respond as if\
    \ you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it.\n\n<code>:\neval7(\n    char_u\t\
    **arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t\
    // after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t  \
    \    && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t\
    *s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n\
    \    int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n \
    \   /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n\
    \     * string and free a string that isn't there.\n     */\n    rettv->v_type\
    \ = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are\
    \ handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg,\
    \ in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if\
    \ (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n\
    #endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\
    \treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000\
    \ we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\t\
    semsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\
    \n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case\
    \ '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n\
    \    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret\
    \ = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"\
    -\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret\
    \ == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type\
    \ != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\
    \t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"\
    ':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal\
    \ string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg,\
    \ rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n\
    \    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n  \
    \  /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\
    \t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse\
    \ if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg,\
    \ rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\
    \n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key':\
    \ val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\
    \t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\
    \t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\
    \t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret\
    \ = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment\
    \ variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\
    \t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t\
    ++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\
    \t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script()\
    \ && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\
    \t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\
    \t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t\
    \    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n\
    \     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\t\
    if (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\
    \t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\
    \n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type\
    \ is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in\
    \ compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t\
    \    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\
    \t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\
    \t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t\
    {\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg,\
    \ rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg,\
    \ evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret ==\
    \ OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\
    \t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\
    \t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable\
    \ or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t\
    \ */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias\
    \ != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t\
    {\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t   \
    \ if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\
    \t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg))\
    \ == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\
    \t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t  \
    \  else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\
    \t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len\
    \ == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type\
    \ = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\
    \t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\"\
    , 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number\
    \ = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\
    \t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\
    \t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv,\
    \ NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t\
    \    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\
    \t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and\
    \ '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if\
    \ (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\
    \n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n\
    \     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret =\
    \ eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n \
    \   return ret;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    model: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    model_type: ft:gpt-4o-2024-08-06:personal:moderator:BAWoJsPO
    temperature: 0.0
  memory:
    memory_type: judge
  name: moderator
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver:
  - review_board
  - security_researcher
  - code_author
  role_description: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies.\n\n<code>:\neval7(\n    char_u\t**arg,\n    typval_T\t\
    *rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n\
    {\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags\
    \ & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start\
    \ = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n   \
    \ char_u\t*alias;\n    static\tint recurse = 0;\n\n    /*\n     * Initialise variable\
    \ so that clear_tv() can't mistake this for a\n     * string and free a string\
    \ that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n   \
    \  * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n   \
    \ start_leader = *arg;\n    if (eval_leader(arg, in_vim9script()) == FAIL)\n\t\
    return FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg\
    \ + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\
    \tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\
    \n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n\
    \    // and crash.\n    if (recurse == 1000)\n    {\n\tsemsg(_(e_expression_too_recursive_str),\
    \ *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n\
    \    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case\
    \ '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n\
    \    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate,\
    \ want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially\
    \ when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader >\
    \ start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv,\
    \ TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant:\
    \ \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate);\n\
    \t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n \
    \   case '\\'':\tret = eval_lit_string(arg, rettv, evaluate);\n\t\tbreak;\n\n\
    \    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg,\
    \ rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val,\
    \ key: val}\n     */\n    case '#':\tif (in_vim9script())\n\t\t{\n\t\t    ret\
    \ = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] ==\
    \ '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\
    \t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda:\
    \ {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n \
    \   case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t  \
    \  ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\t\tif (ret ==\
    \ NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\
    \n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg,\
    \ rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n\
    \     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\
    \n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\t\
    if (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\
    \t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script()\
    \ && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\
    \t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\
    \t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t\
    \    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n\
    \     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\t\
    if (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\
    \t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\
    \n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type\
    \ is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in\
    \ compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t\
    \    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\
    \t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\
    \t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t\
    {\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg,\
    \ rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg,\
    \ evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret ==\
    \ OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\
    \t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\
    \t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable\
    \ or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t\
    \ */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias\
    \ != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t\
    {\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t   \
    \ if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\
    \t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg))\
    \ == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\
    \t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t  \
    \  else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\
    \t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len\
    \ == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type\
    \ = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\
    \t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\"\
    , 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number\
    \ = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\
    \t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\
    \t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv,\
    \ NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t\
    \    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\
    \t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and\
    \ '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if\
    \ (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\
    \n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n\
    \     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret =\
    \ eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n \
    \   return ret;\n}"
  verbose: true
- agent_type: conversation
  llm:
    llm_type: gpt-4o
    model: gpt-4o
    model_type: gpt-4o
    temperature: 0.0
  memory:
    memory_type: judge
  name: review_board
  output_parser:
    type: vultrial
  prompt_template: 'You are working in a programming team to check whether a code
    have a potential vulnerability in it.


    ${role_description}


    ${chat_history}'
  receiver: []
  role_description: "You are the Review Board. After reviewing the Moderator\xE2\u20AC\
    \u2122s summary and <code> (if needed, the original arguments), \nproduce a JSON\
    \ array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality.\n\n<code>:\neval7(\n    char_u\t**arg,\n\
    \    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t//\
    \ after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t   \
    \   && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n\
    \    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n  \
    \  int\t\tret = OK;\n    char_u\t*alias;\n    static\tint recurse = 0;\n\n   \
    \ /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n\
    \     * string and free a string that isn't there.\n     */\n    rettv->v_type\
    \ = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are\
    \ handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg,\
    \ in_vim9script()) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if\
    \ (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n\
    #endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\
    \treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000\
    \ we run out of stack\n    // and crash.\n    if (recurse == 1000)\n    {\n\t\
    semsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\
    \n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case\
    \ '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n\
    \    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret\
    \ = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"\
    -\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret\
    \ == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type\
    \ != VAR_BLOB)\n\t\t    ret = eval7_leader(rettv, TRUE, start_leader, &end_leader);\n\
    \t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"\
    ':\tret = eval_string(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Literal\
    \ string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg,\
    \ rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n\
    \    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n  \
    \  /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (in_vim9script())\n\
    \t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse\
    \ if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg,\
    \ rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\
    \n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key':\
    \ val}\n     */\n    case '{':\tif (in_vim9script())\n\t\t    ret = NOTDONE;\n\
    \t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg);\n\
    \t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\
    \t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret\
    \ = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment\
    \ variable: $VAR.\n     */\n    case '$':\tret = eval_env_var(arg, rettv, evaluate);\n\
    \t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t\
    ++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (in_vim9script() && IS_WHITE_OR_NUL(**arg))\n\
    \t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (in_vim9script()\
    \ && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\
    \t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\
    \t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t\
    \    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n\
    \     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\t\
    if (in_vim9script())\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\
    \t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\
    \n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type\
    \ is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in\
    \ compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t\
    \    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc,\n\
    \t\t\t\t     FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\
    \t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t\
    {\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg,\
    \ rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg,\
    \ evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret ==\
    \ OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\
    \t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\
    \t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable\
    \ or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t\
    \ */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias\
    \ != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t\
    {\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t   \
    \ if (evaluate && in_vim9script() && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\
    \t\tret = FAIL;\n\t    }\n\t    else if ((in_vim9script() ? **arg : *skipwhite(*arg))\
    \ == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\
    \t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t  \
    \  else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\
    \t    {\n\t\t// get the value of \"true\", \"false\" or a variable\n\t\tif (len\
    \ == 4 && in_vim9script() && STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type\
    \ = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    ret = OK;\n\t\
    \t}\n\t\telse if (len == 5 && in_vim9script()\n\t\t\t\t\t\t&& STRNCMP(s, \"false\"\
    , 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number\
    \ = VVAL_FALSE;\n\t\t    ret = OK;\n\t\t}\n\t\telse if (len == 4 && in_vim9script()\n\
    \t\t\t\t\t\t&& STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\
    \t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    ret = OK;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv,\
    \ NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t\
    \    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\
    \t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and\
    \ '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if\
    \ (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\
    \n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n\
    \     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret =\
    \ eval7_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n \
    \   return ret;\n}"
  verbose: true
environment:
  env_type: judge
  id_save: 355649
  max_turns: 4
  rule:
    describer:
      type: basic
    order:
      type: judge
    selector:
      type: basic
    updater:
      type: basic
    visibility:
      type: all
  target: 0
  task_name: code_vulnerability_review
  unit_tests: None
prompts:
  code_author_role_prompt: "You are the Code Author of <code>. The Security Researcher\
    \ has presented a JSON array of alleged vulnerabilities. \nYou must respond as\
    \ if you are presenting your case to a group of decision-makers who will evaluate\
    \ each claim. \nYour tone should be respectful, authoritative, and confident,\
    \ as if you are defending the integrity of your work to a panel of experts.\n\n\
    For each identified vulnerability, produce a corresponding JSON object with the\
    \ following fields:\n- `vulnerability`: The same name/description from the Security\
    \ Researcher\xE2\u20AC\u2122s entry.\n- `response_type`: 'refutation' if you believe\
    \ this concern is unfounded, or 'mitigation' if you acknowledge it and propose\
    \ a workable solution.\n- `reason`: A concise explanation of why the vulnerability\
    \ is refuted or how you propose to mitigate it."
  moderator_role_prompt: "You are the Moderator, and your role is to provide a neutral\
    \ summary. \nAfter reviewing both the Security Researcher\xE2\u20AC\u2122s identified\
    \ vulnerabilities and the Code Author\xE2\u20AC\u2122s responses, \nprovide a\
    \ single JSON object with two fields:\n- `researcher_summary`: A concise summary\
    \ of the vulnerabilities and reasoning presented by the Security Researcher.\n\
    - `author_summary`: A concise summary of the Code Author\xE2\u20AC\u2122s counterarguments\
    \ or mitigation strategies."
  prompt: 'You are working in a programming team to check whether a code have a potential
    vulnerability in it.


    ${role_description}


    ${chat_history}'
  review_board_role_prompt: "You are the Review Board. After reviewing the Moderator\xE2\
    \u20AC\u2122s summary and <code> (if needed, the original arguments), \nproduce\
    \ a JSON array of verdicts for each vulnerability identified by the Security Researcher.\
    \ Each object in the array should include:\n- `vulnerability`: The same name as\
    \ given by the Security Researcher.\n- `decision`: One of 'valid', 'invalid',\
    \ or 'partially valid'.\n- `severity`: If valid or partially valid, assign a severity\
    \ ('low', 'medium', 'high'); if invalid, use 'none'.\n- `recommended_action`:\
    \ Suggest what should be done next (e.g., 'fix immediately', 'monitor', 'no action\
    \ needed').\n- `justification`: A brief explanation of why you reached this conclusion,\
    \ considering both the Security Researcher\xE2\u20AC\u2122s and Code Author\xE2\
    \u20AC\u2122s perspectives.\n\nYou need to analyze the code and evaluate the reasoning\
    \ provided by the Security Researcher, Code Author, and Moderator. Do not automatically\
    \ mark a decision as 'valid' just because the Code Author refutes it, nor mark\
    \ it as 'invalid' because the Security Researcher claims a vulnerability exists.\
    \ Instead, carefully assess whether their reasoning aligns with the actual security\
    \ implications and technical reality."
  security_researcher_role_prompt: "You are the Security Researcher. Identify all\
    \ potential security vulnerabilities in the given <code> snippet. \nProvide your\
    \ output as a JSON array. Each element in the array represents one identified\
    \ vulnerability and should include:\n- `vulnerability`: A short name or description\
    \ of the vulnerability.\n- `reason`: A detailed explanation of why this is a vulnerability\
    \ and how it could be exploited.\n- `impact`: The potential consequences if this\
    \ vulnerability were exploited.\n\nNow please analyze the following code."
