[
    {
        "function_name": "do_put",
        "vulnerability": "Buffer Overflow",
        "criticism": "The vulnerability is correctly identified as a buffer overflow due to inadequate bounds checking before copying data into the 'newp' buffer. However, the severity score is lower because the code does allocate memory for 'newp' based on calculations, which reduces the likelihood of a severe buffer overflow. The correctness score is higher as the vulnerability is accurately identified. The profitability score is moderate as exploiting this vulnerability may require specific conditions.",
        "correctness": 7,
        "severity": 4,
        "profitability": 5,
        "reason": "The function allocates memory for 'newp' but does not perform proper bounds checking before copying data into it. This can lead to a buffer overflow vulnerability where an attacker can overwrite adjacent memory locations and potentially execute arbitrary code.",
        "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t\n    int\t\tdir,\t\t\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t\n    int\t\tindent_diff = 0;\t\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n    curbuf->b_op_start = curwin->w_cursor;\t\n    curbuf->b_op_end = curwin->w_cursor;\t\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n\tcurbuf->b_op_end = curwin->w_cursor;\t\n    }\n    if (flags & PUT_LINE)\t\n\ty_type = MLINE;\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n    yanklen = (int)STRLEN(y_array[0]);\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\t    if (vcol < col) \n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\t    yanklen = (int)STRLEN(y_array[i]);\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\tif (y_type == MCHAR)\n\t{\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; \n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\t\tif (VIsual_active) \n\t\t    lnum--;\n\t    }\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     \n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     \n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\nerror:\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n    VIsual_active = FALSE;\n    adjust_cursor_eol();\n}",
        "file_name": "202081.sol"
    },
    {
        "function_name": "do_put",
        "vulnerability": "Memory Leak",
        "criticism": "The vulnerability is correctly identified as a memory leak due to not freeing the allocated memory for 'newp' before exiting the function. The severity score is moderate as memory leaks can lead to performance issues over time. The correctness score is higher as the vulnerability is accurately identified. The profitability score is low as exploiting this vulnerability does not provide direct benefits to an attacker.",
        "correctness": 8,
        "severity": 6,
        "profitability": 2,
        "reason": "The function allocates memory for 'newp' but does not free it before exiting the function. This can lead to a memory leak vulnerability where memory is allocated but not properly released, causing the program to consume excessive memory over time.",
        "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t\n    int\t\tdir,\t\t\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t\n    int\t\tindent_diff = 0;\t\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n    curbuf->b_op_start = curwin->w_cursor;\t\n    curbuf->b_op_end = curwin->w_cursor;\t\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n\tcurbuf->b_op_end = curwin->w_cursor;\t\n    }\n    if (flags & PUT_LINE)\t\n\ty_type = MLINE;\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n    yanklen = (int)STRLEN(y_array[0]);\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\t    if (vcol < col) \n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\t    yanklen = (int)STRLEN(y_array[i]);\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\tif (y_type == MCHAR)\n\t{\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; \n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\t\tif (VIsual_active) \n\t\t    lnum--;\n\t    }\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     \n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     \n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\nerror:\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n    VIsual_active = FALSE;\n    adjust_cursor_eol();\n}",
        "file_name": "202081.sol"
    },
    {
        "function_name": "do_put",
        "vulnerability": "Null Pointer Dereference",
        "criticism": "The vulnerability is correctly identified as a null pointer dereference due to accessing 'y_array' without proper validation. The severity score is moderate as null pointer dereferences can lead to crashes or undefined behavior. The correctness score is higher as the vulnerability is accurately identified. The profitability score is low as exploiting this vulnerability may not provide significant benefits to an attacker.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The function dereferences the 'y_array' pointer without proper validation, which can lead to a null pointer dereference vulnerability. If 'y_array' is NULL, accessing its elements can cause the program to crash or exhibit undefined behavior.",
        "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t\n    int\t\tdir,\t\t\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t\n    int\t\tindent_diff = 0;\t\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n    curbuf->b_op_start = curwin->w_cursor;\t\n    curbuf->b_op_end = curwin->w_cursor;\t\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n\tcurbuf->b_op_end = curwin->w_cursor;\t\n    }\n    if (flags & PUT_LINE)\t\n\ty_type = MLINE;\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n    yanklen = (int)STRLEN(y_array[0]);\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\t    if (vcol < col) \n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\t    yanklen = (int)STRLEN(y_array[i]);\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\tif (y_type == MCHAR)\n\t{\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; \n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\t\tif (VIsual_active) \n\t\t    lnum--;\n\t    }\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     \n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     \n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\nerror:\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n    VIsual_active = FALSE;\n    adjust_cursor_eol();\n}",
        "file_name": "202081.sol"
    },
    {
        "function_name": "do_put",
        "vulnerability": "Potential buffer overflow",
        "criticism": "The vulnerability is correctly identified as a potential buffer overflow due to inadequate bounds checking when copying user input into buffers. The severity score is moderate as buffer overflows can lead to security risks. The correctness score is higher as the vulnerability is accurately identified. The profitability score is moderate as exploiting this vulnerability may require specific conditions.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "There are multiple instances in the code where user input is being copied into buffers without proper bounds checking. This can lead to buffer overflow vulnerabilities if the input size exceeds the allocated buffer size, potentially allowing an attacker to overwrite adjacent memory locations.",
        "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t\n    int\t\tdir,\t\t\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t\n    int\t\tindent_diff = 0;\t\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n    curbuf->b_op_start = curwin->w_cursor;\t\n    curbuf->b_op_end = curwin->w_cursor;\t\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n\tcurbuf->b_op_end = curwin->w_cursor;\t\n    }\n    if (flags & PUT_LINE)\t\n\ty_type = MLINE;\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n    yanklen = (int)STRLEN(y_array[0]);\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\t    if (vcol < col) \n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\t    yanklen = (int)STRLEN(y_array[i]);\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\tif (y_type == MCHAR)\n\t{\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; \n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\t\tif (VIsual_active) \n\t\t    lnum--;\n\t    }\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     \n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     \n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\nerror:\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n    VIsual_active = FALSE;\n    adjust_cursor_eol();\n}",
        "file_name": "202081.sol"
    },
    {
        "function_name": "do_put",
        "vulnerability": "Potential integer overflow",
        "criticism": "The vulnerability is correctly identified as a potential integer overflow due to lack of validation for the 'count' variable. The severity score is moderate as integer overflows can lead to unexpected behavior. The correctness score is higher as the vulnerability is accurately identified. The profitability score is low as exploiting this vulnerability may not provide direct benefits to an attacker.",
        "correctness": 8,
        "severity": 6,
        "profitability": 2,
        "reason": "In this section of the code, there is a loop that iterates 'count' number of times without proper validation of the input. If 'count' is a large value, it can lead to an integer overflow, causing unexpected behavior or crashes in the application.",
        "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t\n    int\t\tdir,\t\t\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t\n    int\t\tindent_diff = 0;\t\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n    curbuf->b_op_start = curwin->w_cursor;\t\n    curbuf->b_op_end = curwin->w_cursor;\t\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n\tcurbuf->b_op_end = curwin->w_cursor;\t\n    }\n    if (flags & PUT_LINE)\t\n\ty_type = MLINE;\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n    yanklen = (int)STRLEN(y_array[0]);\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\t    if (vcol < col) \n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\t    yanklen = (int)STRLEN(y_array[i]);\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\tif (y_type == MCHAR)\n\t{\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; \n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\t\tif (VIsual_active) \n\t\t    lnum--;\n\t    }\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     \n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     \n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\nerror:\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n    VIsual_active = FALSE;\n    adjust_cursor_eol();\n}",
        "file_name": "202081.sol"
    },
    {
        "function_name": "do_put",
        "vulnerability": "Potential null pointer dereference",
        "criticism": "The vulnerability is correctly identified as a potential null pointer dereference due to lack of validation before accessing 'y_array'. The severity score is moderate as null pointer dereferences can lead to crashes or undefined behavior. The correctness score is higher as the vulnerability is accurately identified. The profitability score is low as exploiting this vulnerability may not provide significant benefits to an attacker.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The code does not perform proper validation to check if 'y_array' is NULL before accessing it. This can lead to a null pointer dereference if 'y_array' is NULL, resulting in a crash or unexpected behavior.",
        "code": "do_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t\n    int\t\tdir,\t\t\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t\n    int\t\tindent_diff = 0;\t\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n    curbuf->b_op_start = curwin->w_cursor;\t\n    curbuf->b_op_end = curwin->w_cursor;\t\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n\tcurbuf->b_op_end = curwin->w_cursor;\t\n    }\n    if (flags & PUT_LINE)\t\n\ty_type = MLINE;\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n    yanklen = (int)STRLEN(y_array[0]);\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int spaces = 0;\n\t    char shortline;\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    for (ptr = oldp; vcol < col && *ptr; )\n\t    {\n\t\tincr = lbr_chartabsize_adv(oldp, &ptr, vcol);\n\t\tvcol += incr;\n\t    }\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\t    if (vcol < col) \n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\t    yanklen = (int)STRLEN(y_array[i]);\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\tspaces = y_width + 1;\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t    spaces -= lbr_chartabsize(NULL, &y_array[i][j], 0);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t    }\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\tif (y_type == MCHAR)\n\t{\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; \n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\t\tif (VIsual_active) \n\t\t    lnum--;\n\t    }\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t    changed_bytes(lnum, col);\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     \n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     \n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\nerror:\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    if (curbuf->b_op_start.lnum + (y_type == MCHAR) - 1 + nr_lines\n\t\t\t\t\t\t < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t\t\t\t\t || curwin->w_p_diff\n#endif\n\t\t\t\t\t\t )\n\t\tmark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n    VIsual_active = FALSE;\n    adjust_cursor_eol();\n}",
        "file_name": "202081.sol"
    }
]