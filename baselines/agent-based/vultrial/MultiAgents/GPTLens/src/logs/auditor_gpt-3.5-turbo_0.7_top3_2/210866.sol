[
    {
        "function_name": "SProcXkbSelectEvents",
        "code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code does not properly check for the size of the data being processed, which could lead to a buffer overflow if 'dataLeft' is larger than expected. This can be exploited by an attacker to overwrite adjacent memory and potentially execute arbitrary code.",
        "file_name": "210866.sol"
    },
    {
        "function_name": "SProcXkbSelectEvents",
        "code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}",
        "vulnerability": "Incomplete input validation",
        "reason": "The code does not fully validate the input data, allowing for potential manipulation of the 'affectWhich' field. An attacker could exploit this vulnerability to bypass intended restrictions and trigger unexpected behavior in the program.",
        "file_name": "210866.sol"
    },
    {
        "function_name": "SProcXkbSelectEvents",
        "code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}",
        "vulnerability": "Potential pointer arithmetic vulnerability",
        "reason": "The code assigns a pointer to a specific memory location without performing proper boundary checks. This could potentially lead to pointer arithmetic vulnerabilities, allowing an attacker to manipulate memory addresses and access sensitive data or execute arbitrary code.",
        "file_name": "210866.sol"
    },
    {
        "function_name": "SProcXkbSelectEvents",
        "code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code does not properly check for buffer overflow when processing data. An attacker could exploit this vulnerability by providing extra data that exceeds the allocated buffer size, leading to a buffer overflow and potential code execution.",
        "file_name": "210866.sol"
    },
    {
        "function_name": "SProcXkbSelectEvents",
        "code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}",
        "vulnerability": "Incomplete validation of input data",
        "reason": "The code does not fully validate the input data before processing it. An attacker could manipulate the input data to bypass certain checks and potentially trigger undesired behavior in the code.",
        "file_name": "210866.sol"
    },
    {
        "function_name": "SProcXkbSelectEvents",
        "code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}",
        "vulnerability": "Information leakage",
        "reason": "The code exposes potentially sensitive information to the client by setting the error value based on specific conditions. An attacker could leverage this information leakage to gain insight into the system and aid in further attacks.",
        "file_name": "210866.sol"
    }
]