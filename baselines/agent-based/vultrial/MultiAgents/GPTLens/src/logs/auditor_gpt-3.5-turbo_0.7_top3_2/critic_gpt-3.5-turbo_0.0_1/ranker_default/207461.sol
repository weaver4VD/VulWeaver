[
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning for this vulnerability is accurate, and the severity and profitability scores are appropriate. The correctness score is also justified as the vulnerability can lead to buffer overflow and potential code execution due to lack of bounds checking.",
        "correctness": 8,
        "severity": 8,
        "profitability": 8,
        "reason": "The buffer size of 64 bytes is used for reading data from the input file without proper bounds checking. An attacker can exploit this vulnerability by providing a specially crafted input file that exceeds the buffer size, leading to a buffer overflow and potential code execution.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 8.0
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Memory Corruption",
        "criticism": "The reasoning for this vulnerability is accurate, and the severity and profitability scores are appropriate. The correctness score is also justified as the vulnerability can lead to memory corruption and potential code execution due to lack of input data validation.",
        "correctness": 8,
        "severity": 8,
        "profitability": 7,
        "reason": "The code reads 4 bytes into the buffer without verifying the size of the input data. This can lead to memory corruption vulnerabilities if the input data is not properly validated, allowing an attacker to manipulate memory and potentially execute arbitrary code.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 7.75
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Potential File Seek Vulnerability",
        "criticism": "The reasoning for this vulnerability is accurate, and the severity and profitability scores are appropriate. The correctness score is also justified as the vulnerability can lead to unauthorized access or file corruption due to improper bounds checking.",
        "correctness": 8,
        "severity": 7,
        "profitability": 7,
        "reason": "The code performs a file seek operation using the 'bfOffs' field from 'Bitmap_File_Head' without proper bounds checking. If an attacker can control the 'bfOffs' field, they could potentially manipulate the seek operation to access arbitrary locations in the file, leading to unauthorized access or file corruption.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 7.5
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The reasoning for this vulnerability is valid, but the severity and profitability scores are too high. The correctness score is also affected by the incorrect severity and profitability scores. The severity should be lower as the impact of integer overflow is not clearly defined in the context of the function. The profitability should also be lower as the likelihood of exploitation is not clearly defined.",
        "correctness": 6,
        "severity": 4,
        "profitability": 5,
        "reason": "The code performs type casting on 'Bitmap_Head.biWidth' and 'Bitmap_Head.biHeight' to 'unsigned short' without proper validation or checking for integer overflow. If the original values are large enough to cause an overflow during the type casting, it could lead to unexpected behavior or vulnerabilities in downstream functions that rely on these values.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 5.25
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Unrestricted File Access",
        "criticism": "The reasoning for this vulnerability is partially correct, but the severity and profitability scores are too high. The correctness score is also affected by the incorrect severity and profitability scores. The severity should be lower as the vulnerability does not directly lead to unrestricted file access, but rather has the potential for it. The profitability should also be lower as the likelihood of exploitation is not clearly defined.",
        "correctness": 6,
        "severity": 4,
        "profitability": 5,
        "reason": "The function does not properly validate the file format by only checking for specific magic numbers. This can allow an attacker to bypass the check by providing a malicious file with a valid magic number, leading to unrestricted file access and potential security risks.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 5.25
    },
    {
        "function_name": "input_bmp_reader",
        "vulnerability": "Potential File Disclosure",
        "criticism": "The reasoning for this vulnerability is partially correct as the code does not perform proper input validation on the 'filename' parameter. However, the severity and profitability scores are too high. The correctness score is also affected by the incorrect severity and profitability scores. The severity should be lower as the vulnerability does not directly lead to file disclosure, but rather has the potential for it. The profitability should also be lower as the likelihood of exploitation is not clearly defined.",
        "correctness": 5,
        "severity": 3,
        "profitability": 4,
        "reason": "The code does not perform proper input validation or sanitization on the 'filename' parameter before using it to open a file. An attacker could potentially manipulate the 'filename' parameter to access sensitive system files or directories, leading to information disclosure.",
        "code": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps;\n  gboolean Grey = FALSE;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n  char magick[2];\n  Bitmap_Channel masks[4];\n  fd = fopen(filename, \"rb\");\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    goto cleanup;\n  }\n  if (!ReadOK(fd, magick, 2) ||\n\t  !(!strncmp(magick, \"BA\", 2) ||\n\t\t  !strncmp(magick, \"BM\", 2) ||\n\t\t  !strncmp(magick, \"IC\", 2) ||\n\t\t  !strncmp(magick, \"PT\", 2) ||\n\t\t  !strncmp(magick, \"CI\", 2) ||\n\t\t  !strncmp(magick, \"CP\", 2)))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  while (!strncmp(magick, \"BA\", 2))\n  {\n\t  if (!ReadOK(fd, buffer, 12))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n\t  if (!ReadOK(fd, magick, 2))\n\t  {\n\t\t  LOG(\"%s is not a valid BMP file\", filename);\n\t\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t\t  goto cleanup;\n\t  }\n  }\n  if (!ReadOK(fd, buffer, 12))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x00]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x04]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x06]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x08]);\n  if (!ReadOK(fd, buffer, 4))\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  Bitmap_File_Head.biSize = ToL(&buffer[0x00]);\n  if (Bitmap_File_Head.biSize == 12) {  \n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  \n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Bitmap_Head.biClrImp = 0;\n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    memset(masks, 0, sizeof(masks));\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { \n    if (!ReadOK(fd, buffer, 36))\n    {\n      LOG (\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = 0;\n    Bitmap_Head.masks[1] = 0;\n    Bitmap_Head.masks[2] = 0;\n    Bitmap_Head.masks[3] = 0;\n    Maps = 4;\n    memset(masks, 0, sizeof(masks));\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n      {\n\tif (!ReadOK(fd, buffer, 3 * sizeof(unsigned long)))\n\t  {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n\t  }\n\tBitmap_Head.masks[0] = ToL(&buffer[0x00]);\n\tBitmap_Head.masks[1] = ToL(&buffer[0x04]);\n\tBitmap_Head.masks[2] = ToL(&buffer[0x08]);\n\tReadChannelMasks(&Bitmap_Head.masks[0], masks, 3);\n      }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n      {\n\tsetMasksDefault(Bitmap_Head.biBitCnt, masks);\n      }\n    else if ((Bitmap_Head.biCompr != BI_RLE4) &&\n\t     (Bitmap_Head.biCompr != BI_RLE8))\n      {\n\tLOG(\"Unsupported compression in BMP file\\n\");\n\tat_exception_fatal(&exp, \"Unsupported compression in BMP file\");\n\tgoto cleanup;\n      }\n  }\n  else if (Bitmap_File_Head.biSize >= 56 &&\n\t   Bitmap_File_Head.biSize <= 64)\n  {\n    if (!ReadOK (fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); \n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  \n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  \n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  \n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); \n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  \n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); \n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); \n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); \n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  \n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);       \n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);       \n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);       \n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);       \n    Maps = 4;\n    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n  }\n  else if (Bitmap_File_Head.biSize == 108 ||\n           Bitmap_File_Head.biSize == 124)\n  {\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4))\n    {\n\t    LOG(\"Error reading BMP file header\\n\");\n\t    at_exception_fatal(&exp, \"Error reading BMP file header\");\n\t    goto cleanup;\n    }\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]);\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]);\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]);\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]);\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);\n    Bitmap_Head.masks[0] = ToL(&buffer[0x24]);\n    Bitmap_Head.masks[1] = ToL(&buffer[0x28]);\n    Bitmap_Head.masks[2] = ToL(&buffer[0x2C]);\n    Bitmap_Head.masks[3] = ToL(&buffer[0x30]);\n    Maps = 4;\n    if (Bitmap_Head.biCompr == BI_BITFIELDS)\n    {\n\t    ReadChannelMasks(&Bitmap_Head.masks[0], masks, 4);\n    }\n    else if (Bitmap_Head.biCompr == BI_RGB)\n    {\n\t    setMasksDefault(Bitmap_Head.biBitCnt, masks);\n    }\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n  switch (Bitmap_Head.biBitCnt)\n  {\n  case 1:\n  case 2:\n  case 4:\n  case 8:\n  case 16:\n  case 24:\n  case 32:\n\t  break;\n  default:\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n  if ((Bitmap_Head.biClrUsed == 0) &&\n      (Bitmap_Head.biBitCnt <= 8))\n  {\n\t  ColormapSize = Bitmap_Head.biClrUsed = 1 << Bitmap_Head.biBitCnt;\n  }\n  if (ColormapSize > 256)\n    ColormapSize = 256;\n  if (Bitmap_Head.biHeight == 0 ||\n\t  Bitmap_Head.biWidth == 0)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biWidth < 0 ||\n\t  Bitmap_Head.biHeight == -2147483648)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biPlanes != 1)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (Bitmap_Head.biClrUsed > 256 &&\n\t  Bitmap_Head.biBitCnt <= 8)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  if (((unsigned long)Bitmap_Head.biWidth) > (unsigned int)0x7fffffff / Bitmap_Head.biBitCnt ||\n\t  ((unsigned long)Bitmap_Head.biWidth) > ((unsigned int)0x7fffffff /abs(Bitmap_Head.biHeight)) / 4)\n  {\n\t  LOG(\"%s is not a valid BMP file\", filename);\n\t  at_exception_fatal(&exp, \"bmp: invalid input file\");\n\t  goto cleanup;\n  }\n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n  if (Bitmap_Head.biBitCnt <= 8)\n  {\n#ifdef DEBUG\n    printf(\"Colormap read\\n\");\n#endif\n\t  if (!ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp))\n\t\t  goto cleanup;\n  }\n  fseek(fd, Bitmap_File_Head.bfOffs, SEEK_SET);\n  image_storage = ReadImage(fd, \n\tBitmap_Head.biWidth, Bitmap_Head.biHeight,\n\tColorMap,\n        Bitmap_Head.biClrUsed,\n\tBitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes,\n        Grey,\n\tmasks,\n\t&exp);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "file_name": "207461.sol",
        "final_score": 4.25
    }
]