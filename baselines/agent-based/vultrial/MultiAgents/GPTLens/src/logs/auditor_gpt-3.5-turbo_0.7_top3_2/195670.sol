[
    {
        "function_name": "xml_parse_node",
        "code": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n    PJ_CHECK_STACK();\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    node = alloc_node(pool);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    return node;\n}",
        "vulnerability": "Improper input validation leading to syntax error",
        "reason": "The code does not properly validate the input before processing, allowing an attacker to potentially input malicious data that can lead to a syntax error and disrupt the parsing process.",
        "file_name": "195670.sol"
    },
    {
        "function_name": "xml_parse_node",
        "code": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n    PJ_CHECK_STACK();\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    node = alloc_node(pool);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    return node;\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "There is a potential buffer overflow vulnerability in the code as it does not properly check the bounds of the buffer when comparing strings, which could be exploited by an attacker to overwrite adjacent memory.",
        "file_name": "195670.sol"
    },
    {
        "function_name": "xml_parse_node",
        "code": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n    PJ_CHECK_STACK();\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    node = alloc_node(pool);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    return node;\n}",
        "vulnerability": "Potential XML injection",
        "reason": "The code does not properly validate the ending tag name, which could be exploited by an attacker to inject malicious XML content and potentially manipulate the parsing process.",
        "file_name": "195670.sol"
    },
    {
        "function_name": "xml_parse_node",
        "code": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n    PJ_CHECK_STACK();\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    node = alloc_node(pool);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    return node;\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code does not check if the length of the input string is within the bounds of the buffer before accessing it, which could lead to a buffer overflow if an attacker provides a very long input string.",
        "file_name": "195670.sol"
    },
    {
        "function_name": "xml_parse_node",
        "code": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n    PJ_CHECK_STACK();\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    node = alloc_node(pool);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    return node;\n}",
        "vulnerability": "Potential denial of service",
        "reason": "The code does not handle the case where the CDATA section is never closed properly, leading to an infinite loop and causing a denial of service if an attacker provides malicious input.",
        "file_name": "195670.sol"
    },
    {
        "function_name": "xml_parse_node",
        "code": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n    PJ_CHECK_STACK();\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n    node = alloc_node(pool);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n    return node;\n}",
        "vulnerability": "Potential XML injection",
        "reason": "The code compares node names without sanitizing or validating them, which could allow an attacker to perform XML injection attacks by manipulating the node names.",
        "file_name": "195670.sol"
    }
]