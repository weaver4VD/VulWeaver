[
    {
        "function_name": "optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "SQL Injection",
        "reason": "The code does not properly sanitize user input in subqueries, allowing for potential SQL injection attacks. An attacker could manipulate the subqueries to execute malicious SQL commands.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code does not perform proper bounds checking on arrays and buffers, making it susceptible to buffer overflow attacks. An attacker could craft input that overflows the buffer, leading to potential code execution or crash.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Denial of Service",
        "reason": "The code lacks proper input validation and error handling, allowing an attacker to send specially crafted input that could lead to a denial of service by causing the application to enter into an infinite loop or consume excessive resources.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Potential SQL Injection",
        "reason": "The code dynamically constructs and executes SQL queries without proper input validation. This can lead to SQL injection attacks where an attacker can manipulate the query to retrieve or modify sensitive data.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Potential Denial of Service (DoS)",
        "reason": "The code does not have proper checks for resource exhaustion. An attacker could potentially exploit this by sending specially crafted requests to exhaust system resources, leading to a denial of service.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Insecure Direct Object Reference",
        "reason": "The code does not properly validate and authorize user access to resources. This could lead to insecure direct object references where an attacker can access unauthorized data or perform unauthorized actions.",
        "file_name": "508874.sol"
    }
]