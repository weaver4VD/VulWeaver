[
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Unvalidated input leading to potential bypass of error handling",
        "reason": "The code directly checks if the input value is an error and if so, jumps to the 'failed' label. However, the input value is not validated or sanitized before this check, allowing an attacker to potentially bypass the error handling logic by providing a malicious input.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Potential memory corruption through unvalidated input",
        "reason": "In the error handling section of the code, the 'value' pointer is assigned the address of 'vm->retval' without any validation or checks. This can potentially lead to memory corruption vulnerabilities if 'vm->retval' is not a valid pointer or contains unexpected data.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Potential use-after-free vulnerability",
        "reason": "After calling 'njs_vmcode_interpreter', the code sets 'function->context' and 'function->await' to NULL without ensuring that they are not being used elsewhere. This can lead to a use-after-free vulnerability if other parts of the code still try to access these fields.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Unvalidated input leading to potential error propagation",
        "reason": "The code does not perform proper validation on the input value before using it. This can lead to unexpected errors being propagated through the code, potentially allowing attackers to cause a denial of service or execute arbitrary code.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code does not perform proper bounds checking when accessing the arguments array. This could potentially lead to a buffer overflow if the nargs parameter is manipulated by an attacker, allowing them to overwrite adjacent memory and potentially execute arbitrary code.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Potential memory corruption",
        "reason": "The code assigns pointers to local, closure, and temporary variables without performing proper validation or memory allocation checks. This could potentially lead to memory corruption if the async structure is manipulated by an attacker, allowing them to control the program's execution flow or access sensitive data.",
        "file_name": "198476.sol"
    }
]