[
    {
        "function_name": "gdImageFillToBorder",
        "code": "gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n}",
        "vulnerability": "Recursive Call Vulnerability",
        "reason": "The function gdImageFillToBorder calls itself recursively when the conditions are met. This can lead to a stack overflow if the recursion depth becomes too deep, resulting in a denial of service attack.",
        "file_name": "206588.sol"
    },
    {
        "function_name": "gdImageFillToBorder",
        "code": "gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n}",
        "vulnerability": "Stack Buffer Overflow",
        "reason": "The function does not perform any bounds checking when setting pixels in the image buffer. An attacker could provide input values that cause the function to write beyond the boundaries of the image buffer, leading to a stack buffer overflow. This can be exploited to execute arbitrary code and gain control over the program.",
        "file_name": "206588.sol"
    },
    {
        "function_name": "gdImageFillToBorder",
        "code": "gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n}",
        "vulnerability": "Unrestricted Recursion",
        "reason": "The function gdImageFillToBorder does not have a limit on the number of recursive calls it can make. An attacker could potentially create a large number of recursive calls, exhausting system resources and causing a denial of service by making the program unresponsive.",
        "file_name": "206588.sol"
    },
    {
        "function_name": "gdImageFillToBorder",
        "code": "gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n}",
        "vulnerability": "Potential stack overflow via recursive calls",
        "reason": "The function gdImageFillToBorder recursively calls itself in certain conditions, which can lead to a stack overflow if the recursion depth is too high. An attacker could potentially exploit this vulnerability by causing the function to recursively call itself numerous times, exhausting the stack space and causing a denial of service.",
        "file_name": "206588.sol"
    },
    {
        "function_name": "gdImageFillToBorder",
        "code": "gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n}",
        "vulnerability": "Potential for buffer overflow",
        "reason": "The function gdImageFillToBorder does not perform bounds checking when setting pixels using gdImageSetPixel. If the values of 'x' and 'y' are not properly validated before calling this function, an attacker could provide malicious input that causes the function to write outside the bounds of the image buffer, leading to a buffer overflow vulnerability.",
        "file_name": "206588.sol"
    },
    {
        "function_name": "gdImageFillToBorder",
        "code": "gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n  int lastBorder;\n  int leftLimit, rightLimit;\n  int i;\n  leftLimit = (-1);\n  if (border < 0)\n    {\n      return;\n    }\n  for (i = x; (i >= 0); i--)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      leftLimit = i;\n    }\n  if (leftLimit == (-1))\n    {\n      return;\n    }\n  rightLimit = x;\n  for (i = (x + 1); (i < im->sx); i++)\n    {\n      if (gdImageGetPixel (im, i, y) == border)\n\t{\n\t  break;\n\t}\n      gdImageSetPixel (im, i, y, color);\n      rightLimit = i;\n    }\n  if (y > 0)\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y - 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y - 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n  if (y < ((im->sy) - 1))\n    {\n      lastBorder = 1;\n      for (i = leftLimit; (i <= rightLimit); i++)\n\t{\n\t  int c;\n\t  c = gdImageGetPixel (im, i, y + 1);\n\t  if (lastBorder)\n\t    {\n\t      if ((c != border) && (c != color))\n\t\t{\n\t\t  gdImageFillToBorder (im, i, y + 1,\n\t\t\t\t       border, color);\n\t\t  lastBorder = 0;\n\t\t}\n\t    }\n\t  else if ((c == border) || (c == color))\n\t    {\n\t      lastBorder = 1;\n\t    }\n\t}\n    }\n}",
        "vulnerability": "Potential for integer overflow",
        "reason": "The function gdImageFillToBorder does not check for potential integer overflow when calculating the loop boundaries in the 'for' loops. If the values of 'x' and 'y' are manipulated by an attacker to be very large, it could lead to an integer overflow when adding or subtracting values in the loops, causing unexpected behavior and potentially leading to security vulnerabilities.",
        "file_name": "206588.sol"
    }
]