[
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Unbounded string copy leading to buffer overflow",
        "criticism": "The reasoning provided for this vulnerability is accurate as the function xstrdup does not check the size of the input string before copying it to process->args[i]. This can indeed lead to a buffer overflow if the input string is larger than the allocated memory for process->args[i]. An attacker can exploit this vulnerability by providing a large input string, causing a buffer overflow and potentially executing malicious code. The correctness score is high as the vulnerability is correctly identified. The severity score is also high as a buffer overflow can lead to serious security implications. The profitability score is moderate as exploiting this vulnerability may require specific conditions.",
        "correctness": 8,
        "severity": 8,
        "profitability": 5,
        "reason": "The function xstrdup does not check the size of the input string before copying it to process->args[i]. This can lead to a buffer overflow if the input string is larger than the allocated memory for process->args[i]. An attacker can exploit this vulnerability by providing a large input string, causing a buffer overflow and potentially executing malicious code.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Uninitialized memory read",
        "criticism": "The reasoning provided for this vulnerability is accurate as the function dup_array copies the contents of exec_options.cap to capabilities->bounding without initializing the memory in capabilities->bounding. This can lead to reading uninitialized memory if exec_options.cap_size is greater than the size of capabilities->bounding. An attacker can exploit this vulnerability to leak sensitive information from memory. The correctness score is high as the vulnerability is correctly identified. The severity score is moderate as uninitialized memory read can lead to information disclosure. The profitability score is low as exploiting this vulnerability may not provide direct benefits to an attacker.",
        "correctness": 8,
        "severity": 6,
        "profitability": 3,
        "reason": "The function dup_array copies the contents of exec_options.cap to capabilities->bounding without initializing the memory in capabilities->bounding. If exec_options.cap_size is greater than the size of capabilities->bounding, it can lead to reading uninitialized memory. An attacker can exploit this vulnerability to leak sensitive information from memory.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential command injection",
        "criticism": "The reasoning provided for this vulnerability is accurate as the function argv[first_arg] is directly passed to libcrun_container_exec_with_options without proper validation or sanitization. This can indeed lead to command injection if the input from argv[first_arg] is controlled by an attacker. An attacker can exploit this vulnerability to execute arbitrary commands on the system. The correctness score is high as the vulnerability is correctly identified. The severity score is moderate as command injection can have serious consequences. The profitability score is moderate as exploiting this vulnerability may provide attackers with control over the system.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The function argv[first_arg] is directly passed to libcrun_container_exec_with_options without proper validation or sanitization. This can lead to command injection if the input from argv[first_arg] is controlled by an attacker. An attacker can exploit this vulnerability to execute arbitrary commands on the system.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Command Injection",
        "criticism": "The reasoning provided for this vulnerability is accurate as the function 'init_libcrun_context' is called with user-controlled input 'argv[first_arg]' without proper input validation. This can be exploited by an attacker to inject malicious commands through the 'argv' array, leading to command injection vulnerability. The correctness score is high as the vulnerability is correctly identified. The severity score is moderate as command injection can have serious consequences. The profitability score is moderate as exploiting this vulnerability may provide attackers with control over the system.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The function 'init_libcrun_context' is called with user-controlled input 'argv[first_arg]' without proper input validation. This can be exploited by an attacker to inject malicious commands through the 'argv' array, leading to command injection vulnerability.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning provided for this vulnerability is accurate as the function 'xstrdup' is used to copy user-controlled input 'argv[first_arg + i + 1]' into 'process->args[i]' without proper bounds checking, leading to a potential buffer overflow vulnerability if the input size exceeds the allocated memory for 'process->args'. An attacker can exploit this vulnerability to overwrite adjacent memory locations and execute arbitrary code. The correctness score is high as the vulnerability is correctly identified. The severity score is high as buffer overflow can lead to serious security implications. The profitability score is moderate as exploiting this vulnerability may require specific conditions.",
        "correctness": 8,
        "severity": 8,
        "profitability": 5,
        "reason": "The function 'xstrdup' is used to copy user-controlled input 'argv[first_arg + i + 1]' into 'process->args[i]' without proper bounds checking, leading to a potential buffer overflow vulnerability if the input size exceeds the allocated memory for 'process->args'. An attacker can exploit this vulnerability to overwrite adjacent memory locations and execute arbitrary code.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Memory Leak",
        "criticism": "The reasoning provided for this vulnerability is accurate as the memory allocated for 'capabilities->bounding' using 'dup_array' function is not freed, leading to a memory leak vulnerability. This can be exploited by an attacker to exhaust system resources by repeatedly triggering this code path, causing denial of service. The correctness score is high as the vulnerability is correctly identified. The severity score is low as memory leaks may not have immediate security implications. The profitability score is low as exploiting this vulnerability may not provide direct benefits to an attacker.",
        "correctness": 8,
        "severity": 3,
        "profitability": 2,
        "reason": "Memory allocated for 'capabilities->bounding' using 'dup_array' function is not freed, leading to a memory leak vulnerability. This can be exploited by an attacker to exhaust system resources by repeatedly triggering this code path, causing denial of service.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    }
]