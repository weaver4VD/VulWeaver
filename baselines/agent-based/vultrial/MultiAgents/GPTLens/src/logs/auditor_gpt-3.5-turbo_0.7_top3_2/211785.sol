[
    {
        "function_name": "cp_create",
        "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\tif (tcp->numlyrs > 1) {\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\treturn cp;\nerror:\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "vulnerability": "Potential Buffer Overflow",
        "reason": "The code does not perform adequate input validation on user-provided values before using them to allocate memory or access arrays. This can lead to buffer overflows if the user inputs values that are larger than expected, allowing attackers to overwrite adjacent memory locations and potentially execute malicious code.",
        "file_name": "211785.sol"
    },
    {
        "function_name": "cp_create",
        "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\tif (tcp->numlyrs > 1) {\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\treturn cp;\nerror:\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "vulnerability": "Potential Logic Flaw",
        "reason": "The code contains a logic flaw in determining the color space and multi-component transform (MCT) settings. Depending on the input values and conditions, the code may incorrectly assign MCT settings or issue warning messages. This can be exploited by attackers to manipulate the color space or transform settings in unexpected ways, potentially leading to data corruption or security vulnerabilities.",
        "file_name": "211785.sol"
    },
    {
        "function_name": "cp_create",
        "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\tif (tcp->numlyrs > 1) {\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\treturn cp;\nerror:\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "vulnerability": "Potential Information Disclosure",
        "reason": "The code does not properly enforce the monotonic increase of intermediate layer rates, allowing for potential information disclosure if the rates are not correctly ordered. If an attacker can manipulate the rates to violate this requirement, they may gain insights into the encoding process or exploit vulnerabilities related to the incorrect interpretation of layer rates.",
        "file_name": "211785.sol"
    },
    {
        "function_name": "cp_create",
        "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\tif (tcp->numlyrs > 1) {\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\treturn cp;\nerror:\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "There is a potential buffer overflow vulnerability in the function cp_create. Specifically, in the section where the option values are being parsed, there are no checks to ensure that the input values do not exceed the allocated buffer size. This could potentially lead to a buffer overflow if the input values are larger than expected, allowing an attacker to overwrite adjacent memory locations and potentially execute arbitrary code.",
        "file_name": "211785.sol"
    },
    {
        "function_name": "cp_create",
        "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\tif (tcp->numlyrs > 1) {\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\treturn cp;\nerror:\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "vulnerability": "Memory Leak",
        "reason": "There is a memory leak vulnerability in the function cp_create. In the error handling section of the function, if an error occurs, the function will return without freeing the allocated memory for ilyrrates. This can result in a memory leak over time, potentially leading to resource exhaustion and denial of service.",
        "file_name": "211785.sol"
    },
    {
        "function_name": "cp_create",
        "code": "static jpc_enc_cp_t *cp_create(const char *optstr, jas_image_t *image)\n{\n\tjpc_enc_cp_t *cp;\n\tjas_tvparser_t *tvp;\n\tint ret;\n\tint numilyrrates;\n\tdouble *ilyrrates;\n\tint i;\n\tint tagid;\n\tjpc_enc_tcp_t *tcp;\n\tjpc_enc_tccp_t *tccp;\n\tjpc_enc_ccp_t *ccp;\n\tuint_fast16_t rlvlno;\n\tuint_fast16_t prcwidthexpn;\n\tuint_fast16_t prcheightexpn;\n\tbool enablemct;\n\tuint_fast32_t jp2overhead;\n\tuint_fast16_t lyrno;\n\tuint_fast32_t hsteplcm;\n\tuint_fast32_t vsteplcm;\n\tbool mctvalid;\n\ttvp = 0;\n\tcp = 0;\n\tilyrrates = 0;\n\tnumilyrrates = 0;\n\tif (!(cp = jas_malloc(sizeof(jpc_enc_cp_t)))) {\n\t\tgoto error;\n\t}\n\tprcwidthexpn = 15;\n\tprcheightexpn = 15;\n\tenablemct = true;\n\tjp2overhead = 0;\n\tcp->ccps = 0;\n\tcp->debug = 0;\n\tcp->imgareatlx = UINT_FAST32_MAX;\n\tcp->imgareatly = UINT_FAST32_MAX;\n\tcp->refgrdwidth = 0;\n\tcp->refgrdheight = 0;\n\tcp->tilegrdoffx = UINT_FAST32_MAX;\n\tcp->tilegrdoffy = UINT_FAST32_MAX;\n\tcp->tilewidth = 0;\n\tcp->tileheight = 0;\n\tcp->numcmpts = jas_image_numcmpts(image);\n\thsteplcm = 1;\n\tvsteplcm = 1;\n\tfor (unsigned cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\tif (jas_image_cmptbrx(image, cmptno) + jas_image_cmpthstep(image, cmptno) <=\n\t\t  jas_image_brx(image) || jas_image_cmptbry(image, cmptno) +\n\t\t  jas_image_cmptvstep(image, cmptno) <= jas_image_bry(image)) {\n\t\t\tjas_eprintf(\"unsupported image type\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\thsteplcm *= jas_image_cmpthstep(image, cmptno);\n\t\tvsteplcm *= jas_image_cmptvstep(image, cmptno);\n\t}\n\tif (!(cp->ccps = jas_alloc2(cp->numcmpts, sizeof(jpc_enc_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tunsigned cmptno;\n\tfor (cmptno = 0, ccp = cp->ccps; cmptno < cp->numcmpts; ++cmptno,\n\t  ++ccp) {\n\t\tccp->sampgrdstepx = jas_image_cmpthstep(image, cmptno);\n\t\tccp->sampgrdstepy = jas_image_cmptvstep(image, cmptno);\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->sampgrdsubstepx = 0;\n\t\tccp->prec = jas_image_cmptprec(image, cmptno);\n\t\tccp->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tccp->numstepsizes = 0;\n\t\tmemset(ccp->stepsizes, 0, sizeof(ccp->stepsizes));\n\t}\n\tcp->rawsize = jas_image_rawsize(image);\n\tif (cp->rawsize == 0) {\n\t\tgoto error;\n\t}\n\tcp->totalsize = UINT_FAST32_MAX;\n\ttcp = &cp->tcp;\n\ttcp->csty = 0;\n\ttcp->intmode = true;\n\ttcp->prg = JPC_COD_LRCPPRG;\n\ttcp->numlyrs = 1;\n\ttcp->ilyrrates = 0;\n\ttccp = &cp->tccp;\n\ttccp->csty = 0;\n\ttccp->maxrlvls = 6;\n\ttccp->cblkwidthexpn = 6;\n\ttccp->cblkheightexpn = 6;\n\ttccp->cblksty = 0;\n\ttccp->numgbits = 2;\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\tgoto error;\n\t}\n\twhile (!(ret = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(encopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_DEBUG:\n\t\t\tcp->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFX:\n\t\t\tcp->imgareatlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_IMGAREAOFFY:\n\t\t\tcp->imgareatly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFX:\n\t\t\tcp->tilegrdoffx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEGRDOFFY:\n\t\t\tcp->tilegrdoffy = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEWIDTH:\n\t\t\tcp->tilewidth = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_TILEHEIGHT:\n\t\t\tcp->tileheight = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_PRCWIDTH:\n\t\t\tprcwidthexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_PRCHEIGHT:\n\t\t\tprcheightexpn = jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKWIDTH:\n\t\t\ttccp->cblkwidthexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_CBLKHEIGHT:\n\t\t\ttccp->cblkheightexpn =\n\t\t\t  jpc_floorlog2(atoi(jas_tvparser_getval(tvp)));\n\t\t\tbreak;\n\t\tcase OPT_MODE:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(modetab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid mode %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->intmode = (tagid == MODE_INT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_PRG:\n\t\t\tif ((tagid = jas_taginfo_nonull(jas_taginfos_lookup(prgordtab,\n\t\t\t  jas_tvparser_getval(tvp)))->id) < 0) {\n\t\t\t\tjas_eprintf(\"ignoring invalid progression order %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t} else {\n\t\t\t\ttcp->prg = tagid;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_NOMCT:\n\t\t\tenablemct = false;\n\t\t\tbreak;\n\t\tcase OPT_MAXRLVLS:\n\t\t\ttccp->maxrlvls = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_SOP:\n\t\t\tcp->tcp.csty |= JPC_COD_SOP;\n\t\t\tbreak;\n\t\tcase OPT_EPH:\n\t\t\tcp->tcp.csty |= JPC_COD_EPH;\n\t\t\tbreak;\n\t\tcase OPT_LAZY:\n\t\t\ttccp->cblksty |= JPC_COX_LAZY;\n\t\t\tbreak;\n\t\tcase OPT_TERMALL:\n\t\t\ttccp->cblksty |= JPC_COX_TERMALL;\n\t\t\tbreak;\n\t\tcase OPT_SEGSYM:\n\t\t\ttccp->cblksty |= JPC_COX_SEGSYM;\n\t\t\tbreak;\n\t\tcase OPT_VCAUSAL:\n\t\t\ttccp->cblksty |= JPC_COX_VSC;\n\t\t\tbreak;\n\t\tcase OPT_RESET:\n\t\t\ttccp->cblksty |= JPC_COX_RESET;\n\t\t\tbreak;\n\t\tcase OPT_PTERM:\n\t\t\ttccp->cblksty |= JPC_COX_PTERM;\n\t\t\tbreak;\n\t\tcase OPT_NUMGBITS:\n\t\t\tcp->tccp.numgbits = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_RATE:\n\t\t\tif (ratestrtosize(jas_tvparser_getval(tvp), cp->rawsize,\n\t\t\t  &cp->totalsize)) {\n\t\t\t\tjas_eprintf(\"ignoring bad rate specifier %s\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_ILYRRATES:\n\t\t\tif (jpc_atoaf(jas_tvparser_getval(tvp), &numilyrrates,\n\t\t\t  &ilyrrates)) {\n\t\t\t\tjas_eprintf(\"warning: invalid intermediate layer rates specifier ignored (%s)\\n\",\n\t\t\t\t  jas_tvparser_getval(tvp));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_JP2OVERHEAD:\n\t\t\tjp2overhead = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\ttvp = 0;\n\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\tcp->totalsize = (cp->totalsize > jp2overhead) ?\n\t\t  (cp->totalsize - jp2overhead) : 0;\n\t}\n\tif (cp->imgareatlx == UINT_FAST32_MAX) {\n\t\tcp->imgareatlx = 0;\n\t} else {\n\t\tif (hsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatlx value\\n\");\n\t\t}\n\t\tcp->imgareatlx *= hsteplcm;\n\t}\n\tif (cp->imgareatly == UINT_FAST32_MAX) {\n\t\tcp->imgareatly = 0;\n\t} else {\n\t\tif (vsteplcm != 1) {\n\t\t\tjas_eprintf(\"warning: overriding imgareatly value\\n\");\n\t\t}\n\t\tcp->imgareatly *= vsteplcm;\n\t}\n\tcp->refgrdwidth = cp->imgareatlx + jas_image_width(image);\n\tcp->refgrdheight = cp->imgareatly + jas_image_height(image);\n\tif (cp->tilegrdoffx == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffx = cp->imgareatlx;\n\t}\n\tif (cp->tilegrdoffy == UINT_FAST32_MAX) {\n\t\tcp->tilegrdoffy = cp->imgareatly;\n\t}\n\tif (!cp->tilewidth) {\n\t\tcp->tilewidth = cp->refgrdwidth - cp->tilegrdoffx;\n\t}\n\tif (!cp->tileheight) {\n\t\tcp->tileheight = cp->refgrdheight - cp->tilegrdoffy;\n\t}\n\tif (cp->numcmpts == 3) {\n\t\tmctvalid = true;\n\t\tfor (cmptno = 0; cmptno < jas_image_numcmpts(image); ++cmptno) {\n\t\t\tif (jas_image_cmptprec(image, cmptno) != jas_image_cmptprec(image, 0) ||\n\t\t\t  jas_image_cmptsgnd(image, cmptno) != jas_image_cmptsgnd(image, 0) ||\n\t\t\t  jas_image_cmptwidth(image, cmptno) != jas_image_cmptwidth(image, 0) ||\n\t\t\t  jas_image_cmptheight(image, cmptno) != jas_image_cmptheight(image, 0)) {\n\t\t\t\tmctvalid = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmctvalid = false;\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) != JAS_CLRSPC_FAM_RGB) {\n\t\tjas_eprintf(\"warning: color space apparently not RGB\\n\");\n\t}\n\tif (mctvalid && enablemct && jas_clrspc_fam(jas_image_clrspc(image)) == JAS_CLRSPC_FAM_RGB) {\n\t\ttcp->mctid = (tcp->intmode) ? (JPC_MCT_RCT) : (JPC_MCT_ICT);\n\t} else {\n\t\ttcp->mctid = JPC_MCT_NONE;\n\t}\n\ttccp->qmfbid = (tcp->intmode) ? (JPC_COX_RFT) : (JPC_COX_INS);\n\tfor (rlvlno = 0; rlvlno < tccp->maxrlvls; ++rlvlno) {\n\t\ttccp->prcwidthexpns[rlvlno] = prcwidthexpn;\n\t\ttccp->prcheightexpns[rlvlno] = prcheightexpn;\n\t}\n\tif (prcwidthexpn != 15 || prcheightexpn != 15) {\n\t\ttccp->csty |= JPC_COX_PRT;\n\t}\n\tif (!cp->tilewidth) {\n\t\tjas_eprintf(\"invalid tile width %lu\\n\", (unsigned long)\n\t\t  cp->tilewidth);\n\t\tgoto error;\n\t}\n\tif (!cp->tileheight) {\n\t\tjas_eprintf(\"invalid tile height %lu\\n\", (unsigned long)\n\t\t  cp->tileheight);\n\t\tgoto error;\n\t}\n\tif (cp->tilegrdoffx > cp->imgareatlx ||\n\t  cp->tilegrdoffy > cp->imgareatly ||\n\t  cp->tilegrdoffx + cp->tilewidth < cp->imgareatlx ||\n\t  cp->tilegrdoffy + cp->tileheight < cp->imgareatly) {\n\t\tjas_eprintf(\"invalid tile grid offset (%lu, %lu)\\n\",\n\t\t  (unsigned long) cp->tilegrdoffx, (unsigned long)\n\t\t  cp->tilegrdoffy);\n\t\tgoto error;\n\t}\n\tcp->numhtiles = JPC_CEILDIV(cp->refgrdwidth - cp->tilegrdoffx,\n\t  cp->tilewidth);\n\tcp->numvtiles = JPC_CEILDIV(cp->refgrdheight - cp->tilegrdoffy,\n\t  cp->tileheight);\n\tcp->numtiles = cp->numhtiles * cp->numvtiles;\n\tif (ilyrrates && numilyrrates > 0) {\n\t\ttcp->numlyrs = numilyrrates + 1;\n\t\tif (!(tcp->ilyrrates = jas_alloc2((tcp->numlyrs - 1),\n\t\t  sizeof(jpc_fix_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < JAS_CAST(int, tcp->numlyrs - 1); ++i) {\n\t\t\ttcp->ilyrrates[i] = jpc_dbltofix(ilyrrates[i]);\n\t\t}\n\t}\n\tif (cp->totalsize == UINT_FAST32_MAX && (!cp->tcp.intmode)) {\n\t\tjas_eprintf(\"cannot use real mode for lossless coding\\n\");\n\t\tgoto error;\n\t}\n\tif (prcwidthexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct width\\n\");\n\t\tgoto error;\n\t}\n\tif (prcheightexpn > 15) {\n\t\tjas_eprintf(\"invalid precinct height\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn < 2 || cp->tccp.cblkwidthexpn > 12) {\n\t\tjas_eprintf(\"invalid code block width %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkwidthexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkheightexpn < 2 || cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"invalid code block height %d\\n\",\n\t\t  JPC_POW2(cp->tccp.cblkheightexpn));\n\t\tgoto error;\n\t}\n\tif (cp->tccp.cblkwidthexpn + cp->tccp.cblkheightexpn > 12) {\n\t\tjas_eprintf(\"code block size too large\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tcp.numlyrs > 16384) {\n\t\tjas_eprintf(\"too many layers\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.maxrlvls < 1) {\n\t\tjas_eprintf(\"must be at least one resolution level\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->tccp.numgbits > 8) {\n\t\tjas_eprintf(\"invalid number of guard bits\\n\");\n\t\tgoto error;\n\t}\n\tif (cp->totalsize != UINT_FAST32_MAX && cp->totalsize > cp->rawsize) {\n\t\tjas_eprintf(\"warning: specified rate is unreasonably large (%lu > %lu)\\n\", (unsigned long) cp->totalsize, (unsigned long) cp->rawsize);\n\t}\n\tif (tcp->numlyrs > 1) {\n\t\tfor (lyrno = 0; lyrno + 2 < tcp->numlyrs; ++lyrno) {\n\t\t\tif (tcp->ilyrrates[lyrno] >= tcp->ilyrrates[lyrno + 1]) {\n\t\t\t\tjas_eprintf(\"intermediate layer rates must increase monotonically\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cp->totalsize != UINT_FAST32_MAX) {\n\t\t\tfor (lyrno = 0; lyrno < tcp->numlyrs - 1; ++lyrno) {\n\t\t\t\tif (jpc_fixtodbl(tcp->ilyrrates[lyrno]) > ((double) cp->totalsize)\n\t\t\t\t  / cp->rawsize) {\n\t\t\t\t\tjas_eprintf(\"warning: intermediate layer rates must be less than overall rate\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\treturn cp;\nerror:\n\tif (ilyrrates) {\n\t\tjas_free(ilyrrates);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\tif (cp) {\n\t\tjpc_enc_cp_destroy(cp);\n\t}\n\treturn 0;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "There is a potential integer overflow vulnerability in the function cp_create. In several places within the function, integer values are being manipulated without proper checks for overflow. This could lead to unexpected behavior or security vulnerabilities if the calculated values exceed the maximum allowable integer size, allowing an attacker to potentially control the program flow.",
        "file_name": "211785.sol"
    }
]