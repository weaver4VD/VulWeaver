[
    {
        "function_name": "parse",
        "vulnerability": "Buffer Overflow",
        "criticism": "The function uses the strcpy function to copy the name of sections with a potential buffer overflow vulnerability. If the length of the section name is greater than 15 characters, the function attempts to copy a longer string than the allocated buffer size of 4 characters in the flag array, leading to a buffer overflow. The reasoning provided is accurate and the vulnerability is correctly identified. However, the severity score could be higher as buffer overflows can lead to serious security implications, such as remote code execution. The profitability score is also high as attackers can exploit buffer overflows to gain unauthorized access or disrupt the system.",
        "correctness": 7,
        "severity": 8,
        "profitability": 8,
        "reason": "The function uses the strcpy function to copy the name of sections with a potential buffer overflow vulnerability. If the length of the section name is greater than 15 characters, the function attempts to copy a longer string than the allocated buffer size of 4 characters in the flag array, leading to a buffer overflow.",
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n    MODE = get_elf_class(elf);\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n    if (MODE == ELFCLASS32) {\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    if (MODE == ELFCLASS64) {\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    return 0;\n}",
        "file_name": "217551.sol"
    },
    {
        "function_name": "parse",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The function does not perform proper checks when copying the section name to the flag array, potentially leading to an integer overflow vulnerability. If the length of the section name is too large, the calculation to copy the name to the flag array may overflow and result in unexpected behavior. The reasoning provided is accurate, and the vulnerability is correctly identified. The severity score could be higher as integer overflows can lead to unpredictable behavior and security risks. The profitability score is also high as attackers can potentially exploit integer overflows to manipulate program behavior.",
        "correctness": 7,
        "severity": 7,
        "profitability": 8,
        "reason": "The function does not perform proper checks when copying the section name to the flag array, potentially leading to an integer overflow vulnerability. If the length of the section name is too large, the calculation to copy the name to the flag array may overflow and result in unexpected behavior.",
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n    MODE = get_elf_class(elf);\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n    if (MODE == ELFCLASS32) {\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    if (MODE == ELFCLASS64) {\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    return 0;\n}",
        "file_name": "217551.sol"
    },
    {
        "function_name": "parse",
        "vulnerability": "Potential Use After Free",
        "criticism": "The function accesses memory that may have been unmapped or released, potentially leading to a use-after-free vulnerability. This could be exploited by an attacker to execute arbitrary code or crash the application. The reasoning provided is accurate, and the vulnerability is correctly identified. The severity score could be higher as use-after-free vulnerabilities can be exploited to gain control of the application's execution flow. The profitability score is also high as attackers can leverage use-after-free vulnerabilities for malicious purposes.",
        "correctness": 8,
        "severity": 8,
        "profitability": 8,
        "reason": "The function accesses memory that may have been unmapped or released, potentially leading to a use-after-free vulnerability. This could be exploited by an attacker to execute arbitrary code or crash the application.",
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n    MODE = get_elf_class(elf);\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n    if (MODE == ELFCLASS32) {\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    if (MODE == ELFCLASS64) {\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    return 0;\n}",
        "file_name": "217551.sol"
    },
    {
        "function_name": "parse",
        "vulnerability": "Buffer Overflow",
        "criticism": "The code is copying a string into the 'name' variable using the strcpy function without ensuring that the destination buffer has enough space. This can lead to a buffer overflow if the length of the 'name' string is greater than the available space in the 'name' buffer. The reasoning provided is accurate, and the vulnerability is correctly identified. The severity score could be higher as buffer overflows can lead to serious security implications. The profitability score is also high as attackers can exploit buffer overflows to gain unauthorized access or disrupt the system.",
        "correctness": 7,
        "severity": 8,
        "profitability": 8,
        "reason": "The code is copying a string into the 'name' variable using the strcpy function without ensuring that the destination buffer has enough space. This can lead to a buffer overflow if the length of the 'name' string is greater than the available space in the 'name' buffer.",
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n    MODE = get_elf_class(elf);\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n    if (MODE == ELFCLASS32) {\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    if (MODE == ELFCLASS64) {\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    return 0;\n}",
        "file_name": "217551.sol"
    },
    {
        "function_name": "parse",
        "vulnerability": "Command Injection",
        "criticism": "The code is using user input in the printf function without proper validation or sanitization. This can lead to command injection vulnerabilities if an attacker is able to control the input passed to the printf function. The reasoning provided is accurate, and the vulnerability is correctly identified. The severity score could be higher as command injection vulnerabilities can allow attackers to execute arbitrary commands on the system. The profitability score is also high as attackers can exploit command injection to gain unauthorized access or disrupt the system.",
        "correctness": 8,
        "severity": 8,
        "profitability": 8,
        "reason": "The code is using user input in the printf function without proper validation or sanitization. This can lead to command injection vulnerabilities if an attacker is able to control the input passed to the printf function.",
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n    MODE = get_elf_class(elf);\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n    if (MODE == ELFCLASS32) {\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    if (MODE == ELFCLASS64) {\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    return 0;\n}",
        "file_name": "217551.sol"
    },
    {
        "function_name": "parse",
        "vulnerability": "Integer Overflow",
        "criticism": "The code is using the snprintf function to format an integer value into a string without ensuring that the destination buffer has enough space. This can lead to integer overflow vulnerabilities if the formatted integer value is too large for the buffer. The reasoning provided is accurate, and the vulnerability is correctly identified. The severity score could be higher as integer overflows can lead to unpredictable behavior and security risks. The profitability score is also high as attackers can potentially exploit integer overflows to manipulate program behavior.",
        "correctness": 7,
        "severity": 7,
        "profitability": 8,
        "reason": "The code is using the snprintf function to format an integer value into a string without ensuring that the destination buffer has enough space. This can lead to integer overflow vulnerabilities if the formatted integer value is too large for the buffer.",
        "code": "int parse(char *elf) {\n    int fd;\n    struct stat st;\n    uint8_t *elf_map;\n    int count;\n    char *tmp;\n    char *name;\n    char flag[4];\n    MODE = get_elf_class(elf);\n    fd = open(elf, O_RDONLY);\n    if (fd < 0) {\n        perror(\"open\");\n        return -1;\n    }\n    if (fstat(fd, &st) < 0) {\n        perror(\"fstat\");\n        return -1;\n    }\n    elf_map = mmap(0, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    if (elf_map == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n    if (MODE == ELFCLASS32) {\n        Elf32_Ehdr *ehdr;\n        ehdr = (Elf32_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf32_Shdr *shdr;\n        Elf32_Phdr *phdr;\n        Elf32_Shdr shstrtab;\n        shdr = (Elf32_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf32_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf32_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf32_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf32_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    if (MODE == ELFCLASS64) {\n        Elf64_Ehdr *ehdr;\n        ehdr = (Elf64_Ehdr *)elf_map;\n        INFO(\"ELF Header\\n\");        \n        switch (ehdr->e_type) {\n            case ET_NONE:\n                tmp = \"An unknown type\";\n                break;\n            case ET_REL:\n                tmp = \"A relocatable file\";\n                break;\n            case ET_EXEC:\n                tmp = \"An executable file\";\n                break;\n            case ET_DYN:\n                tmp = \"A shared object\";\n                break;\n            case ET_CORE:\n                tmp = \"A core file\";\n                break;\n            default:\n                tmp = \"An unknown type\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_type:\", ehdr->e_type, tmp);\n        switch (ehdr->e_type) {\n            case EM_NONE:\n                tmp = \"An unknown machine\";\n                break;\n            case EM_M32:\n                tmp = \"AT&T WE 32100\";\n                break;\n            case EM_SPARC:\n                tmp = \"Sun Microsystems SPARC\";\n                break;\n            case EM_386:\n                tmp = \"Intel 80386\";\n                break;\n            case EM_68K:\n                tmp = \"Motorola 68000\";\n                break;\n            case EM_88K:\n                tmp = \"Motorola 88000\";\n                break;\n            case EM_860:\n                tmp = \"Intel 80860\";\n                break;\n            case EM_MIPS:\n                tmp = \"MIPS RS3000 (big-endian only)\";\n                break;\n            case EM_PARISC:\n                tmp = \"HP/PA\";\n                break;\n            case EM_SPARC32PLUS:\n                tmp = \"SPARC with enhanced instruction set\";\n                break;\n            case EM_PPC:\n                tmp = \"PowerPC\";\n                break;\n            case EM_PPC64:\n                tmp = \"PowerPC 64-bit\";\n                break;\n            case EM_S390:\n                tmp = \"IBM S/390\";\n                break;\n            case EM_ARM:\n                tmp = \"Advanced RISC Machines\";\n                break;\n            case EM_SH:\n                tmp = \"Renesas SuperH\";\n                break;\n            case EM_SPARCV9:\n                tmp = \"SPARC v9 64-bit\";\n                break;\n            case EM_IA_64:\n                tmp = \"Intel Itanium\";\n                break;\n            case EM_X86_64:\n                tmp = \"AMD x86-64\";\n                break;\n            case EM_VAX:\n                tmp = \"DEC Vax\";\n                break;\n            default:\n                tmp = \"An unknown machine\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_machine:\", ehdr->e_machine, tmp);\n        switch (ehdr->e_version) {\n            case EV_NONE:\n                tmp = \"Invalid version\";\n                break;\n            case EV_CURRENT:\n                tmp = \"Current version\";\n                break;\n            default:\n                tmp = \"Known version\";\n                break;\n        }\n        PRINT_HEADER_EXP(\"e_version:\", ehdr->e_version, tmp);\n        PRINT_HEADER(\"e_entry:\", ehdr->e_entry);\n        PRINT_HEADER(\"e_phoff:\", ehdr->e_phoff);\n        PRINT_HEADER(\"e_shoff:\", ehdr->e_shoff);\n        PRINT_HEADER(\"e_flags:\", ehdr->e_flags);\n        PRINT_HEADER(\"e_ehsize:\", ehdr->e_ehsize);\n        PRINT_HEADER(\"e_phentsize:\", ehdr->e_phentsize);\n        PRINT_HEADER(\"e_phnum:\", ehdr->e_phnum);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shentsize:\", ehdr->e_shentsize);\n        PRINT_HEADER(\"e_shstrndx:\", ehdr->e_shstrndx);\n        Elf64_Shdr *shdr;\n        Elf64_Phdr *phdr;\n        Elf64_Shdr shstrtab;\n        shdr = (Elf64_Shdr *)&elf_map[ehdr->e_shoff];\n        phdr = (Elf64_Phdr *)&elf_map[ehdr->e_phoff];\n        shstrtab = shdr[ehdr->e_shstrndx];\n        INFO(\"Section Header Table\\n\");\n        PRINT_SECTION_TITLE(\"Nr\", \"Name\", \"Type\", \"Addr\", \"Off\", \"Size\", \"Es\", \"Flg\", \"Lk\", \"Inf\", \"Al\");\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            switch (shdr[i].sh_type) {\n                case SHT_NULL:\n                    tmp = \"SHT_NULL\";\n                    break;\n                case SHT_PROGBITS:\n                    tmp = \"SHT_PROGBITS\";\n                    break;\n                case SHT_SYMTAB:\n                    tmp = \"SHT_SYMTAB\";\n                    break;\n                case SHT_STRTAB:\n                    tmp = \"SHT_STRTAB\";\n                    break;\n                case SHT_RELA:\n                    tmp = \"SHT_RELA\";\n                    break;\n                case SHT_HASH:\n                    tmp = \"SHT_HASH\";\n                    break;\n                case SHT_DYNAMIC:\n                    tmp = \"SHT_DYNAMIC\";\n                    break;\n                case SHT_NOTE:\n                    tmp = \"SHT_NOTE\";\n                    break;\n                case SHT_NOBITS:\n                    tmp = \"SHT_NOBITS\";\n                    break;\n                case SHT_REL:\n                    tmp = \"SHT_REL\";\n                    break;\n                case SHT_SHLIB:\n                    tmp = \"SHT_SHLIB\";\n                    break;\n                case SHT_DYNSYM:\n                    tmp = \"SHT_DYNSYM\";\n                    break;\n                case SHT_LOPROC:\n                    tmp = \"SHT_LOPROC\";\n                    break;\n                case SHT_HIPROC:\n                    tmp = \"SHT_HIPROC\";\n                    break;\n                case SHT_LOUSER:\n                    tmp = \"SHT_LOUSER\";\n                    break;\n                case SHT_HIUSER:\n                    tmp = \"SHT_HIUSER\";\n                    break;\n                default:\n                    break;\n            }\n            if (strlen(name) > 15) {\n                strcpy(&name[15 - 6], \"[...]\");\n            }\n            strcpy(flag, \"   \");\n            flag2str_sh(shdr[i].sh_flags, flag);\n            PRINT_SECTION(i, name, tmp, shdr[i].sh_addr, shdr[i].sh_offset, shdr[i].sh_size, shdr[i].sh_entsize, \\\n                            flag, shdr[i].sh_link, shdr[i].sh_info, shdr[i].sh_addralign);\n        }\n        INFO(\"Program Header Table\\n\");\n        PRINT_PROGRAM_TITLE(\"Nr\", \"Type\", \"Offset\", \"Virtaddr\", \"Physaddr\", \"Filesiz\", \"Memsiz\", \"Flg\", \"Align\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            switch (phdr[i].p_type) {\n                case PT_NULL:\n                    tmp = \"PT_NULL\";\n                    break;\n                case PT_LOAD:\n                    tmp = \"PT_LOAD\";\n                    break;\n                case PT_DYNAMIC:\n                    tmp = \"PT_DYNAMIC\";\n                    break;\n                case PT_INTERP:\n                    tmp = \"PT_INTERP\";\n                    break;\n                case PT_NOTE:\n                    tmp = \"PT_NOTE\";\n                    break;\n                case PT_SHLIB:\n                    tmp = \"PT_SHLIB\";\n                    break;\n                case PT_PHDR:\n                    tmp = \"PT_PHDR\";\n                    break;\n                case PT_LOPROC:\n                    tmp = \"PT_LOPROC\";\n                    break;\n                case PT_HIPROC:\n                    tmp = \"PT_HIPROC\";\n                    break;\n                case PT_GNU_STACK:\n                    tmp = \"PT_GNU_STACK\";\n                    break;\n                default:\n                    break;\n            }\n            strcpy(flag, \"   \");\n            flag2str(phdr[i].p_flags, flag);\n            PRINT_PROGRAM(i, tmp, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr, phdr[i].p_filesz, phdr[i].p_memsz, flag, phdr[i].p_align); \n        }\n        INFO(\"Section to segment mapping\\n\");\n        for (int i = 0; i < ehdr->e_phnum; i++) {\n            printf(\"     [%2d]\", i);\n            for (int j = 0; j < ehdr->e_shnum; j++) {\n                name = elf_map + shstrtab.sh_offset + shdr[j].sh_name;\n                if (shdr[j].sh_addr >= phdr[i].p_vaddr && shdr[j].sh_addr + shdr[j].sh_size <= phdr[i].p_vaddr + phdr[i].p_memsz && shdr[j].sh_type != SHT_NULL) {\n                    if (shdr[j].sh_flags >> 1 & 0x1) {\n                        printf(\" %s\", name);\n                    }\n                }    \n            }\n            printf(\"\\n\");\n        }\n        INFO(\"Dynamic link information\\n\");\n        int dynstr;\n        int dynamic;\n        Elf64_Dyn *dyn;\n        for (int i = 0; i < ehdr->e_shnum; i++) {\n            name = elf_map + shstrtab.sh_offset + shdr[i].sh_name;\n            if (!strcmp(name, \".dynstr\")) {\n                dynstr = i;\n            }\n            if (!strcmp(name, \".dynamic\")) {\n                dynamic = i;\n            }\n        }\n        char value[50];\n        name = \"\";\n        dyn = (Elf64_Dyn *)&elf_map[shdr[dynamic].sh_offset];\n        count = shdr[dynamic].sh_size / sizeof(Elf64_Dyn);\n        INFO(\"Dynamic section at offset 0x%x contains %d entries\\n\", shdr[dynamic].sh_offset, count);\n        PRINT_DYN_TITLE(\"Tag\", \"Type\", \"Name/Value\");\n        for(int i = 0; i < count; i++) {\n            tmp = \"\";\n            memset(value, 0, 50);\n            snprintf(value, 50, \"0x%x\", dyn[i].d_un.d_val);\n            switch (dyn[i].d_tag) {\n                case DT_NULL:\n                    tmp = \"DT_NULL\";\n                    break;\n                case DT_NEEDED:\n                    tmp = \"DT_NEEDED\";\n                    name = elf_map + shdr[dynstr].sh_offset + dyn[i].d_un.d_val;\n                    snprintf(value, 50, \"Shared library: [%s]\", name);\n                    break;\n                case DT_PLTRELSZ:\n                    tmp = \"DT_PLTRELSZ\";\n                    break;\n                case DT_PLTGOT:\n                    tmp = \"DT_PLTGOT\";\n                    break;\n                case DT_HASH:\n                    tmp = \"DT_HASH\";\n                    break;\n                case DT_STRTAB:\n                    tmp = \"DT_STRTAB\";\n                    break;\n                case DT_SYMTAB:\n                    tmp = \"DT_SYMTAB\";\n                    break;\n                case DT_RELA:\n                    tmp = \"DT_RELA\";\n                    break;\n                case DT_RELASZ:\n                    tmp = \"DT_RELASZ\";\n                    break;\n                case DT_RELAENT:\n                    tmp = \"DT_RELAENT\";\n                    break;\n                case DT_STRSZ:\n                    tmp = \"DT_STRSZ\";\n                    break;\n                case DT_SYMENT:\n                    tmp = \"DT_SYMENT\";\n                    break;\n                case DT_INIT:\n                    tmp = \"DT_INIT\";\n                    break;\n                case DT_FINI:\n                    tmp = \"DT_FINI\";\n                    break;\n                case DT_SONAME:\n                    tmp = \"DT_SONAME\";\n                    break;\n                case DT_RPATH:\n                    tmp = \"DT_RPATH\";\n                    break;\n                case DT_SYMBOLIC:\n                    tmp = \"DT_SYMBOLIC\";\n                    break;\n                case DT_REL:\n                    tmp = \"DT_REL\";\n                    break;\n                case DT_RELSZ:\n                    tmp = \"DT_RELSZ\";\n                    break;\n                case DT_RELENT:\n                    tmp = \"DT_RELENT\";\n                    break;\n                case DT_PLTREL:\n                    tmp = \"DT_PLTREL\";\n                    break;\n                case DT_DEBUG:\n                    tmp = \"DT_DEBUG\";\n                    break;\n                case DT_TEXTREL:\n                    tmp = \"DT_TEXTREL\";\n                    break;\n                case DT_JMPREL:\n                    tmp = \"DT_JMPREL\";\n                    break;\n                case DT_BIND_NOW:\n                    tmp = \"DT_BIND_NOW\";\n                    break;\n                case DT_INIT_ARRAY:\n                    tmp = \"DT_INIT_ARRAY\";\n                    break;\n                case DT_FINI_ARRAY:\n                    tmp = \"DT_FINI_ARRAY\";\n                    break;\n                case DT_INIT_ARRAYSZ:\n                    tmp = \"DT_INIT_ARRAYSZ\";\n                    break;\n                case DT_FINI_ARRAYSZ:\n                    tmp = \"DT_FINI_ARRAYSZ\";\n                    break;\n                case DT_RUNPATH:\n                    tmp = \"DT_RUNPATH\";\n                    break;\n                case DT_FLAGS:\n                    tmp = \"DT_FLAGS\";\n                    snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                    break;\n                case DT_ENCODING:\n                    tmp = \"DT_ENCODING\";\n                    break;\n                case DT_PREINIT_ARRAYSZ:\n                    tmp = \"DT_PREINIT_ARRAYSZ\";\n                    break;\n                case DT_SYMTAB_SHNDX:\n                    tmp = \"DT_SYMTAB_SHNDX\";\n                    break;\n                case DT_NUM:\n                    tmp = \"DT_NUM\";\n                    break;\n                case DT_LOOS:\n                    tmp = \"DT_LOOS\";\n                    break;\n                case DT_HIOS:\n                    tmp = \"DT_HIOS\";\n                    break;\n                case DT_LOPROC:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_HIPROC:\n                    tmp = \"DT_HIPROC\";\n                    break;\n                case DT_PROCNUM:\n                    tmp = \"DT_LOPROC\";\n                    break;\n                case DT_VALRNGLO:\n                    tmp = \"DT_VALRNGLO\";\n                    break;\n                case DT_GNU_PRELINKED:\n                    tmp = \"DT_GNU_PRELINKED\";\n                    break;\n                case DT_GNU_CONFLICTSZ:\n                    tmp = \"DT_GNU_CONFLICTSZ\";\n                    break;\n                case DT_GNU_LIBLISTSZ:\n                    tmp = \"DT_GNU_LIBLISTSZ\";\n                    break;\n                case DT_CHECKSUM:\n                    tmp = \"DT_CHECKSUM\";\n                    break;\n                case DT_PLTPADSZ:\n                    tmp = \"DT_PLTPADSZ\";\n                    break;\n                case DT_MOVEENT:\n                    tmp = \"DT_MOVEENT\";\n                    break;\n                case DT_MOVESZ:\n                    tmp = \"DT_MOVESZ\";\n                    break;\n                case DT_FEATURE_1:\n                    tmp = \"DT_FEATURE_1\";\n                    break;\n                case DT_POSFLAG_1:\n                    tmp = \"DT_POSFLAG_1\";\n                    break;\n                case DT_SYMINSZ:\n                    tmp = \"DT_SYMINSZ\";\n                    break;\n                case DT_SYMINENT:\n                    tmp = \"DT_SYMINENT\";\n                    break;\n                case DT_ADDRRNGLO:\n                    tmp = \"DT_ADDRRNGLO\";\n                    break;\n                case DT_GNU_HASH:\n                    tmp = \"DT_GNU_HASH\";\n                    break;\n                case DT_TLSDESC_PLT:\n                    tmp = \"DT_TLSDESC_PLT\";\n                    break;\n                case DT_TLSDESC_GOT:\n                    tmp = \"DT_TLSDESC_GOT\";\n                    break;\n                case DT_GNU_CONFLICT:\n                    tmp = \"DT_GNU_CONFLICT\";\n                    break;\n                case DT_GNU_LIBLIST:\n                    tmp = \"DT_GNU_LIBLIST\";\n                    break;\n                case DT_CONFIG:\n                    tmp = \"DT_CONFIG\";\n                    break;\n                case DT_DEPAUDIT:\n                    tmp = \"DT_DEPAUDIT\";\n                    break;\n                case DT_AUDIT:\n                    tmp = \"DT_AUDIT\";\n                    break;\n                case DT_PLTPAD:\n                    tmp = \"DT_PLTPAD\";\n                    break;\n                case DT_MOVETAB:\n                    tmp = \"DT_MOVETAB\";\n                    break;\n                case DT_SYMINFO:\n                    tmp = \"DT_SYMINFO\";\n                    break;\n                case DT_VERSYM:\n                    tmp = \"DT_VERSYM\";\n                    break;\n                case DT_RELACOUNT:\n                    tmp = \"DT_RELACOUNT\";\n                    break;\n                case DT_RELCOUNT:\n                    tmp = \"DT_RELCOUNT\";\n                    break;\n                case DT_FLAGS_1:\n                    tmp = \"DT_FLAGS_1\";\n                    switch (dyn[i].d_un.d_val) {\n                        case DF_1_PIE:\n                            snprintf(value, 50, \"Flags: %s\", \"PIE\");\n                            break;\n                        default:\n                            snprintf(value, 50, \"Flags: %d\", dyn[i].d_un.d_val);\n                            break;\n                    }\n                    break;\n                case DT_VERDEF:\n                    tmp = \"DT_VERDEF\";\n                    break;\n                case DT_VERDEFNUM:\n                    tmp = \"DT_VERDEFNUM\";\n                    break;\n                case DT_VERNEED:\n                    tmp = \"DT_VERNEED\";\n                    break;\n                case DT_VERNEEDNUM:\n                    tmp = \"DT_VERNEEDNUM\";\n                    break;\n                default:\n                    break;\n            }\n            PRINT_DYN(dyn[i].d_tag, tmp, value);\n        }        \n    }\n    return 0;\n}",
        "file_name": "217551.sol"
    }
]