[
    {
        "function_name": "g_socket_client_connected_callback",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n        }\n      else\n        {\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n        }\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data, FALSE);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data, FALSE);\n    }\n}",
        "vulnerability": "Potential DoS through resource exhaustion",
        "reason": "An attacker can repeatedly trigger the condition where the connection attempt fails, leading to the execution of 'enumerator_next_async' and potentially causing resource exhaustion on the server side, ultimately resulting in a denial of service (DoS) attack.",
        "file_name": "468349.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n        }\n      else\n        {\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n        }\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data, FALSE);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data, FALSE);\n    }\n}",
        "vulnerability": "Information Disclosure",
        "reason": "The use of 'g_critical' to log an error message indicating a potential bug in the library may provide attackers with insights into the internal workings of the application, potentially aiding them in crafting further attacks or exploiting existing vulnerabilities.",
        "file_name": "468349.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n        }\n      else\n        {\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n        }\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data, FALSE);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data, FALSE);\n    }\n}",
        "vulnerability": "Error Handling and Information Leakage",
        "reason": "The error message generated in this code snippet may unintentionally leak sensitive information about the proxy protocol being used, potentially aiding attackers in understanding the system's configuration and devising targeted attacks based on this information.",
        "file_name": "468349.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n        }\n      else\n        {\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n        }\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data, FALSE);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data, FALSE);\n    }\n}",
        "vulnerability": "Proxying over non-TCP connection",
        "reason": "The code attempts to proxy over a non-TCP connection, which is flagged as a critical issue. This vulnerability can be exploited by an attacker to manipulate the proxying process and potentially gain unauthorized access or perform malicious actions on the network.",
        "file_name": "468349.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n        }\n      else\n        {\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n        }\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data, FALSE);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data, FALSE);\n    }\n}",
        "vulnerability": "Incomplete proxy connection handling",
        "reason": "The code calls the function g_socket_client_async_connect_complete without proper validation or checks for potential errors in the proxy connection process. This can lead to incomplete or insecure proxy connections, allowing attackers to intercept or manipulate network traffic.",
        "file_name": "468349.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (g_cancellable_is_cancelled (attempt->cancellable) || task_completed_or_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data, FALSE);\n        }\n      else\n        {\n          g_clear_error (&error);\n          g_object_unref (data->task);\n          connection_attempt_unref (attempt);\n        }\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data, FALSE);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data, FALSE);\n    }\n}",
        "vulnerability": "Unvalidated proxy connection",
        "reason": "The code initiates a proxy connection without sufficient validation or verification of the proxy server's authenticity. This can be exploited by an attacker to redirect network traffic to a malicious proxy server, leading to data interception or manipulation.",
        "file_name": "468349.sol"
    }
]