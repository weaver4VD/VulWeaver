[
    {
        "function_name": "pax_decode_header",
        "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n  return true;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code snippet is vulnerable to a buffer overflow attack because there is no check for the length of the input buffer 'nbuf' before writing to it. An attacker can provide a malicious input that exceeds the bounds of the buffer, causing a buffer overflow and potentially leading to arbitrary code execution.",
        "file_name": "216027.sol"
    },
    {
        "function_name": "pax_decode_header",
        "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n  return true;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The code snippet is vulnerable to an integer overflow attack because the decode_num function does not perform proper input validation on the input 'nbuf'. An attacker can provide a malicious input that causes an integer overflow, leading to unexpected behavior and potentially a denial of service or privilege escalation.",
        "file_name": "216027.sol"
    },
    {
        "function_name": "pax_decode_header",
        "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n  return true;\n}",
        "vulnerability": "Memory Allocation Vulnerability",
        "reason": "The code snippet is vulnerable to a memory allocation vulnerability because it allocates memory based on user-controlled input 'file->stat_info->sparse_map_size'. An attacker can provide a large value for 'sparse_map_size', causing excessive memory allocation and potentially leading to a memory exhaustion attack.",
        "file_name": "216027.sol"
    },
    {
        "function_name": "pax_decode_header",
        "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n  return true;\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code snippet is using a macro COPY_BUF to copy data from one buffer to another. However, the macro does not check for buffer overflow before copying data. This can lead to a buffer overflow vulnerability if the source buffer is larger than the destination buffer.",
        "file_name": "216027.sol"
    },
    {
        "function_name": "pax_decode_header",
        "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n  return true;\n}",
        "vulnerability": "Potential memory corruption",
        "reason": "The code snippet is allocating memory for sparse_map using xcalloc based on the value of sparse_map_size. However, there is no check to ensure that sparse_map_size is a valid size. If an attacker can control the value of sparse_map_size, they can trigger a memory corruption vulnerability by allocating a large amount of memory.",
        "file_name": "216027.sol"
    },
    {
        "function_name": "pax_decode_header",
        "code": "pax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n  return true;\n}",
        "vulnerability": "Potential integer overflow",
        "reason": "The code snippet is using a for loop to iterate over sparse_map_size elements. If the value of sparse_map_size is controlled by an attacker and is a large value, it can lead to an integer overflow vulnerability. This can potentially result in unexpected behavior and security issues.",
        "file_name": "216027.sol"
    }
]