[
    {
        "function_name": "vfswrap_fsctl",
        "vulnerability": "Potential Buffer Overflow in FSCTL_CREATE_OR_GET_OBJECT_ID",
        "criticism": "The reasoning provided correctly identifies the potential buffer overflow vulnerability in the FSCTL_CREATE_OR_GET_OBJECT_ID case due to the lack of input validation for in_len. However, the severity score should be higher as buffer overflows can lead to critical security issues. The correctness score is high as the vulnerability is accurately described. The profitability score is also high as exploiting buffer overflows can lead to unauthorized access or code execution.",
        "correctness": 8,
        "severity": 7,
        "profitability": 8,
        "reason": "In the FSCTL_CREATE_OR_GET_OBJECT_ID case, the function allocates a buffer of size 64 using talloc_array. However, it does not check if the input in_len is greater than 64 before copying data into the buffer. This could lead to a buffer overflow if in_len is larger than the allocated buffer size, potentially allowing an attacker to overwrite critical data or execute arbitrary code.",
        "code": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, \n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\t\treturn status;\n\t}\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count;\n\t\t}\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*out_data = cur_pdata;\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\t\tif (labels) {\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n\t\tcur_pdata += 12;\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\t\tTALLOC_FREE(shadow_data);\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\t\tif (in_len < 8) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\t\tif (offset + length < offset) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\t\t*out_data = out_data_tmp;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tdefault:\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
        "file_name": "301429.sol"
    },
    {
        "function_name": "vfswrap_fsctl",
        "vulnerability": "Memory Leak in FSCTL_GET_SHADOW_COPY_DATA",
        "criticism": "The reasoning correctly identifies the memory leak vulnerability in the FSCTL_GET_SHADOW_COPY_DATA case. The severity score should be higher as memory leaks can impact system performance and stability. The correctness score is high as the vulnerability is accurately described. The profitability score is moderate as memory leaks can be used in conjunction with other vulnerabilities for exploitation.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "In the FSCTL_GET_SHADOW_COPY_DATA case, the function allocates memory for shadow_data using talloc_zero but does not free this memory before returning. If an error condition is met in the function, the allocated memory is not properly freed, leading to a memory leak. This could be exploited by an attacker to exhaust system memory resources and potentially cause a denial of service.",
        "code": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, \n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\t\treturn status;\n\t}\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count;\n\t\t}\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*out_data = cur_pdata;\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\t\tif (labels) {\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n\t\tcur_pdata += 12;\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\t\tTALLOC_FREE(shadow_data);\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\t\tif (in_len < 8) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\t\tif (offset + length < offset) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\t\t*out_data = out_data_tmp;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tdefault:\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
        "file_name": "301429.sol"
    },
    {
        "function_name": "vfswrap_fsctl",
        "vulnerability": "Information Disclosure in FSCTL_FIND_FILES_BY_SID",
        "criticism": "The reasoning accurately identifies the information disclosure vulnerability in the FSCTL_FIND_FILES_BY_SID case due to revealing sensitive information in debug output. The severity score should be higher as information disclosure can lead to privacy breaches. The correctness score is high as the vulnerability is accurately described. The profitability score is moderate as information disclosure can aid attackers in further exploitation.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "In the FSCTL_FIND_FILES_BY_SID case, the function extracts a security identifier (SID) from the input data and attempts to convert it to a user ID (uid). If the conversion fails, the function returns an error status. However, the error message in the debug output reveals sensitive information about the SID being processed, potentially leaking information about user accounts or security settings to an attacker.",
        "code": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, \n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\t\treturn status;\n\t}\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count;\n\t\t}\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*out_data = cur_pdata;\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\t\tif (labels) {\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n\t\tcur_pdata += 12;\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\t\tTALLOC_FREE(shadow_data);\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\t\tif (in_len < 8) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\t\tif (offset + length < offset) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\t\t*out_data = out_data_tmp;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tdefault:\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
        "file_name": "301429.sol"
    },
    {
        "function_name": "vfswrap_fsctl",
        "vulnerability": "Potential Buffer Overflow",
        "criticism": "The reasoning correctly identifies the potential buffer overflow vulnerability in the FSCTL_GET_SHADOW_COPY_DATA case due to insufficient validation for *out_data allocation. The severity score should be higher as buffer overflows can lead to critical security issues. The correctness score is high as the vulnerability is accurately described. The profitability score is moderate as exploiting buffer overflows can lead to unauthorized access or code execution.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "In the FSCTL_GET_SHADOW_COPY_DATA case, the function allocates memory for *out_data based on the value of max_out_len without sufficient validation. If an attacker provides a very large value for max_out_len, it could lead to a buffer overflow vulnerability, allowing them to overwrite adjacent memory and potentially execute arbitrary code.",
        "code": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, \n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\t\treturn status;\n\t}\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count;\n\t\t}\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*out_data = cur_pdata;\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\t\tif (labels) {\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n\t\tcur_pdata += 12;\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\t\tTALLOC_FREE(shadow_data);\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\t\tif (in_len < 8) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\t\tif (offset + length < offset) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\t\t*out_data = out_data_tmp;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tdefault:\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
        "file_name": "301429.sol"
    },
    {
        "function_name": "vfswrap_fsctl",
        "vulnerability": "Information Disclosure",
        "criticism": "The reasoning correctly identifies the information disclosure vulnerability in the FSCTL_FIND_FILES_BY_SID case due to parsing input data without proper validation. The severity score should be higher as information disclosure can lead to privacy breaches. The correctness score is high as the vulnerability is accurately described. The profitability score is moderate as information disclosure can aid attackers in further exploitation.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "In the FSCTL_FIND_FILES_BY_SID case, the function parses input data as a security identifier (SID) without proper validation or bounds checking. If an attacker provides malicious input data for the SID, it could potentially disclose sensitive information or leak memory contents, leading to an information disclosure vulnerability.",
        "code": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, \n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\t\treturn status;\n\t}\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count;\n\t\t}\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*out_data = cur_pdata;\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\t\tif (labels) {\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n\t\tcur_pdata += 12;\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\t\tTALLOC_FREE(shadow_data);\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\t\tif (in_len < 8) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\t\tif (offset + length < offset) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\t\t*out_data = out_data_tmp;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tdefault:\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
        "file_name": "301429.sol"
    },
    {
        "function_name": "vfswrap_fsctl",
        "vulnerability": "Denial of Service (DoS)",
        "criticism": "The reasoning correctly identifies the denial of service vulnerability in the FSCTL_QUERY_ALLOCATED_RANGES case due to lack of proper validation for offset and length. The severity score should be higher as denial of service can disrupt system availability. The correctness score is high as the vulnerability is accurately described. The profitability score is moderate as denial of service can impact system performance and availability.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "In the FSCTL_QUERY_ALLOCATED_RANGES case, the function calculates the offset and length based on input data without proper validation. If an attacker provides manipulated or extreme values for offset and length, it could lead to excessive resource consumption or crashes, resulting in a denial of service vulnerability.",
        "code": "static NTSTATUS vfswrap_fsctl(struct vfs_handle_struct *handle,\n\t\t\t      struct files_struct *fsp,\n\t\t\t      TALLOC_CTX *ctx,\n\t\t\t      uint32_t function,\n\t\t\t      uint16_t req_flags, \n\t\t\t      const uint8_t *_in_data,\n\t\t\t      uint32_t in_len,\n\t\t\t      uint8_t **_out_data,\n\t\t\t      uint32_t max_out_len,\n\t\t\t      uint32_t *out_len)\n{\n\tconst char *in_data = (const char *)_in_data;\n\tchar **out_data = (char **)_out_data;\n\tswitch (function) {\n\tcase FSCTL_SET_SPARSE:\n\t{\n\t\tbool set_sparse = true;\n\t\tNTSTATUS status;\n\t\tif (in_len >= 1 && in_data[0] == 0) {\n\t\t\tset_sparse = false;\n\t\t}\n\t\tstatus = file_set_sparse(handle->conn, fsp, set_sparse);\n\t\tDEBUG(NT_STATUS_IS_OK(status) ? 10 : 9,\n\t\t      (\"FSCTL_SET_SPARSE: fname[%s] set[%u] - %s\\n\",\n\t\t       smb_fname_str_dbg(fsp->fsp_name), set_sparse, \n\t\t       nt_errstr(status)));\n\t\treturn status;\n\t}\n\tcase FSCTL_CREATE_OR_GET_OBJECT_ID:\n\t{\n\t\tunsigned char objid[16];\n\t\tchar *return_data = NULL;\n\t\tDEBUG(10,(\"FSCTL_CREATE_OR_GET_OBJECT_ID: called on %s\\n\",\n\t\t\t  fsp_fnum_dbg(fsp)));\n\t\t*out_len = (max_out_len >= 64) ? 64 : max_out_len;\n\t\treturn_data = talloc_array(ctx, char, 64);\n\t\tif (return_data == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tpush_file_id_16(return_data, &fsp->file_id);\n\t\tmemcpy(return_data+16,create_volume_objectid(fsp->conn,objid),16);\n\t\tpush_file_id_16(return_data+32, &fsp->file_id);\n\t\t*out_data = return_data;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_GET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_GET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_SET_REPARSE_POINT:\n\t{\n\t\tDEBUG(10, (\"FSCTL_SET_REPARSE_POINT: called on %s. \"\n\t\t\t   \"Status: NOT_IMPLEMENTED\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_NOT_A_REPARSE_POINT;\n\t}\n\tcase FSCTL_GET_SHADOW_COPY_DATA:\n\t{\n\t\tstruct shadow_copy_data *shadow_data = NULL;\n\t\tbool labels = False;\n\t\tuint32 labels_data_count = 0;\n\t\tuint32 i;\n\t\tchar *cur_pdata = NULL;\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len > 16) {\n\t\t\tlabels = True;\n\t\t}\n\t\tshadow_data = talloc_zero(ctx, struct shadow_copy_data);\n\t\tif (shadow_data == NULL) {\n\t\t\tDEBUG(0,(\"TALLOC_ZERO() failed!\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (SMB_VFS_GET_SHADOW_COPY_DATA(fsp, shadow_data, labels)!=0) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\tif (errno == ENOSYS) {\n\t\t\t\tDEBUG(5,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, not supported.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: connectpath %s, failed.\\n\", \n\t\t\t\t\tfsp->conn->connectpath));\n\t\t\t\treturn NT_STATUS_UNSUCCESSFUL;\n\t\t\t}\n\t\t}\n\t\tlabels_data_count = (shadow_data->num_volumes * 2 * \n\t\t\t\t\tsizeof(SHADOW_COPY_LABEL)) + 2;\n\t\tif (!labels) {\n\t\t\t*out_len = 16;\n\t\t} else {\n\t\t\t*out_len = 12 + labels_data_count;\n\t\t}\n\t\tif (max_out_len < *out_len) {\n\t\t\tDEBUG(0,(\"FSCTL_GET_SHADOW_COPY_DATA: max_data_count(%u) too small (%u) bytes needed!\\n\",\n\t\t\t\tmax_out_len, *out_len));\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_BUFFER_TOO_SMALL;\n\t\t}\n\t\tcur_pdata = talloc_zero_array(ctx, char, *out_len);\n\t\tif (cur_pdata == NULL) {\n\t\t\tTALLOC_FREE(shadow_data);\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\t*out_data = cur_pdata;\n\t\tSIVAL(cur_pdata, 0, shadow_data->num_volumes);\n\t\tif (labels) {\n\t\t\tSIVAL(cur_pdata, 4, shadow_data->num_volumes);\n\t\t}\n\t\tSIVAL(cur_pdata, 8, labels_data_count);\n\t\tcur_pdata += 12;\n\t\tDEBUG(10,(\"FSCTL_GET_SHADOW_COPY_DATA: %u volumes for path[%s].\\n\",\n\t\t\t  shadow_data->num_volumes, fsp_str_dbg(fsp)));\n\t\tif (labels && shadow_data->labels) {\n\t\t\tfor (i=0; i<shadow_data->num_volumes; i++) {\n\t\t\t\tsrvstr_push(cur_pdata, req_flags,\n\t\t\t\t\t    cur_pdata, shadow_data->labels[i],\n\t\t\t\t\t    2 * sizeof(SHADOW_COPY_LABEL),\n\t\t\t\t\t    STR_UNICODE|STR_TERMINATE);\n\t\t\t\tcur_pdata += 2 * sizeof(SHADOW_COPY_LABEL);\n\t\t\t\tDEBUGADD(10,(\"Label[%u]: '%s'\\n\",i,shadow_data->labels[i]));\n\t\t\t}\n\t\t}\n\t\tTALLOC_FREE(shadow_data);\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_FIND_FILES_BY_SID:\n\t{\n\t\tstruct dom_sid sid;\n\t\tuid_t uid;\n\t\tsize_t sid_len;\n\t\tDEBUG(10, (\"FSCTL_FIND_FILES_BY_SID: called on %s\\n\",\n\t\t\t   fsp_fnum_dbg(fsp)));\n\t\tif (in_len < 8) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tsid_len = MIN(in_len - 4,SID_MAX_SIZE);\n\t\tif (!sid_parse(in_data + 4, sid_len, &sid)) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tDEBUGADD(10, (\"for SID: %s\\n\", sid_string_dbg(&sid)));\n\t\tif (!sid_to_uid(&sid, &uid)) {\n\t\t\tDEBUG(0,(\"sid_to_uid: failed, sid[%s] sid_len[%lu]\\n\",\n\t\t\t\t sid_string_dbg(&sid),\n\t\t\t\t (unsigned long)sid_len));\n\t\t\tuid = (-1);\n\t\t}\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_QUERY_ALLOCATED_RANGES:\n\t{\n\t\tNTSTATUS status;\n\t\tuint64_t offset, length;\n\t\tchar *out_data_tmp = NULL;\n\t\tif (in_len != 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: data_count(%u) != 16 is invalid!\\n\",\n\t\t\t\tin_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tif (max_out_len < 16) {\n\t\t\tDEBUG(0,(\"FSCTL_QUERY_ALLOCATED_RANGES: max_out_len (%u) < 16 is invalid!\\n\",\n\t\t\t\tmax_out_len));\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\toffset = BVAL(in_data,0);\n\t\tlength = BVAL(in_data,8);\n\t\tif (offset + length < offset) {\n\t\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t\t}\n\t\tstatus = vfs_stat_fsp(fsp);\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn status;\n\t\t}\n\t\t*out_len = 16;\n\t\tout_data_tmp = talloc_array(ctx, char, *out_len);\n\t\tif (out_data_tmp == NULL) {\n\t\t\tDEBUG(10, (\"unable to allocate memory for response\\n\"));\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t\tif (offset > fsp->fsp_name->st.st_ex_size ||\n\t\t\t\tfsp->fsp_name->st.st_ex_size == 0 ||\n\t\t\t\tlength == 0) {\n\t\t\tmemset(out_data_tmp, 0, *out_len);\n\t\t} else {\n\t\t\tuint64_t end = offset + length;\n\t\t\tend = MIN(end, fsp->fsp_name->st.st_ex_size);\n\t\t\tSBVAL(out_data_tmp, 0, 0);\n\t\t\tSBVAL(out_data_tmp, 8, end);\n\t\t}\n\t\t*out_data = out_data_tmp;\n\t\treturn NT_STATUS_OK;\n\t}\n\tcase FSCTL_IS_VOLUME_DIRTY:\n\t{\n\t\tDEBUG(10,(\"FSCTL_IS_VOLUME_DIRTY: called on %s \"\n\t\t\t  \"(but remotely not supported)\\n\", fsp_fnum_dbg(fsp)));\n\t\treturn NT_STATUS_INVALID_PARAMETER;\n\t}\n\tdefault:\n\t\tif (!vfswrap_logged_ioctl_message) {\n\t\t\tvfswrap_logged_ioctl_message = true;\n\t\t\tDEBUG(2, (\"%s (0x%x): Currently not implemented.\\n\",\n\t\t\t__func__, function));\n\t\t}\n\t}\n\treturn NT_STATUS_NOT_SUPPORTED;\n}",
        "file_name": "301429.sol"
    }
]