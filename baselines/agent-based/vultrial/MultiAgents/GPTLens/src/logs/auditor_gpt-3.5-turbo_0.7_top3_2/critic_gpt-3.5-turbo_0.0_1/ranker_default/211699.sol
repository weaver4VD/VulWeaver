[
    {
        "function_name": "glob",
        "vulnerability": "Potential Buffer Overflow",
        "criticism": "The reasoning accurately points out the potential buffer overflow vulnerability in the code due to lack of proper bounds checking when manipulating strings. This vulnerability can be exploited by an attacker to overwrite adjacent memory locations and execute arbitrary code. The correctness score is 9 as the vulnerability is valid, the severity score is 8 as it can lead to arbitrary code execution, and the profitability score is 7 as it can be exploited for malicious purposes.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The code does not perform proper bounds checking when manipulating strings, leading to potential buffer overflow vulnerabilities. An attacker could provide specially crafted input that exceeds the buffer size, resulting in overwriting adjacent memory locations and potentially executing arbitrary code.",
        "code": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n  if (!(flags & GLOB_DOOFFS))\n    pglob->gl_offs = 0;\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n              ++begin;\n            }\n        }\n      if (begin != NULL)\n        {\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                goto illegal_brace;\n            }\n          rest_len = strlen (++rest) + 1;\n          firstc = pglob->gl_pathc;\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n              if (*next == '}')\n                break;\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n          if (pglob->gl_pathc != firstc)\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n  filename = strrchr (pattern, '/');\n#if defined __MSDOS__ || defined WINDOWS32\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif \n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n        }\n#endif\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              char *p = (char *) &dirname[dirlen - 1];\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; \n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif \n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; \n                  malloc_home_dir = 0;\n                }\n            }\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif \n        }\n    }\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n      return 0;\n    }\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      size_t i;\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          char *p = (char *) &dirname[dirlen - 1];\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            continue;\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n      flags |= GLOB_MAGCHAR;\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              ++pglob->gl_pathc;\n              ++newcount;\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n      if (dirlen > 0)\n        {\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n  if (flags & GLOB_MARK)\n    {\n      size_t i;\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n  if (!(flags & GLOB_NOSORT))\n    {\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n  return retval;\n}",
        "file_name": "211699.sol",
        "final_score": 8.25
    },
    {
        "function_name": "glob",
        "vulnerability": "Stack Buffer Overflow",
        "criticism": "The reasoning correctly identifies the potential stack buffer overflow vulnerability in the code due to the use of alloca() function for stack-based memory allocation. This vulnerability can lead to memory corruption and execution of arbitrary code. The correctness score is 9 as the vulnerability is valid, the severity score is 8 as it can lead to arbitrary code execution, and the profitability score is 7 as it can be exploited for malicious purposes.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The code uses alloca() function to allocate memory on the stack for the 'onealt' array. This can lead to a stack-based buffer overflow if the input pattern length is too large, causing potential memory corruption and execution of arbitrary code.",
        "code": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n  if (!(flags & GLOB_DOOFFS))\n    pglob->gl_offs = 0;\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n              ++begin;\n            }\n        }\n      if (begin != NULL)\n        {\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                goto illegal_brace;\n            }\n          rest_len = strlen (++rest) + 1;\n          firstc = pglob->gl_pathc;\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n              if (*next == '}')\n                break;\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n          if (pglob->gl_pathc != firstc)\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n  filename = strrchr (pattern, '/');\n#if defined __MSDOS__ || defined WINDOWS32\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif \n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n        }\n#endif\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              char *p = (char *) &dirname[dirlen - 1];\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; \n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif \n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; \n                  malloc_home_dir = 0;\n                }\n            }\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif \n        }\n    }\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n      return 0;\n    }\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      size_t i;\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          char *p = (char *) &dirname[dirlen - 1];\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            continue;\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n      flags |= GLOB_MAGCHAR;\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              ++pglob->gl_pathc;\n              ++newcount;\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n      if (dirlen > 0)\n        {\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n  if (flags & GLOB_MARK)\n    {\n      size_t i;\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n  if (!(flags & GLOB_NOSORT))\n    {\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n  return retval;\n}",
        "file_name": "211699.sol",
        "final_score": 8.25
    },
    {
        "function_name": "glob",
        "vulnerability": "Potential Memory Leak",
        "criticism": "The reasoning provided accurately identifies the potential memory leak in the code due to improper memory deallocation paths. This vulnerability can be exploited by an attacker to consume all available memory and cause denial of service. The correctness score is 8 as the vulnerability is valid, the severity score is 7 as it can lead to denial of service, and the profitability score is 6 as it can be exploited for malicious purposes.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The code dynamically allocates memory using 'malloc' and 'realloc' functions, but there are paths in the code where the allocated memory is not properly freed. This can lead to memory leaks, which could be exploited by an attacker to consume all available memory and cause denial of service.",
        "code": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n  if (!(flags & GLOB_DOOFFS))\n    pglob->gl_offs = 0;\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n              ++begin;\n            }\n        }\n      if (begin != NULL)\n        {\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                goto illegal_brace;\n            }\n          rest_len = strlen (++rest) + 1;\n          firstc = pglob->gl_pathc;\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n              if (*next == '}')\n                break;\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n          if (pglob->gl_pathc != firstc)\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n  filename = strrchr (pattern, '/');\n#if defined __MSDOS__ || defined WINDOWS32\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif \n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n        }\n#endif\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              char *p = (char *) &dirname[dirlen - 1];\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; \n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif \n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; \n                  malloc_home_dir = 0;\n                }\n            }\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif \n        }\n    }\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n      return 0;\n    }\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      size_t i;\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          char *p = (char *) &dirname[dirlen - 1];\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            continue;\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n      flags |= GLOB_MAGCHAR;\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              ++pglob->gl_pathc;\n              ++newcount;\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n      if (dirlen > 0)\n        {\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n  if (flags & GLOB_MARK)\n    {\n      size_t i;\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n  if (!(flags & GLOB_NOSORT))\n    {\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n  return retval;\n}",
        "file_name": "211699.sol",
        "final_score": 7.25
    },
    {
        "function_name": "glob",
        "vulnerability": "Memory Leak",
        "criticism": "The reasoning accurately identifies the potential memory leak in the code due to memory not being freed before returning in a specific block. This vulnerability can lead to memory leaks in the program. The correctness score is 8 as the vulnerability is valid, the severity score is 5 as it may not have immediate impact, and the profitability score is 4 as it may not be easily exploitable.",
        "correctness": 8,
        "severity": 5,
        "profitability": 4,
        "reason": "The code allocates memory for 'newp' in the 'if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\')' block but does not free it before returning. This can lead to memory leaks in the program.",
        "code": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n  if (!(flags & GLOB_DOOFFS))\n    pglob->gl_offs = 0;\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n              ++begin;\n            }\n        }\n      if (begin != NULL)\n        {\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                goto illegal_brace;\n            }\n          rest_len = strlen (++rest) + 1;\n          firstc = pglob->gl_pathc;\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n              if (*next == '}')\n                break;\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n          if (pglob->gl_pathc != firstc)\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n  filename = strrchr (pattern, '/');\n#if defined __MSDOS__ || defined WINDOWS32\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif \n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n        }\n#endif\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              char *p = (char *) &dirname[dirlen - 1];\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; \n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif \n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; \n                  malloc_home_dir = 0;\n                }\n            }\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif \n        }\n    }\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n      return 0;\n    }\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      size_t i;\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          char *p = (char *) &dirname[dirlen - 1];\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            continue;\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n      flags |= GLOB_MAGCHAR;\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              ++pglob->gl_pathc;\n              ++newcount;\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n      if (dirlen > 0)\n        {\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n  if (flags & GLOB_MARK)\n    {\n      size_t i;\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n  if (!(flags & GLOB_NOSORT))\n    {\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n  return retval;\n}",
        "file_name": "211699.sol",
        "final_score": 6.25
    },
    {
        "function_name": "glob",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The reasoning correctly points out the potential integer overflow vulnerability in the code due to improper size calculations. This vulnerability can lead to unexpected behavior and security vulnerabilities. The correctness score is 7 as the vulnerability is valid, the severity score is 6 as it can lead to unexpected behavior, and the profitability score is 5 as it may require specific input to trigger.",
        "correctness": 7,
        "severity": 6,
        "profitability": 5,
        "reason": "In the 'if (newcount > SIZE_MAX / sizeof (char *) - 2)' condition, there is a potential integer overflow if 'newcount' is too large. This can lead to unexpected behavior and security vulnerabilities in the program.",
        "code": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n  if (!(flags & GLOB_DOOFFS))\n    pglob->gl_offs = 0;\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n              ++begin;\n            }\n        }\n      if (begin != NULL)\n        {\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                goto illegal_brace;\n            }\n          rest_len = strlen (++rest) + 1;\n          firstc = pglob->gl_pathc;\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n              if (*next == '}')\n                break;\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n          if (pglob->gl_pathc != firstc)\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n  filename = strrchr (pattern, '/');\n#if defined __MSDOS__ || defined WINDOWS32\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif \n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n        }\n#endif\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              char *p = (char *) &dirname[dirlen - 1];\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; \n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif \n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; \n                  malloc_home_dir = 0;\n                }\n            }\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif \n        }\n    }\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n      return 0;\n    }\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      size_t i;\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          char *p = (char *) &dirname[dirlen - 1];\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            continue;\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n      flags |= GLOB_MAGCHAR;\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              ++pglob->gl_pathc;\n              ++newcount;\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n      if (dirlen > 0)\n        {\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n  if (flags & GLOB_MARK)\n    {\n      size_t i;\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n  if (!(flags & GLOB_NOSORT))\n    {\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n  return retval;\n}",
        "file_name": "211699.sol",
        "final_score": 6.25
    },
    {
        "function_name": "glob",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The reasoning provided is accurate as the code does contain multiple instances where integer overflow can occur due to improper size calculations for memory allocation. This vulnerability can lead to unexpected behavior or crashes. However, the severity and profitability of this vulnerability are not very high as it may require specific input to trigger the overflow. The correctness score is 7 as the vulnerability is valid, the severity score is 6 as it can lead to crashes, and the profitability score is 4 as it may not be easily exploitable.",
        "correctness": 7,
        "severity": 6,
        "profitability": 4,
        "reason": "The code contains multiple instances where integer overflow can occur, such as when calculating the size for memory allocation. An attacker could potentially exploit this vulnerability by providing crafted input that triggers the overflow, leading to unexpected behavior or crashes.",
        "code": "glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n      glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n  if (!(flags & GLOB_DOOFFS))\n    pglob->gl_offs = 0;\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n              ++begin;\n            }\n        }\n      if (begin != NULL)\n        {\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                goto illegal_brace;\n            }\n          rest_len = strlen (++rest) + 1;\n          firstc = pglob->gl_pathc;\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n              result = glob (onealt,\n                             ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                              | GLOB_APPEND), errfunc, pglob);\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n              if (*next == '}')\n                break;\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n          if (pglob->gl_pathc != firstc)\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n  filename = strrchr (pattern, '/');\n#if defined __MSDOS__ || defined WINDOWS32\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif \n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n        }\n#endif\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              char *p = (char *) &dirname[dirlen - 1];\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; \n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      err = getpwnam_r (s.data, &pwbuf, s.data + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif \n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; \n                  malloc_home_dir = 0;\n                }\n            }\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (*q != '\\0')\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q[1] == '\\0')\n                            {\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname))\n                  = '\\0';\n              user_name = newp;\n            }\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                char *d;\n                if (__glibc_unlikely (malloc_dirname))\n                  free (dirname);\n                malloc_dirname = 0;\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#endif \n        }\n    }\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n      return 0;\n    }\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      size_t i;\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          char *p = (char *) &dirname[dirlen - 1];\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n      status = glob (dirname,\n                     ((flags & (GLOB_ERR | GLOB_NOESCAPE\n                                | GLOB_ALTDIRFUNC))\n                      | GLOB_NOSORT | GLOB_ONLYDIR),\n                     errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            continue;\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n      flags |= GLOB_MAGCHAR;\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n              ++pglob->gl_pathc;\n              ++newcount;\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n      if (dirlen > 0)\n        {\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n  if (flags & GLOB_MARK)\n    {\n      size_t i;\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n  if (!(flags & GLOB_NOSORT))\n    {\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n  return retval;\n}",
        "file_name": "211699.sol",
        "final_score": 6.0
    }
]