[
    {
        "function_name": "get_complex_object",
        "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "vulnerability": "Heap Buffer Overflow",
        "reason": "There are multiple instances in the code where the allocated buffers (s1 and s2) are not properly checked for buffer overflow. An attacker could provide a malicious input that exceeds the allocated buffer size (n1 and n2) leading to heap buffer overflow vulnerabilities. This can result in overwriting adjacent memory locations and potentially executing arbitrary code.",
        "file_name": "371185.sol"
    },
    {
        "function_name": "get_complex_object",
        "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "vulnerability": "Memory Leak",
        "reason": "The code allocates memory for s1 and s2 using malloc, but does not free this memory in case of certain error conditions. This can lead to memory leaks where the allocated memory is not properly released, causing the program to consume more memory than necessary. An attacker could potentially exploit this vulnerability to exhaust system resources and cause denial of service.",
        "file_name": "371185.sol"
    },
    {
        "function_name": "get_complex_object",
        "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "vulnerability": "Dereference of NULL Pointer",
        "reason": "In the code, if an error occurs during the allocation of s1 or s2, the function returns NULL without freeing the previously allocated 'ret' object. This can lead to a dereference of a NULL pointer if the calling function assumes that 'ret' is valid. An attacker could potentially exploit this vulnerability to cause a crash or manipulate the program's behavior.",
        "file_name": "371185.sol"
    },
    {
        "function_name": "get_complex_object",
        "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "vulnerability": "Heap Buffer Overflow",
        "reason": "The code dynamically allocates memory for strings s1 and s2 using malloc without checking the size of the input data. This could lead to a heap buffer overflow if the input data size is larger than the allocated memory size, allowing an attacker to overwrite adjacent memory.",
        "file_name": "371185.sol"
    },
    {
        "function_name": "get_complex_object",
        "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "vulnerability": "Memory Leak",
        "reason": "The code allocates memory for strings s1 and s2 using malloc but fails to free the memory before returning in case of certain error conditions. This can lead to memory leaks, causing the program to consume excessive memory over time and potentially exhaust system resources.",
        "file_name": "371185.sol"
    },
    {
        "function_name": "get_complex_object",
        "code": "static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n1, 1)) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s1, n1) != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else {\n\t\tn2 = get_st32(buffer, &error);\n\t}\n\tif (error || UT32_ADD_OVFCHK(n2, 1)) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\tif (rz_buf_read(buffer, s2, n2) != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"%s+%sj\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "vulnerability": "Double Free",
        "reason": "The code frees memory for strings s1 and s2 using RZ_FREE, which is likely to use free internally. If the memory is freed twice (double free), it can lead to memory corruption and potential security vulnerabilities, allowing an attacker to execute arbitrary code or crash the application.",
        "file_name": "371185.sol"
    }
]