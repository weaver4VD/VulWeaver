[
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Potential buffer overflow vulnerability",
        "reason": "The code snippet copies data from the input buffer into url->errormsg without properly verifying the length of the data being copied. This can lead to a buffer overflow if the length of the data exceeds the size of url->errormsg, allowing an attacker to overwrite adjacent memory locations.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Potential format string vulnerability",
        "reason": "The code snippet uses the input buffer directly in the sscanf function without proper input validation, which can lead to a format string vulnerability. An attacker can craft a malicious input string to exploit this vulnerability, potentially leading to arbitrary code execution.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Potential information disclosure vulnerability",
        "reason": "The code snippet copies data from the input buffer into url->errormsg without proper length validation. This can potentially lead to information disclosure if the copied data contains sensitive information that should not be exposed to unauthorized users.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code snippet copies data from the 'ptr' buffer into the 'url->errormsg' buffer without proper bounds checking. This can lead to a buffer overflow vulnerability where an attacker can craft a malicious 'ptr' buffer that is larger than the destination 'url->errormsg' buffer, causing a buffer overflow and potentially overwriting adjacent memory.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Input Validation",
        "reason": "The code snippet assumes that the 'ptr' buffer contains a valid time limit header and directly parses the value without proper input validation. This can be exploited by an attacker to craft a malicious 'ptr' buffer containing unexpected data, leading to incorrect parsing and potentially setting a malicious disconnect time for the client.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Memory Corruption",
        "reason": "The code snippet uses 'memcpy' to copy data from the 'ptr' buffer into the 'url->errormsg' buffer without proper validation. This can lead to memory corruption vulnerabilities where an attacker can provide specially crafted input in the 'ptr' buffer to overwrite memory beyond the bounds of 'url->errormsg' buffer, potentially leading to crashes or arbitrary code execution.",
        "file_name": "457772.sol"
    }
]