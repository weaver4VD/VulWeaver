[
    {
        "function_name": "InferShapesForFunctionSubNode",
        "code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n  return Status::OK();\n}",
        "vulnerability": "Potential buffer overflow through unchecked user input",
        "reason": "The function GetNodeAttr is used to retrieve the value of the 'index' attribute from the node definition without validating its size. This can potentially lead to a buffer overflow if the 'index' value is larger than expected, allowing an attacker to manipulate memory beyond the allocated buffer.",
        "file_name": "255932.sol"
    },
    {
        "function_name": "InferShapesForFunctionSubNode",
        "code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n  return Status::OK();\n}",
        "vulnerability": "Potential memory corruption through unchecked user input",
        "reason": "The function set_output is used to set the output at a specific index in the outer context without validating the index value. An attacker could potentially manipulate the index value to corrupt memory locations outside the bounds of the allocated memory, leading to memory corruption vulnerabilities.",
        "file_name": "255932.sol"
    },
    {
        "function_name": "InferShapesForFunctionSubNode",
        "code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n  return Status::OK();\n}",
        "vulnerability": "Potential iterator invalidation",
        "reason": "The code iterates over the 'resource' vector using a reference to each element. If the vector is modified (elements added or removed) during the iteration, it can lead to iterator invalidation and undefined behavior. An attacker could exploit this vulnerability to cause a crash or potentially execute arbitrary code.",
        "file_name": "255932.sol"
    },
    {
        "function_name": "InferShapesForFunctionSubNode",
        "code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n  return Status::OK();\n}",
        "vulnerability": "Potential Integer Overflow",
        "reason": "The comparison 'outer_context->num_inputs() <= index' could result in an integer overflow if 'index' is a very large positive value. This can lead to unexpected behavior and potentially allow an attacker to manipulate the program flow.",
        "file_name": "255932.sol"
    },
    {
        "function_name": "InferShapesForFunctionSubNode",
        "code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n  return Status::OK();\n}",
        "vulnerability": "Potential Memory Corruption",
        "reason": "The function 'MakeShapeFromShapeProto' may not properly handle invalid or malicious input data, leading to potential memory corruption vulnerabilities. An attacker could exploit this vulnerability to execute arbitrary code or crash the program.",
        "file_name": "255932.sol"
    },
    {
        "function_name": "InferShapesForFunctionSubNode",
        "code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    const std::vector<ShapeAndType>* resource =\n        node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      std::vector<ShapeAndType> copied_shapes_and_types;\n      for (auto& shape_and_type : *resource) {\n        ShapeHandle handle;\n        TensorShapeProto proto;\n        node_context->ShapeHandleToProto(shape_and_type.shape, &proto);\n        TF_RETURN_IF_ERROR(\n            outer_context->MakeShapeFromShapeProto(proto, &handle));\n        copied_shapes_and_types.push_back(\n            ShapeAndType(handle, shape_and_type.dtype, shape_and_type.type));\n      }\n      outer_context->set_output_handle_shapes_and_types(\n          index, copied_shapes_and_types);\n    }\n  }\n  return Status::OK();\n}",
        "vulnerability": "Potential Denial of Service (DoS)",
        "reason": "The loop iterating over 'resource' may not have proper bounds checking, potentially leading to a DoS vulnerability if 'resource' contains a large number of elements. An attacker could exploit this by providing a large input to exhaust system resources.",
        "file_name": "255932.sol"
    }
]