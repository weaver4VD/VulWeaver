[
    {
        "function_name": "io_read",
        "vulnerability": "Potential memory leak",
        "criticism": "The reasoning provided for the potential memory leak vulnerability is accurate. The code does not free the 'iovec' memory in the 'done' and 'out_free' labels, leading to a memory leak if the program execution reaches those points. The severity of this vulnerability is high as it can exhaust system memory and cause a denial of service. However, the profitability is moderate as it requires specific conditions to be met for exploitation. The correctness score is 7 due to the accurate identification of the vulnerability.",
        "correctness": 7,
        "severity": 8,
        "profitability": 5,
        "reason": "In the 'io_read' function, there is a potential memory leak when 'iovec' is allocated but not freed in the 'done' and 'out_free' labels. If the program execution reaches these labels, 'iovec' will not be freed, leading to a memory leak. This can be exploited by an attacker to exhaust system memory and cause a denial of service.",
        "code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\tret = io_iter_do_read(req, iter);\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\tgoto done;\n\t}\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\tiovec = NULL;\n\trw = req->async_data;\n\titer = &rw->iter;\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "file_name": "210484.sol"
    },
    {
        "function_name": "io_read",
        "vulnerability": "Potential use-after-free vulnerability",
        "criticism": "The reasoning provided for the potential use-after-free vulnerability is valid. If the program execution reaches the 'out_free' label after freeing 'iovec', but 'iovec' is still accessed later in the function, it can lead to undefined behavior. The severity of this vulnerability is high as it can potentially lead to arbitrary code execution. The profitability is moderate as it requires specific conditions to be met. The correctness score is 8 for accurately identifying the vulnerability.",
        "correctness": 8,
        "severity": 9,
        "profitability": 6,
        "reason": "In the 'io_read' function, there is a potential use-after-free vulnerability when 'iovec' is freed at 'out_free' label but still used later in the function. If the program execution reaches this label, 'iovec' will be freed but accessed again in the subsequent code, leading to undefined behavior. This can be exploited by an attacker to potentially execute arbitrary code.",
        "code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\tret = io_iter_do_read(req, iter);\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\tgoto done;\n\t}\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\tiovec = NULL;\n\trw = req->async_data;\n\titer = &rw->iter;\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "file_name": "210484.sol"
    },
    {
        "function_name": "io_read",
        "vulnerability": "Missing input validation",
        "criticism": "The reasoning provided for the missing input validation vulnerability is incorrect. The code does not dereference 'iter' without checking its validity. Therefore, the assessment of a null pointer dereference vulnerability is inaccurate. The correctness score is 2 for the incorrect identification of the vulnerability.",
        "correctness": 2,
        "severity": 0,
        "profitability": 0,
        "reason": "In the 'io_read' function, there is missing input validation when handling the 'iter' pointer. The code does not check if 'iter' is a valid pointer before dereferencing it. This can be exploited by an attacker to trigger a null pointer dereference, leading to a denial of service or potentially arbitrary code execution.",
        "code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\tret = io_iter_do_read(req, iter);\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\tgoto done;\n\t}\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\tiovec = NULL;\n\trw = req->async_data;\n\titer = &rw->iter;\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "file_name": "210484.sol"
    },
    {
        "function_name": "io_read",
        "vulnerability": "Memory Leak",
        "criticism": "The reasoning provided for the memory leak vulnerability is accurate. If the program execution reaches the 'done' label without freeing the memory allocated to 'iovec', it can lead to a memory leak. The severity of this vulnerability is moderate as it can impact system resources. The profitability is low as it requires specific conditions to be met. The correctness score is 7 for the accurate identification of the vulnerability.",
        "correctness": 7,
        "severity": 6,
        "profitability": 3,
        "reason": "There is a memory leak vulnerability in the io_read function. If the condition 'ret == -EAGAIN || (req->flags & REQ_F_REISSUE)' is met, and the code jumps to 'done' label without freeing the memory allocated to iovec. This can lead to a memory leak as the allocated memory is not released before returning from the function.",
        "code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\tret = io_iter_do_read(req, iter);\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\tgoto done;\n\t}\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\tiovec = NULL;\n\trw = req->async_data;\n\titer = &rw->iter;\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "file_name": "210484.sol"
    },
    {
        "function_name": "io_read",
        "vulnerability": "Potential Use-after-Free",
        "criticism": "The reasoning provided for the potential use-after-free vulnerability is valid. If the program execution reaches the 'done' label without setting 'iovec' to NULL, the subsequent call to 'io_setup_async_rw' function could potentially lead to a use-after-free scenario. The severity of this vulnerability is moderate as it can lead to undefined behavior. The profitability is low as it requires specific conditions to be met. The correctness score is 8 for accurately identifying the vulnerability.",
        "correctness": 8,
        "severity": 7,
        "profitability": 3,
        "reason": "There is a potential use-after-free vulnerability in the io_read function. If the condition 'ret <= 0 || ret == io_size || !force_nonblock || (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)' is met, and the code jumps to 'done' label without setting iovec to NULL, the subsequent call to io_setup_async_rw function could potentially lead to a use-after-free scenario if iovec was freed before reaching this point.",
        "code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\tret = io_iter_do_read(req, iter);\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\tgoto done;\n\t}\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\tiovec = NULL;\n\trw = req->async_data;\n\titer = &rw->iter;\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "file_name": "210484.sol"
    },
    {
        "function_name": "io_read",
        "vulnerability": "Potential Infinite Loop",
        "criticism": "The reasoning provided for the potential infinite loop vulnerability is accurate. If the condition '!io_rw_should_retry(req)' is never met inside the do-while loop, it can lead to an infinite loop. The severity of this vulnerability is high as it can cause a denial of service by consuming system resources. The profitability is low as it requires specific conditions to be met. The correctness score is 8 for the accurate identification of the vulnerability.",
        "correctness": 8,
        "severity": 9,
        "profitability": 3,
        "reason": "There is a potential infinite loop vulnerability in the io_read function. Inside the do-while loop, if the condition '!io_rw_should_retry(req)' is never met, the loop will continue indefinitely. This can lead to a denial of service (DoS) situation where the function never returns, consuming system resources and potentially causing a system crash.",
        "code": "static int io_read(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct iov_iter __iter, *iter = &__iter;\n\tstruct io_async_rw *rw = req->async_data;\n\tssize_t io_size, ret, ret2;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\tif (rw) {\n\t\titer = &rw->iter;\n\t\tiovec = NULL;\n\t} else {\n\t\tret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tio_size = iov_iter_count(iter);\n\treq->result = io_size;\n\tif (!force_nonblock)\n\t\tkiocb->ki_flags &= ~IOCB_NOWAIT;\n\telse\n\t\tkiocb->ki_flags |= IOCB_NOWAIT;\n\tif (force_nonblock && !io_file_supports_async(req, READ)) {\n\t\tret = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\t\treturn ret ?: -EAGAIN;\n\t}\n\tret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), io_size);\n\tif (unlikely(ret)) {\n\t\tkfree(iovec);\n\t\treturn ret;\n\t}\n\tret = io_iter_do_read(req, iter);\n\tif (ret == -EAGAIN || (req->flags & REQ_F_REISSUE)) {\n\t\treq->flags &= ~REQ_F_REISSUE;\n\t\tif (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\t\tgoto done;\n\t\tif (req->flags & REQ_F_NOWAIT)\n\t\t\tgoto done;\n\t\tiov_iter_revert(iter, io_size - iov_iter_count(iter));\n\t\tret = 0;\n\t} else if (ret == -EIOCBQUEUED) {\n\t\tgoto out_free;\n\t} else if (ret <= 0 || ret == io_size || !force_nonblock ||\n\t\t   (req->flags & REQ_F_NOWAIT) || !(req->flags & REQ_F_ISREG)) {\n\t\tgoto done;\n\t}\n\tret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);\n\tif (ret2)\n\t\treturn ret2;\n\tiovec = NULL;\n\trw = req->async_data;\n\titer = &rw->iter;\n\tdo {\n\t\tio_size -= ret;\n\t\trw->bytes_done += ret;\n\t\tif (!io_rw_should_retry(req)) {\n\t\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tret = io_iter_do_read(req, iter);\n\t\tif (ret == -EIOCBQUEUED)\n\t\t\treturn 0;\n\t\tkiocb->ki_flags &= ~IOCB_WAITQ;\n\t} while (ret > 0 && ret < io_size);\ndone:\n\tkiocb_done(kiocb, ret, issue_flags);\nout_free:\n\tif (iovec)\n\t\tkfree(iovec);\n\treturn 0;\n}",
        "file_name": "210484.sol"
    }
]