[
    {
        "function_name": "TIFFReadDirEntryArrayWithLimit",
        "vulnerability": "Potential Buffer Overflow",
        "criticism": "The reasoning provided for the potential buffer overflow vulnerability is accurate as the code does not perform proper bounds checking when allocating memory for 'data' based on 'datasize'. This could lead to a buffer overflow, allowing attackers to execute arbitrary code. The correctness score is 7 as the vulnerability is correctly identified. The severity score is 8 as a buffer overflow can lead to serious security implications. The profitability score is 7 as exploiting this vulnerability could provide attackers with significant control over the application.",
        "correctness": 7,
        "severity": 8,
        "profitability": 7,
        "reason": "The code does not perform proper bounds checking when allocating memory for 'data' based on 'datasize'. An attacker could craft malicious input that leads to a buffer overflow, potentially allowing them to execute arbitrary code.",
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "file_name": "504608.sol"
    },
    {
        "function_name": "TIFFReadDirEntryArrayWithLimit",
        "vulnerability": "Memory Leak",
        "criticism": "The reasoning provided for the memory leak vulnerability is valid as there is a potential memory leak if the allocation of memory for 'data' is successful but an error occurs later in the function. This could lead to a denial of service attack. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 6 as memory leaks can impact system performance. The profitability score is 5 as exploiting this vulnerability may not provide direct benefits to attackers.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "There is a potential memory leak in the code if the allocation of memory for 'data' using _TIFFCheckMalloc is successful, but an error occurs later in the function. This could lead to a denial of service attack by exhausting available memory resources.",
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "file_name": "504608.sol"
    },
    {
        "function_name": "TIFFReadDirEntryArrayWithLimit",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The reasoning provided for the potential integer overflow vulnerability is accurate as the code uses integer calculations without proper validation, which could lead to integer overflow vulnerabilities. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 7 as integer overflows can lead to unexpected behavior. The profitability score is 6 as exploiting this vulnerability may provide attackers with some benefits.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The code uses integer calculations for memory allocation and size checks without proper validation, which could lead to integer overflow vulnerabilities. An attacker could potentially manipulate these calculations to trigger unexpected behavior and exploit the application.",
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "file_name": "504608.sol"
    },
    {
        "function_name": "TIFFReadDirEntryArrayWithLimit",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning provided for the buffer overflow vulnerability is valid as the function does not perform proper bounds checking when copying data to the 'data' buffer, leading to a buffer overflow vulnerability. The correctness score is 7 as the vulnerability is correctly identified. The severity score is 8 as buffer overflows can have serious security implications. The profitability score is 7 as exploiting this vulnerability could provide attackers with significant control over the application.",
        "correctness": 7,
        "severity": 8,
        "profitability": 7,
        "reason": "The function does not perform proper bounds checking when copying data to 'data' buffer, which can lead to a buffer overflow vulnerability. Attackers can exploit this vulnerability to overwrite adjacent memory locations and potentially execute arbitrary code.",
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "file_name": "504608.sol"
    },
    {
        "function_name": "TIFFReadDirEntryArrayWithLimit",
        "vulnerability": "Memory Corruption",
        "criticism": "The reasoning provided for the memory corruption vulnerability is accurate as the function does not handle memory allocation failures properly, leading to potential memory corruption vulnerabilities. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 7 as memory corruption can lead to security issues. The profitability score is 6 as exploiting this vulnerability may provide attackers with some benefits.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The function does not handle memory allocation failures properly. If '_TIFFCheckMalloc' fails to allocate memory for 'data', the function returns 'TIFFReadDirEntryErrAlloc' without freeing previously allocated memory, leading to memory corruption vulnerabilities. Attackers can exploit this to manipulate memory contents and potentially execute arbitrary code.",
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "file_name": "504608.sol"
    },
    {
        "function_name": "TIFFReadDirEntryArrayWithLimit",
        "vulnerability": "Integer Overflow",
        "criticism": "The reasoning provided for the integer overflow vulnerability is valid as the function does not properly handle integer overflows when calculating 'datasize'. This could lead to unexpected behavior and security issues. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 7 as integer overflows can have serious implications. The profitability score is 6 as exploiting this vulnerability may provide attackers with some benefits.",
        "correctness": 8,
        "severity": 7,
        "profitability": 6,
        "reason": "The function does not properly handle integer overflows when calculating 'datasize' based on '*count' and 'typesize'. This can lead to an integer overflow vulnerability, where an attacker can exploit the arithmetic operation to cause unexpected behavior, potentially leading to security issues such as denial of service or arbitrary code execution.",
        "code": "static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(\n    TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize,\n    void** value, uint64 maxcount)\n{\n\tint typesize;\n\tuint32 datasize;\n\tvoid* data;\n        uint64 target_count64;\n\ttypesize=TIFFDataWidth(direntry->tdir_type);\n        target_count64 = (direntry->tdir_count > maxcount) ?\n                maxcount : direntry->tdir_count;\n\tif ((target_count64==0)||(typesize==0))\n\t{\n\t\t*value=0;\n\t\treturn(TIFFReadDirEntryErrOk);\n\t}\n        (void) desttypesize;\n\tif ((uint64)(2147483647/typesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\tif ((uint64)(2147483647/desttypesize)<target_count64)\n\t\treturn(TIFFReadDirEntryErrSizesan);\n\t*count=(uint32)target_count64;\n\tdatasize=(*count)*typesize;\n\tassert((tmsize_t)datasize>0);\n\tif( isMapped(tif) && datasize > tif->tif_size )\n\t\treturn TIFFReadDirEntryErrIo;\n\tif( !isMapped(tif) &&\n\t\t(((tif->tif_flags&TIFF_BIGTIFF) && datasize > 8) ||\n\t\t(!(tif->tif_flags&TIFF_BIGTIFF) && datasize > 4)) )\n\t{\n\t\tdata = NULL;\n\t}\n\telse\n\t{\n\t\tdata=_TIFFCheckMalloc(tif, *count, typesize, \"ReadDirEntryArray\");\n\t\tif (data==0)\n\t\t\treturn(TIFFReadDirEntryErrAlloc);\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tif (datasize<=4)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint32 offset = direntry->tdir_offset.toff_long;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (datasize<=8)\n\t\t\t_TIFFmemcpy(data,&direntry->tdir_offset,datasize);\n\t\telse\n\t\t{\n\t\t\tenum TIFFReadDirEntryErr err;\n\t\t\tuint64 offset = direntry->tdir_offset.toff_long8;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8(&offset);\n\t\t\tif( isMapped(tif) )\n\t\t\t\terr=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);\n\t\t\telse\n\t\t\t\terr=TIFFReadDirEntryDataAndRealloc(tif,(uint64)offset,(tmsize_t)datasize,&data);\n\t\t\tif (err!=TIFFReadDirEntryErrOk)\n\t\t\t{\n\t\t\t\t_TIFFfree(data);\n\t\t\t\treturn(err);\n\t\t\t}\n\t\t}\n\t}\n\t*value=data;\n\treturn(TIFFReadDirEntryErrOk);\n}",
        "file_name": "504608.sol"
    }
]