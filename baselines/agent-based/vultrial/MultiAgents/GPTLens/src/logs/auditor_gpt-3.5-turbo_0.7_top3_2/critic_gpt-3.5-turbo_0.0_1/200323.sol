[
    {
        "function_name": "suggest_trie_walk",
        "vulnerability": "Potential buffer overflow",
        "criticism": "The code snippet initializes the 'stack' array with a fixed size of MAXWLEN, but does not perform proper bounds checking when accessing elements of the array. This can lead to a buffer overflow vulnerability if the 'depth' variable exceeds the bounds of the 'stack' array.",
        "correctness": 4,
        "severity": 7,
        "profitability": 5,
        "reason": "The code snippet initializes the 'stack' array with a fixed size of MAXWLEN, but does not perform proper bounds checking when accessing elements of the array. This can lead to a buffer overflow vulnerability if the 'depth' variable exceeds the bounds of the 'stack' array.",
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    \n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; \n    char_u\tcompflags[MAXWLEN];\t\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    \n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n    if (soundfold)\n    {\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    arridx = sp->ts_arridx;\t    \n\t    len = byts[arridx];\t\t    \n\t    arridx += sp->ts_curi;\t    \n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\t    ++sp->ts_curi;\t\t\n\t    flags = (int)idxs[arridx];\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\t    if (!soundfold)\n\t    {\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\t    newscore = 0;\n\t    if (!soundfold)\t\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    \n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\t\t\tsp->ts_arridx = 0;\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SPLITUNDO:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\tcase STATE_ENDNUL:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\tcase STATE_PLAIN:\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_DEL:\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\tcase STATE_INS:\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SWAP:\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\tcase STATE_SWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3L:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3R:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\tcase STATE_REP_INI:\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\tcase STATE_REP:\n\t    p = fword + sp->ts_fidx;\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\t    break;\n\tcase STATE_REP_UNDO:\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\tdefault:\n\t    --depth;\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "file_name": "200323.sol"
    },
    {
        "function_name": "suggest_trie_walk",
        "vulnerability": "Potential null pointer dereference",
        "criticism": "The code snippet assigns 'pbyts' and 'pidxs' to 'NULL' in the 'soundfold' condition block, but later in the 'else' block, it accesses these pointers without checking if they are NULL. This can lead to a null pointer dereference vulnerability if 'pbyts' or 'pidxs' are indeed NULL.",
        "correctness": 3,
        "severity": 6,
        "profitability": 4,
        "reason": "The code snippet assigns 'pbyts' and 'pidxs' to 'NULL' in the 'soundfold' condition block, but later in the 'else' block, it accesses these pointers without checking if they are NULL. This can lead to a null pointer dereference vulnerability if 'pbyts' or 'pidxs' are indeed NULL.",
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    \n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; \n    char_u\tcompflags[MAXWLEN];\t\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    \n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n    if (soundfold)\n    {\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    arridx = sp->ts_arridx;\t    \n\t    len = byts[arridx];\t\t    \n\t    arridx += sp->ts_curi;\t    \n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\t    ++sp->ts_curi;\t\t\n\t    flags = (int)idxs[arridx];\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\t    if (!soundfold)\n\t    {\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\t    newscore = 0;\n\t    if (!soundfold)\t\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    \n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\t\t\tsp->ts_arridx = 0;\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SPLITUNDO:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\tcase STATE_ENDNUL:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\tcase STATE_PLAIN:\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_DEL:\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\tcase STATE_INS:\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SWAP:\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\tcase STATE_SWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3L:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3R:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\tcase STATE_REP_INI:\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\tcase STATE_REP:\n\t    p = fword + sp->ts_fidx;\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\t    break;\n\tcase STATE_REP_UNDO:\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\tdefault:\n\t    --depth;\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "file_name": "200323.sol"
    },
    {
        "function_name": "suggest_trie_walk",
        "vulnerability": "Potential uninitialized variable",
        "criticism": "The code snippet initializes 'pbyts' and 'pidxs' to NULL in the 'soundfold' condition block, but in the subsequent 'else' block, it directly accesses these variables without reassigning them. This can lead to potential use of uninitialized variables and unpredictable behavior.",
        "correctness": 2,
        "severity": 5,
        "profitability": 3,
        "reason": "The code snippet initializes 'pbyts' and 'pidxs' to NULL in the 'soundfold' condition block, but in the subsequent 'else' block, it directly accesses these variables without reassigning them. This can lead to potential use of uninitialized variables and unpredictable behavior.",
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    \n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; \n    char_u\tcompflags[MAXWLEN];\t\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    \n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n    if (soundfold)\n    {\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    arridx = sp->ts_arridx;\t    \n\t    len = byts[arridx];\t\t    \n\t    arridx += sp->ts_curi;\t    \n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\t    ++sp->ts_curi;\t\t\n\t    flags = (int)idxs[arridx];\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\t    if (!soundfold)\n\t    {\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\t    newscore = 0;\n\t    if (!soundfold)\t\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    \n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\t\t\tsp->ts_arridx = 0;\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SPLITUNDO:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\tcase STATE_ENDNUL:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\tcase STATE_PLAIN:\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_DEL:\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\tcase STATE_INS:\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SWAP:\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\tcase STATE_SWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3L:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3R:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\tcase STATE_REP_INI:\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\tcase STATE_REP:\n\t    p = fword + sp->ts_fidx;\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\t    break;\n\tcase STATE_REP_UNDO:\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\tdefault:\n\t    --depth;\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "file_name": "200323.sol"
    },
    {
        "function_name": "suggest_trie_walk",
        "vulnerability": "Potential infinite loop",
        "criticism": "The while loop in the suggest_trie_walk function can potentially result in an infinite loop if the condition for decrementing the depth variable is not met. This can be exploited by an attacker to cause a Denial of Service (DoS) by consuming excessive resources.",
        "correctness": 4,
        "severity": 8,
        "profitability": 6,
        "reason": "The while loop in the suggest_trie_walk function can potentially result in an infinite loop if the condition for decrementing the depth variable is not met. This can be exploited by an attacker to cause a Denial of Service (DoS) by consuming excessive resources.",
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    \n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; \n    char_u\tcompflags[MAXWLEN];\t\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    \n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n    if (soundfold)\n    {\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    arridx = sp->ts_arridx;\t    \n\t    len = byts[arridx];\t\t    \n\t    arridx += sp->ts_curi;\t    \n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\t    ++sp->ts_curi;\t\t\n\t    flags = (int)idxs[arridx];\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\t    if (!soundfold)\n\t    {\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\t    newscore = 0;\n\t    if (!soundfold)\t\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    \n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\t\t\tsp->ts_arridx = 0;\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SPLITUNDO:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\tcase STATE_ENDNUL:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\tcase STATE_PLAIN:\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_DEL:\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\tcase STATE_INS:\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SWAP:\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\tcase STATE_SWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3L:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3R:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\tcase STATE_REP_INI:\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\tcase STATE_REP:\n\t    p = fword + sp->ts_fidx;\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\t    break;\n\tcase STATE_REP_UNDO:\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\tdefault:\n\t    --depth;\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "file_name": "200323.sol"
    },
    {
        "function_name": "suggest_trie_walk",
        "vulnerability": "Potential use of uninitialized variables",
        "criticism": "The code snippet initializes variables byts, fbyts, idxs, fidxs, pbyts, and pidxs based on conditions, but there are paths where these variables may remain uninitialized. This can lead to unpredictable behavior and potential security vulnerabilities.",
        "correctness": 3,
        "severity": 6,
        "profitability": 4,
        "reason": "The code snippet initializes variables byts, fbyts, idxs, fidxs, pbyts, and pidxs based on conditions, but there are paths where these variables may remain uninitialized. This can lead to unpredictable behavior and potential security vulnerabilities.",
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    \n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; \n    char_u\tcompflags[MAXWLEN];\t\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    \n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n    if (soundfold)\n    {\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    arridx = sp->ts_arridx;\t    \n\t    len = byts[arridx];\t\t    \n\t    arridx += sp->ts_curi;\t    \n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\t    ++sp->ts_curi;\t\t\n\t    flags = (int)idxs[arridx];\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\t    if (!soundfold)\n\t    {\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\t    newscore = 0;\n\t    if (!soundfold)\t\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    \n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\t\t\tsp->ts_arridx = 0;\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SPLITUNDO:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\tcase STATE_ENDNUL:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\tcase STATE_PLAIN:\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_DEL:\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\tcase STATE_INS:\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SWAP:\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\tcase STATE_SWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3L:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3R:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\tcase STATE_REP_INI:\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\tcase STATE_REP:\n\t    p = fword + sp->ts_fidx;\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\t    break;\n\tcase STATE_REP_UNDO:\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\tdefault:\n\t    --depth;\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "file_name": "200323.sol"
    },
    {
        "function_name": "suggest_trie_walk",
        "vulnerability": "Potential resource exhaustion",
        "criticism": "The code snippet sets a time limit for spell suggestion based on the spell_suggest_timeout value. If this value is set to a very large number or manipulated by an attacker, it can lead to resource exhaustion by consuming excessive CPU time.",
        "correctness": 5,
        "severity": 8,
        "profitability": 7,
        "reason": "The code snippet sets a time limit for spell suggestion based on the spell_suggest_timeout value. If this value is set to a very large number or manipulated by an attacker, it can lead to resource exhaustion by consuming excessive CPU time.",
        "code": "suggest_trie_walk(\n    suginfo_T\t*su,\n    langp_T\t*lp,\n    char_u\t*fword,\n    int\t\tsoundfold)\n{\n    char_u\ttword[MAXWLEN];\t    \n    trystate_T\tstack[MAXWLEN];\n    char_u\tpreword[MAXWLEN * 3]; \n    char_u\tcompflags[MAXWLEN];\t\n    trystate_T\t*sp;\n    int\t\tnewscore;\n    int\t\tscore;\n    char_u\t*byts, *fbyts, *pbyts;\n    idx_T\t*idxs, *fidxs, *pidxs;\n    int\t\tdepth;\n    int\t\tc, c2, c3;\n    int\t\tn = 0;\n    int\t\tflags;\n    garray_T\t*gap;\n    idx_T\tarridx;\n    int\t\tlen;\n    char_u\t*p;\n    fromto_T\t*ftp;\n    int\t\tfl = 0, tl;\n    int\t\trepextra = 0;\t    \n    slang_T\t*slang = lp->lp_slang;\n    int\t\tfword_ends;\n    int\t\tgoodword_ends;\n#ifdef DEBUG_TRIEWALK\n    char_u\tchangename[MAXWLEN][80];\n#endif\n    int\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n    proftime_T\ttime_limit;\n#endif\n    int\t\tcompound_ok;\n    depth = 0;\n    sp = &stack[0];\n    CLEAR_POINTER(sp);\n    sp->ts_curi = 1;\n    if (soundfold)\n    {\n\tbyts = fbyts = slang->sl_sbyts;\n\tidxs = fidxs = slang->sl_sidxs;\n\tpbyts = NULL;\n\tpidxs = NULL;\n\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\tsp->ts_state = STATE_START;\n    }\n    else\n    {\n\tfbyts = slang->sl_fbyts;\n\tfidxs = slang->sl_fidxs;\n\tpbyts = slang->sl_pbyts;\n\tpidxs = slang->sl_pidxs;\n\tif (pbyts != NULL)\n\t{\n\t    byts = pbyts;\n\t    idxs = pidxs;\n\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t    sp->ts_state = STATE_NOPREFIX;\t\n\t}\n\telse\n\t{\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    sp->ts_prefixdepth = PFD_NOPREFIX;\n\t    sp->ts_state = STATE_START;\n\t}\n    }\n#ifdef FEAT_RELTIME\n    if (spell_suggest_timeout > 0)\n\tprofile_setlimit(spell_suggest_timeout, &time_limit);\n#endif\n    while (depth >= 0 && !got_int)\n    {\n\tsp = &stack[depth];\n\tswitch (sp->ts_state)\n\t{\n\tcase STATE_START:\n\tcase STATE_NOPREFIX:\n\t    arridx = sp->ts_arridx;\t    \n\t    len = byts[arridx];\t\t    \n\t    arridx += sp->ts_curi;\t    \n\t    if (sp->ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tfor (n = 0; n < len && byts[arridx + n] == 0; ++n)\n\t\t    ;\n\t\tsp->ts_curi += n;\n\t\tn = (int)sp->ts_state;\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tif (depth < MAXWLEN - 1\n\t\t\t    && (byts[arridx] == 0 || n == (int)STATE_NOPREFIX))\n\t\t{\n\t\t    if (has_mbyte)\n\t\t\tn = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t    else\n\t\t\tn = sp->ts_fidx;\n\t\t    flags = badword_captype(su->su_badptr, su->su_badptr + n);\n\t\t    su->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"prefix\");\n#endif\n\t\t    go_deeper(stack, depth, 0);\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    sp->ts_prefixdepth = depth - 1;\n\t\t    byts = fbyts;\n\t\t    idxs = fidxs;\n\t\t    sp->ts_arridx = 0;\n\t\t    tword[sp->ts_twordlen] = NUL;\n\t\t    make_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t  preword + sp->ts_prewordlen, flags);\n\t\t    sp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t    sp->ts_splitoff = sp->ts_twordlen;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (sp->ts_curi > len || byts[arridx] != 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_ENDNUL;\n\t\tsp->ts_save_badflags = su->su_badflags;\n\t\tbreak;\n\t    }\n\t    ++sp->ts_curi;\t\t\n\t    flags = (int)idxs[arridx];\n\t    if (flags & WF_NOSUGGEST)\n\t\tbreak;\n\t    fword_ends = (fword[sp->ts_fidx] == NUL\n\t\t\t   || (soundfold\n\t\t\t       ? VIM_ISWHITE(fword[sp->ts_fidx])\n\t\t\t       : !spell_iswordp(fword + sp->ts_fidx, curwin)));\n\t    tword[sp->ts_twordlen] = NUL;\n\t    if (sp->ts_prefixdepth <= PFD_NOTSPECIAL\n\t\t\t\t\t&& (sp->ts_flags & TSF_PREFIXOK) == 0\n\t\t\t\t\t&& pbyts != NULL)\n\t    {\n\t\tn = stack[sp->ts_prefixdepth].ts_arridx;\n\t\tlen = pbyts[n++];\n\t\tfor (c = 0; c < len && pbyts[n + c] == 0; ++c)\n\t\t    ;\n\t\tif (c > 0)\n\t\t{\n\t\t    c = valid_word_prefix(c, n, flags,\n\t\t\t\t       tword + sp->ts_splitoff, slang, FALSE);\n\t\t    if (c == 0)\n\t\t\tbreak;\n\t\t    if (c & WF_RAREPFX)\n\t\t\tflags |= WF_RARE;\n\t\t    sp->ts_flags |= TSF_PREFIXOK;\n\t\t}\n\t    }\n\t    if (sp->ts_complen == sp->ts_compsplit && fword_ends\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\tgoodword_ends = FALSE;\n\t    else\n\t\tgoodword_ends = TRUE;\n\t    p = NULL;\n\t    compound_ok = TRUE;\n\t    if (sp->ts_complen > sp->ts_compsplit)\n\t    {\n\t\tif (slang->sl_nobreak)\n\t\t{\n\t\t    if (sp->ts_fidx - sp->ts_splitfidx\n\t\t\t\t\t  == sp->ts_twordlen - sp->ts_splitoff\n\t\t\t    && STRNCMP(fword + sp->ts_splitfidx,\n\t\t\t\t\ttword + sp->ts_splitoff,\n\t\t\t\t\t sp->ts_fidx - sp->ts_splitfidx) == 0)\n\t\t    {\n\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\tnewscore = score_wordcount_adj(slang, sp->ts_score,\n\t\t\t\t\t\t preword + sp->ts_prewordlen,\n\t\t\t\t\t\t sp->ts_prewordlen > 0);\n\t\t\tif (newscore <= su->su_maxscore)\n\t\t\t    add_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_splitfidx - repextra,\n\t\t\t\t    newscore, 0, FALSE,\n\t\t\t\t    lp->lp_sallang, FALSE);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (((unsigned)flags >> 24) == 0\n\t\t\t    || sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    if (has_mbyte\n\t\t\t    && slang->sl_compminlen > 0\n\t\t\t    && mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t       < slang->sl_compminlen)\n\t\t\tbreak;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t    vim_strncpy(preword + sp->ts_prewordlen,\n\t\t\t    tword + sp->ts_splitoff,\n\t\t\t    sp->ts_twordlen - sp->ts_splitoff);\n\t\t    if (match_checkcompoundpattern(preword,  sp->ts_prewordlen,\n\t\t\t\t\t\t\t  &slang->sl_comppat))\n\t\t\tcompound_ok = FALSE;\n\t\t    if (compound_ok)\n\t\t    {\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (fword_ends && !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    compound_ok = FALSE;\n\t\t    }\n\t\t    p = preword + sp->ts_prewordlen;\n\t\t    MB_PTR_BACK(preword, p);\n\t\t}\n\t    }\n\t    if (soundfold)\n\t\tSTRCPY(preword + sp->ts_prewordlen, tword + sp->ts_splitoff);\n\t    else if (flags & WF_KEEPCAP)\n\t\tfind_keepcap_word(slang, tword + sp->ts_splitoff,\n\t\t\t\t\t\t preword + sp->ts_prewordlen);\n\t    else\n\t    {\n\t\tc = su->su_badflags;\n\t\tif ((c & WF_ALLCAP)\n\t\t\t&& su->su_badlen == (*mb_ptr2len)(su->su_badptr))\n\t\t    c = WF_ONECAP;\n\t\tc |= flags;\n\t\tif (p != NULL && spell_iswordp_nmw(p, curwin))\n\t\t    c &= ~WF_ONECAP;\n\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen, c);\n\t    }\n\t    if (!soundfold)\n\t    {\n\t\tif (flags & WF_BANNED)\n\t\t{\n\t\t    add_banned(su, preword + sp->ts_prewordlen);\n\t\t    break;\n\t\t}\n\t\tif ((sp->ts_complen == sp->ts_compsplit\n\t\t\t    && WAS_BANNED(su, preword + sp->ts_prewordlen))\n\t\t\t\t\t\t   || WAS_BANNED(su, preword))\n\t\t{\n\t\t    if (slang->sl_compprog == NULL)\n\t\t\tbreak;\n\t\t    goodword_ends = FALSE;\n\t\t}\n\t    }\n\t    newscore = 0;\n\t    if (!soundfold)\t\n\t    {\n\t\tif ((flags & WF_REGION)\n\t\t\t    && (((unsigned)flags >> 16) & lp->lp_region) == 0)\n\t\t    newscore += SCORE_REGION;\n\t\tif (flags & WF_RARE)\n\t\t    newscore += SCORE_RARE;\n\t\tif (!spell_valid_case(su->su_badflags,\n\t\t\t\t  captype(preword + sp->ts_prewordlen, NULL)))\n\t\t    newscore += SCORE_ICASE;\n\t    }\n\t    if (fword_ends\n\t\t    && goodword_ends\n\t\t    && sp->ts_fidx >= sp->ts_fidxtry\n\t\t    && compound_ok)\n\t    {\n#ifdef DEBUG_TRIEWALK\n\t\tif (soundfold && STRCMP(preword, \"smwrd\") == 0)\n\t\t{\n\t\t    int\t    j;\n\t\t    smsg(\"------ %s -------\", fword);\n\t\t    for (j = 0; j < depth; ++j)\n\t\t\tsmsg(\"%s\", changename[j]);\n\t\t}\n#endif\n\t\tif (soundfold)\n\t\t{\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,\n\t\t\t\t\t\tpreword + sp->ts_prewordlen,\n\t\t\t\t\t\tsp->ts_prewordlen > 0);\n\t\t    if (score <= su->su_maxscore)\n\t\t    {\n\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t    sp->ts_fidx - repextra,\n\t\t\t\t    score, 0, FALSE, lp->lp_sallang, FALSE);\n\t\t\tif (su->su_badflags & WF_MIXCAP)\n\t\t\t{\n\t\t\t    c = captype(preword, NULL);\n\t\t\t    if (c == 0 || c == WF_ALLCAP)\n\t\t\t    {\n\t\t\t\tmake_case_word(tword + sp->ts_splitoff,\n\t\t\t\t\t      preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      c == 0 ? WF_ALLCAP : 0);\n\t\t\t\tadd_suggestion(su, &su->su_ga, preword,\n\t\t\t\t\tsp->ts_fidx - repextra,\n\t\t\t\t\tscore + SCORE_ICASE, 0, FALSE,\n\t\t\t\t\tlp->lp_sallang, FALSE);\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if ((sp->ts_fidx >= sp->ts_fidxtry || fword_ends)\n\t\t    && (!has_mbyte || sp->ts_tcharlen == 0))\n\t    {\n\t\tint\ttry_compound;\n\t\tint\ttry_split;\n\t\ttry_split = (sp->ts_fidx - repextra < su->su_badlen)\n\t\t\t\t\t\t\t\t&& !soundfold;\n\t\ttry_compound = FALSE;\n\t\tif (!soundfold\n\t\t\t&& !slang->sl_nocompoundsugs\n\t\t\t&& slang->sl_compprog != NULL\n\t\t\t&& ((unsigned)flags >> 24) != 0\n\t\t\t&& sp->ts_twordlen - sp->ts_splitoff\n\t\t\t\t\t\t       >= slang->sl_compminlen\n\t\t\t&& (!has_mbyte\n\t\t\t    || slang->sl_compminlen == 0\n\t\t\t    || mb_charlen(tword + sp->ts_splitoff)\n\t\t\t\t\t\t      >= slang->sl_compminlen)\n\t\t\t&& (slang->sl_compsylmax < MAXWLEN\n\t\t\t    || sp->ts_complen + 1 - sp->ts_compsplit\n\t\t\t\t\t\t\t  < slang->sl_compmax)\n\t\t\t&& (can_be_compound(sp, slang,\n\t\t\t\t\t compflags, ((unsigned)flags >> 24))))\n\t\t{\n\t\t    try_compound = TRUE;\n\t\t    compflags[sp->ts_complen] = ((unsigned)flags >> 24);\n\t\t    compflags[sp->ts_complen + 1] = NUL;\n\t\t}\n\t\tif (slang->sl_nobreak && !slang->sl_nocompoundsugs)\n\t\t    try_compound = TRUE;\n\t\telse if (!fword_ends\n\t\t\t&& try_compound\n\t\t\t&& (sp->ts_flags & TSF_DIDSPLIT) == 0)\n\t\t{\n\t\t    try_compound = FALSE;\n\t\t    sp->ts_flags |= TSF_DIDSPLIT;\n\t\t    --sp->ts_curi;\t    \n\t\t    compflags[sp->ts_complen] = NUL;\n\t\t}\n\t\telse\n\t\t    sp->ts_flags &= ~TSF_DIDSPLIT;\n\t\tif (try_split || try_compound)\n\t\t{\n\t\t    if (!try_compound && (!fword_ends || !goodword_ends))\n\t\t    {\n\t\t\tif (sp->ts_complen == sp->ts_compsplit\n\t\t\t\t\t\t     && (flags & WF_NEEDCOMP))\n\t\t\t    break;\n\t\t\tp = preword;\n\t\t\twhile (*skiptowhite(p) != NUL)\n\t\t\t    p = skipwhite(skiptowhite(p));\n\t\t\tif (sp->ts_complen > sp->ts_compsplit\n\t\t\t\t&& !can_compound(slang, p,\n\t\t\t\t\t\tcompflags + sp->ts_compsplit))\n\t\t\t    break;\n\t\t\tif (slang->sl_nosplitsugs)\n\t\t\t    newscore += SCORE_SPLIT_NO;\n\t\t\telse\n\t\t\t    newscore += SCORE_SPLIT;\n\t\t\tnewscore = score_wordcount_adj(slang, newscore,\n\t\t\t\t\t   preword + sp->ts_prewordlen, TRUE);\n\t\t    }\n\t\t    if (TRY_DEEPER(su, stack, depth, newscore))\n\t\t    {\n\t\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: split\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n\t\t\telse\n\t\t\t    sprintf(changename[depth], \"%.*s-%s: compound\",\n\t\t\t\t sp->ts_twordlen, tword, fword + sp->ts_fidx);\n#endif\n\t\t\tsp->ts_save_badflags = su->su_badflags;\n\t\t\tPROF_STORE(sp->ts_state)\n\t\t\tsp->ts_state = STATE_SPLITUNDO;\n\t\t\t++depth;\n\t\t\tsp = &stack[depth];\n\t\t\tif (!try_compound && !fword_ends)\n\t\t\t    STRCAT(preword, \" \");\n\t\t\tsp->ts_prewordlen = (char_u)STRLEN(preword);\n\t\t\tsp->ts_splitoff = sp->ts_twordlen;\n\t\t\tsp->ts_splitfidx = sp->ts_fidx;\n\t\t\tif (((!try_compound && !spell_iswordp_nmw(fword\n\t\t\t\t\t\t\t       + sp->ts_fidx,\n\t\t\t\t\t\t\t       curwin))\n\t\t\t\t    || fword_ends)\n\t\t\t\t&& fword[sp->ts_fidx] != NUL\n\t\t\t\t&& goodword_ends)\n\t\t\t{\n\t\t\t    int\t    l;\n\t\t\t    l = mb_ptr2len(fword + sp->ts_fidx);\n\t\t\t    if (fword_ends)\n\t\t\t    {\n\t\t\t\tmch_memmove(preword + sp->ts_prewordlen,\n\t\t\t\t\t\t      fword + sp->ts_fidx, l);\n\t\t\t\tsp->ts_prewordlen += l;\n\t\t\t\tpreword[sp->ts_prewordlen] = NUL;\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tsp->ts_score -= SCORE_SPLIT - SCORE_SUBST;\n\t\t\t    sp->ts_fidx += l;\n\t\t\t}\n\t\t\tif (try_compound)\n\t\t\t    ++sp->ts_complen;\n\t\t\telse\n\t\t\t    sp->ts_compsplit = sp->ts_complen;\n\t\t\tsp->ts_prefixdepth = PFD_NOPREFIX;\n\t\t\tif (has_mbyte)\n\t\t\t    n = nofold_len(fword, sp->ts_fidx, su->su_badptr);\n\t\t\telse\n\t\t\t    n = sp->ts_fidx;\n\t\t\tsu->su_badflags = badword_captype(su->su_badptr + n,\n\t\t\t\t\t       su->su_badptr + su->su_badlen);\n\t\t\tsp->ts_arridx = 0;\n\t\t\tif (pbyts != NULL)\n\t\t\t{\n\t\t\t    byts = pbyts;\n\t\t\t    idxs = pidxs;\n\t\t\t    sp->ts_prefixdepth = PFD_PREFIXTREE;\n\t\t\t    PROF_STORE(sp->ts_state)\n\t\t\t    sp->ts_state = STATE_NOPREFIX;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SPLITUNDO:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_START;\n\t    byts = fbyts;\n\t    idxs = fidxs;\n\t    break;\n\tcase STATE_ENDNUL:\n\t    su->su_badflags = sp->ts_save_badflags;\n\t    if (fword[sp->ts_fidx] == NUL && sp->ts_tcharlen == 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_DEL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_PLAIN;\n\tcase STATE_PLAIN:\n\t    arridx = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[arridx])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tif (sp->ts_fidx >= sp->ts_fidxtry)\n\t\t    sp->ts_state = STATE_DEL;\n\t\telse\n\t\t    sp->ts_state = STATE_FINAL;\n\t    }\n\t    else\n\t    {\n\t\tarridx += sp->ts_curi++;\n\t\tc = byts[arridx];\n\t\tif (c == fword[sp->ts_fidx]\n\t\t\t|| (sp->ts_tcharlen > 0 && sp->ts_isdiff != DIFF_NONE))\n\t\t    newscore = 0;\n\t\telse\n\t\t    newscore = SCORE_SUBST;\n\t\tif ((newscore == 0\n\t\t\t    || (sp->ts_fidx >= sp->ts_fidxtry\n\t\t\t\t&& ((sp->ts_flags & TSF_DIDDEL) == 0\n\t\t\t\t    || c != fword[sp->ts_delidx])))\n\t\t\t&& TRY_DEEPER(su, stack, depth, newscore))\n\t\t{\n\t\t    go_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\t    if (newscore > 0)\n\t\t\tsprintf(changename[depth], \"%.*s-%s: subst %c to %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx], c);\n\t\t    else\n\t\t\tsprintf(changename[depth], \"%.*s-%s: accept %c\",\n\t\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t    ++depth;\n\t\t    sp = &stack[depth];\n\t\t    if (fword[sp->ts_fidx] != NUL)\n\t\t\t++sp->ts_fidx;\n\t\t    tword[sp->ts_twordlen++] = c;\n\t\t    sp->ts_arridx = idxs[arridx];\n\t\t    if (newscore == SCORE_SUBST)\n\t\t\tsp->ts_isdiff = DIFF_YES;\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif (sp->ts_tcharlen == 0)\n\t\t\t{\n\t\t\t    sp->ts_tcharidx = 0;\n\t\t\t    sp->ts_tcharlen = MB_BYTE2LEN(c);\n\t\t\t    sp->ts_fcharstart = sp->ts_fidx - 1;\n\t\t\t    sp->ts_isdiff = (newscore != 0)\n\t\t\t\t\t\t       ? DIFF_YES : DIFF_NONE;\n\t\t\t}\n\t\t\telse if (sp->ts_isdiff == DIFF_INSERT)\n\t\t\t    --sp->ts_fidx;\n\t\t\tif (++sp->ts_tcharidx == sp->ts_tcharlen)\n\t\t\t{\n\t\t\t    if (sp->ts_isdiff == DIFF_YES)\n\t\t\t    {\n\t\t\t\tsp->ts_fidx = sp->ts_fcharstart\n\t\t\t\t\t    + mb_ptr2len(\n\t\t\t\t\t\t    fword + sp->ts_fcharstart);\n\t\t\t\tif (enc_utf8\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen))\n\t\t\t\t\t&& utf_iscomposing(\n\t\t\t\t\t    utf_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SUBCOMP;\n\t\t\t\telse if (!soundfold\n\t\t\t\t\t&& slang->sl_has_map\n\t\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t    mb_ptr2char(tword\n\t\t\t\t\t\t+ sp->ts_twordlen\n\t\t\t\t\t\t\t   - sp->ts_tcharlen),\n\t\t\t\t\t    mb_ptr2char(fword\n\t\t\t\t\t\t\t+ sp->ts_fcharstart)))\n\t\t\t\t    sp->ts_score -=\n\t\t\t\t\t\t  SCORE_SUBST - SCORE_SIMILAR;\n\t\t\t    }\n\t\t\t    else if (sp->ts_isdiff == DIFF_INSERT\n\t\t\t\t\t && sp->ts_twordlen > sp->ts_tcharlen)\n\t\t\t    {\n\t\t\t\tp = tword + sp->ts_twordlen - sp->ts_tcharlen;\n\t\t\t\tc = mb_ptr2char(p);\n\t\t\t\tif (enc_utf8 && utf_iscomposing(c))\n\t\t\t\t{\n\t\t\t\t    sp->ts_score -= SCORE_INS - SCORE_INSCOMP;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    MB_PTR_BACK(tword, p);\n\t\t\t\t    if (c == mb_ptr2char(p))\n\t\t\t\t\tsp->ts_score -= SCORE_INS\n\t\t\t\t\t\t\t       - SCORE_INSDUP;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    sp->ts_tcharlen = 0;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (newscore != 0\n\t\t\t\t&& !soundfold\n\t\t\t\t&& slang->sl_has_map\n\t\t\t\t&& similar_chars(slang,\n\t\t\t\t\t\t   c, fword[sp->ts_fidx - 1]))\n\t\t\t    sp->ts_score -= SCORE_SUBST - SCORE_SIMILAR;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_DEL:\n\t    if (has_mbyte && sp->ts_tcharlen > 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_INS_PREP;\n\t    sp->ts_curi = 1;\n\t    if (soundfold && sp->ts_fidx == 0 && fword[sp->ts_fidx] == '*')\n\t\tnewscore = 2 * SCORE_DEL / 3;\n\t    else\n\t\tnewscore = SCORE_DEL;\n\t    if (fword[sp->ts_fidx] != NUL\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: delete %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tfword[sp->ts_fidx]);\n#endif\n\t\t++depth;\n\t\tstack[depth].ts_flags |= TSF_DIDDEL;\n\t\tstack[depth].ts_delidx = sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    c = mb_ptr2char(fword + sp->ts_fidx);\n\t\t    stack[depth].ts_fidx += mb_ptr2len(fword + sp->ts_fidx);\n\t\t    if (enc_utf8 && utf_iscomposing(c))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;\n\t\t    else if (c == mb_ptr2char(fword + stack[depth].ts_fidx))\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++stack[depth].ts_fidx;\n\t\t    if (fword[sp->ts_fidx] == fword[sp->ts_fidx + 1])\n\t\t\tstack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;\n\t\t}\n\t\tbreak;\n\t    }\n\tcase STATE_INS_PREP:\n\t    if (sp->ts_flags & TSF_DIDDEL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n = sp->ts_arridx;\n\t    for (;;)\n\t    {\n\t\tif (sp->ts_curi > byts[n])\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_SWAP;\n\t\t    break;\n\t\t}\n\t\tif (byts[n + sp->ts_curi] != NUL)\n\t\t{\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_INS;\n\t\t    break;\n\t\t}\n\t\t++sp->ts_curi;\n\t    }\n\t    break;\n\tcase STATE_INS:\n\t    n = sp->ts_arridx;\n\t    if (sp->ts_curi > byts[n])\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP;\n\t\tbreak;\n\t    }\n\t    n += sp->ts_curi++;\n\t    c = byts[n];\n\t    if (soundfold && sp->ts_twordlen == 0 && c == '*')\n\t\tnewscore = 2 * SCORE_INS / 3;\n\t    else\n\t\tnewscore = SCORE_INS;\n\t    if (c != fword[sp->ts_fidx]\n\t\t\t\t    && TRY_DEEPER(su, stack, depth, newscore))\n\t    {\n\t\tgo_deeper(stack, depth, newscore);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: insert %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc);\n#endif\n\t\t++depth;\n\t\tsp = &stack[depth];\n\t\ttword[sp->ts_twordlen++] = c;\n\t\tsp->ts_arridx = idxs[n];\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = MB_BYTE2LEN(c);\n\t\t    if (fl > 1)\n\t\t    {\n\t\t\tsp->ts_tcharlen = fl;\n\t\t\tsp->ts_tcharidx = 1;\n\t\t\tsp->ts_isdiff = DIFF_INSERT;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    fl = 1;\n\t\tif (fl == 1)\n\t\t{\n\t\t    if (sp->ts_twordlen >= 2\n\t\t\t\t\t   && tword[sp->ts_twordlen - 2] == c)\n\t\t\tsp->ts_score -= SCORE_INS - SCORE_INSDUP;\n\t\t}\n\t    }\n\t    break;\n\tcase STATE_SWAP:\n\t    p = fword + sp->ts_fidx;\n\t    c = *p;\n\t    if (c == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tif (p[n] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + n, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = mb_ptr2char(p + n);\n\t    }\n\t    else\n\t    {\n\t\tif (p[1] == NUL)\n\t\t    c2 = NUL;\n\t\telse if (!soundfold && !spell_iswordp(p + 1, curwin))\n\t\t    c2 = c; \n\t\telse\n\t\t    c2 = p[1];\n\t    }\n\t    if (c2 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (c == c2)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_SWAP3;\n\t\tbreak;\n\t    }\n\t    if (c2 != NUL && TRY_DEEPER(su, stack, depth, SCORE_SWAP))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c2);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    fl = mb_char2len(c2);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = c2;\n\t\t    p[1] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 2;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc = mb_ptr2char(p + n);\n\t\tmch_memmove(p + mb_ptr2len(p + n), p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = c;\n\t    }\n\tcase STATE_SWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = MB_CPTR2LEN(p);\n\t\tc = mb_ptr2char(p);\n\t\tfl = MB_CPTR2LEN(p + n);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tif (!soundfold && !spell_iswordp(p + n + fl, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = mb_ptr2char(p + n + fl);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\tc2 = p[1];\n\t\tif (!soundfold && !spell_iswordp(p + 2, curwin))\n\t\t    c3 = c;\t\n\t\telse\n\t\t    c3 = p[2];\n\t    }\n\t    if (c == c3 || c3 == NUL)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tsprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tc, c3);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNSWAP3;\n\t\t++depth;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    tl = mb_char2len(c3);\n\t\t    mch_memmove(p, p + n + fl, tl);\n\t\t    mb_char2bytes(c2, p + tl);\n\t\t    mb_char2bytes(c, p + fl + tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    p[0] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNSWAP3:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tc2 = mb_ptr2char(p + n);\n\t\tfl = mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n + fl);\n\t\ttl = mb_ptr2len(p + n + fl);\n\t\tmch_memmove(p + fl + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t\tmb_char2bytes(c2, p + tl);\n\t\tp = p + tl;\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[2];\n\t\tp[2] = c;\n\t\t++p;\n\t    }\n\t    if (!soundfold && !spell_iswordp(p, curwin))\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t\tbreak;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3L;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    c = mb_ptr2char(p);\n\t\t    fl = MB_CPTR2LEN(p + n);\n\t\t    fl += MB_CPTR2LEN(p + n + fl);\n\t\t    mch_memmove(p, p + n, fl);\n\t\t    mb_char2bytes(c, p + fl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + fl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = *p;\n\t\t    *p = p[1];\n\t\t    p[1] = p[2];\n\t\t    p[2] = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3L:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tn = mb_ptr2len(p);\n\t\tn += mb_ptr2len(p + n);\n\t\tc = mb_ptr2char(p + n);\n\t\ttl = mb_ptr2len(p + n);\n\t\tmch_memmove(p + tl, p, n);\n\t\tmb_char2bytes(c, p);\n\t    }\n\t    else\n\t    {\n\t\tc = p[2];\n\t\tp[2] = p[1];\n\t\tp[1] = *p;\n\t\t*p = c;\n\t    }\n\t    if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3))\n\t    {\n\t\tgo_deeper(stack, depth, SCORE_SWAP3);\n#ifdef DEBUG_TRIEWALK\n\t\tp = fword + sp->ts_fidx;\n\t\tsprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",\n\t\t\tsp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\tp[0], p[1], p[2]);\n#endif\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_UNROT3R;\n\t\t++depth;\n\t\tp = fword + sp->ts_fidx;\n\t\tif (has_mbyte)\n\t\t{\n\t\t    n = MB_CPTR2LEN(p);\n\t\t    n += MB_CPTR2LEN(p + n);\n\t\t    c = mb_ptr2char(p + n);\n\t\t    tl = MB_CPTR2LEN(p + n);\n\t\t    mch_memmove(p + tl, p, n);\n\t\t    mb_char2bytes(c, p);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + n + tl;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = p[2];\n\t\t    p[2] = p[1];\n\t\t    p[1] = *p;\n\t\t    *p = c;\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + 3;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_REP_INI;\n\t    }\n\t    break;\n\tcase STATE_UNROT3R:\n\t    p = fword + sp->ts_fidx;\n\t    if (has_mbyte)\n\t    {\n\t\tc = mb_ptr2char(p);\n\t\ttl = mb_ptr2len(p);\n\t\tn = mb_ptr2len(p + tl);\n\t\tn += mb_ptr2len(p + tl + n);\n\t\tmch_memmove(p, p + tl, n);\n\t\tmb_char2bytes(c, p + n);\n\t    }\n\t    else\n\t    {\n\t\tc = *p;\n\t\t*p = p[1];\n\t\tp[1] = p[2];\n\t\tp[2] = c;\n\t    }\n\tcase STATE_REP_INI:\n\t    if ((lp->lp_replang == NULL && !soundfold)\n\t\t    || sp->ts_score + SCORE_REP >= su->su_maxscore\n\t\t    || sp->ts_fidx < sp->ts_fidxtry)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    if (soundfold)\n\t\tsp->ts_curi = slang->sl_repsal_first[fword[sp->ts_fidx]];\n\t    else\n\t\tsp->ts_curi = lp->lp_replang->sl_rep_first[fword[sp->ts_fidx]];\n\t    if (sp->ts_curi < 0)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t\tbreak;\n\t    }\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\tcase STATE_REP:\n\t    p = fword + sp->ts_fidx;\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    while (sp->ts_curi < gap->ga_len)\n\t    {\n\t\tftp = (fromto_T *)gap->ga_data + sp->ts_curi++;\n\t\tif (*ftp->ft_from != *p)\n\t\t{\n\t\t    sp->ts_curi = gap->ga_len;\n\t\t    break;\n\t\t}\n\t\tif (STRNCMP(ftp->ft_from, p, STRLEN(ftp->ft_from)) == 0\n\t\t\t&& TRY_DEEPER(su, stack, depth, SCORE_REP))\n\t\t{\n\t\t    go_deeper(stack, depth, SCORE_REP);\n#ifdef DEBUG_TRIEWALK\n\t\t    sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",\n\t\t\t    sp->ts_twordlen, tword, fword + sp->ts_fidx,\n\t\t\t    ftp->ft_from, ftp->ft_to);\n#endif\n\t\t    PROF_STORE(sp->ts_state)\n\t\t    sp->ts_state = STATE_REP_UNDO;\n\t\t    ++depth;\n\t\t    fl = (int)STRLEN(ftp->ft_from);\n\t\t    tl = (int)STRLEN(ftp->ft_to);\n\t\t    if (fl != tl)\n\t\t    {\n\t\t\tSTRMOVE(p + tl, p + fl);\n\t\t\trepextra += tl - fl;\n\t\t    }\n\t\t    mch_memmove(p, ftp->ft_to, tl);\n\t\t    stack[depth].ts_fidxtry = sp->ts_fidx + tl;\n\t\t    stack[depth].ts_tcharlen = 0;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (sp->ts_curi >= gap->ga_len && sp->ts_state == STATE_REP)\n\t    {\n\t\tPROF_STORE(sp->ts_state)\n\t\tsp->ts_state = STATE_FINAL;\n\t    }\n\t    break;\n\tcase STATE_REP_UNDO:\n\t    if (soundfold)\n\t\tgap = &slang->sl_repsal;\n\t    else\n\t\tgap = &lp->lp_replang->sl_rep;\n\t    ftp = (fromto_T *)gap->ga_data + sp->ts_curi - 1;\n\t    fl = (int)STRLEN(ftp->ft_from);\n\t    tl = (int)STRLEN(ftp->ft_to);\n\t    p = fword + sp->ts_fidx;\n\t    if (fl != tl)\n\t    {\n\t\tSTRMOVE(p + fl, p + tl);\n\t\trepextra -= tl - fl;\n\t    }\n\t    mch_memmove(p, ftp->ft_from, fl);\n\t    PROF_STORE(sp->ts_state)\n\t    sp->ts_state = STATE_REP;\n\t    break;\n\tdefault:\n\t    --depth;\n\t    if (depth >= 0 && stack[depth].ts_prefixdepth == PFD_PREFIXTREE)\n\t    {\n\t\tbyts = pbyts;\n\t\tidxs = pidxs;\n\t    }\n\t    if (--breakcheckcount == 0)\n\t    {\n\t\tui_breakcheck();\n\t\tbreakcheckcount = 1000;\n#ifdef FEAT_RELTIME\n\t\tif (spell_suggest_timeout > 0\n\t\t\t\t\t  && profile_passed_limit(&time_limit))\n\t\t    got_int = TRUE;\n#endif\n\t    }\n\t}\n    }\n}",
        "file_name": "200323.sol"
    }
]