[
    {
        "function_name": "GmfOpenMesh",
        "vulnerability": "Potential stack buffer overflow",
        "criticism": "The vulnerability reasoning is correct as the code uses strcpy function to copy the input FilNam to msh->FilNam without checking the length of FilNam, which can lead to a buffer overflow. However, the severity score should be lower as the buffer overflow is limited to the size of GmfStrSiz. The correctness score is high as the vulnerability reasoning is accurate. The profitability score is also high as an attacker could potentially exploit this vulnerability to overwrite adjacent memory.",
        "correctness": 8,
        "severity": 5,
        "profitability": 8,
        "reason": "The code uses strcpy function to copy the input FilNam to msh->FilNam without checking the length of FilNam. This can lead to a buffer overflow if the length of FilNam is larger than the allocated buffer size, potentially allowing an attacker to overwrite adjacent memory.",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "file_name": "217547.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "vulnerability": "Uncontrolled format string vulnerability",
        "criticism": "The vulnerability reasoning is accurate as the code uses fprintf function without specifying the format string dynamically, which can lead to a format string vulnerability. The severity score should be higher as format string vulnerabilities can be critical. The correctness score is high as the vulnerability reasoning is correct. The profitability score is also high as an attacker could exploit this vulnerability to read or write arbitrary memory locations.",
        "correctness": 9,
        "severity": 8,
        "profitability": 9,
        "reason": "The code uses fprintf function to write data to a file without specifying the format string dynamically. This can lead to a format string vulnerability where an attacker can craft a malicious format string to read or write arbitrary memory locations, potentially leading to code execution.",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "file_name": "217547.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "vulnerability": "Use of insecure functions",
        "criticism": "The vulnerability reasoning is valid as the code uses potentially insecure functions like strcpy, fopen, fscanf, and fprintf without proper input validation. The severity score should be higher as the use of insecure functions can lead to various vulnerabilities. The correctness score is high as the vulnerability reasoning is accurate. The profitability score is also high as an attacker could exploit these vulnerabilities for malicious purposes.",
        "correctness": 9,
        "severity": 7,
        "profitability": 8,
        "reason": "The code uses potentially insecure functions like strcpy, fopen, fscanf, and fprintf without proper input validation. These functions can be susceptible to buffer overflows, path traversal attacks, and format string vulnerabilities, making the code exploitable by attackers.",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "file_name": "217547.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "vulnerability": "Buffer Overflow",
        "criticism": "The vulnerability reasoning is correct as the function does not perform proper bounds checking when copying the input filename 'FilNam' into the 'msh->FilNam' buffer using the 'strcpy' function. The severity score should be higher as buffer overflow vulnerabilities can lead to code execution. The correctness score is high as the vulnerability reasoning is accurate. The profitability score is also high as an attacker could exploit this vulnerability to execute arbitrary code.",
        "correctness": 9,
        "severity": 8,
        "profitability": 9,
        "reason": "The function does not perform proper bounds checking when copying the input filename 'FilNam' into the 'msh->FilNam' buffer using the 'strcpy' function. This can lead to a buffer overflow vulnerability if the input filename is longer than the buffer size 'GmfStrSiz'. An attacker can exploit this vulnerability to overwrite adjacent memory locations and potentially execute arbitrary code.",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "file_name": "217547.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "vulnerability": "Arbitrary File Write",
        "criticism": "The vulnerability reasoning is valid as the function lacks proper input validation when opening files for writing in binary mode, which can allow an attacker to specify arbitrary file paths and write malicious content. The severity score should be higher as arbitrary file writes can lead to unauthorized access. The correctness score is high as the vulnerability reasoning is accurate. The profitability score is also high as an attacker could exploit this vulnerability to write to sensitive system files.",
        "correctness": 9,
        "severity": 8,
        "profitability": 9,
        "reason": "The function lacks proper input validation and sanitization when opening files for writing in binary mode. This can allow an attacker to specify arbitrary file paths and write malicious content to sensitive system files, leading to unauthorized access or denial of service attacks.",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "file_name": "217547.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "vulnerability": "Uncontrolled Format String",
        "criticism": "The vulnerability reasoning is correct as the function uses format string specifiers in the 'fprintf' function calls without proper validation of user-supplied data, leading to format string vulnerabilities. The severity score should be higher as format string vulnerabilities can be critical. The correctness score is high as the vulnerability reasoning is accurate. The profitability score is also high as an attacker could exploit this vulnerability to execute arbitrary code.",
        "correctness": 9,
        "severity": 8,
        "profitability": 9,
        "reason": "The function uses format string specifiers in the 'fprintf' function calls without proper validation or sanitization of user-supplied data. This can lead to format string vulnerabilities, allowing an attacker to read or write arbitrary memory locations, leak sensitive information, or execute arbitrary code.",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "file_name": "217547.sol"
    }
]