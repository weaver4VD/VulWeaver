[
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY |\n\t\t    O_CLOEXEC | O_NOFOLLOW);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Potential privilege escalation via improper file flags manipulation",
        "reason": "The code allows for arbitrary manipulation of file flags without proper validation. An attacker could potentially exploit this vulnerability to escalate their privileges by setting or clearing certain file flags that grant them additional permissions on files.",
        "file_name": "326629.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY |\n\t\t    O_CLOEXEC | O_NOFOLLOW);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Potential Privilege Escalation through Insecure File Flags Manipulation",
        "reason": "The function set_fflags_platform allows for manipulation of file flags through the use of ioctl calls, which can potentially lead to privilege escalation if not properly restricted. An attacker could exploit this vulnerability by setting or clearing certain file flags that could grant them elevated privileges on the system.",
        "file_name": "326629.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY |\n\t\t    O_CLOEXEC | O_NOFOLLOW);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Information Disclosure through Improper Error Handling",
        "reason": "The function set_fflags_platform does not handle errors securely, specifically in the case of failing to set file flags. This could potentially lead to information disclosure as the error message 'Failed to set file flags' can reveal sensitive information about the file system or application logic to an attacker.",
        "file_name": "326629.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY |\n\t\t    O_CLOEXEC | O_NOFOLLOW);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Resource Leakage due to Improper File Descriptor Handling",
        "reason": "The function set_fflags_platform potentially leaks file descriptors in the case where 'fd' is less than zero. If the condition 'if (fd < 0)' is met, the function closes 'myfd' but does not check if 'myfd' was opened or not, leading to a resource leakage vulnerability. An attacker could exploit this to exhaust system resources and cause a denial of service.",
        "file_name": "326629.sol"
    }
]