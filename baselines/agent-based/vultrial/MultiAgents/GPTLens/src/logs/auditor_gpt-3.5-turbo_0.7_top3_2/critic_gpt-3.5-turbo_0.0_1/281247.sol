[
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Uninitialized Pointers",
        "criticism": "The vulnerability of uninitialized pointers is valid as the pointers header, instr, smp, and phead are being initialized without any memory allocation, leading to potential undefined behavior and security vulnerabilities. The reasoning is accurate, and the severity is high as it can result in critical issues. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 9 due to the high impact on the system. The profitability score is 7 as exploiting uninitialized pointers can lead to security breaches.",
        "correctness": 8,
        "severity": 9,
        "profitability": 7,
        "reason": "The pointers header, instr, smp, and phead are being initialized without any memory allocation. This can lead to accessing uninitialized memory, causing undefined behavior and potential security vulnerabilities.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol"
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Memory Allocation Vulnerabilities",
        "criticism": "The vulnerability of memory allocation without proper bounds checking is valid as the code dynamically allocates memory using the new keyword without adequate validation, potentially leading to buffer overflow vulnerabilities. The reasoning is sound, and the severity is high due to the risk of exploitation. The correctness score is 8 as the vulnerability is accurately identified. The severity score is 8 as it poses a significant threat. The profitability score is 7 as attackers can exploit memory allocation vulnerabilities.",
        "correctness": 8,
        "severity": 8,
        "profitability": 7,
        "reason": "The code dynamically allocates memory using new keyword without proper bounds checking. This can lead to buffer overflow vulnerabilities if the input values for ordnum, insnum, patnum, and insnum are controlled by an attacker.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol"
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Input Validation Vulnerabilities",
        "criticism": "The vulnerability of reading data without proper validation or size checking is valid as it can lead to buffer overflow vulnerabilities if the input data size exceeds the expected size. The reasoning is appropriate, and the severity is significant. The correctness score is 8 as the vulnerability is correctly pointed out. The severity score is 8 due to the potential impact on system security. The profitability score is 7 as attackers can exploit input validation vulnerabilities.",
        "correctness": 8,
        "severity": 8,
        "profitability": 7,
        "reason": "The code reads data from the input file without proper validation or size checking. This can lead to buffer overflow vulnerabilities if the input data size exceeds the expected size, potentially allowing an attacker to overwrite critical data or execute arbitrary code.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol"
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Potential buffer overflow",
        "criticism": "The vulnerability of potential buffer overflow due to lack of bounds checking in accessing 'instr' and 'smp' arrays is valid. This can lead to memory corruption and potential execution of arbitrary code. The reasoning is accurate, and the severity is high. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 9 due to the critical impact. The profitability score is 8 as attackers can exploit buffer overflow vulnerabilities.",
        "correctness": 8,
        "severity": 9,
        "profitability": 8,
        "reason": "There is a potential buffer overflow vulnerability in the code snippet where the 'instr' and 'smp' arrays are accessed without proper bounds checking. This could lead to writing data beyond the allocated memory for these arrays, resulting in memory corruption and potentially allowing an attacker to execute arbitrary code.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol"
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Memory leak",
        "criticism": "The vulnerability of memory leak due to not deallocating 'insParaPtrs', 'patParaPtrs', and 'samplePtrs' arrays before returning from the function is valid. This can lead to denial of service or resource exhaustion. The reasoning is correct, and the severity is moderate. The correctness score is 8 as the vulnerability is accurately identified. The severity score is 6 due to the impact on system resources. The profitability score is 5 as memory leaks can be exploited for resource exhaustion.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "There is a memory leak vulnerability in the code snippet where memory is allocated for 'insParaPtrs', 'patParaPtrs', and 'samplePtrs' arrays, but they are not properly deallocated before returning from the function. This could lead to a denial of service or exhaustion of system resources if the function is called repeatedly.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol"
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Potential heap buffer overflow",
        "criticism": "The vulnerability of potential heap buffer overflow in the 'pattern' array due to fixed size allocation without bounds checking is valid. This can result in buffer overflow and potential code execution. The reasoning is sound, and the severity is high. The correctness score is 8 as the vulnerability is correctly identified. The severity score is 9 due to the critical impact. The profitability score is 8 as attackers can exploit heap buffer overflow vulnerabilities.",
        "correctness": 8,
        "severity": 9,
        "profitability": 8,
        "reason": "There is a potential heap buffer overflow vulnerability in the code snippet where the 'pattern' array is allocated with a fixed size without proper bounds checking. If the calculated size exceeds the allocated memory size, it could lead to a buffer overflow and potentially allow an attacker to execute arbitrary code.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol"
    }
]