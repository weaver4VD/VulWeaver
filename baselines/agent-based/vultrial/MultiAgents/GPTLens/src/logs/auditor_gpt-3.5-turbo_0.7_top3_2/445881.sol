[
    {
        "function_name": "_fr_window_ask_overwrite_dialog",
        "code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\t\t\tg_object_unref (destination);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\tif (perform_extraction) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}",
        "vulnerability": "Potential Memory Corruption Vulnerability",
        "reason": "The function '_g_path_get_relative_basename_safe' is used to get the base name of a file safely, but the casting of 'odata->current_file->data' to 'char *' might lead to memory corruption if 'odata->current_file->data' is not a valid C string. This can be exploited by an attacker to manipulate memory and potentially execute arbitrary code.",
        "file_name": "445881.sol"
    },
    {
        "function_name": "_fr_window_ask_overwrite_dialog",
        "code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\t\t\tg_object_unref (destination);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\tif (perform_extraction) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}",
        "vulnerability": "Potential Null Pointer Dereference Vulnerability",
        "reason": "The code does not perform proper NULL checks before dereferencing pointers, such as 'odata->current_file' and 'odata->edata->file_list'. If these pointers are NULL, attempting to access their members or call functions on them can lead to a null pointer dereference, causing the program to crash. An attacker can potentially exploit this to disrupt the application's functionality.",
        "file_name": "445881.sol"
    },
    {
        "function_name": "_fr_window_ask_overwrite_dialog",
        "code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\t\t\tg_object_unref (destination);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\tif (perform_extraction) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}",
        "vulnerability": "Potential Resource Exhaustion Vulnerability",
        "reason": "The function does not handle memory resources efficiently. It allocates memory for 'destination' using 'g_file_get_child' but fails to free it properly in all code paths. This can lead to resource exhaustion if the function is called repeatedly without releasing the allocated memory, potentially causing the application to consume excessive memory and slow down or crash. An attacker could exploit this vulnerability to degrade the performance of the application or trigger a denial of service condition.",
        "file_name": "445881.sol"
    },
    {
        "function_name": "_fr_window_ask_overwrite_dialog",
        "code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\t\t\tg_object_unref (destination);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\tif (perform_extraction) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}",
        "vulnerability": "Potential NULL pointer dereference",
        "reason": "The code snippet checks if 'base_name' is not NULL before using it to create 'destination'. However, there is a potential race condition where 'base_name' could be modified after the NULL check, leading to a NULL pointer dereference vulnerability. Attackers could exploit this vulnerability to crash the application or potentially execute arbitrary code.",
        "file_name": "445881.sol"
    },
    {
        "function_name": "_fr_window_ask_overwrite_dialog",
        "code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\t\t\tg_object_unref (destination);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\tif (perform_extraction) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}",
        "vulnerability": "Potential NULL pointer dereference",
        "reason": "The code snippet directly checks if 'file_list' is NULL without validating its access. If 'file_list' is accessed before this check, it could lead to a NULL pointer dereference vulnerability. Attackers could exploit this vulnerability to crash the application or potentially execute arbitrary code.",
        "file_name": "445881.sol"
    },
    {
        "function_name": "_fr_window_ask_overwrite_dialog",
        "code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tgboolean perform_extraction = TRUE;\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename_safe ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tif (base_name != NULL) {\n\t\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\t\tg_file_query_info_async (destination,\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t\t odata);\n\t\t\tg_object_unref (destination);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tperform_extraction = FALSE;\n\t}\n\tif (odata->edata->file_list == NULL)\n\t\tperform_extraction = FALSE;\n\tif (perform_extraction) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}",
        "vulnerability": "Use-after-free vulnerability",
        "reason": "The code snippet frees the 'odata' object at the end of the function. If 'odata' is accessed or used after this point, it could lead to a use-after-free vulnerability. Attackers could exploit this vulnerability to manipulate memory contents and potentially execute arbitrary code.",
        "file_name": "445881.sol"
    }
]