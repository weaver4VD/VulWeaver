[
    {
        "function_name": "sftp_mkdir",
        "code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}",
        "vulnerability": "Potential Double Free Vulnerability",
        "reason": "The code snippet shows that the resources 'buffer' and 'path' are being freed twice in the error handling block. If any of the functions inside the if statement fail, the resources are freed and then the code proceeds to free the resources again after the if statement. This can lead to a double free vulnerability where an attacker can exploit this behavior to potentially execute arbitrary code.",
        "file_name": "216202.sol"
    },
    {
        "function_name": "sftp_mkdir",
        "code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}",
        "vulnerability": "Potential Memory Leak Vulnerability",
        "reason": "The code snippet shows that if the status of the mkdir operation is SSH_FX_FAILURE, the 'errno_attr' variable is assigned a value using 'sftp_lstat' function. If 'errno_attr' is not NULL, it is freed using 'SAFE_FREE'. However, if 'errno_attr' is NULL, it is not freed, causing a potential memory leak. An attacker could repeatedly trigger this scenario to exhaust memory resources.",
        "file_name": "216202.sol"
    },
    {
        "function_name": "sftp_mkdir",
        "code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}",
        "vulnerability": "Information Disclosure Vulnerability",
        "reason": "The code snippet shows that when an unexpected status is received, an error message is set using 'status->errormsg'. This error message may contain sensitive information about the SFTP server implementation, which can be leveraged by an attacker to gain insights into the server's internal workings and potentially exploit other vulnerabilities.",
        "file_name": "216202.sol"
    },
    {
        "function_name": "sftp_mkdir",
        "code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}",
        "vulnerability": "Potential memory leaks",
        "reason": "The code snippet shows that if certain conditions are met, the buffer and path resources are freed before returning from the function. However, if any of the conditions in the if statement are true, the resources will not be freed, leading to a potential memory leak.",
        "file_name": "216202.sol"
    },
    {
        "function_name": "sftp_mkdir",
        "code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}",
        "vulnerability": "Potential resource exhaustion",
        "reason": "In the case when the status is SSH_FX_FAILURE, the function calls sftp_lstat to get information about the specified directory. However, if the directory does not exist, sftp_lstat will return NULL and the SAFE_FREE function will be called on a NULL pointer, potentially leading to resource exhaustion or a segmentation fault.",
        "file_name": "216202.sol"
    },
    {
        "function_name": "sftp_mkdir",
        "code": "int sftp_mkdir(sftp_session sftp, const char *directory, mode_t mode) {\n  sftp_status_message status = NULL;\n  sftp_message msg = NULL;\n  sftp_attributes errno_attr = NULL;\n  struct sftp_attributes_struct attr;\n  ssh_buffer buffer;\n  ssh_string path;\n  uint32_t id;\n  buffer = ssh_buffer_new();\n  if (buffer == NULL) {\n    ssh_set_error_oom(sftp->session);\n    return -1;\n  }\n  path = ssh_string_from_char(directory);\n  if (path == NULL) {\n    ssh_set_error_oom(sftp->session);\n    ssh_buffer_free(buffer);\n    return -1;\n  }\n  ZERO_STRUCT(attr);\n  attr.permissions = mode;\n  attr.flags = SSH_FILEXFER_ATTR_PERMISSIONS;\n  id = sftp_get_new_id(sftp);\n  if (buffer_add_u32(buffer, id) < 0 ||\n      buffer_add_ssh_string(buffer, path) < 0 ||\n      buffer_add_attributes(buffer, &attr) < 0 ||\n      sftp_packet_write(sftp, SSH_FXP_MKDIR, buffer) < 0) {\n    ssh_buffer_free(buffer);\n    ssh_string_free(path);\n  }\n  ssh_buffer_free(buffer);\n  ssh_string_free(path);\n  while (msg == NULL) {\n    if (sftp_read_and_dispatch(sftp) < 0) {\n      return -1;\n    }\n    msg = sftp_dequeue(sftp, id);\n  }\n  if (msg->packet_type == SSH_FXP_STATUS) {\n    status = parse_status_msg(msg);\n    sftp_message_free(msg);\n    if (status == NULL) {\n      return -1;\n    }\n    sftp_set_error(sftp, status->status);\n    switch (status->status) {\n      case SSH_FX_FAILURE:\n        errno_attr = sftp_lstat(sftp, directory);\n        if (errno_attr != NULL) {\n          SAFE_FREE(errno_attr);\n          sftp_set_error(sftp, SSH_FX_FILE_ALREADY_EXISTS);\n        }\n        break;\n      case SSH_FX_OK:\n        status_msg_free(status);\n        return 0;\n        break;\n      default:\n        break;\n    }\n    ssh_set_error(sftp->session, SSH_REQUEST_DENIED,\n        \"SFTP server: %s\", status->errormsg);\n    status_msg_free(status);\n    return -1;\n  } else {\n    ssh_set_error(sftp->session, SSH_FATAL,\n        \"Received message %d when attempting to make directory\",\n        msg->packet_type);\n    sftp_message_free(msg);\n  }\n  return -1;\n}",
        "vulnerability": "Potential information disclosure",
        "reason": "If the received message type is not SSH_FXP_STATUS, the function sets an error message with the received packet type. This can potentially leak information about the internal workings of the SFTP server to an attacker, aiding them in crafting targeted attacks.",
        "file_name": "216202.sol"
    }
]