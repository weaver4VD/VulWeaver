[
    {
        "function_name": "njs_array_prototype_splice",
        "vulnerability": "Arithmetic overflow leading to denial of service",
        "criticism": "The reasoning for this vulnerability is incorrect. The code snippet does handle the possibility of overflow when calculating the new length of the array after splicing by checking if the sum of length and delta exceeds NJS_MAX_LENGTH. Therefore, the correctness score should be high. However, the severity and profitability scores are low as the impact of this vulnerability is minimal.",
        "correctness": 8,
        "severity": 2,
        "profitability": 2,
        "reason": "The code does not check for overflow when calculating the new length of the array after splicing. An attacker could provide input that causes an overflow, leading to a denial of service by crashing the application.",
        "code": "njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n    this = njs_argument(args, 0);\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n    items = 0;\n    delete = 0;\n    if (nargs == 2) {\n        delete = length - start;\n    } else if (nargs > 2) {\n        items = nargs - 3;\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n    delta = items - delete;\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n    } else {\n        njs_set_array(&del_object, deleted);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n            if (ret == NJS_OK) {\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n        if (delta != 0) {\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            array->length += delta;\n        }\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n    } else {\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    njs_set_array(&vm->retval, deleted);\n    return NJS_OK;\n}",
        "file_name": "230302.sol"
    },
    {
        "function_name": "njs_array_prototype_splice",
        "vulnerability": "Memory corruption",
        "criticism": "The reasoning for this vulnerability is valid. The code snippet does not properly handle setting the length of the deleted array object, which can lead to memory corruption. The correctness score should be high as the vulnerability is correctly identified. The severity and profitability scores are also high as memory corruption can lead to arbitrary code execution.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The code does not properly handle setting the length of the deleted array object. An attacker could manipulate the length value to cause memory corruption, potentially leading to arbitrary code execution.",
        "code": "njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n    this = njs_argument(args, 0);\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n    items = 0;\n    delete = 0;\n    if (nargs == 2) {\n        delete = length - start;\n    } else if (nargs > 2) {\n        items = nargs - 3;\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n    delta = items - delete;\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n    } else {\n        njs_set_array(&del_object, deleted);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n            if (ret == NJS_OK) {\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n        if (delta != 0) {\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            array->length += delta;\n        }\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n    } else {\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    njs_set_array(&vm->retval, deleted);\n    return NJS_OK;\n}",
        "file_name": "230302.sol"
    },
    {
        "function_name": "njs_array_prototype_splice",
        "vulnerability": "Out-of-bounds memory access",
        "criticism": "The reasoning for this vulnerability is valid. The code snippet does not properly check for out-of-bounds memory access when setting the new length of the array after splicing, which can lead to data leakage or code execution. The correctness score should be high as the vulnerability is correctly identified. The severity and profitability scores are also high due to the potential impact of out-of-bounds access.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The code does not properly check for out-of-bounds memory access when setting the new length of the array after splicing. An attacker could manipulate the delta value to access memory beyond the bounds of the array, leading to potential data leakage or code execution.",
        "code": "njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n    this = njs_argument(args, 0);\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n    items = 0;\n    delete = 0;\n    if (nargs == 2) {\n        delete = length - start;\n    } else if (nargs > 2) {\n        items = nargs - 3;\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n    delta = items - delete;\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n    } else {\n        njs_set_array(&del_object, deleted);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n            if (ret == NJS_OK) {\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n        if (delta != 0) {\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            array->length += delta;\n        }\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n    } else {\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    njs_set_array(&vm->retval, deleted);\n    return NJS_OK;\n}",
        "file_name": "230302.sol"
    },
    {
        "function_name": "njs_array_prototype_splice",
        "vulnerability": "Use of uninitialized value",
        "criticism": "The reasoning for this vulnerability is valid. The code snippet initializes 'del_object' without setting any value to it, which can lead to the use of uninitialized value and unexpected behavior. The correctness score should be high as the vulnerability is correctly identified. The severity and profitability scores are moderate as uninitialized values can lead to bugs but may not always result in security vulnerabilities.",
        "correctness": 8,
        "severity": 5,
        "profitability": 5,
        "reason": "The code snippet initializes 'del_object' without setting any value to it. This can lead to use of uninitialized value and potentially cause unexpected behavior or security vulnerabilities.",
        "code": "njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n    this = njs_argument(args, 0);\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n    items = 0;\n    delete = 0;\n    if (nargs == 2) {\n        delete = length - start;\n    } else if (nargs > 2) {\n        items = nargs - 3;\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n    delta = items - delete;\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n    } else {\n        njs_set_array(&del_object, deleted);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n            if (ret == NJS_OK) {\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n        if (delta != 0) {\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            array->length += delta;\n        }\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n    } else {\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    njs_set_array(&vm->retval, deleted);\n    return NJS_OK;\n}",
        "file_name": "230302.sol"
    },
    {
        "function_name": "njs_array_prototype_splice",
        "vulnerability": "Type confusion vulnerability",
        "criticism": "The reasoning for this vulnerability is valid. The code snippet performs a type check on 'this' and 'deleted->object.fast_array', which can lead to a type confusion vulnerability if the types are manipulated by an attacker. The correctness score should be high as the vulnerability is correctly identified. The severity and profitability scores are high as type confusion vulnerabilities can lead to arbitrary code execution.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The code snippet performs a type check on 'this' and 'deleted->object.fast_array', which can lead to a type confusion vulnerability if the types are manipulated by an attacker. This can be exploited to execute arbitrary code or gain unauthorized access.",
        "code": "njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n    this = njs_argument(args, 0);\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n    items = 0;\n    delete = 0;\n    if (nargs == 2) {\n        delete = length - start;\n    } else if (nargs > 2) {\n        items = nargs - 3;\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n    delta = items - delete;\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n    } else {\n        njs_set_array(&del_object, deleted);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n            if (ret == NJS_OK) {\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n        if (delta != 0) {\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            array->length += delta;\n        }\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n    } else {\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    njs_set_array(&vm->retval, deleted);\n    return NJS_OK;\n}",
        "file_name": "230302.sol"
    },
    {
        "function_name": "njs_array_prototype_splice",
        "vulnerability": "Memory leak",
        "criticism": "The reasoning for this vulnerability is valid. The code snippet sets 'vm->retval' to 'deleted', which can lead to a memory leak if 'vm->retval' was previously pointing to allocated memory. The correctness score should be high as the vulnerability is correctly identified. The severity and profitability scores are moderate as memory leaks can impact system performance but may not always lead to security vulnerabilities.",
        "correctness": 8,
        "severity": 4,
        "profitability": 4,
        "reason": "The code snippet sets 'vm->retval' to 'deleted', which can lead to a memory leak if 'vm->retval' was previously pointing to allocated memory. This can be exploited by an attacker to consume excessive memory resources and potentially cause a denial of service.",
        "code": "njs_array_prototype_splice(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t      i, n, start, length, items, delta, delete;\n    njs_int_t    ret;\n    njs_value_t  *this, value, del_object;\n    njs_array_t  *array, *deleted;\n    this = njs_argument(args, 0);\n    ret = njs_value_to_object(vm, this);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_object_length(vm, this, &length);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    ret = njs_value_to_integer(vm, njs_arg(args, nargs, 1), &start);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    start = (start < 0) ? njs_max(length + start, 0) : njs_min(start, length);\n    items = 0;\n    delete = 0;\n    if (nargs == 2) {\n        delete = length - start;\n    } else if (nargs > 2) {\n        items = nargs - 3;\n        ret = njs_value_to_integer(vm, njs_arg(args, nargs, 2), &delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        delete = njs_min(njs_max(delete, 0), length - start);\n    }\n    delta = items - delete;\n    if (njs_slow_path((length + delta) > NJS_MAX_LENGTH)) {\n        njs_type_error(vm, \"Invalid length\");\n        return NJS_ERROR;\n    }\n    deleted = njs_array_alloc(vm, 0, delete, 0);\n    if (njs_slow_path(deleted == NULL)) {\n        return NJS_ERROR;\n    }\n    if (njs_fast_path(njs_is_fast_array(this) && deleted->object.fast_array)) {\n        array = njs_array(this);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            deleted->start[i] = array->start[n];\n        }\n    } else {\n        njs_set_array(&del_object, deleted);\n        for (i = 0, n = start; i < delete; i++, n++) {\n            ret = njs_value_property_i64(vm, this, n, &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n            if (ret == NJS_OK) {\n                ret = njs_value_property_i64_set(vm, &del_object, i, &value);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return ret;\n                }\n            } else {\n                if (deleted->object.fast_array) {\n                    njs_set_invalid(&deleted->start[i]);\n                }\n            }\n        }\n        ret = njs_object_length_set(vm, &del_object, delete);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    if (njs_fast_path(njs_is_fast_array(this))) {\n        array = njs_array(this);\n        if (delta != 0) {\n            if (delta > 0) {\n                ret = njs_array_expand(vm, array, 0, delta);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    return ret;\n                }\n            }\n            ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                        array->length - (start + delete), 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            array->length += delta;\n        }\n        if (items > 0) {\n            memcpy(&array->start[start], &args[3],\n                   items * sizeof(njs_value_t));\n        }\n    } else {\n       if (delta != 0) {\n           ret = njs_array_copy_within(vm, this, start + items, start + delete,\n                                       length - (start + delete), delta < 0);\n            if (njs_slow_path(ret != NJS_OK)) {\n                return ret;\n            }\n            for (i = length - 1; i >= length + delta; i--) {\n                ret = njs_value_property_i64_delete(vm, this, i, NULL);\n                if (njs_slow_path(ret == NJS_ERROR)) {\n                    return NJS_ERROR;\n                }\n            }\n       }\n        for (i = 3, n = start; items-- > 0; i++, n++) {\n            ret = njs_value_property_i64_set(vm, this, n, &args[i]);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NJS_ERROR;\n            }\n        }\n        ret = njs_object_length_set(vm, this, length + delta);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return NJS_ERROR;\n        }\n    }\n    njs_set_array(&vm->retval, deleted);\n    return NJS_OK;\n}",
        "file_name": "230302.sol"
    }
]