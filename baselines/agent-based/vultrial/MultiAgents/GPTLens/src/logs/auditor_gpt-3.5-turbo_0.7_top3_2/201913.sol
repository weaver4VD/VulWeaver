[
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Insecure File Handling",
        "reason": "The function uses open() to open a file without proper validation of the file path/name. This can lead to directory traversal attacks where an attacker can manipulate the 'name' parameter to access files outside of the intended directory.",
        "file_name": "201913.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Insecure File Permissions",
        "reason": "The function sets file flags without properly validating the permissions required. This can allow an attacker to manipulate the 'set' and 'clear' parameters to change file permissions, potentially giving them unauthorized access to sensitive files.",
        "file_name": "201913.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Insufficient Error Handling",
        "reason": "The function does not handle errors properly, specifically when setting file flags. If an error occurs during the file flag manipulation process, the function only logs the error but continues execution. This can lead to incomplete or incorrect file flag settings, leaving the system vulnerable to attacks.",
        "file_name": "201913.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Potential arbitrary file attribute manipulation",
        "reason": "The function allows setting and clearing file flags using the 'set' and 'clear' parameters without proper validation. An attacker could potentially pass malicious values to manipulate file attributes, leading to unauthorized changes in file properties, which could be exploited for malicious purposes.",
        "file_name": "201913.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Insecure file descriptor handling",
        "reason": "The function opens a file descriptor using 'open' without proper error handling or validation. If the open operation fails, the function continues execution, potentially leading to unexpected behavior or resource leaks. An attacker could leverage this vulnerability to cause a denial of service or exploit other weaknesses in the code.",
        "file_name": "201913.sol"
    },
    {
        "function_name": "set_fflags_platform",
        "code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}",
        "vulnerability": "Lack of error handling",
        "reason": "The function performs an 'ioctl' operation to get file flags, but it lacks proper error handling. If the 'ioctl' call fails, the function jumps to the 'fail' label without handling the error, potentially leaving the program in an inconsistent state. An attacker could exploit this vulnerability to cause a crash or trigger unexpected behavior.",
        "file_name": "201913.sol"
    }
]