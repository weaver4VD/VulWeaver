[
    {
        "function_name": "ZRLE_DECODE",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "vulnerability": "Potential buffer overflow vulnerability",
        "reason": "The code reads data into the 'buf' array without performing proper bounds checking. This can lead to a buffer overflow if the input data size exceeds the allocated size of the array (64 * 64). An attacker can exploit this vulnerability by providing a specially crafted input that overflows the buffer, potentially leading to arbitrary code execution.",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "vulnerability": "Potential integer overflow vulnerability",
        "reason": "The code uses integer variables without proper validation for potential overflow. For example, the 'len' variable in the RLE decoding section could be manipulated by an attacker to overflow and potentially lead to a buffer overflow or memory corruption. This can be exploited by providing malicious input data to trigger the overflow and potentially execute arbitrary code.",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "vulnerability": "Potential denial of service vulnerability",
        "reason": "The code lacks proper input validation and error handling mechanisms, which can be exploited by an attacker to cause a denial of service (DoS) by providing specially crafted input. For instance, the code does not properly handle exceptional conditions such as buffer overflows or integer overflows, which can lead to crashes or hangs in the application. An attacker can exploit these weaknesses to disrupt the normal operation of the system.",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code has multiple instances where it reads data into the 'buf' array without sufficient bounds checking. This can lead to buffer overflow vulnerabilities if the input data size exceeds the allocated buffer size (64*64). An attacker can exploit this vulnerability by providing malicious input data to overflow the buffer and potentially execute arbitrary code.",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "vulnerability": "Uncontrolled Resource Consumption",
        "reason": "The code does not have proper checks to limit the amount of resources (CPU, memory) that can be consumed during the decoding process. This can lead to an attacker sending specially crafted input that causes the application to consume excessive resources, potentially leading to denial of service (DoS) by exhausting system resources.",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "vulnerability": "Insufficient Input Validation",
        "reason": "The code lacks proper input validation checks, especially when processing the 'mode' variable and 'palSize'. This can lead to unexpected behavior or exploitation by an attacker providing malicious input outside the expected range. Attackers can manipulate these values to bypass intended restrictions and potentially cause security issues.",
        "file_name": "376682.sol"
    }
]