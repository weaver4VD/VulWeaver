[
    {
        "function_name": "change_indent",
        "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t\n    int\t\tcall_changed_bytes)\t\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t\n    char_u\t*new_line, *orig_line = NULL;\t\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  \n\torig_col = curwin->w_cursor.col;\n    }\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n    start_col = curwin->w_cursor.col;\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n    insstart_less = curwin->w_cursor.col;\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n    if (new_cursor_col > 0)\t    \n\tstart_col = -1;\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n    if (new_cursor_col >= 0)\n    {\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\tinsstart_less = MAXCOL;\n    }\n    curwin->w_p_list = save_p_list;\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    \n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n    if (State & VREPLACE_FLAG)\n    {\n\tif (orig_line == NULL)\n\t    return;\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\tnew_line[curwin->w_cursor.col] = NUL;\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\tbackspace_until_column(0);\n\tins_bytes(new_line);\n\tvim_free(new_line);\n    }\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The function 'change_indent' does not perform bounds checking when manipulating strings, specifically in the section where it allocates memory for 'ptr' without verifying the size. This can lead to a buffer overflow vulnerability where an attacker could craft input that exceeds the allocated memory, causing unexpected behavior and potentially allowing for arbitrary code execution.",
        "file_name": "211842.sol"
    },
    {
        "function_name": "change_indent",
        "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t\n    int\t\tcall_changed_bytes)\t\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t\n    char_u\t*new_line, *orig_line = NULL;\t\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  \n\torig_col = curwin->w_cursor.col;\n    }\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n    start_col = curwin->w_cursor.col;\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n    insstart_less = curwin->w_cursor.col;\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n    if (new_cursor_col > 0)\t    \n\tstart_col = -1;\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n    if (new_cursor_col >= 0)\n    {\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\tinsstart_less = MAXCOL;\n    }\n    curwin->w_p_list = save_p_list;\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    \n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n    if (State & VREPLACE_FLAG)\n    {\n\tif (orig_line == NULL)\n\t    return;\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\tnew_line[curwin->w_cursor.col] = NUL;\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\tbackspace_until_column(0);\n\tins_bytes(new_line);\n\tvim_free(new_line);\n    }\n}",
        "vulnerability": "Uncontrolled Format String",
        "reason": "The function 'change_indent' utilizes functions like 'vim_strsave' and 'ml_replace' without proper format string protection. This can lead to an uncontrolled format string vulnerability, where an attacker can craft malicious input to exploit the format string in these functions and potentially execute arbitrary code.",
        "file_name": "211842.sol"
    },
    {
        "function_name": "change_indent",
        "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t\n    int\t\tcall_changed_bytes)\t\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t\n    char_u\t*new_line, *orig_line = NULL;\t\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  \n\torig_col = curwin->w_cursor.col;\n    }\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n    start_col = curwin->w_cursor.col;\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n    insstart_less = curwin->w_cursor.col;\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n    if (new_cursor_col > 0)\t    \n\tstart_col = -1;\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n    if (new_cursor_col >= 0)\n    {\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\tinsstart_less = MAXCOL;\n    }\n    curwin->w_p_list = save_p_list;\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    \n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n    if (State & VREPLACE_FLAG)\n    {\n\tif (orig_line == NULL)\n\t    return;\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\tnew_line[curwin->w_cursor.col] = NUL;\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\tbackspace_until_column(0);\n\tins_bytes(new_line);\n\tvim_free(new_line);\n    }\n}",
        "vulnerability": "Null Pointer Dereference",
        "reason": "The code in function 'change_indent' contains several instances where pointers are used without proper validation, such as the usage of 'ptr' without checking if it is NULL before dereferencing it. This can lead to a null pointer dereference vulnerability, where an attacker could exploit this behavior to crash the application or potentially execute arbitrary code.",
        "file_name": "211842.sol"
    },
    {
        "function_name": "change_indent",
        "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t\n    int\t\tcall_changed_bytes)\t\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t\n    char_u\t*new_line, *orig_line = NULL;\t\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  \n\torig_col = curwin->w_cursor.col;\n    }\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n    start_col = curwin->w_cursor.col;\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n    insstart_less = curwin->w_cursor.col;\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n    if (new_cursor_col > 0)\t    \n\tstart_col = -1;\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n    if (new_cursor_col >= 0)\n    {\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\tinsstart_less = MAXCOL;\n    }\n    curwin->w_p_list = save_p_list;\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    \n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n    if (State & VREPLACE_FLAG)\n    {\n\tif (orig_line == NULL)\n\t    return;\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\tnew_line[curwin->w_cursor.col] = NUL;\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\tbackspace_until_column(0);\n\tins_bytes(new_line);\n\tvim_free(new_line);\n    }\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The function allows for potential buffer overflow vulnerabilities due to improper handling of memory allocation and manipulation. For example, in the section where 'ptr' is allocated memory, there is no check to ensure that the allocation does not exceed the bounds of the allocated space. This could be exploited by an attacker to overwrite adjacent memory locations and potentially execute malicious code.",
        "file_name": "211842.sol"
    },
    {
        "function_name": "change_indent",
        "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t\n    int\t\tcall_changed_bytes)\t\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t\n    char_u\t*new_line, *orig_line = NULL;\t\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  \n\torig_col = curwin->w_cursor.col;\n    }\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n    start_col = curwin->w_cursor.col;\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n    insstart_less = curwin->w_cursor.col;\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n    if (new_cursor_col > 0)\t    \n\tstart_col = -1;\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n    if (new_cursor_col >= 0)\n    {\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\tinsstart_less = MAXCOL;\n    }\n    curwin->w_p_list = save_p_list;\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    \n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n    if (State & VREPLACE_FLAG)\n    {\n\tif (orig_line == NULL)\n\t    return;\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\tnew_line[curwin->w_cursor.col] = NUL;\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\tbackspace_until_column(0);\n\tins_bytes(new_line);\n\tvim_free(new_line);\n    }\n}",
        "vulnerability": "Arbitrary Code Execution",
        "reason": "The function includes sections where user input is directly used in memory manipulation operations without proper validation or sanitization. This can lead to potential arbitrary code execution vulnerabilities if an attacker can control the input values passed to the function. For instance, the 'set_indent' function call with 'amount' parameter could be manipulated to execute arbitrary code by an attacker.",
        "file_name": "211842.sol"
    },
    {
        "function_name": "change_indent",
        "code": "change_indent(\n    int\t\ttype,\n    int\t\tamount,\n    int\t\tround,\n    int\t\treplaced,\t\n    int\t\tcall_changed_bytes)\t\n{\n    int\t\tvcol;\n    int\t\tlast_vcol;\n    int\t\tinsstart_less;\t\t\n    int\t\tnew_cursor_col;\n    int\t\ti;\n    char_u\t*ptr;\n    int\t\tsave_p_list;\n    int\t\tstart_col;\n    colnr_T\tvc;\n    colnr_T\torig_col = 0;\t\t\n    char_u\t*new_line, *orig_line = NULL;\t\n    if (State & VREPLACE_FLAG)\n    {\n\torig_line = vim_strsave(ml_get_curline());  \n\torig_col = curwin->w_cursor.col;\n    }\n    save_p_list = curwin->w_p_list;\n    curwin->w_p_list = FALSE;\n    vc = getvcol_nolist(&curwin->w_cursor);\n    vcol = vc;\n    start_col = curwin->w_cursor.col;\n    new_cursor_col = curwin->w_cursor.col;\n    beginline(BL_WHITE);\n    new_cursor_col -= curwin->w_cursor.col;\n    insstart_less = curwin->w_cursor.col;\n    if (new_cursor_col < 0)\n\tvcol = get_indent() - vcol;\n    if (new_cursor_col > 0)\t    \n\tstart_col = -1;\n    if (type == INDENT_SET)\n\t(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);\n    else\n    {\n\tint\tsave_State = State;\n\tif (State & VREPLACE_FLAG)\n\t    State = INSERT;\n\tshift_line(type == INDENT_DEC, round, 1, call_changed_bytes);\n\tState = save_State;\n    }\n    insstart_less -= curwin->w_cursor.col;\n    if (new_cursor_col >= 0)\n    {\n\tif (new_cursor_col == 0)\n\t    insstart_less = MAXCOL;\n\tnew_cursor_col += curwin->w_cursor.col;\n    }\n    else if (!(State & INSERT))\n\tnew_cursor_col = curwin->w_cursor.col;\n    else\n    {\n\tvcol = get_indent() - vcol;\n\tcurwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);\n\tvcol = last_vcol = 0;\n\tnew_cursor_col = -1;\n\tptr = ml_get_curline();\n\twhile (vcol <= (int)curwin->w_virtcol)\n\t{\n\t    last_vcol = vcol;\n\t    if (has_mbyte && new_cursor_col >= 0)\n\t\tnew_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);\n\t    else\n\t\t++new_cursor_col;\n\t    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);\n\t}\n\tvcol = last_vcol;\n\tif (vcol != (int)curwin->w_virtcol)\n\t{\n\t    curwin->w_cursor.col = (colnr_T)new_cursor_col;\n\t    i = (int)curwin->w_virtcol - vcol;\n\t    ptr = alloc(i + 1);\n\t    if (ptr != NULL)\n\t    {\n\t\tnew_cursor_col += i;\n\t\tptr[i] = NUL;\n\t\twhile (--i >= 0)\n\t\t    ptr[i] = ' ';\n\t\tins_str(ptr);\n\t\tvim_free(ptr);\n\t    }\n\t}\n\tinsstart_less = MAXCOL;\n    }\n    curwin->w_p_list = save_p_list;\n    if (new_cursor_col <= 0)\n\tcurwin->w_cursor.col = 0;\n    else\n\tcurwin->w_cursor.col = (colnr_T)new_cursor_col;\n    curwin->w_set_curswant = TRUE;\n    changed_cline_bef_curs();\n    if (State & INSERT)\n    {\n\tif (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)\n\t{\n\t    if ((int)Insstart.col <= insstart_less)\n\t\tInsstart.col = 0;\n\t    else\n\t\tInsstart.col -= insstart_less;\n\t}\n\tif ((int)ai_col <= insstart_less)\n\t    ai_col = 0;\n\telse\n\t    ai_col -= insstart_less;\n    }\n    if (REPLACE_NORMAL(State) && start_col >= 0)\n    {\n\twhile (start_col > (int)curwin->w_cursor.col)\n\t{\n\t    replace_join(0);\t    \n\t    --start_col;\n\t}\n\twhile (start_col < (int)curwin->w_cursor.col || replaced)\n\t{\n\t    replace_push(NUL);\n\t    if (replaced)\n\t    {\n\t\treplace_push(replaced);\n\t\treplaced = NUL;\n\t    }\n\t    ++start_col;\n\t}\n    }\n    if (State & VREPLACE_FLAG)\n    {\n\tif (orig_line == NULL)\n\t    return;\n\tnew_line = vim_strsave(ml_get_curline());\n\tif (new_line == NULL)\n\t    return;\n\tnew_line[curwin->w_cursor.col] = NUL;\n\tml_replace(curwin->w_cursor.lnum, orig_line, FALSE);\n\tcurwin->w_cursor.col = orig_col;\n\tbackspace_until_column(0);\n\tins_bytes(new_line);\n\tvim_free(new_line);\n    }\n}",
        "vulnerability": "Information Disclosure",
        "reason": "The function may expose sensitive information due to improper handling of memory and cursor positioning. For instance, in the section where 'orig_line' is copied from 'ml_get_curline()', there is a potential risk of leaking sensitive data stored in 'orig_line'. An attacker could exploit this vulnerability to extract confidential information from the application's memory.",
        "file_name": "211842.sol"
    }
]