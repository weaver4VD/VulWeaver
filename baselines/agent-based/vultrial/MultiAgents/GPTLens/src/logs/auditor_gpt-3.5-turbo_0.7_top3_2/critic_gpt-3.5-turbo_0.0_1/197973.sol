[
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential denial of service",
        "criticism": "The reasoning provided for the potential denial of service vulnerability is valid as the code snippet returns the value of 'ret' without further validation or error handling. This could potentially lead to a denial of service if 'ret' is a negative value that is not properly handled. However, the severity of this vulnerability is not very high as it may not directly lead to a security breach. The correctness score is 7 as the vulnerability is valid, the severity score is 5 as it may not have a significant impact, and the profitability score is 4 as exploiting this vulnerability may not provide significant benefits to an attacker.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The code is returning the value of 'ret' without further validation or error handling. This could potentially lead to a denial of service if 'ret' is a negative value that is not properly handled.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "197973.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Environment variable injection",
        "criticism": "The reasoning provided for the environment variable injection vulnerability is valid as the code snippet directly uses the value of the 'LISTEN_FDS' environment variable without proper validation or sanitization. This could allow an attacker to inject arbitrary values and potentially manipulate the 'listen_fds' and 'preserve_fds' variables. The severity of this vulnerability is moderate as it could lead to unauthorized access or manipulation of sensitive data. The correctness score is 8 as the vulnerability is valid, the severity score is 6 as it could have a moderate impact, and the profitability score is 5 as exploiting this vulnerability may provide some benefits to an attacker.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "The code is directly using the value of the 'LISTEN_FDS' environment variable without proper validation or sanitization. If an attacker can control the value of this environment variable, they could inject arbitrary values and potentially manipulate the 'listen_fds' and 'preserve_fds' variables.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "197973.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential memory corruption",
        "criticism": "The reasoning provided for the potential memory corruption vulnerability is valid as the code snippet copies the 'exec_options.cap' array into multiple fields of the 'capabilities' struct without proper bounds checking. This could lead to buffer overflows and potential memory corruption vulnerabilities if the 'exec_options.cap_size' is larger than expected. The severity of this vulnerability is high as it could lead to arbitrary code execution or system compromise. The correctness score is 9 as the vulnerability is valid, the severity score is 8 as it has a high impact, and the profitability score is 7 as exploiting this vulnerability could provide significant benefits to an attacker.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The code is directly copying the 'exec_options.cap' array into multiple fields of the 'capabilities' struct without proper bounds checking. If the 'exec_options.cap_size' is larger than expected, it could lead to buffer overflows and potential memory corruption vulnerabilities.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "197973.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential denial of service (DoS)",
        "criticism": "The reasoning provided for the potential denial of service vulnerability is valid as the code snippet returns 'ret' if it is less than 0 without handling the error condition. This could potentially allow an attacker to repeatedly trigger this condition to cause the application to crash or become unresponsive, resulting in a denial of service. The severity of this vulnerability is moderate as it could disrupt the availability of the application. The correctness score is 7 as the vulnerability is valid, the severity score is 6 as it could have a moderate impact, and the profitability score is 5 as exploiting this vulnerability may not provide significant benefits to an attacker.",
        "correctness": 7,
        "severity": 6,
        "profitability": 5,
        "reason": "The code snippet contains a potential denial of service vulnerability where the function returns 'ret' if it is less than 0 without handling the error condition. This could potentially allow an attacker to repeatedly trigger this condition to cause the application to crash or become unresponsive, resulting in a denial of service.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "197973.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential buffer overflow",
        "criticism": "The reasoning provided for the potential buffer overflow vulnerability is valid as the 'args' array in the 'process' struct is assigned a value from 'argv' without proper bounds checking. This could lead to a buffer overflow and potential code execution if the length of 'args' array is not properly validated. The severity of this vulnerability is high as it could lead to arbitrary code execution or system compromise. The correctness score is 9 as the vulnerability is valid, the severity score is 8 as it has a high impact, and the profitability score is 7 as exploiting this vulnerability could provide significant benefits to an attacker.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The code snippet contains a potential buffer overflow vulnerability where the 'args' array in the 'process' struct is assigned a value from 'argv' without proper bounds checking. If the length of 'args' array is not properly validated, an attacker could provide a large input that exceeds the bounds of the array, leading to a buffer overflow and potential code execution.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "197973.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential memory leak",
        "criticism": "The reasoning provided for the potential memory leak vulnerability is valid as memory allocated for 'capabilities->inheritable' is assigned the result of 'dup_array' function without proper memory deallocation. This could lead to a memory leak over time, potentially exhausting system resources. The severity of this vulnerability is low as it may not directly lead to a security breach. The correctness score is 7 as the vulnerability is valid, the severity score is 4 as it may not have a significant impact, and the profitability score is 3 as exploiting this vulnerability may not provide significant benefits to an attacker.",
        "correctness": 7,
        "severity": 4,
        "profitability": 3,
        "reason": "The code snippet contains a potential memory leak vulnerability where memory allocated for 'capabilities->inheritable' is assigned the result of 'dup_array' function. If the memory allocated for 'capabilities->inheritable' is not properly freed after its use, it could lead to a memory leak over time, potentially exhausting system resources and impacting the application's performance.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "197973.sol"
    }
]