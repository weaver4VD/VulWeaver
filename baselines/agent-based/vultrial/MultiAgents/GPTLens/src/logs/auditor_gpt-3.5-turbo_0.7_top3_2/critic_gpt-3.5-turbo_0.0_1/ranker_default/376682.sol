[
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Potential integer overflow vulnerability",
        "criticism": "The reasoning provided for the potential integer overflow vulnerability is valid. The code uses integer variables without proper validation, which can lead to an overflow and potentially result in a buffer overflow or memory corruption. However, the severity and profitability of this vulnerability are moderate as it requires manipulation of input data to trigger the overflow.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "The code uses integer variables without proper validation for potential overflow. For example, the 'len' variable in the RLE decoding section could be manipulated by an attacker to overflow and potentially lead to a buffer overflow or memory corruption. This can be exploited by providing malicious input data to trigger the overflow and potentially execute arbitrary code.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol",
        "final_score": 6.75
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Potential denial of service vulnerability",
        "criticism": "The reasoning for the potential denial of service vulnerability is accurate. The lack of proper input validation and error handling mechanisms can be exploited by an attacker to cause a denial of service by providing specially crafted input. The severity and profitability of this vulnerability are moderate as it can disrupt the normal operation of the system.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "The code lacks proper input validation and error handling mechanisms, which can be exploited by an attacker to cause a denial of service (DoS) by providing specially crafted input. For instance, the code does not properly handle exceptional conditions such as buffer overflows or integer overflows, which can lead to crashes or hangs in the application. An attacker can exploit these weaknesses to disrupt the normal operation of the system.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol",
        "final_score": 6.75
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Uncontrolled Resource Consumption",
        "criticism": "The reasoning for the uncontrolled resource consumption vulnerability is accurate. The code lacks proper checks to limit the amount of resources that can be consumed during the decoding process, which can lead to denial of service by exhausting system resources. The severity and profitability of this vulnerability are moderate as it can disrupt the normal operation of the system.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "The code does not have proper checks to limit the amount of resources (CPU, memory) that can be consumed during the decoding process. This can lead to an attacker sending specially crafted input that causes the application to consume excessive resources, potentially leading to denial of service (DoS) by exhausting system resources.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol",
        "final_score": 6.75
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Insufficient Input Validation",
        "criticism": "The reasoning for the insufficient input validation vulnerability is valid. The code lacks proper input validation checks, especially when processing the 'mode' variable and 'palSize', which can lead to unexpected behavior or exploitation by an attacker providing malicious input. The severity and profitability of this vulnerability are moderate as it can lead to security issues.",
        "correctness": 8,
        "severity": 6,
        "profitability": 5,
        "reason": "The code lacks proper input validation checks, especially when processing the 'mode' variable and 'palSize'. This can lead to unexpected behavior or exploitation by an attacker providing malicious input outside the expected range. Attackers can manipulate these values to bypass intended restrictions and potentially cause security issues.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol",
        "final_score": 6.75
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Potential buffer overflow vulnerability",
        "criticism": "The reasoning provided for the potential buffer overflow vulnerability is accurate. The code reads data into the 'buf' array without performing proper bounds checking, which can lead to a buffer overflow if the input data size exceeds the allocated size of the array. This vulnerability can be exploited by an attacker to execute arbitrary code. However, the severity and profitability of this vulnerability are not very high as it requires specific conditions to be met for exploitation.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The code reads data into the 'buf' array without performing proper bounds checking. This can lead to a buffer overflow if the input data size exceeds the allocated size of the array (64 * 64). An attacker can exploit this vulnerability by providing a specially crafted input that overflows the buffer, potentially leading to arbitrary code execution.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol",
        "final_score": 5.75
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning for the buffer overflow vulnerability is valid. The code reads data into the 'buf' array without sufficient bounds checking, which can lead to buffer overflow vulnerabilities if the input data size exceeds the allocated buffer size. The severity and profitability of this vulnerability are moderate as it requires specific conditions to be met for exploitation.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The code has multiple instances where it reads data into the 'buf' array without sufficient bounds checking. This can lead to buffer overflow vulnerabilities if the input data size exceeds the allocated buffer size (64*64). An attacker can exploit this vulnerability by providing malicious input data to overflow the buffer and potentially execute arbitrary code.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol",
        "final_score": 5.75
    }
]