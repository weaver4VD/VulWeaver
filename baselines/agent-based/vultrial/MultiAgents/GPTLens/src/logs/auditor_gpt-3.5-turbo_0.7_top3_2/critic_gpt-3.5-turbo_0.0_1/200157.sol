[
    {
        "function_name": "readconf_main",
        "vulnerability": "Arbitrary File Reading",
        "criticism": "The reasoning provided for this vulnerability is accurate as the code does allow an attacker to read arbitrary files on the system by manipulating the filename in the configuration filelist. However, the severity score should be higher as arbitrary file reading can lead to unauthorized access to sensitive information. The correctness score is also high as the vulnerability is clearly present in the code. The profitability score should be high as well since attackers can exploit this vulnerability to access confidential data.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The code allows an attacker to read arbitrary files on the system by providing a specially crafted filename in the configuration filelist. The attacker can manipulate the filename to access sensitive files containing passwords, cryptographic keys, or other confidential information.",
        "code": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  \n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  \n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  \n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  \n  config_file = Ufopen(filename, \"rb\");\n  #endif\n  if (config_file != NULL || errno != ENOENT) break;\n  }\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n  if ((statbuf.st_uid != root_uid                \n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           \n       #endif\n         ) ||                                    \n      (statbuf.st_gid != root_gid                \n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           \n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       \n      ((statbuf.st_mode & 2) != 0))              \n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\nfreeze_tell_config = freeze_tell;\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n  primary_hostname = string_copy(hostname);\n  }\nsmtp_active_hostname = primary_hostname;\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       \n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n  log_file_path = s;\n  }\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n#ifdef SUPPORT_TLS\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "file_name": "200157.sol"
    },
    {
        "function_name": "readconf_main",
        "vulnerability": "Information Disclosure",
        "criticism": "The reasoning provided for this vulnerability is valid as the code does disclose sensitive system information by calling the uname function without proper checks. The severity score should be higher as information disclosure can aid attackers in planning further attacks. The correctness score is high as the vulnerability is present in the code. The profitability score should also be high as attackers can leverage this information for malicious purposes.",
        "correctness": 9,
        "severity": 7,
        "profitability": 8,
        "reason": "The code discloses sensitive system information by calling the uname function without proper checks. This information can be valuable for attackers in planning further attacks or gaining unauthorized access to the system.",
        "code": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  \n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  \n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  \n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  \n  config_file = Ufopen(filename, \"rb\");\n  #endif\n  if (config_file != NULL || errno != ENOENT) break;\n  }\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n  if ((statbuf.st_uid != root_uid                \n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           \n       #endif\n         ) ||                                    \n      (statbuf.st_gid != root_gid                \n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           \n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       \n      ((statbuf.st_mode & 2) != 0))              \n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\nfreeze_tell_config = freeze_tell;\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n  primary_hostname = string_copy(hostname);\n  }\nsmtp_active_hostname = primary_hostname;\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       \n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n  log_file_path = s;\n  }\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n#ifdef SUPPORT_TLS\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "file_name": "200157.sol"
    },
    {
        "function_name": "readconf_main",
        "vulnerability": "Insecure File Permissions",
        "criticism": "The reasoning provided for this vulnerability is accurate as the code does not properly validate the file permissions of the configuration file, making it susceptible to unauthorized access. The severity score should be higher as insecure file permissions can lead to unauthorized modification of critical files. The correctness score is high as the vulnerability is clearly present in the code. The profitability score should be high as well since attackers can exploit this vulnerability to execute arbitrary code.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The code does not properly validate the file permissions of the configuration file, making it susceptible to unauthorized access. Attackers can exploit this vulnerability to modify the configuration file and potentially execute arbitrary code on the system.",
        "code": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  \n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  \n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  \n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  \n  config_file = Ufopen(filename, \"rb\");\n  #endif\n  if (config_file != NULL || errno != ENOENT) break;\n  }\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n  if ((statbuf.st_uid != root_uid                \n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           \n       #endif\n         ) ||                                    \n      (statbuf.st_gid != root_gid                \n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           \n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       \n      ((statbuf.st_mode & 2) != 0))              \n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\nfreeze_tell_config = freeze_tell;\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n  primary_hostname = string_copy(hostname);\n  }\nsmtp_active_hostname = primary_hostname;\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       \n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n  log_file_path = s;\n  }\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n#ifdef SUPPORT_TLS\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "file_name": "200157.sol"
    },
    {
        "function_name": "readconf_main",
        "vulnerability": "Potential Path Traversal Vulnerability",
        "criticism": "The reasoning provided for this vulnerability is accurate as the code is vulnerable to path traversal attacks due to improper validation of the filename obtained from the configuration file list. The severity score should be higher as path traversal vulnerabilities can lead to unauthorized access to sensitive files. The correctness score is high as the vulnerability is clearly present in the code. The profitability score should be high as well since attackers can exploit this vulnerability to access arbitrary files.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The code uses the filename obtained from the configuration file list directly without proper validation. This can lead to a path traversal vulnerability, where an attacker may manipulate the filename to access arbitrary files on the system outside the intended directory. If an attacker can control the 'config_main_filelist' variable, they can potentially read sensitive files or execute malicious code.",
        "code": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  \n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  \n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  \n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  \n  config_file = Ufopen(filename, \"rb\");\n  #endif\n  if (config_file != NULL || errno != ENOENT) break;\n  }\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n  if ((statbuf.st_uid != root_uid                \n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           \n       #endif\n         ) ||                                    \n      (statbuf.st_gid != root_gid                \n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           \n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       \n      ((statbuf.st_mode & 2) != 0))              \n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\nfreeze_tell_config = freeze_tell;\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n  primary_hostname = string_copy(hostname);\n  }\nsmtp_active_hostname = primary_hostname;\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       \n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n  log_file_path = s;\n  }\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n#ifdef SUPPORT_TLS\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "file_name": "200157.sol"
    },
    {
        "function_name": "readconf_main",
        "vulnerability": "Insecure Configuration",
        "criticism": "The reasoning provided for this vulnerability is accurate as the code allows for a misconfiguration where both 'local_sender_retain' and 'local_from_check' flags are set simultaneously. The severity score should be higher as this misconfiguration can lead to security vulnerabilities and unexpected behavior. The correctness score is high as the vulnerability is clearly present in the code. The profitability score should be high as attackers can exploit this misconfiguration to bypass sender verification checks.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The code allows for a configuration where both 'local_sender_retain' and 'local_from_check' flags are set simultaneously. This configuration is not allowed and can lead to unexpected behavior or security vulnerabilities. An attacker could potentially exploit this misconfiguration to bypass sender verification checks and spoof email addresses, leading to phishing attacks or unauthorized email sending.",
        "code": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  \n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  \n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  \n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  \n  config_file = Ufopen(filename, \"rb\");\n  #endif\n  if (config_file != NULL || errno != ENOENT) break;\n  }\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n  if ((statbuf.st_uid != root_uid                \n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           \n       #endif\n         ) ||                                    \n      (statbuf.st_gid != root_gid                \n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           \n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       \n      ((statbuf.st_mode & 2) != 0))              \n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\nfreeze_tell_config = freeze_tell;\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n  primary_hostname = string_copy(hostname);\n  }\nsmtp_active_hostname = primary_hostname;\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       \n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n  log_file_path = s;\n  }\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n#ifdef SUPPORT_TLS\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "file_name": "200157.sol"
    },
    {
        "function_name": "readconf_main",
        "vulnerability": "Misconfiguration Handling",
        "criticism": "The reasoning provided for this vulnerability is accurate as the code enforces a requirement that 'smtp_accept_max' must be set if certain conditions are met. Failure to adhere to this requirement can lead to potential denial of service attacks. The severity score should be higher as misconfigurations can have serious consequences. The correctness score is high as the vulnerability is clearly present in the code. The profitability score should be high as attackers can exploit this misconfiguration to disrupt email services.",
        "correctness": 9,
        "severity": 8,
        "profitability": 8,
        "reason": "The code enforces a requirement that 'smtp_accept_max' must be set if either 'smtp_accept_queue' is greater than 0 or 'smtp_accept_max_per_host' is not NULL. Failure to adhere to this requirement can lead to potential denial of service (DoS) attacks by overwhelming the system with incoming connections. An attacker could exploit this misconfiguration to exhaust server resources and disrupt normal email services.",
        "code": "readconf_main(void)\n{\nint sep = 0;\nstruct stat statbuf;\nuschar *s, *filename;\nuschar *list = config_main_filelist;\nwhile((filename = string_nextinlist(&list, &sep, big_buffer, big_buffer_size))\n       != NULL)\n  {\n  #if defined(CONFIGURE_FILE_USE_NODE) || defined(CONFIGURE_FILE_USE_EUID)\n  uschar *suffix = filename + Ustrlen(filename);\n  #ifdef CONFIGURE_FILE_USE_NODE\n  struct utsname uts;\n  if (uname(&uts) >= 0)\n    {\n    #ifdef CONFIGURE_FILE_USE_EUID\n    sprintf(CS suffix, \".%ld.%.256s\", (long int)original_euid, uts.nodename);\n    config_file = Ufopen(filename, \"rb\");\n    if (config_file == NULL)\n    #endif  \n      {\n      sprintf(CS suffix, \".%.256s\", uts.nodename);\n      config_file = Ufopen(filename, \"rb\");\n      }\n    }\n  #endif  \n  #ifdef CONFIGURE_FILE_USE_EUID\n  if (config_file == NULL)\n    {\n    sprintf(CS suffix, \".%ld\", (long int)original_euid);\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #endif  \n  if (config_file == NULL)\n    {\n    *suffix = 0;\n    config_file = Ufopen(filename, \"rb\");\n    }\n  #else  \n  config_file = Ufopen(filename, \"rb\");\n  #endif\n  if (config_file != NULL || errno != ENOENT) break;\n  }\nif (config_file != NULL)\n  {\n  config_filename = config_main_filename = string_copy(filename);\n  }\nelse\n  {\n  if (filename == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"non-existent configuration file(s): \"\n      \"%s\", config_main_filelist);\n  else\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"%s\", string_open_failed(errno,\n      \"configuration file %s\", filename));\n  }\nif (!config_changed)\n  {\n  if (fstat(fileno(config_file), &statbuf) != 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to stat configuration file %s\",\n      big_buffer);\n  if ((statbuf.st_uid != root_uid                \n       #ifdef CONFIGURE_OWNER\n       && statbuf.st_uid != config_uid           \n       #endif\n         ) ||                                    \n      (statbuf.st_gid != root_gid                \n       #ifdef CONFIGURE_GROUP\n       && statbuf.st_gid != config_gid           \n       #endif\n       && (statbuf.st_mode & 020) != 0) ||       \n      ((statbuf.st_mode & 2) != 0))              \n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Exim configuration file %s has the \"\n      \"wrong owner, group, or mode\", big_buffer);\n  }\nwhile ((s = get_config_line()) != NULL)\n  {\n  if (isupper(s[0])) read_macro_assignment(s);\n  else if (Ustrncmp(s, \"domainlist\", 10) == 0)\n    read_named_list(&domainlist_anchor, &domainlist_count,\n      MAX_NAMED_LIST, s+10, US\"domain list\");\n  else if (Ustrncmp(s, \"hostlist\", 8) == 0)\n    read_named_list(&hostlist_anchor, &hostlist_count,\n      MAX_NAMED_LIST, s+8, US\"host list\");\n  else if (Ustrncmp(s, US\"addresslist\", 11) == 0)\n    read_named_list(&addresslist_anchor, &addresslist_count,\n      MAX_NAMED_LIST, s+11, US\"address list\");\n  else if (Ustrncmp(s, US\"localpartlist\", 13) == 0)\n    read_named_list(&localpartlist_anchor, &localpartlist_count,\n      MAX_NAMED_LIST, s+13, US\"local part list\");\n  else\n    (void) readconf_handle_option(s, optionlist_config, optionlist_config_size,\n      NULL, US\"main option \\\"%s\\\" unknown\");\n  }\nif (local_sender_retain && local_from_check)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"both local_from_check and \"\n    \"local_sender_retain are set; this combination is not allowed\");\nif (timezone_string != NULL && *timezone_string == 0) timezone_string = NULL;\nif (retry_interval_max > 24*60*60) retry_interval_max = 24*60*60;\nif (remote_max_parallel <= 0) remote_max_parallel = 1;\nfreeze_tell_config = freeze_tell;\nif (primary_hostname == NULL)\n  {\n  uschar *hostname;\n  struct utsname uts;\n  if (uname(&uts) < 0)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"uname() failed to yield host name\");\n  hostname = US uts.nodename;\n  if (Ustrchr(hostname, '.') == NULL)\n    {\n    int af = AF_INET;\n    struct hostent *hostdata;\n    #if HAVE_IPV6\n    if (!disable_ipv6 && (dns_ipv4_lookup == NULL ||\n         match_isinlist(hostname, &dns_ipv4_lookup, 0, NULL, NULL, MCL_DOMAIN,\n           TRUE, NULL) != OK))\n      af = AF_INET6;\n    #else\n    af = AF_INET;\n    #endif\n    for (;;)\n      {\n      #if HAVE_IPV6\n        #if HAVE_GETIPNODEBYNAME\n        int error_num;\n        hostdata = getipnodebyname(CS hostname, af, 0, &error_num);\n        #else\n        hostdata = gethostbyname2(CS hostname, af);\n        #endif\n      #else\n      hostdata = gethostbyname(CS hostname);\n      #endif\n      if (hostdata != NULL)\n        {\n        hostname = US hostdata->h_name;\n        break;\n        }\n      if (af == AF_INET) break;\n      af = AF_INET;\n      }\n    }\n  primary_hostname = string_copy(hostname);\n  }\nsmtp_active_hostname = primary_hostname;\nif (*spool_directory == 0)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"spool_directory undefined: cannot \"\n    \"proceed\");\ns = expand_string(spool_directory);\nif (s == NULL)\n  log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand spool_directory \"\n    \"\\\"%s\\\": %s\", spool_directory, expand_string_message);\nspool_directory = s;\nif (*log_file_path != 0)\n  {\n  uschar *ss, *sss;\n  int sep = ':';                       \n  s = expand_string(log_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand log_file_path \"\n      \"\\\"%s\\\": %s\", log_file_path, expand_string_message);\n  ss = s;\n  while ((sss = string_nextinlist(&ss,&sep,big_buffer,big_buffer_size)) != NULL)\n    {\n    uschar *t;\n    if (sss[0] == 0 || Ustrcmp(sss, \"syslog\") == 0) continue;\n    t = Ustrstr(sss, \"%s\");\n    if (t == NULL)\n      log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" does not \"\n        \"contain \\\"%%s\\\"\", sss);\n    *t = 'X';\n    t = Ustrchr(sss, '%');\n    if (t != NULL)\n      {\n      if (t[1] != 'D' || Ustrchr(t+2, '%') != NULL)\n        log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"log_file_path \\\"%s\\\" contains \"\n          \"unexpected \\\"%%\\\" character\", s);\n      }\n    }\n  log_file_path = s;\n  }\nif (syslog_facility_str != NULL)\n  {\n  int i;\n  uschar *s = syslog_facility_str;\n  if ((Ustrlen(syslog_facility_str) >= 4) &&\n        (strncmpic(syslog_facility_str, US\"log_\", 4) == 0))\n    s += 4;\n  for (i = 0; i < syslog_list_size; i++)\n    {\n    if (strcmpic(s, syslog_list[i].name) == 0)\n      {\n      syslog_facility = syslog_list[i].value;\n      break;\n      }\n    }\n  if (i >= syslog_list_size)\n    {\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"failed to interpret syslog_facility \\\"%s\\\"\", syslog_facility_str);\n    }\n  }\nif (*pid_file_path != 0)\n  {\n  s = expand_string(pid_file_path);\n  if (s == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"failed to expand pid_file_path \"\n      \"\\\"%s\\\": %s\", pid_file_path, expand_string_message);\n  pid_file_path = s;\n  }\nregex_From = regex_must_compile(uucp_from_pattern, FALSE, TRUE);\nif (smtp_ratelimit_mail != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_mail, &smtp_rlm_threshold,\n    &smtp_rlm_base, &smtp_rlm_factor, &smtp_rlm_limit);\n  }\nif (smtp_ratelimit_rcpt != NULL)\n  {\n  unpick_ratelimit(smtp_ratelimit_rcpt, &smtp_rlr_threshold,\n    &smtp_rlr_base, &smtp_rlr_factor, &smtp_rlr_limit);\n  }\nif (qualify_domain_sender == NULL)\n  qualify_domain_sender = primary_hostname;\nif (qualify_domain_recipient == NULL)\n  qualify_domain_recipient = qualify_domain_sender;\nif (system_filter_uid_set && !system_filter_gid_set)\n  {\n  struct passwd *pw = getpwuid(system_filter_uid);\n  if (pw == NULL)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Failed to look up uid %ld\",\n      (long int)system_filter_uid);\n  system_filter_gid = pw->pw_gid;\n  system_filter_gid_set = TRUE;\n  }\nif (errors_reply_to != NULL)\n  {\n  uschar *errmess;\n  int start, end, domain;\n  uschar *recipient = parse_extract_address(errors_reply_to, &errmess,\n    &start, &end, &domain, FALSE);\n  if (recipient == NULL)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"error in errors_reply_to (%s): %s\", errors_reply_to, errmess);\n  if (domain == 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"errors_reply_to (%s) does not contain a domain\", errors_reply_to);\n  }\nif (smtp_accept_max == 0 &&\n    (smtp_accept_queue > 0 || smtp_accept_max_per_host != NULL))\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"smtp_accept_max must be set if smtp_accept_queue or \"\n    \"smtp_accept_max_per_host is set\");\nif (host_number_string != NULL)\n  {\n  uschar *end;\n  uschar *s = expand_string(host_number_string);\n  long int n = Ustrtol(s, &end, 0);\n  while (isspace(*end)) end++;\n  if (*end != 0)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number value is not a number: %s\", s);\n  if (n > LOCALHOST_MAX)\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"localhost_number is greater than the maximum allowed value (%d)\",\n        LOCALHOST_MAX);\n  host_number = n;\n  }\n#ifdef SUPPORT_TLS\nif ((tls_verify_hosts != NULL || tls_try_verify_hosts != NULL) &&\n     tls_verify_certificates == NULL)\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"tls_%sverify_hosts is set, but tls_verify_certificates is not set\",\n    (tls_verify_hosts != NULL)? \"\" : \"try_\");\nif (openssl_options != NULL)\n  {\n# ifdef USE_GNUTLS\n  log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n    \"openssl_options is set but we're using GnuTLS\");\n# else\n  long dummy;\n  if (!(tls_openssl_options_parse(openssl_options, &dummy)))\n    log_write(0, LOG_PANIC_DIE|LOG_CONFIG,\n      \"openssl_options parse error: %s\", openssl_options);\n# endif\n  }\n#endif\n}",
        "file_name": "200157.sol"
    }
]