[
    {
        "function_name": "read_bitmap_file_data",
        "code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t\n\tchar line[MAX_SIZE];\t\t\n\tint size;\t\t\t\n\tchar name_and_type[MAX_SIZE];\t\n\tchar *type;\t\t\t\n\tint value;\t\t\t\n\tint version10p;\t\t\t\n\tint padding;\t\t\t\n\tint bytes_per_line;\t\t\n\tguint ww = 0;\t\t\t\n\tguint hh = 0;\t\t\t\n\tint hx = -1;\t\t\t\n\tint hy = -1;\t\t\t\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n#define\tRETURN(code) { g_free (bits); return code; }\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) \n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (!bits)\n\t\tRETURN (FALSE);\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\treturn TRUE;\n}",
        "vulnerability": "Potential Buffer Overflow",
        "reason": "The check for the line length being 'MAX_SIZE-1' is intended to detect lines that have been truncated because they are too long for the buffer, 'line', to hold. However, it does not prevent the possibility of a buffer overflow on the 'fgets' call itself if 'MAX_SIZE' is reached. If a line in the file is exactly 'MAX_SIZE' characters long, 'fgets' will not null-terminate the buffer, leading to potential buffer overflow vulnerabilities when using string functions that rely on null termination.",
        "file_name": "448584.sol"
    },
    {
        "function_name": "read_bitmap_file_data",
        "code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t\n\tchar line[MAX_SIZE];\t\t\n\tint size;\t\t\t\n\tchar name_and_type[MAX_SIZE];\t\n\tchar *type;\t\t\t\n\tint value;\t\t\t\n\tint version10p;\t\t\t\n\tint padding;\t\t\t\n\tint bytes_per_line;\t\t\n\tguint ww = 0;\t\t\t\n\tguint hh = 0;\t\t\t\n\tint hx = -1;\t\t\t\n\tint hy = -1;\t\t\t\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n#define\tRETURN(code) { g_free (bits); return code; }\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) \n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (!bits)\n\t\tRETURN (FALSE);\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\treturn TRUE;\n}",
        "vulnerability": "Integer Overflow Leading to Insufficient Memory Allocation",
        "reason": "The calculation for 'size' as 'bytes_per_line * hh' can result in an integer overflow if 'hh' is large enough. If an overflow occurs, the allocated memory for 'bits' will be smaller than intended, leading to subsequent buffer overflows when writing to 'bits'. This can be exploited by an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution.",
        "file_name": "448584.sol"
    },
    {
        "function_name": "read_bitmap_file_data",
        "code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t\n\tchar line[MAX_SIZE];\t\t\n\tint size;\t\t\t\n\tchar name_and_type[MAX_SIZE];\t\n\tchar *type;\t\t\t\n\tint value;\t\t\t\n\tint version10p;\t\t\t\n\tint padding;\t\t\t\n\tint bytes_per_line;\t\t\n\tguint ww = 0;\t\t\t\n\tguint hh = 0;\t\t\t\n\tint hx = -1;\t\t\t\n\tint hy = -1;\t\t\t\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n#define\tRETURN(code) { g_free (bits); return code; }\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) \n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (!bits)\n\t\tRETURN (FALSE);\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\treturn TRUE;\n}",
        "vulnerability": "Unchecked Value Assignment to Unsigned Char",
        "reason": "The 'next_int' function is assumed to return an integer, which is then directly assigned to an unsigned char pointer '*ptr'. If 'next_int' returns a value larger than 255 or less than 0, it can lead to incorrect data being written to memory, potentially corrupting the bitmap data or leading to unexpected behavior. This can be exploited if 'next_int' can be influenced by controlled input to return out-of-bound values.",
        "file_name": "448584.sol"
    },
    {
        "function_name": "read_bitmap_file_data",
        "code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t\n\tchar line[MAX_SIZE];\t\t\n\tint size;\t\t\t\n\tchar name_and_type[MAX_SIZE];\t\n\tchar *type;\t\t\t\n\tint value;\t\t\t\n\tint version10p;\t\t\t\n\tint padding;\t\t\t\n\tint bytes_per_line;\t\t\n\tguint ww = 0;\t\t\t\n\tguint hh = 0;\t\t\t\n\tint hx = -1;\t\t\t\n\tint hy = -1;\t\t\t\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n#define\tRETURN(code) { g_free (bits); return code; }\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) \n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (!bits)\n\t\tRETURN (FALSE);\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\treturn TRUE;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The width and height values are being assigned to unsigned integers without checking for potential overflow after the sscanf operation. If a large value is provided, it could wrap around to a small positive value, potentially leading to insufficient memory allocation and subsequent buffer overflow.",
        "file_name": "448584.sol"
    },
    {
        "function_name": "read_bitmap_file_data",
        "code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t\n\tchar line[MAX_SIZE];\t\t\n\tint size;\t\t\t\n\tchar name_and_type[MAX_SIZE];\t\n\tchar *type;\t\t\t\n\tint value;\t\t\t\n\tint version10p;\t\t\t\n\tint padding;\t\t\t\n\tint bytes_per_line;\t\t\n\tguint ww = 0;\t\t\t\n\tguint hh = 0;\t\t\t\n\tint hx = -1;\t\t\t\n\tint hy = -1;\t\t\t\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n#define\tRETURN(code) { g_free (bits); return code; }\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) \n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (!bits)\n\t\tRETURN (FALSE);\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\treturn TRUE;\n}",
        "vulnerability": "Unchecked Memory Allocation",
        "reason": "The function allocates memory based on the 'size' variable calculated from user-controlled dimensions without checking if the allocation was successful. If the allocation fails due to a large 'size', it would result in a NULL pointer dereference when accessing 'bits'. This could lead to a crash or be exploited to execute arbitrary code.",
        "file_name": "448584.sol"
    },
    {
        "function_name": "read_bitmap_file_data",
        "code": "read_bitmap_file_data (FILE    *fstream,\n\t\t       guint   *width, \n\t\t       guint   *height,\n\t\t       guchar **data,\n\t\t       int     *x_hot, \n\t\t       int     *y_hot)\n{\n\tguchar *bits = NULL;\t\t\n\tchar line[MAX_SIZE];\t\t\n\tint size;\t\t\t\n\tchar name_and_type[MAX_SIZE];\t\n\tchar *type;\t\t\t\n\tint value;\t\t\t\n\tint version10p;\t\t\t\n\tint padding;\t\t\t\n\tint bytes_per_line;\t\t\n\tguint ww = 0;\t\t\t\n\tguint hh = 0;\t\t\t\n\tint hx = -1;\t\t\t\n\tint hy = -1;\t\t\t\n\tif (!initialized) {\n\t\tinit_hex_table ();\n\t}\n#define\tRETURN(code) { g_free (bits); return code; }\n\twhile (fgets (line, MAX_SIZE, fstream)) {\n\t\tif (strlen (line) == MAX_SIZE-1)\n\t\t\tRETURN (FALSE);\n\t\tif (sscanf (line,\"#define %s %d\",name_and_type,&value) == 2) {\n\t\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\t\ttype = name_and_type;\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t}\n\t\t\tif (!strcmp (\"width\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\tww = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"height\", type)) {\n                                if (value <= 0)\n                                        RETURN (FALSE);\n\t\t\t\thh = (unsigned int) value;\n                        }\n\t\t\tif (!strcmp (\"hot\", type)) {\n\t\t\t\tif (type-- == name_and_type\n\t\t\t\t    || type-- == name_and_type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!strcmp (\"x_hot\", type))\n\t\t\t\t\thx = value;\n\t\t\t\tif (!strcmp (\"y_hot\", type))\n\t\t\t\t\thy = value;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (sscanf (line, \"static short %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 1;\n\t\telse if (sscanf (line,\"static const unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line,\"static unsigned char %s = {\",name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static const char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse if (sscanf (line, \"static char %s = {\", name_and_type) == 1)\n\t\t\tversion10p = 0;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(type = strrchr (name_and_type, '_')))\n\t\t\ttype = name_and_type;\n\t\telse\n\t\t\ttype++;\n\t\tif (strcmp (\"bits[]\", type))\n\t\t\tcontinue;\n\t\tif (!ww || !hh)\n\t\t\tRETURN (FALSE);\n\t\tif ((ww % 16) && ((ww % 16) < 9) && version10p)\n\t\t\tpadding = 1;\n\t\telse\n\t\t\tpadding = 0;\n\t\tbytes_per_line = (ww+7)/8 + padding;\n\t\tsize = bytes_per_line * hh;\n                if (size / bytes_per_line != hh) \n                        RETURN (FALSE);\n\t\tbits = g_malloc (size);\n\t\tif (version10p) {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; (bytes += 2)) {\n\t\t\t\tif ((value = next_int (fstream)) < 0)\n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*(ptr++) = value;\n\t\t\t\tif (!padding || ((bytes+2) % bytes_per_line))\n\t\t\t\t\t*(ptr++) = value >> 8;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned char *ptr;\n\t\t\tint bytes;\n\t\t\tfor (bytes = 0, ptr = bits; bytes < size; bytes++, ptr++) {\n\t\t\t\tif ((value = next_int (fstream)) < 0) \n\t\t\t\t\tRETURN (FALSE);\n\t\t\t\t*ptr=value;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tif (!bits)\n\t\tRETURN (FALSE);\n\t*data = bits;\n\t*width = ww;\n\t*height = hh;\n\tif (x_hot)\n\t\t*x_hot = hx;\n\tif (y_hot)\n\t\t*y_hot = hy;\n\treturn TRUE;\n}",
        "vulnerability": "Potential Buffer Overflow",
        "reason": "The code checks if the line length equals MAX_SIZE-1, returning FALSE if so, but this check isn't sufficient to prevent buffer overflows. fgets reads at most MAX_SIZE-1 characters, leaving room for the null terminator. However, if a line equals MAX_SIZE-1 characters without a newline, it could lead to logic errors or buffer overflows elsewhere in the function.",
        "file_name": "448584.sol"
    }
]