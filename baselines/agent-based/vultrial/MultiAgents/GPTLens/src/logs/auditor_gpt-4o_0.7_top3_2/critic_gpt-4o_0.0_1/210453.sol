[
    {
        "function_name": "jetp3852_print_page",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The reasoning suggests that 'line_size' could overflow, but 'line_size' is an integer, and the check 'line_size > DATA_SIZE' is in place to prevent any overflow from affecting the buffer size. The function 'gdev_mem_bytes_per_scan_line' would need to be examined to determine if it can return values that cause overflow. Without evidence of such behavior, the reasoning lacks support. Additionally, the code already checks if 'line_size' exceeds 'DATA_SIZE', which mitigates the risk of buffer overflow. Therefore, the correctness of the reasoning is low.",
        "correctness": 3,
        "severity": 2,
        "profitability": 1,
        "reason": "The calculation of 'line_size' using 'gdev_mem_bytes_per_scan_line' may result in an integer overflow if the parameters are not properly controlled. This overflow can bypass the condition 'line_size > DATA_SIZE', potentially allowing attackers to manipulate the 'line_size' variable and cause a buffer overflow during the 'gdev_prn_copy_scan_lines' operation.",
        "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n    gp_fputs(\"\\033@\",prn_stream);\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n                memset(end_data, 0, 7);\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { \n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                if ( num_blank_lines > 0 ) {\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n    gp_fputs(\"\\014\", prn_stream);\n    return 0;\n}",
        "file_name": "210453.sol"
    },
    {
        "function_name": "jetp3852_print_page",
        "vulnerability": "Improper Handling of Large Values",
        "criticism": "The reasoning correctly identifies that handling a large number of blank lines could lead to resource exhaustion. However, the impact is limited to excessive printing commands, which is more of a performance issue than a security vulnerability. The function does not directly lead to a denial of service in a typical security context, as it does not crash or corrupt memory. The reasoning is partially correct but overstates the severity.",
        "correctness": 6,
        "severity": 3,
        "profitability": 2,
        "reason": "The loop that handles 'num_blank_lines' reduces it by 255 but does not validate whether decrementing or printing large numbers of blank lines could result in resource exhaustion or a denial of service. An attacker might exploit this by crafting input that results in a high number of blank lines, leading to excessive resource consumption and potential denial of service.",
        "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n    gp_fputs(\"\\033@\",prn_stream);\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n                memset(end_data, 0, 7);\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { \n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                if ( num_blank_lines > 0 ) {\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n    gp_fputs(\"\\014\", prn_stream);\n    return 0;\n}",
        "file_name": "210453.sol"
    },
    {
        "function_name": "jetp3852_print_page",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning suggests a buffer overflow due to 'line_size_color_plane' exceeding bounds, but 'line_size_color_plane' is derived from 'line_size', which is checked against 'DATA_SIZE'. The loop iterating over 'plane_data' is controlled by 'line_size_color_plane', which is calculated based on 'line_size'. The reasoning does not account for the checks already in place, making the correctness of the reasoning low.",
        "correctness": 3,
        "severity": 2,
        "profitability": 1,
        "reason": "The loop that performs bitwise NOT operations on 'plane_data' does not check for boundary conditions on 'line_size_color_plane'. If 'line_size_color_plane' exceeds the actual allocated bounds of 'plane_data', it can lead to buffer overflow. An attacker could exploit this by supplying crafted input size, causing data corruption, potential code execution, or denial of service.",
        "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n    gp_fputs(\"\\033@\",prn_stream);\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n                memset(end_data, 0, 7);\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { \n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                if ( num_blank_lines > 0 ) {\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n    gp_fputs(\"\\014\", prn_stream);\n    return 0;\n}",
        "file_name": "210453.sol"
    },
    {
        "function_name": "jetp3852_print_page",
        "vulnerability": "Buffer overflow",
        "criticism": "The reasoning points out a potential buffer overflow due to 'odp' indexing into 'plane_data'. However, 'odp' is incremented in a controlled manner within the bounds of 'plane_data', as 'i' is incremented by 8 and 'odp' is incremented by 1. The loop is controlled by 'DATA_SIZE', which is a multiple of 'LINE_SIZE'. The reasoning does not consider these constraints, making the correctness low.",
        "correctness": 3,
        "severity": 2,
        "profitability": 1,
        "reason": "The use of 'odp' to index into 'plane_data' without bounds checking could lead to a buffer overflow if 'i' exceeds the allocated size of 'plane_data'. This can be exploited by an attacker to execute arbitrary code.",
        "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n    gp_fputs(\"\\033@\",prn_stream);\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n                memset(end_data, 0, 7);\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { \n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                if ( num_blank_lines > 0 ) {\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n    gp_fputs(\"\\014\", prn_stream);\n    return 0;\n}",
        "file_name": "210453.sol"
    },
    {
        "function_name": "jetp3852_print_page",
        "vulnerability": "Integer overflow",
        "criticism": "The reasoning suggests an integer overflow in 'cnt_2prn', but 'cnt_2prn' is derived from 'line_size_color_plane', which is calculated from 'line_size'. Since 'line_size' is checked against 'DATA_SIZE', the risk of overflow is minimal. The reasoning does not provide sufficient evidence of how an overflow could occur, making the correctness low.",
        "correctness": 3,
        "severity": 2,
        "profitability": 1,
        "reason": "The calculation of 'cnt_2prn' and subsequent operations can lead to an integer overflow, especially if 'line_size' is large, which may result in incorrect memory allocation or data corruption, potentially leading to security vulnerabilities.",
        "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n    gp_fputs(\"\\033@\",prn_stream);\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n                memset(end_data, 0, 7);\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { \n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                if ( num_blank_lines > 0 ) {\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n    gp_fputs(\"\\014\", prn_stream);\n    return 0;\n}",
        "file_name": "210453.sol"
    },
    {
        "function_name": "jetp3852_print_page",
        "vulnerability": "Out-of-bounds write",
        "criticism": "The reasoning correctly identifies a potential out-of-bounds write with 'memset' on 'end_data'. If 'end_data' is close to the start of 'data', writing 7 bytes could exceed the buffer. This is a valid concern, as the code does not check the distance from 'end_data' to the start of 'data'. The reasoning is accurate, and the vulnerability could lead to memory corruption.",
        "correctness": 8,
        "severity": 7,
        "profitability": 5,
        "reason": "The usage of 'memset' with a size of 7 on 'end_data' assumes there is enough space in 'data' to zero out 7 bytes, which may not be true if 'end_data' is close to the start of 'data', leading to out-of-bounds writes.",
        "code": "jetp3852_print_page(gx_device_printer *pdev, gp_file *prn_stream)\n{\n#define DATA_SIZE (LINE_SIZE * 8)\n    unsigned int cnt_2prn;\n    unsigned int count,tempcnt;\n    unsigned char vtp,cntc1,cntc2;\n    int line_size_color_plane;\n    byte data[DATA_SIZE];\n    byte plane_data[LINE_SIZE * 3];\n    gp_fputs(\"\\033@\",prn_stream);\n    {\n        int lnum;\n        int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev);\n        int num_blank_lines = 0;\n        if (line_size > DATA_SIZE) {\n            emprintf2(pdev->memory, \"invalid resolution and/or width gives line_size = %d, max. is %d\\n\",\n                      line_size, DATA_SIZE);\n            return_error(gs_error_rangecheck);\n        }\n        for ( lnum = 0; lnum < pdev->height; lnum++ ) {\n            byte *end_data = data + line_size;\n            gdev_prn_copy_scan_lines(pdev, lnum,\n                                     (byte *)data, line_size);\n            while ( end_data > data && end_data[-1] == 0 )\n                end_data--;\n            if ( end_data == data ) {\n                num_blank_lines++;\n            } else {\n                int i;\n                byte *odp;\n                byte *row;\n                memset(end_data, 0, 7);\n                for ( i = 0, odp = plane_data; i < DATA_SIZE;\n                      i += 8, odp++\n                    ) { \n#define spread3(c)\\\n { 0, c, c*0x100, c*0x101, c*0x10000L, c*0x10001L, c*0x10100L, c*0x10101L }\n                    static ulong spr40[8] = spread3(0x40);\n                    static ulong spr8[8] = spread3(8);\n                    static ulong spr2[8] = spread3(2);\n                    register byte *dp = data + i;\n                    register ulong pword =\n                                     (spr40[dp[0]] << 1) +\n                                     (spr40[dp[1]]) +\n                                     (spr40[dp[2]] >> 1) +\n                                     (spr8[dp[3]] << 1) +\n                                     (spr8[dp[4]]) +\n                                     (spr8[dp[5]] >> 1) +\n                                     (spr2[dp[6]]) +\n                                     (spr2[dp[7]] >> 1);\n                    odp[0] = (byte)(pword >> 16);\n                    odp[LINE_SIZE] = (byte)(pword >> 8);\n                    odp[LINE_SIZE*2] = (byte)(pword);\n                }\n                if ( num_blank_lines > 0 ) {\n                    while(num_blank_lines > 255) {\n                        gp_fputs(\"\\033e\\377\",prn_stream);\n                        num_blank_lines -= 255;\n                    }\n                    vtp = num_blank_lines;\n                    gp_fprintf(prn_stream,\"\\033e%c\",vtp);\n                    num_blank_lines = 0;\n                }\n                count = line_size / 3;\n                line_size_color_plane = count / 3;\n                cnt_2prn = line_size_color_plane * 3 + 5;\n                tempcnt = cnt_2prn;\n                cntc1 = (tempcnt & 0xFF00) >> 8;\n                cntc2 = (tempcnt & 0x00FF);\n                gp_fprintf(prn_stream, \"\\033[O%c%c\\200\\037\",cntc2,cntc1);\n                gp_fputc('\\000',prn_stream);\n                gp_fputs(\"\\124\\124\",prn_stream);\n                for ( row = plane_data + LINE_SIZE * 2, i = 0;\n                      i < 3; row -= LINE_SIZE, i++ ) {\n                    int jj;\n                    byte ctemp;\n                    odp = row;\n                    for (jj=0; jj< line_size_color_plane; jj++) {\n                        ctemp = *odp;\n                        *odp++ = ~ctemp;\n                    }\n                    gp_fwrite(row, sizeof(byte),\n                              line_size_color_plane, prn_stream);\n                }\n            }\n        }\n    }\n    gp_fputs(\"\\014\", prn_stream);\n    return 0;\n}",
        "file_name": "210453.sol"
    }
]