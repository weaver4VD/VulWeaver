[
    {
        "function_name": "SingleComponentLSScan::ParseMCU",
        "vulnerability": "Integer Underflow",
        "criticism": "The reasoning correctly identifies a potential integer underflow issue with the 'length' variable. However, the code does check if 'length' is greater than zero before entering the loop, which mitigates the risk of underflow to some extent. The vulnerability is plausible but not as severe as described. The potential for buffer overflow is also mentioned, but the reasoning does not fully explore the implications of this underflow leading to a buffer overflow.",
        "correctness": 7,
        "severity": 6,
        "profitability": 5,
        "reason": "The 'length' variable is decremented in a loop without checking if it can become negative. If 'run' is larger than 'length', this could cause 'length' to underflow, potentially leading to buffer overflows when '*lp++ = a << preshift;' is executed.",
        "code": "bool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; \n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  assert(m_ucCount == 1);\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  if (lines == 0)\n    return false;\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      do {\n        LONG a,b,c,d;   \n        LONG d1,d2,d3;  \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    \n        d2  = b - c;\n        d3  = c - a;\n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          while(run) {\n            UpdateContext(0,a);\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n          }\n          if (length) {\n            bool negative; \n            bool rtype;    \n            LONG errval;   \n            LONG merr;     \n            LONG rx;       \n            UBYTE k;       \n            GetContext(0,a,b,c,d);\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            k      = GolombParameter(rtype);\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            UpdateContext(0,rx);\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            UpdateState(rtype,errval);\n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; \n        } else {\n          UWORD ctxt;\n          bool  negative; \n          LONG  px;       \n          LONG  rx;       \n          LONG  errval;   \n          LONG  merr;     \n          UBYTE k;        \n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          ctxt   = Context(negative,d1,d2,d3); \n          px     = Predict(a,b,c);\n          px     = CorrectPrediction(ctxt,negative,px);\n          k      = GolombParameter(ctxt);\n          merr   = GolombDecode(k,m_lLimit);\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          UpdateState(ctxt,errval);\n          rx     = Reconstruct(negative,px,errval);\n          UpdateContext(0,rx);\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } \n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}",
        "file_name": "232287.sol"
    },
    {
        "function_name": "SingleComponentLSScan::ParseMCU",
        "vulnerability": "Logical Error with Loop Control",
        "criticism": "The reasoning highlights a potential issue with the 'lines' variable being decremented without bounds checking. However, the code does not directly set 'lines' to a negative value, and the decrement is controlled by the loop condition. The risk of an infinite loop is low unless there is a bug elsewhere in the code that sets 'lines' incorrectly. The severity and profitability are lower because the likelihood of this issue occurring is minimal.",
        "correctness": 6,
        "severity": 3,
        "profitability": 2,
        "reason": "The 'lines' variable is decremented in a loop without any bounds checking. If 'lines' is set to a negative value by mistake, or if 'HeightOf()' returns a negative value, this may lead to an infinite loop or unexpected behavior.",
        "code": "bool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; \n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  assert(m_ucCount == 1);\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  if (lines == 0)\n    return false;\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      do {\n        LONG a,b,c,d;   \n        LONG d1,d2,d3;  \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    \n        d2  = b - c;\n        d3  = c - a;\n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          while(run) {\n            UpdateContext(0,a);\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n          }\n          if (length) {\n            bool negative; \n            bool rtype;    \n            LONG errval;   \n            LONG merr;     \n            LONG rx;       \n            UBYTE k;       \n            GetContext(0,a,b,c,d);\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            k      = GolombParameter(rtype);\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            UpdateContext(0,rx);\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            UpdateState(rtype,errval);\n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; \n        } else {\n          UWORD ctxt;\n          bool  negative; \n          LONG  px;       \n          LONG  rx;       \n          LONG  errval;   \n          LONG  merr;     \n          UBYTE k;        \n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          ctxt   = Context(negative,d1,d2,d3); \n          px     = Predict(a,b,c);\n          px     = CorrectPrediction(ctxt,negative,px);\n          k      = GolombParameter(ctxt);\n          merr   = GolombDecode(k,m_lLimit);\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          UpdateState(ctxt,errval);\n          rx     = Reconstruct(negative,px,errval);\n          UpdateContext(0,rx);\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } \n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}",
        "file_name": "232287.sol"
    },
    {
        "function_name": "SingleComponentLSScan::ParseMCU",
        "vulnerability": "Unchecked Return Value",
        "criticism": "The reasoning correctly identifies that the return value of 'BeginReadMCU' is used to control the loop, but there is no handling for a false return value. This could lead to inconsistent states if 'BeginReadMCU' fails. However, the impact of this issue depends on the implementation of 'BeginReadMCU' and how critical its success is to the subsequent operations. The severity is moderate, and the profitability is low unless the function is critical to a larger system.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The return value of 'BeginReadMCU(m_Stream.ByteStreamOf())' is used to control the loop, but there is no check on what happens if this function returns false after some iterations. This could lead to inconsistent states or memory issues depending on what 'BeginReadMCU' is supposed to do.",
        "code": "bool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; \n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  assert(m_ucCount == 1);\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  if (lines == 0)\n    return false;\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      do {\n        LONG a,b,c,d;   \n        LONG d1,d2,d3;  \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    \n        d2  = b - c;\n        d3  = c - a;\n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          while(run) {\n            UpdateContext(0,a);\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n          }\n          if (length) {\n            bool negative; \n            bool rtype;    \n            LONG errval;   \n            LONG merr;     \n            LONG rx;       \n            UBYTE k;       \n            GetContext(0,a,b,c,d);\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            k      = GolombParameter(rtype);\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            UpdateContext(0,rx);\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            UpdateState(rtype,errval);\n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; \n        } else {\n          UWORD ctxt;\n          bool  negative; \n          LONG  px;       \n          LONG  rx;       \n          LONG  errval;   \n          LONG  merr;     \n          UBYTE k;        \n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          ctxt   = Context(negative,d1,d2,d3); \n          px     = Predict(a,b,c);\n          px     = CorrectPrediction(ctxt,negative,px);\n          k      = GolombParameter(ctxt);\n          merr   = GolombDecode(k,m_lLimit);\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          UpdateState(ctxt,errval);\n          rx     = Reconstruct(negative,px,errval);\n          UpdateContext(0,rx);\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } \n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}",
        "file_name": "232287.sol"
    },
    {
        "function_name": "SingleComponentLSScan::ParseMCU",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning correctly identifies the risk of buffer overflow due to pointer manipulation without bounds checking. The code does not appear to ensure that 'lp' stays within the bounds of 'line->m_pData', which could lead to memory corruption. This is a significant vulnerability with high severity and profitability, especially if exploited in a security context.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The code contains multiple loops that manipulate pointers (e.g., `*lp++ = ...` and `*lp = ...`). If the length of data read exceeds the allocated buffer size for `line->m_pData`, this could result in a buffer overflow, leading to potential memory corruption and security vulnerabilities. The code does not appear to check whether `lp` exceeds the bounds of the allocated memory for `line->m_pData`.",
        "code": "bool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; \n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  assert(m_ucCount == 1);\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  if (lines == 0)\n    return false;\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      do {\n        LONG a,b,c,d;   \n        LONG d1,d2,d3;  \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    \n        d2  = b - c;\n        d3  = c - a;\n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          while(run) {\n            UpdateContext(0,a);\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n          }\n          if (length) {\n            bool negative; \n            bool rtype;    \n            LONG errval;   \n            LONG merr;     \n            LONG rx;       \n            UBYTE k;       \n            GetContext(0,a,b,c,d);\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            k      = GolombParameter(rtype);\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            UpdateContext(0,rx);\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            UpdateState(rtype,errval);\n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; \n        } else {\n          UWORD ctxt;\n          bool  negative; \n          LONG  px;       \n          LONG  rx;       \n          LONG  errval;   \n          LONG  merr;     \n          UBYTE k;        \n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          ctxt   = Context(negative,d1,d2,d3); \n          px     = Predict(a,b,c);\n          px     = CorrectPrediction(ctxt,negative,px);\n          k      = GolombParameter(ctxt);\n          merr   = GolombDecode(k,m_lLimit);\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          UpdateState(ctxt,errval);\n          rx     = Reconstruct(negative,px,errval);\n          UpdateContext(0,rx);\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } \n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}",
        "file_name": "232287.sol"
    },
    {
        "function_name": "SingleComponentLSScan::ParseMCU",
        "vulnerability": "Integer Underflow",
        "criticism": "This reasoning is similar to the first vulnerability identified. The potential for 'length' to become negative is noted, but the code does check if 'length' is greater than zero before entering the loop. The risk of underflow is present but not as severe as described. The reasoning does not fully address the implications of this underflow leading to incorrect behavior.",
        "correctness": 7,
        "severity": 6,
        "profitability": 5,
        "reason": "The variable `length` is decremented in the loop (`length--`), and there does not appear to be a check to ensure that `length` remains non-negative. If `length` becomes negative, this could lead to incorrect behavior or attempts to access invalid memory locations.",
        "code": "bool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; \n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  assert(m_ucCount == 1);\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  if (lines == 0)\n    return false;\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      do {\n        LONG a,b,c,d;   \n        LONG d1,d2,d3;  \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    \n        d2  = b - c;\n        d3  = c - a;\n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          while(run) {\n            UpdateContext(0,a);\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n          }\n          if (length) {\n            bool negative; \n            bool rtype;    \n            LONG errval;   \n            LONG merr;     \n            LONG rx;       \n            UBYTE k;       \n            GetContext(0,a,b,c,d);\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            k      = GolombParameter(rtype);\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            UpdateContext(0,rx);\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            UpdateState(rtype,errval);\n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; \n        } else {\n          UWORD ctxt;\n          bool  negative; \n          LONG  px;       \n          LONG  rx;       \n          LONG  errval;   \n          LONG  merr;     \n          UBYTE k;        \n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          ctxt   = Context(negative,d1,d2,d3); \n          px     = Predict(a,b,c);\n          px     = CorrectPrediction(ctxt,negative,px);\n          k      = GolombParameter(ctxt);\n          merr   = GolombDecode(k,m_lLimit);\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          UpdateState(ctxt,errval);\n          rx     = Reconstruct(negative,px,errval);\n          UpdateContext(0,rx);\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } \n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}",
        "file_name": "232287.sol"
    },
    {
        "function_name": "SingleComponentLSScan::ParseMCU",
        "vulnerability": "Unchecked Return Value",
        "criticism": "The reasoning correctly identifies the lack of error handling for a false return value from 'BeginReadMCU'. This could lead to undefined behavior if the function fails. The severity and profitability depend on the criticality of 'BeginReadMCU' in the overall system. The reasoning is accurate, but the impact is context-dependent.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The function `BeginReadMCU` is called, and its return value is checked. However, the handling of the case where `BeginReadMCU` fails (returns false) is insufficient. The code inside the loop assumes successful execution without additional error handling. This could lead to undefined behavior if `BeginReadMCU` fails and subsequent operations are performed on uninitialized or invalid data.",
        "code": "bool SingleComponentLSScan::ParseMCU(void)\n{ \n#if ACCUSOFT_CODE\n  int lines             = m_ulRemaining[0]; \n  UBYTE preshift        = m_ucLowBit + FractionalColorBitsOf();\n  struct Line *line     = CurrentLine(0);\n  if (m_pFrame->HeightOf() == 0) {\n    assert(lines == 0);\n    lines = 8;\n  }\n  assert(m_ucCount == 1);\n  if (lines > 8) {\n    lines = 8;\n  }\n  if (m_pFrame->HeightOf() > 0)\n    m_ulRemaining[0] -= lines;\n  if (lines == 0)\n    return false;\n  do {\n    LONG length = m_ulWidth[0];\n    LONG *lp    = line->m_pData;\n#ifdef DEBUG_LS\n    int xpos    = 0;\n    static int linenumber = 0;\n    printf(\"\\n%4d : \",++linenumber);\n#endif\n    StartLine(0);\n    if (BeginReadMCU(m_Stream.ByteStreamOf())) { \n      do {\n        LONG a,b,c,d;   \n        LONG d1,d2,d3;  \n        GetContext(0,a,b,c,d);\n        d1  = d - b;    \n        d2  = b - c;\n        d3  = c - a;\n        if (isRunMode(d1,d2,d3)) {\n          LONG run = DecodeRun(length,m_lRunIndex[0]);\n          while(run) {\n            UpdateContext(0,a);\n            *lp++ = a << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,a);\n#endif\n            run--,length--;\n          }\n          if (length) {\n            bool negative; \n            bool rtype;    \n            LONG errval;   \n            LONG merr;     \n            LONG rx;       \n            UBYTE k;       \n            GetContext(0,a,b,c,d);\n            rtype  = InterruptedPredictionMode(negative,a,b);\n            k      = GolombParameter(rtype);\n            merr   = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1);\n            errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k));\n            rx     = Reconstruct(negative,rtype?a:b,errval);\n            UpdateContext(0,rx);\n            *lp    = rx << preshift;\n#ifdef DEBUG_LS\n            printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n            UpdateState(rtype,errval);\n            if (m_lRunIndex[0] > 0)\n              m_lRunIndex[0]--;\n          } else break; \n        } else {\n          UWORD ctxt;\n          bool  negative; \n          LONG  px;       \n          LONG  rx;       \n          LONG  errval;   \n          LONG  merr;     \n          UBYTE k;        \n          d1     = QuantizedGradient(d1);\n          d2     = QuantizedGradient(d2);\n          d3     = QuantizedGradient(d3);\n          ctxt   = Context(negative,d1,d2,d3); \n          px     = Predict(a,b,c);\n          px     = CorrectPrediction(ctxt,negative,px);\n          k      = GolombParameter(ctxt);\n          merr   = GolombDecode(k,m_lLimit);\n          errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k));\n          UpdateState(ctxt,errval);\n          rx     = Reconstruct(negative,px,errval);\n          UpdateContext(0,rx);\n          *lp    = rx << preshift;\n#ifdef DEBUG_LS\n          printf(\"%4d:<%2x> \",xpos++,*lp);\n#endif\n        }\n      } while(++lp,--length);\n    } \n    EndLine(0);\n    line = line->m_pNext;\n  } while(--lines); \n  m_Stream.SkipStuffing();\n#endif  \n  return false;\n}",
        "file_name": "232287.sol"
    }
]