[
    {
        "function_name": "main",
        "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tstatic const ul_excl_t excl[] = {       \n\t\t{ 'B','M','R',\t\t\t\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\tif (all) {\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\t} else if (argc == 1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_target(cxt, argv[0]);\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\t} else\n\t\tusage(stderr);\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\tif (oper) {\n\t\tmnt_context_set_mflags(cxt, oper);\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
        "vulnerability": "Format String Vulnerability",
        "reason": "The use of xasprintf with user-controlled input (optarg) can lead to a format string vulnerability if optarg contains format specifiers. An attacker can exploit this by providing a specially crafted input to read from or write to arbitrary memory locations, potentially leading to code execution.",
        "file_name": "406206.sol"
    },
    {
        "function_name": "main",
        "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tstatic const ul_excl_t excl[] = {       \n\t\t{ 'B','M','R',\t\t\t\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\tif (all) {\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\t} else if (argc == 1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_target(cxt, argv[0]);\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\t} else\n\t\tusage(stderr);\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\tif (oper) {\n\t\tmnt_context_set_mflags(cxt, oper);\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
        "vulnerability": "Unchecked Command Line Options",
        "reason": "The code processes command line options using getopt_long, but it lacks comprehensive validation for potentially dangerous inputs, especially for options like 'o', 'O', 'L', 'U', 'T', and 't'. An attacker could exploit this by injecting malicious input, possibly leading to unintended behaviors or security breaches.",
        "file_name": "406206.sol"
    },
    {
        "function_name": "main",
        "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tstatic const ul_excl_t excl[] = {       \n\t\t{ 'B','M','R',\t\t\t\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\tif (all) {\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\t} else if (argc == 1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_target(cxt, argv[0]);\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\t} else\n\t\tusage(stderr);\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\tif (oper) {\n\t\tmnt_context_set_mflags(cxt, oper);\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
        "vulnerability": "Improper Input Validation",
        "reason": "The code assigns argv elements directly to the context's source and target without proper validation or sanitization. This can be exploited if the inputs are not controlled or properly sanitized, potentially leading to directory traversal attacks or manipulation of filesystem mounts.",
        "file_name": "406206.sol"
    },
    {
        "function_name": "main",
        "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tstatic const ul_excl_t excl[] = {       \n\t\t{ 'B','M','R',\t\t\t\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\tif (all) {\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\t} else if (argc == 1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_target(cxt, argv[0]);\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\t} else\n\t\tusage(stderr);\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\tif (oper) {\n\t\tmnt_context_set_mflags(cxt, oper);\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
        "vulnerability": "Format String Vulnerability",
        "reason": "The xasprintf function is used to create a formatted string with user input (optarg) without proper sanitization, leading to a possible format string vulnerability. An attacker could provide malicious input to manipulate the format string, potentially leading to arbitrary code execution.",
        "file_name": "406206.sol"
    },
    {
        "function_name": "main",
        "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tstatic const ul_excl_t excl[] = {       \n\t\t{ 'B','M','R',\t\t\t\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\tif (all) {\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\t} else if (argc == 1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_target(cxt, argv[0]);\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\t} else\n\t\tusage(stderr);\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\tif (oper) {\n\t\tmnt_context_set_mflags(cxt, oper);\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
        "vulnerability": "Format String Vulnerability",
        "reason": "Similar to the previous case with 'LABEL', the xasprintf function is used here to format a string with user input (optarg) for UUID without sufficient sanitization. This could allow an attacker to exploit format string vulnerabilities, potentially executing arbitrary code.",
        "file_name": "406206.sol"
    },
    {
        "function_name": "main",
        "code": "int main(int argc, char **argv)\n{\n\tint c, rc = MOUNT_EX_SUCCESS, all = 0, show_labels = 0;\n\tstruct libmnt_context *cxt;\n\tstruct libmnt_table *fstab = NULL;\n\tchar *srcbuf = NULL;\n\tchar *types = NULL;\n\tunsigned long oper = 0;\n\tenum {\n\t\tMOUNT_OPT_SHARED = CHAR_MAX + 1,\n\t\tMOUNT_OPT_SLAVE,\n\t\tMOUNT_OPT_PRIVATE,\n\t\tMOUNT_OPT_UNBINDABLE,\n\t\tMOUNT_OPT_RSHARED,\n\t\tMOUNT_OPT_RSLAVE,\n\t\tMOUNT_OPT_RPRIVATE,\n\t\tMOUNT_OPT_RUNBINDABLE,\n\t\tMOUNT_OPT_TARGET,\n\t\tMOUNT_OPT_SOURCE\n\t};\n\tstatic const struct option longopts[] = {\n\t\t{ \"all\", 0, 0, 'a' },\n\t\t{ \"fake\", 0, 0, 'f' },\n\t\t{ \"fstab\", 1, 0, 'T' },\n\t\t{ \"fork\", 0, 0, 'F' },\n\t\t{ \"help\", 0, 0, 'h' },\n\t\t{ \"no-mtab\", 0, 0, 'n' },\n\t\t{ \"read-only\", 0, 0, 'r' },\n\t\t{ \"ro\", 0, 0, 'r' },\n\t\t{ \"verbose\", 0, 0, 'v' },\n\t\t{ \"version\", 0, 0, 'V' },\n\t\t{ \"read-write\", 0, 0, 'w' },\n\t\t{ \"rw\", 0, 0, 'w' },\n\t\t{ \"options\", 1, 0, 'o' },\n\t\t{ \"test-opts\", 1, 0, 'O' },\n\t\t{ \"pass-fd\", 1, 0, 'p' },\n\t\t{ \"types\", 1, 0, 't' },\n\t\t{ \"uuid\", 1, 0, 'U' },\n\t\t{ \"label\", 1, 0, 'L'},\n\t\t{ \"bind\", 0, 0, 'B' },\n\t\t{ \"move\", 0, 0, 'M' },\n\t\t{ \"rbind\", 0, 0, 'R' },\n\t\t{ \"make-shared\", 0, 0, MOUNT_OPT_SHARED },\n\t\t{ \"make-slave\", 0, 0, MOUNT_OPT_SLAVE },\n\t\t{ \"make-private\", 0, 0, MOUNT_OPT_PRIVATE },\n\t\t{ \"make-unbindable\", 0, 0, MOUNT_OPT_UNBINDABLE },\n\t\t{ \"make-rshared\", 0, 0, MOUNT_OPT_RSHARED },\n\t\t{ \"make-rslave\", 0, 0, MOUNT_OPT_RSLAVE },\n\t\t{ \"make-rprivate\", 0, 0, MOUNT_OPT_RPRIVATE },\n\t\t{ \"make-runbindable\", 0, 0, MOUNT_OPT_RUNBINDABLE },\n\t\t{ \"no-canonicalize\", 0, 0, 'c' },\n\t\t{ \"internal-only\", 0, 0, 'i' },\n\t\t{ \"show-labels\", 0, 0, 'l' },\n\t\t{ \"target\", 1, 0, MOUNT_OPT_TARGET },\n\t\t{ \"source\", 1, 0, MOUNT_OPT_SOURCE },\n\t\t{ NULL, 0, 0, 0 }\n\t};\n\tstatic const ul_excl_t excl[] = {       \n\t\t{ 'B','M','R',\t\t\t\n\t\t   MOUNT_OPT_SHARED,   MOUNT_OPT_SLAVE,\n\t\t   MOUNT_OPT_PRIVATE,  MOUNT_OPT_UNBINDABLE,\n\t\t   MOUNT_OPT_RSHARED,  MOUNT_OPT_RSLAVE,\n\t\t   MOUNT_OPT_RPRIVATE, MOUNT_OPT_RUNBINDABLE },\n\t\t{ 'L','U', MOUNT_OPT_SOURCE },\t\n\t\t{ 0 }\n\t};\n\tint excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT;\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tmnt_init_debug(0);\n\tcxt = mnt_new_context();\n\tif (!cxt)\n\t\terr(MOUNT_EX_SYSERR, _(\"libmount context allocation failed\"));\n\tmnt_context_set_tables_errcb(cxt, table_parser_errcb);\n\twhile ((c = getopt_long(argc, argv, \"aBcfFhilL:Mno:O:p:rRsU:vVwt:T:\",\n\t\t\t\t\tlongopts, NULL)) != -1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    !strchr(\"hlLUVvpris\", c) &&\n\t\t    c != MOUNT_OPT_TARGET &&\n\t\t    c != MOUNT_OPT_SOURCE)\n\t\t\texit_non_root(option_to_longopt(c, longopts));\n\t\terr_exclusive_options(c, longopts, excl, excl_st);\n\t\tswitch(c) {\n\t\tcase 'a':\n\t\t\tall = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tmnt_context_disable_canonicalize(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tmnt_context_enable_fake(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tmnt_context_enable_fork(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(stdout);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tmnt_context_disable_helpers(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tmnt_context_disable_mtab(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tif (mnt_context_append_options(cxt, \"ro\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tmnt_context_enable_verbose(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_version();\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tif (mnt_context_append_options(cxt, \"rw\"))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\treadwrite = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (mnt_context_append_options(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to append options\"));\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tif (mnt_context_set_options_pattern(cxt, optarg))\n\t\t\t\terr(MOUNT_EX_SYSERR, _(\"failed to set options pattern\"));\n\t\t\tbreak;\n\t\tcase 'p':\n                        warnx(_(\"--pass-fd is no longer supported\"));\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\txasprintf(&srcbuf, \"LABEL=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\txasprintf(&srcbuf, \"UUID=\\\"%s\\\"\", optarg);\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, srcbuf);\n\t\t\tfree(srcbuf);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tshow_labels = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttypes = optarg;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tfstab = append_fstab(cxt, fstab, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tmnt_context_enable_sloppy(cxt, TRUE);\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\toper |= MS_BIND;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\toper |= MS_MOVE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\toper |= (MS_BIND | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SHARED:\n\t\t\toper |= MS_SHARED;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SLAVE:\n\t\t\toper |= MS_SLAVE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_PRIVATE:\n\t\t\toper |= MS_PRIVATE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_UNBINDABLE:\n\t\t\toper |= MS_UNBINDABLE;\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSHARED:\n\t\t\toper |= (MS_SHARED | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RSLAVE:\n\t\t\toper |= (MS_SLAVE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RPRIVATE:\n\t\t\toper |= (MS_PRIVATE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_RUNBINDABLE:\n\t\t\toper |= (MS_UNBINDABLE | MS_REC);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_TARGET:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_target(cxt, optarg);\n\t\t\tbreak;\n\t\tcase MOUNT_OPT_SOURCE:\n\t\t\tmnt_context_disable_swapmatch(cxt, 1);\n\t\t\tmnt_context_set_source(cxt, optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t\tbreak;\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tif (fstab && !mnt_context_is_nocanonicalize(cxt)) {\n\t\tstruct libmnt_cache *cache = mnt_context_get_cache(cxt);\n\t\tmnt_table_set_cache(fstab, cache);\n\t}\n\tif (!mnt_context_get_source(cxt) &&\n\t    !mnt_context_get_target(cxt) &&\n\t    !argc &&\n\t    !all) {\n\t\tif (oper)\n\t\t\tusage(stderr);\n\t\tprint_all(cxt, types, show_labels);\n\t\tgoto done;\n\t}\n\tif (oper && (types || all || mnt_context_get_source(cxt)))\n\t\tusage(stderr);\n\tif (types && (all || strchr(types, ',') ||\n\t\t\t     strncmp(types, \"no\", 2) == 0))\n\t\tmnt_context_set_fstype_pattern(cxt, types);\n\telse if (types)\n\t\tmnt_context_set_fstype(cxt, types);\n\tif (all) {\n\t\trc = mount_all(cxt);\n\t\tgoto done;\n\t} else if (argc == 0 && (mnt_context_get_source(cxt) ||\n\t\t\t\t mnt_context_get_target(cxt))) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt) &&\n\t\t    mnt_context_get_target(cxt))\n\t\t\texit_non_root(NULL);\n\t} else if (argc == 1) {\n\t\tif (mnt_context_is_restricted(cxt) &&\n\t\t    mnt_context_get_source(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_target(cxt, argv[0]);\n\t} else if (argc == 2 && !mnt_context_get_source(cxt)\n\t\t\t     && !mnt_context_get_target(cxt)) {\n\t\tif (mnt_context_is_restricted(cxt))\n\t\t\texit_non_root(NULL);\n\t\tmnt_context_set_source(cxt, argv[0]);\n\t\tmnt_context_set_target(cxt, argv[1]);\n\t} else\n\t\tusage(stderr);\n\tif (mnt_context_is_restricted(cxt))\n\t\tsanitize_paths(cxt);\n\tif (oper) {\n\t\tmnt_context_set_mflags(cxt, oper);\n\t\tmnt_context_set_optsmode(cxt, MNT_OMODE_NOTAB);\n\t}\n\trc = mnt_context_mount(cxt);\n\trc = mk_exit_code(cxt, rc);\n\tif (rc == MOUNT_EX_SUCCESS && mnt_context_is_verbose(cxt))\n\t\tsuccess_message(cxt);\ndone:\n\tmnt_free_context(cxt);\n\tmnt_free_table(fstab);\n\treturn rc;\n}",
        "vulnerability": "Command Injection",
        "reason": "The 'optarg' retrieved from command line options is directly appended to context options using mnt_context_append_options without proper validation or sanitization. This could allow an attacker to inject malicious mount options that might lead to privilege escalation or other unintended behavior.",
        "file_name": "406206.sol"
    }
]