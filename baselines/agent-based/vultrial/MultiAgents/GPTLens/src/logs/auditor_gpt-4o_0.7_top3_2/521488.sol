[
    {
        "function_name": "ZipFile::uncompressEntry",
        "code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}",
        "vulnerability": "Directory traversal attack",
        "reason": "The code attempts to check if the extracted file is a child of the target directory. However, this check could be bypassed if the 'entryPath' contains path traversal characters like '../'. This could allow an attacker to extract files outside the intended directory, potentially overwriting critical system files or user data.",
        "file_name": "521488.sol"
    },
    {
        "function_name": "ZipFile::uncompressEntry",
        "code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}",
        "vulnerability": "Symbolic link attack",
        "reason": "The function creates symbolic links without adequate checks on the target or link destination. This might allow an attacker to create symbolic links to sensitive files or directories and manipulate the file system, potentially leading to privilege escalation or unauthorized data access.",
        "file_name": "521488.sol"
    },
    {
        "function_name": "ZipFile::uncompressEntry",
        "code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}",
        "vulnerability": "TOCTOU (Time of Check to Time of Use) race condition",
        "reason": "The code creates directories without ensuring that no malicious parties have altered the directory structure between the check and creation. An attacker could exploit this race condition to create a symlink between the check and creation, potentially leading to unauthorized file or directory manipulation.",
        "file_name": "521488.sol"
    },
    {
        "function_name": "ZipFile::uncompressEntry",
        "code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}",
        "vulnerability": "Directory traversal vulnerability",
        "reason": "The code attempts to prevent directory traversal attacks by checking if the target file is a child of the target directory. However, this check might be bypassed if symbolic links are involved or if there is a flaw in the isAChildOf implementation that fails to correctly validate all edge cases, leading to a potential directory traversal vulnerability that allows attackers to write files outside the intended directory.",
        "file_name": "521488.sol"
    },
    {
        "function_name": "ZipFile::uncompressEntry",
        "code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}",
        "vulnerability": "Insecure handling of symbolic links",
        "reason": "The code creates symbolic links if the entry is marked as a symbolic link. However, it does not sufficiently validate the symbolic link target (originalFilePath) before creation. This could allow an attacker to create symbolic links to sensitive files or directories, leading to potential privilege escalation or unauthorized access.",
        "file_name": "521488.sol"
    },
    {
        "function_name": "ZipFile::uncompressEntry",
        "code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (! targetFile.isAChildOf (targetDirectory))\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (overwriteFiles == OverwriteFiles::no)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}",
        "vulnerability": "Race condition vulnerability",
        "reason": "The code creates the parent directory if it does not exist without any further checks. This can lead to a race condition where an attacker could replace the directory with a symbolic link or another file type between the checks and the actual creation, potentially leading to unauthorized file writes or overwrites.",
        "file_name": "521488.sol"
    }
]