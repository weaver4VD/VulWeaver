[
    {
        "function_name": "write_entry",
        "code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n    annotate_begin(d);\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n    if (!value->len && !uid) {\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n    if (!mailbox)\n        sync_log_annotation(\"\");\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n    return r;\n}",
        "vulnerability": "Unchecked database creation",
        "reason": "The function `_annotate_getdb` is called with the `CYRUSDB_CREATE` flag, which could potentially create a new database if it doesn't already exist. If an attacker can control the parameters, they might be able to create or overwrite databases, leading to unauthorized data manipulation or privilege escalation.",
        "file_name": "463134.sol"
    },
    {
        "function_name": "write_entry",
        "code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n    annotate_begin(d);\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n    if (!value->len && !uid) {\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n    if (!mailbox)\n        sync_log_annotation(\"\");\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n    return r;\n}",
        "vulnerability": "Potential bypass of write permission check",
        "reason": "The code checks the `maywrite` flag to determine if writing is permitted. However, this check is insufficiently enforced because the result of `r` is immediately checked and `goto out` is executed, which might not properly prevent subsequent operations from executing depending on other conditions in the code.",
        "file_name": "463134.sol"
    },
    {
        "function_name": "write_entry",
        "code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n    annotate_begin(d);\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n    if (!value->len && !uid) {\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n    if (!mailbox)\n        sync_log_annotation(\"\");\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n    return r;\n}",
        "vulnerability": "Potential unauthorized deletion",
        "reason": "The code deletes an entry if `value->len` and `uid` are both zero, but it does not adequately verify if this operation is authorized. An attacker might exploit this condition to delete database entries without proper authorization, especially if they can influence the `value` and `uid` parameters.",
        "file_name": "463134.sol"
    },
    {
        "function_name": "write_entry",
        "code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n    annotate_begin(d);\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n    if (!value->len && !uid) {\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n    if (!mailbox)\n        sync_log_annotation(\"\");\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n    return r;\n}",
        "vulnerability": "Improper handling of database creation",
        "reason": "The function uses the flag CYRUSDB_CREATE when opening the database with _annotate_getdb, which might lead to the creation of a new database if one doesn't exist. This behavior could be exploited by an attacker to manipulate or create unexpected data stores, potentially leading to unauthorized data manipulation.",
        "file_name": "463134.sol"
    },
    {
        "function_name": "write_entry",
        "code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n    annotate_begin(d);\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n    if (!value->len && !uid) {\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n    if (!mailbox)\n        sync_log_annotation(\"\");\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n    return r;\n}",
        "vulnerability": "Insufficient access control",
        "reason": "This code block checks the maywrite flag to determine if the operation should proceed. If maywrite is false, it sets the error code but does not immediately return, instead checking r again before 'goto out'. This could result in improper permission handling if r is changed inadvertently, allowing unauthorized write operations.",
        "file_name": "463134.sol"
    },
    {
        "function_name": "write_entry",
        "code": "static int write_entry(struct mailbox *mailbox,\n                       unsigned int uid,\n                       const char *entry,\n                       const char *userid,\n                       const struct buf *value,\n                       int ignorequota,\n                       int silent,\n                       const struct annotate_metadata *mdata,\n                       int maywrite)\n{\n    char key[MAX_MAILBOX_PATH+1];\n    int keylen, r;\n    annotate_db_t *d = NULL;\n    struct buf oldval = BUF_INITIALIZER;\n    const char *mboxname = mailbox ? mailbox->name : \"\";\n    modseq_t modseq = mdata ? mdata->modseq : 0;\n    r = _annotate_getdb(mboxname, uid, CYRUSDB_CREATE, &d);\n    if (r)\n        return r;\n    annotate_begin(d);\n    keylen = make_key(mboxname, uid, entry, userid, key, sizeof(key));\n    struct annotate_metadata oldmdata;\n    r = read_old_value(d, key, keylen, &oldval, &oldmdata);\n    if (r) goto out;\n    if (oldval.len == value->len && (!value->len || !memcmp(oldval.s, value->s, value->len)))\n        goto out;\n    if (!maywrite) {\n        r = IMAP_PERMISSION_DENIED;\n        if (r) goto out;\n    }\n    if (mailbox) {\n        if (!ignorequota) {\n            quota_t qdiffs[QUOTA_NUMRESOURCES] = QUOTA_DIFFS_DONTCARE_INITIALIZER;\n            qdiffs[QUOTA_ANNOTSTORAGE] = value->len - (quota_t)oldval.len;\n            r = mailbox_quota_check(mailbox, qdiffs);\n            if (r) goto out;\n        }\n        mailbox_annot_changed(mailbox, uid, entry, userid, &oldval, value, silent);\n        if (uid && !mdata) {\n            modseq = mailbox->i.highestmodseq;\n        }\n    }\n    if (!value->len && !uid) {\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: deleting key %s from %s\",\n                key_as_string(d, key, keylen), d->filename);\n#endif\n        do {\n            r = cyrusdb_delete(d->db, key, keylen, tid(d), 1);\n        } while (r == CYRUSDB_AGAIN);\n    }\n    else {\n        struct buf data = BUF_INITIALIZER;\n        unsigned char flags = 0;\n        if (!value->len || value->s == NULL) {\n            flags |= ANNOTATE_FLAG_DELETED;\n        }\n        else {\n            if (!userid) goto out;\n        }\n        make_entry(&data, value, modseq, flags);\n#if DEBUG\n        syslog(LOG_ERR, \"write_entry: storing key %s (value: %s) to %s (modseq=\" MODSEQ_FMT \")\",\n                key_as_string(d, key, keylen), value->s, d->filename, modseq);\n#endif\n        do {\n            r = cyrusdb_store(d->db, key, keylen, data.s, data.len, tid(d));\n        } while (r == CYRUSDB_AGAIN);\n        buf_free(&data);\n    }\n    if (!mailbox)\n        sync_log_annotation(\"\");\nout:\n    annotate_putdb(&d);\n    buf_free(&oldval);\n    return r;\n}",
        "vulnerability": "Potential null pointer dereference",
        "reason": "There is a check for value->len or value->s being NULL before setting flags, but this assumes value is a valid pointer. If value itself is NULL, accessing value->len or value->s will lead to a null pointer dereference, causing a crash or undefined behavior.",
        "file_name": "463134.sol"
    }
]