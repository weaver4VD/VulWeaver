[
    {
        "function_name": "cookedprint",
        "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\tUNUSED_ARG(datatype);\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\t\tcase HA:\t\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "vulnerability": "format string vulnerability",
        "reason": "The use of snprintf with a fixed size buffer 'b' and variable 'uval' could be exploited if 'uval' contains user-controlled data that is not properly validated. This could lead to a buffer overflow or arbitrary code execution if an attacker controls 'uval' and the resulting format string.",
        "file_name": "211773.sol"
    },
    {
        "function_name": "cookedprint",
        "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\tUNUSED_ARG(datatype);\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\t\tcase HA:\t\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "vulnerability": "buffer overflow",
        "reason": "The functions atoascii are called with 'name' and 'value' which are user-controlled inputs. If these inputs are longer than 'MAXVARLEN' or 'MAXVALLEN', they could overflow 'bn' or 'bv', respectively, leading to potential memory corruption and arbitrary code execution.",
        "file_name": "211773.sol"
    },
    {
        "function_name": "cookedprint",
        "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\tUNUSED_ARG(datatype);\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\t\tcase HA:\t\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "vulnerability": "format string vulnerability",
        "reason": "In the fprintf statement, if the output of statustoa is improperly sanitized and could contain format specifiers, it could lead to a format string vulnerability. This could be exploited if an attacker can influence 'status' or 'datatype' to inject format specifiers.",
        "file_name": "211773.sol"
    },
    {
        "function_name": "cookedprint",
        "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\tUNUSED_ARG(datatype);\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\t\tcase HA:\t\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code writes `output_raw` to `bv` without checking if `bv` has enough space to accommodate the additional character and null terminator. The buffer `bv` is declared with a size of `2 * MAXVALLEN`, and if `strlen(bv)` is close to this limit, adding more characters can cause a buffer overflow, leading to potential memory corruption and exploitation by attackers.",
        "file_name": "211773.sol"
    },
    {
        "function_name": "cookedprint",
        "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\tUNUSED_ARG(datatype);\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\t\tcase HA:\t\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "vulnerability": "Improper Input Validation",
        "reason": "The code assumes that values with a length less than or equal to 4 are safe to use without further validation. If `value` is manipulated or crafted by an attacker, it might contain unexpected or dangerous content. This improper validation could lead to arbitrary data being processed or executed, potentially allowing code injection attacks.",
        "file_name": "211773.sol"
    },
    {
        "function_name": "cookedprint",
        "code": "cookedprint(\n\tint datatype,\n\tint length,\n\tconst char *data,\n\tint status,\n\tint quiet,\n\tFILE *fp\n\t)\n{\n\tchar *name;\n\tchar *value;\n\tchar output_raw;\n\tint fmt;\n\tl_fp lfp;\n\tsockaddr_u hval;\n\tu_long uval;\n\tint narr;\n\tsize_t len;\n\tl_fp lfparr[8];\n\tchar b[12];\n\tchar bn[2 * MAXVARLEN];\n\tchar bv[2 * MAXVALLEN];\n\tUNUSED_ARG(datatype);\n\tif (!quiet)\n\t\tfprintf(fp, \"status=%04x %s,\\n\", status,\n\t\t\tstatustoa(datatype, status));\n\tstartoutput();\n\twhile (nextvar(&length, &data, &name, &value)) {\n\t\tfmt = varfmt(name);\n\t\toutput_raw = 0;\n\t\tswitch (fmt) {\n\t\tcase PADDING:\n\t\t\toutput_raw = '*';\n\t\t\tbreak;\n\t\tcase TS:\n\t\t\tif (!decodets(value, &lfp))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, prettydate(&lfp));\n\t\t\tbreak;\n\t\tcase HA:\t\n\t\tcase NA:\n\t\t\tif (!decodenetnum(value, &hval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else if (fmt == HA){\n\t\t\t\toutput(fp, name, nntohost(&hval));\n\t\t\t} else {\n\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RF:\n\t\t\tif (decodenetnum(value, &hval)) {\n\t\t\t\tif (ISREFCLOCKADR(&hval))\n\t\t\t\t\toutput(fp, name,\n\t\t\t\t\t       refnumtoa(&hval));\n\t\t\t\telse\n\t\t\t\t\toutput(fp, name, stoa(&hval));\n\t\t\t} else if (strlen(value) <= 4) {\n\t\t\t\toutput(fp, name, value);\n\t\t\t} else {\n\t\t\t\toutput_raw = '?';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LP:\n\t\t\tif (!decodeuint(value, &uval) || uval > 3) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tb[0] = (0x2 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[1] = (0x1 & uval)\n\t\t\t\t\t   ? '1'\n\t\t\t\t\t   : '0';\n\t\t\t\tb[2] = '\\0';\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OC:\n\t\t\tif (!decodeuint(value, &uval)) {\n\t\t\t\toutput_raw = '?';\n\t\t\t} else {\n\t\t\t\tsnprintf(b, sizeof(b), \"%03lo\", uval);\n\t\t\t\toutput(fp, name, b);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR:\n\t\t\tif (!decodearr(value, &narr, lfparr))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutputarr(fp, name, narr, lfparr);\n\t\t\tbreak;\n\t\tcase FX:\n\t\t\tif (!decodeuint(value, &uval))\n\t\t\t\toutput_raw = '?';\n\t\t\telse\n\t\t\t\toutput(fp, name, tstflags(uval));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Internal error in cookedprint, %s=%s, fmt %d\\n\",\n\t\t\t\tname, value, fmt);\n\t\t\toutput_raw = '?';\n\t\t\tbreak;\n\t\t}\n\t\tif (output_raw != 0) {\n\t\t\tatoascii(name, MAXVARLEN, bn, sizeof(bn));\n\t\t\tatoascii(value, MAXVALLEN, bv, sizeof(bv));\n\t\t\tif (output_raw != '*') {\n\t\t\t\tlen = strlen(bv);\n\t\t\t\tbv[len] = output_raw;\n\t\t\t\tbv[len+1] = '\\0';\n\t\t\t}\n\t\t\toutput(fp, bn, bv);\n\t\t}\n\t}\n\tendoutput(fp);\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The code uses `snprintf` to convert `uval` to an octal string. If `uval` is large enough, it might cause an integer overflow when calculating the required buffer size for `snprintf`. Although `b` is declared with a size of 12, if `uval` exceeds expected limits, the conversion can lead to unexpected behaviors or memory corruption, which an attacker can exploit.",
        "file_name": "211773.sol"
    }
]