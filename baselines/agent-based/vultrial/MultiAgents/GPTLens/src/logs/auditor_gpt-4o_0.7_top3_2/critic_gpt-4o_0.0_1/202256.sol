[
    {
        "function_name": "QPaintEngineEx::stroke",
        "vulnerability": "Potential Memory Leak",
        "criticism": "The reasoning correctly identifies that the 'StrokeHandler' object is allocated with 'new' and there is no corresponding 'delete'. This could indeed lead to a memory leak if the function is called multiple times without deallocating the previously allocated memory. However, the severity of this issue depends on the context in which this function is used. If the function is called frequently in a long-running application, the memory leak could accumulate and become significant. The profitability of exploiting this vulnerability is low, as it does not directly lead to a security breach but rather a resource exhaustion over time.",
        "correctness": 8,
        "severity": 5,
        "profitability": 2,
        "reason": "The StrokeHandler object is allocated with 'new' but there is no corresponding 'delete', which could lead to a memory leak if this function is called multiple times.",
        "code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n    Q_D(QPaintEngineEx);\n    if (path.isEmpty())\n        return;\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n    if (!d->activeStroker) {\n        return;\n    }\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n    const qreal *lastPoint = points + (pointCount<<1);\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n    uint flags = QVectorPath::WindingFill;\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n    if (!pen.isCosmetic()) {\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n        if (!d->strokeHandler->types.size()) \n            return;\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n        fill(strokePath, brush);\n        state()->matrix = xform;\n        transformChanged();\n    }\n}",
        "file_name": "202256.sol"
    },
    {
        "function_name": "QPaintEngineEx::stroke",
        "vulnerability": "Improper Handling of Pattern Length",
        "criticism": "The reasoning suggests that there is no check for an empty dash pattern list, which could lead to incorrect calculations. However, the code does handle the case where the pattern length is zero by setting the pen style to 'NoPen'. This indicates that the reasoning is not entirely accurate, as the code does account for a zero-length pattern. The severity of this issue is low because the code already has a fallback mechanism. The profitability is also low, as this does not lead to a security vulnerability but rather a potential rendering issue.",
        "correctness": 4,
        "severity": 2,
        "profitability": 1,
        "reason": "There is no check for an empty dash pattern list, which could lead to incorrect calculations or logic errors if the list is empty, potentially causing undefined behavior.",
        "code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n    Q_D(QPaintEngineEx);\n    if (path.isEmpty())\n        return;\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n    if (!d->activeStroker) {\n        return;\n    }\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n    const qreal *lastPoint = points + (pointCount<<1);\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n    uint flags = QVectorPath::WindingFill;\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n    if (!pen.isCosmetic()) {\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n        if (!d->strokeHandler->types.size()) \n            return;\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n        fill(strokePath, brush);\n        state()->matrix = xform;\n        transformChanged();\n    }\n}",
        "file_name": "202256.sol"
    },
    {
        "function_name": "QPaintEngineEx::stroke",
        "vulnerability": "Potential Out-of-Bounds Access",
        "criticism": "The reasoning points out a potential issue with assuming 'path.points()' returns a valid pointer and that 'pointCount' is accurate. However, the code does not explicitly check for null pointers or validate 'pointCount', which could indeed lead to undefined behavior if these assumptions are violated. The severity of this issue is moderate, as it could lead to crashes or undefined behavior if the assumptions are incorrect. The profitability is low, as exploiting this would require specific conditions that are unlikely to be controlled by an attacker.",
        "correctness": 7,
        "severity": 6,
        "profitability": 2,
        "reason": "The code assumes that 'path.points()' returns a valid pointer and that 'pointCount' accurately reflects the number of elements. If 'path.points()' returns a null pointer or 'pointCount' is incorrect, this could lead to undefined behavior or a crash due to out-of-bounds access.",
        "code": "void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen)\n{\n#ifdef QT_DEBUG_DRAW\n    qDebug() << \"QPaintEngineEx::stroke()\" << pen;\n#endif\n    Q_D(QPaintEngineEx);\n    if (path.isEmpty())\n        return;\n    if (!d->strokeHandler) {\n        d->strokeHandler = new StrokeHandler(path.elementCount()+4);\n        d->stroker.setMoveToHook(qpaintengineex_moveTo);\n        d->stroker.setLineToHook(qpaintengineex_lineTo);\n        d->stroker.setCubicToHook(qpaintengineex_cubicTo);\n    }\n    QRectF clipRect;\n    QPen pen = inPen;\n    if (pen.style() > Qt::SolidLine) {\n        QRectF cpRect = path.controlPointRect();\n        const QTransform &xf = state()->matrix;\n        if (pen.isCosmetic()) {\n            clipRect = d->exDeviceRect;\n            cpRect.translate(xf.dx(), xf.dy());\n        } else {\n            clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect));\n        }\n        QRectF extentRect = cpRect & clipRect;\n        qreal extent = qMax(extentRect.width(), extentRect.height());\n        qreal patternLength = 0;\n        const QList<qreal> pattern = pen.dashPattern();\n        const int patternSize = qMin(pattern.size(), 32);\n        for (int i = 0; i < patternSize; i++)\n            patternLength += qMax(pattern.at(i), qreal(0));\n        if (pen.widthF())\n            patternLength *= pen.widthF();\n        if (qFuzzyIsNull(patternLength)) {\n            pen.setStyle(Qt::NoPen);\n        } else if (extent / patternLength > 10000) {\n            pen.setStyle(Qt::SolidLine);\n            QColor color(pen.color());\n            color.setAlpha(color.alpha() / 2);\n            pen.setColor(color);\n        }\n    }\n    if (!qpen_fast_equals(pen, d->strokerPen)) {\n        d->strokerPen = pen;\n        d->stroker.setJoinStyle(pen.joinStyle());\n        d->stroker.setCapStyle(pen.capStyle());\n        d->stroker.setMiterLimit(pen.miterLimit());\n        qreal penWidth = pen.widthF();\n        if (penWidth == 0)\n            d->stroker.setStrokeWidth(1);\n        else\n            d->stroker.setStrokeWidth(penWidth);\n        Qt::PenStyle style = pen.style();\n        if (style == Qt::SolidLine) {\n            d->activeStroker = &d->stroker;\n        } else if (style == Qt::NoPen) {\n            d->activeStroker = nullptr;\n        } else {\n            d->dasher.setDashPattern(pen.dashPattern());\n            d->dasher.setDashOffset(pen.dashOffset());\n            d->activeStroker = &d->dasher;\n        }\n    }\n    if (!d->activeStroker) {\n        return;\n    }\n    if (!clipRect.isNull())\n        d->activeStroker->setClipRect(clipRect);\n    if (d->activeStroker == &d->stroker)\n        d->stroker.setForceOpen(path.hasExplicitOpen());\n    const QPainterPath::ElementType *types = path.elements();\n    const qreal *points = path.points();\n    int pointCount = path.elementCount();\n    const qreal *lastPoint = points + (pointCount<<1);\n    d->strokeHandler->types.reset();\n    d->strokeHandler->pts.reset();\n    uint flags = QVectorPath::WindingFill;\n    if (path.elementCount() > 2)\n        flags |= QVectorPath::NonConvexShapeMask;\n    if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin)\n        flags |= QVectorPath::CurvedShapeMask;\n    if (!pen.isCosmetic()) {\n        d->activeStroker->setCurveThresholdFromTransform(state()->matrix);\n        d->activeStroker->begin(d->strokeHandler);\n        if (types) {\n            while (points < lastPoint) {\n                switch (*types) {\n                case QPainterPath::MoveToElement:\n                    d->activeStroker->moveTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::LineToElement:\n                    d->activeStroker->lineTo(points[0], points[1]);\n                    points += 2;\n                    ++types;\n                    break;\n                case QPainterPath::CurveToElement:\n                    d->activeStroker->cubicTo(points[0], points[1],\n                                              points[2], points[3],\n                                              points[4], points[5]);\n                    points += 6;\n                    types += 3;\n                    flags |= QVectorPath::CurvedShapeMask;\n                    break;\n                default:\n                    break;\n                }\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        } else {\n            d->activeStroker->moveTo(points[0], points[1]);\n            points += 2;\n            while (points < lastPoint) {\n                d->activeStroker->lineTo(points[0], points[1]);\n                points += 2;\n            }\n            if (path.hasImplicitClose())\n                d->activeStroker->lineTo(path.points()[0], path.points()[1]);\n        }\n        d->activeStroker->end();\n        if (!d->strokeHandler->types.size()) \n            return;\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        fill(strokePath, pen.brush());\n    } else {\n        if (state()->matrix.type() >= QTransform::TxProject) {\n            QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath());\n            d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform());\n        } else {\n            d->activeStroker->setCurveThresholdFromTransform(QTransform());\n            d->activeStroker->begin(d->strokeHandler);\n            if (types) {\n                while (points < lastPoint) {\n                    switch (*types) {\n                    case QPainterPath::MoveToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->moveTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::LineToElement: {\n                        QPointF pt = (*(const QPointF *) points) * state()->matrix;\n                        d->activeStroker->lineTo(pt.x(), pt.y());\n                        points += 2;\n                        ++types;\n                        break;\n                    }\n                    case QPainterPath::CurveToElement: {\n                        QPointF c1 = ((const QPointF *) points)[0] * state()->matrix;\n                        QPointF c2 = ((const QPointF *) points)[1] * state()->matrix;\n                        QPointF e =  ((const QPointF *) points)[2] * state()->matrix;\n                        d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y());\n                        points += 6;\n                        types += 3;\n                        flags |= QVectorPath::CurvedShapeMask;\n                        break;\n                    }\n                    default:\n                        break;\n                    }\n                }\n                if (path.hasImplicitClose()) {\n                    QPointF pt = * ((const QPointF *) path.points()) * state()->matrix;\n                    d->activeStroker->lineTo(pt.x(), pt.y());\n                }\n            } else {\n                QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                d->activeStroker->moveTo(p.x(), p.y());\n                points += 2;\n                while (points < lastPoint) {\n                    QPointF p = ((const QPointF *)points)[0] * state()->matrix;\n                    d->activeStroker->lineTo(p.x(), p.y());\n                    points += 2;\n                }\n                if (path.hasImplicitClose())\n                    d->activeStroker->lineTo(p.x(), p.y());\n            }\n            d->activeStroker->end();\n        }\n        QVectorPath strokePath(d->strokeHandler->pts.data(),\n                               d->strokeHandler->types.size(),\n                               d->strokeHandler->types.data(),\n                               flags);\n        QTransform xform = state()->matrix;\n        state()->matrix = QTransform();\n        transformChanged();\n        QBrush brush = pen.brush();\n        if (qbrush_style(brush) != Qt::SolidPattern)\n            brush.setTransform(brush.transform() * xform);\n        fill(strokePath, brush);\n        state()->matrix = xform;\n        transformChanged();\n    }\n}",
        "file_name": "202256.sol"
    }
]