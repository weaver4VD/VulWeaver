[
    {
        "function_name": "r_core_anal_esil",
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; \n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; \n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); \n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tr_reg_arena_pop (core->anal->reg);\n}",
        "vulnerability": "Potential Buffer Overflow",
        "reason": "The buffer `buf` is allocated with a size of `iend + 2`, where `iend` is calculated as `end - start`. If `end` or `start` are improperly set, this can lead to an incorrect buffer size allocation. Additionally, the lack of bounds checking after reading data into `buf` with `r_io_read_at` can result in a buffer overflow if the size of data read from `r_io_read_at` exceeds the allocated size.",
        "file_name": "413623.sol"
    },
    {
        "function_name": "r_core_anal_esil",
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; \n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; \n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); \n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tr_reg_arena_pop (core->anal->reg);\n}",
        "vulnerability": "Potential Memory Leak",
        "reason": "The `strdup` function is used to duplicate the string pointed to by `kspname`, allocating memory that is not freed before the function returns. This can lead to a memory leak if the duplicated string is not freed properly after its use.",
        "file_name": "413623.sol"
    },
    {
        "function_name": "r_core_anal_esil",
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; \n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; \n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); \n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tr_reg_arena_pop (core->anal->reg);\n}",
        "vulnerability": "Null Pointer Dereference",
        "reason": "The function `r_reg_get_name` is used to get a register name, but there is no check to ensure that `kspname` is not NULL before it is used in `strdup`. If `r_reg_get_name` returns NULL, `strdup` will attempt to duplicate a NULL pointer, leading to a null pointer dereference.",
        "file_name": "413623.sol"
    },
    {
        "function_name": "r_core_anal_esil",
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; \n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; \n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); \n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tr_reg_arena_pop (core->anal->reg);\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The allocated buffer size is calculated as `iend + 2`, but the read operation reads `iend + 1` bytes into `buf`. This leaves only 1 byte of space in the buffer for the null terminator, potentially leading to a buffer overflow if the data read is not null-terminated.",
        "file_name": "413623.sol"
    },
    {
        "function_name": "r_core_anal_esil",
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; \n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; \n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); \n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tr_reg_arena_pop (core->anal->reg);\n}",
        "vulnerability": "Potential Memory Leak",
        "reason": "The function uses `strdup` to duplicate a string, but the duplicated string is not freed before the function returns. This results in a memory leak each time the function is called.",
        "file_name": "413623.sol"
    },
    {
        "function_name": "r_core_anal_esil",
        "code": "R_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; \n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; \n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); \n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\tr_reg_arena_pop (core->anal->reg);\n}",
        "vulnerability": "Double Free",
        "reason": "The function frees `spname` and `pcname` at the end, but if the function exits early due to an error (e.g., if `malloc` or `strdup` fails), these pointers are not freed, leading to potential double free if the function is called again without reinitializing these pointers.",
        "file_name": "413623.sol"
    }
]