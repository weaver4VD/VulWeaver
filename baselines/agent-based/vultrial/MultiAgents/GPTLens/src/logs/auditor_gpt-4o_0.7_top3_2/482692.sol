[
    {
        "function_name": "gst_flxdec_chain",
        "code": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n      flxh = &flxdec->hdr;\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n      flxdec->next_time = 0;\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n      g_free (chunk);\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    return GST_FLOW_ERROR;\n  }\n}",
        "vulnerability": "Potential Out-of-Bounds Read",
        "reason": "The code maps a buffer of size `FlxHeaderSize` and then uses `memcpy` to copy its contents to `flxdec->hdr` without verifying if the buffer contains sufficient data. If `avail` is incorrectly reported or manipulated, this can lead to reading from an area outside the valid buffer, potentially causing a crash or exposing sensitive data.",
        "file_name": "482692.sol"
    },
    {
        "function_name": "gst_flxdec_chain",
        "code": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n      flxh = &flxdec->hdr;\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n      flxdec->next_time = 0;\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n      g_free (chunk);\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    return GST_FLOW_ERROR;\n  }\n}",
        "vulnerability": "Unchecked Allocation Size",
        "reason": "The allocation size `flxdec->size` is determined by multiplying `flxh->width` and `flxh->height`, which are values derived from the input data. If these values are manipulated, they could lead to an integer overflow or an excessively large allocation request, potentially causing a denial of service or memory corruption.",
        "file_name": "482692.sol"
    },
    {
        "function_name": "gst_flxdec_chain",
        "code": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n      flxh = &flxdec->hdr;\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n      flxdec->next_time = 0;\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n      g_free (chunk);\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    return GST_FLOW_ERROR;\n  }\n}",
        "vulnerability": "Unchecked Return from Memory Allocation",
        "reason": "The function `gst_buffer_new_and_alloc` is called with a size of `flxdec->size * 4`, which is derived from external data. If this allocation fails, `out` will be `NULL`, but the code proceeds to use `out` without checking, leading to potential null-pointer dereference and crashing the program.",
        "file_name": "482692.sol"
    },
    {
        "function_name": "gst_flxdec_chain",
        "code": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n      flxh = &flxdec->hdr;\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n      flxdec->next_time = 0;\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n      g_free (chunk);\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    return GST_FLOW_ERROR;\n  }\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The use of memcpy without proper boundary checks can lead to a buffer overflow if the size of FlxHeaderSize is larger than the allocated memory for flxdec->hdr. This is especially critical if the input data is controlled by an attacker, potentially allowing them to overwrite adjacent memory and execute arbitrary code.",
        "file_name": "482692.sol"
    },
    {
        "function_name": "gst_flxdec_chain",
        "code": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n      flxh = &flxdec->hdr;\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n      flxdec->next_time = 0;\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n      g_free (chunk);\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    return GST_FLOW_ERROR;\n  }\n}",
        "vulnerability": "Integer Overflow leading to Improper Memory Allocation",
        "reason": "The allocation of memory for flxdec->frame_data and flxdec->delta_data is based on flxdec->size, which is calculated as the product of flxh->width and flxh->height. If these values are large enough, they can cause an integer overflow, resulting in a smaller allocation size than expected. Consequently, subsequent operations on these buffers could lead to memory corruption and potential exploitation.",
        "file_name": "482692.sol"
    },
    {
        "function_name": "gst_flxdec_chain",
        "code": "gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n{\n  GstCaps *caps;\n  guint avail;\n  GstFlowReturn res = GST_FLOW_OK;\n  GstFlxDec *flxdec;\n  FlxHeader *flxh;\n  g_return_val_if_fail (buf != NULL, GST_FLOW_ERROR);\n  flxdec = (GstFlxDec *) parent;\n  g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n  gst_adapter_push (flxdec->adapter, buf);\n  avail = gst_adapter_available (flxdec->adapter);\n  if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n    if (avail >= FlxHeaderSize) {\n      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n      GstCaps *templ;\n      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n      gst_adapter_unmap (flxdec->adapter);\n      gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n      flxh = &flxdec->hdr;\n      if (flxh->type != FLX_MAGICHDR_FLI &&\n          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n        goto wrong_type;\n      GST_LOG (\"size      :  %d\", flxh->size);\n      GST_LOG (\"frames    :  %d\", flxh->frames);\n      GST_LOG (\"width     :  %d\", flxh->width);\n      GST_LOG (\"height    :  %d\", flxh->height);\n      GST_LOG (\"depth     :  %d\", flxh->depth);\n      GST_LOG (\"speed     :  %d\", flxh->speed);\n      flxdec->next_time = 0;\n      if (flxh->type == FLX_MAGICHDR_FLI) {\n        flxdec->frame_time = JIFFIE * flxh->speed;\n      } else if (flxh->speed == 0) {\n        flxdec->frame_time = GST_SECOND / 70;\n      } else {\n        flxdec->frame_time = flxh->speed * GST_MSECOND;\n      }\n      flxdec->duration = flxh->frames * flxdec->frame_time;\n      GST_LOG (\"duration   :  %\" GST_TIME_FORMAT,\n          GST_TIME_ARGS (flxdec->duration));\n      templ = gst_pad_get_pad_template_caps (flxdec->srcpad);\n      caps = gst_caps_copy (templ);\n      gst_caps_unref (templ);\n      gst_caps_set_simple (caps,\n          \"width\", G_TYPE_INT, flxh->width,\n          \"height\", G_TYPE_INT, flxh->height,\n          \"framerate\", GST_TYPE_FRACTION, (gint) GST_MSECOND,\n          (gint) flxdec->frame_time / 1000, NULL);\n      gst_pad_set_caps (flxdec->srcpad, caps);\n      gst_caps_unref (caps);\n      if (flxh->depth <= 8)\n        flxdec->converter =\n            flx_colorspace_converter_new (flxh->width, flxh->height);\n      if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n      }\n      flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n      flxdec->frame_data = g_malloc (flxdec->size);\n      flxdec->delta_data = g_malloc (flxdec->size);\n      flxdec->state = GST_FLXDEC_PLAYING;\n    }\n  } else if (flxdec->state == GST_FLXDEC_PLAYING) {\n    GstBuffer *out;\n    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n      FlxFrameChunk flxfh;\n      guchar *chunk;\n      const guint8 *data;\n      GstMapInfo map;\n      chunk = NULL;\n      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n      memcpy (&flxfh, data, FlxFrameChunkSize);\n      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n      gst_adapter_unmap (flxdec->adapter);\n      switch (flxfh.id) {\n        case FLX_FRAME_TYPE:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n          chunk = gst_adapter_take (flxdec->adapter,\n              flxfh.size - FlxFrameChunkSize);\n          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n          if (((FlxFrameType *) chunk)->chunks == 0)\n            break;\n          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n          if (!flx_decode_chunks (flxdec,\n                  ((FlxFrameType *) chunk)->chunks,\n                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                (\"%s\", \"Could not decode chunk\"), NULL);\n            return GST_FLOW_ERROR;\n          }\n          memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n          gst_buffer_map (out, &map, GST_MAP_WRITE);\n          flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n              map.data);\n          gst_buffer_unmap (out, &map);\n          GST_BUFFER_TIMESTAMP (out) = flxdec->next_time;\n          flxdec->next_time += flxdec->frame_time;\n          res = gst_pad_push (flxdec->srcpad, out);\n          break;\n        default:\n          if (avail < flxfh.size)\n            goto need_more_data;\n          gst_adapter_flush (flxdec->adapter, flxfh.size);\n          break;\n      }\n      g_free (chunk);\n      avail = gst_adapter_available (flxdec->adapter);\n    }\n  }\nneed_more_data:\n  return res;\nwrong_type:\n  {\n    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n        (\"not a flx file (type %x)\", flxh->type));\n    return GST_FLOW_ERROR;\n  }\n}",
        "vulnerability": "Out-of-Bounds Read",
        "reason": "By using gst_adapter_take with flxfh.size without verifying if the available data is sufficient, there is a risk of reading beyond the allocated buffer if flxfh.size is less than FlxFrameChunkSize. This can lead to undefined behavior, including potential leaking of sensitive data or application crashes.",
        "file_name": "482692.sol"
    }
]