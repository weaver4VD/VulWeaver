[
    {
        "function_name": "esp6_output_head",
        "vulnerability": "Use After Free",
        "criticism": "The reasoning suggests a use-after-free vulnerability due to concurrent access to 'page' after releasing the lock. However, the code uses 'get_page' to increment the page's reference count, which should prevent the page from being freed while still in use. The concern about concurrent contexts is valid, but the reference counting mechanism mitigates this risk. Therefore, the correctness of the reasoning is low. The severity is moderate as use-after-free can lead to serious issues, but the actual risk here is mitigated. Profitability is low as exploiting this would be difficult due to the reference counting.",
        "correctness": 3,
        "severity": 5,
        "profitability": 2,
        "reason": "The function does not check if 'page' was freed elsewhere in concurrent contexts after releasing the lock with 'spin_unlock_bh(&x->lock)'. This can lead to a use-after-free if the page is accessed after being freed by another context, potentially leading to memory corruption or privilege escalation.",
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\t\t\tesp->inplace = false;\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\t\t\tspin_lock_bh(&x->lock);\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\t\t\ttail = page_address(page) + pfrag->offset;\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\t\t\tspin_unlock_bh(&x->lock);\n\t\t\tnfrags++;\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\t\t\tgoto out;\n\t\t}\n\t}\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\nout:\n\treturn nfrags;\n}",
        "file_name": "343158.sol"
    },
    {
        "function_name": "esp6_output_head",
        "vulnerability": "Improper Boundary Check",
        "criticism": "The reasoning points out a potential issue with the boundary check of 'allocsz' against 'ESP_SKB_FRAG_MAXSIZE'. However, the code correctly aligns 'allocsz' and checks it against a defined maximum size. The concern about crafted input affecting 'allocsz' is speculative without evidence of how input could bypass the alignment and check. Thus, the correctness of the reasoning is low. The severity and profitability are also low as the boundary check appears to be implemented correctly.",
        "correctness": 2,
        "severity": 2,
        "profitability": 1,
        "reason": "The boundary check for 'allocsz' against 'ESP_SKB_FRAG_MAXSIZE' can lead to improper handling if 'allocsz' is calculated incorrectly or manipulated through crafted input, potentially bypassing limits and causing buffer overflows.",
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\t\t\tesp->inplace = false;\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\t\t\tspin_lock_bh(&x->lock);\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\t\t\ttail = page_address(page) + pfrag->offset;\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\t\t\tspin_unlock_bh(&x->lock);\n\t\t\tnfrags++;\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\t\t\tgoto out;\n\t\t}\n\t}\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\nout:\n\treturn nfrags;\n}",
        "file_name": "343158.sol"
    },
    {
        "function_name": "esp6_output_head",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning suggests a buffer overflow risk with 'pskb_put' and 'tailen'. However, 'pskb_put' is used after ensuring there is enough space in the buffer, either by checking 'skb_tailroom' or by allocating additional space. The reasoning lacks evidence of how 'tailen' could be improperly validated. Therefore, the correctness of the reasoning is low. The severity and profitability are also low as the code appears to handle buffer sizes correctly.",
        "correctness": 2,
        "severity": 2,
        "profitability": 1,
        "reason": "The use of 'pskb_put' with 'tailen' may lead to buffer overflow if 'tailen' is not properly validated, allowing an attacker to overwrite adjacent memory regions, potentially corrupting memory and leading to denial of service or arbitrary code execution.",
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\t\t\tesp->inplace = false;\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\t\t\tspin_lock_bh(&x->lock);\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\t\t\ttail = page_address(page) + pfrag->offset;\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\t\t\tspin_unlock_bh(&x->lock);\n\t\t\tnfrags++;\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\t\t\tgoto out;\n\t\t}\n\t}\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\nout:\n\treturn nfrags;\n}",
        "file_name": "343158.sol"
    },
    {
        "function_name": "esp6_output_head",
        "vulnerability": "Integer Overflow",
        "criticism": "The reasoning highlights a potential integer overflow in the calculation of 'allocsz'. While integer overflow is a valid concern, the use of 'unsigned int' for 'allocsz' reduces the risk of overflow. Additionally, the code checks 'allocsz' against a maximum size, which would catch any overflow resulting in a smaller value. The correctness of the reasoning is moderate as integer overflow is a known risk, but the code seems to handle it adequately. The severity is moderate due to potential memory corruption, but profitability is low due to the difficulty of exploiting this.",
        "correctness": 5,
        "severity": 5,
        "profitability": 2,
        "reason": "The calculation of 'allocsz' involves adding 'skb->data_len' and 'tailen', which can potentially lead to an integer overflow if the sum exceeds the maximum value that can be stored in an integer. This overflow can cause 'allocsz' to wrap around, resulting in a smaller value than intended. If 'allocsz' becomes less than or equal to 'ESP_SKB_FRAG_MAXSIZE', the code might skip the 'goto cow' branch, leading to incorrect memory operations and potential memory corruption.",
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\t\t\tesp->inplace = false;\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\t\t\tspin_lock_bh(&x->lock);\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\t\t\ttail = page_address(page) + pfrag->offset;\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\t\t\tspin_unlock_bh(&x->lock);\n\t\t\tnfrags++;\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\t\t\tgoto out;\n\t\t}\n\t}\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\nout:\n\treturn nfrags;\n}",
        "file_name": "343158.sol"
    },
    {
        "function_name": "esp6_output_head",
        "vulnerability": "Improper Memory Handling",
        "criticism": "The reasoning suggests improper memory handling due to assumptions about 'skb_tailroom'. The code checks 'tailen' against 'skb_tailroom', which should prevent improper access. The concern about concurrent manipulation of 'skb' is speculative without evidence of such manipulation being possible. The correctness of the reasoning is low. The severity and profitability are also low as the code appears to handle memory access correctly.",
        "correctness": 3,
        "severity": 3,
        "profitability": 1,
        "reason": "The logic within this block assumes that if the buffer is not cloned and there is enough tailroom, it can directly proceed to use the tail pointer. However, if there is an error in determining 'skb_tailroom' or if the 'skb' structure is manipulated concurrently, this assumption can lead to improper memory access, potentially allowing attackers to manipulate the memory layout or cause a crash.",
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\t\t\tesp->inplace = false;\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\t\t\tspin_lock_bh(&x->lock);\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\t\t\ttail = page_address(page) + pfrag->offset;\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\t\t\tspin_unlock_bh(&x->lock);\n\t\t\tnfrags++;\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\t\t\tgoto out;\n\t\t}\n\t}\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\nout:\n\treturn nfrags;\n}",
        "file_name": "343158.sol"
    },
    {
        "function_name": "esp6_output_head",
        "vulnerability": "Resource Exhaustion",
        "criticism": "The reasoning points out a potential resource exhaustion issue with 'skb_page_frag_refill'. The code does handle allocation failure by going to 'cow', but repeated attempts in high-load scenarios could indeed lead to resource exhaustion. The correctness of the reasoning is moderate as the risk is plausible. The severity is moderate due to potential denial of service, but profitability is low as exploiting this would require specific conditions.",
        "correctness": 6,
        "severity": 5,
        "profitability": 2,
        "reason": "The function 'skb_page_frag_refill' is used to allocate memory without checking available resources adequately. If memory is exhausted, the function returns false, and the code simply goes to 'cow'. However, repeated allocation attempts in a high-load scenario could lead to resource exhaustion attacks, potentially causing denial of service as the function keeps trying to allocate memory without proper handling of failure cases.",
        "code": "int esp6_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\tunsigned int allocsz;\n\tif (x->encap) {\n\t\tint err = esp6_output_encap(x, skb, esp);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tallocsz = ALIGN(skb->data_len + tailen, L1_CACHE_BYTES);\n\tif (allocsz > ESP_SKB_FRAG_MAXSIZE)\n\t\tgoto cow;\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\t\t\tesp->inplace = false;\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\t\t\tspin_lock_bh(&x->lock);\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\t\t\ttail = page_address(page) + pfrag->offset;\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\t\t\tspin_unlock_bh(&x->lock);\n\t\t\tnfrags++;\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\t\t\tgoto out;\n\t\t}\n\t}\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\nout:\n\treturn nfrags;\n}",
        "file_name": "343158.sol"
    }
]