[
    {
        "function_name": "dnsc_load_local_data",
        "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
        "vulnerability": "Improper handling of strdup return value",
        "reason": "The return value of strdup is not checked for NULL, which can occur if memory allocation fails. This can lead to a NULL pointer dereference later in the code, potentially causing a segmentation fault and making the application crash. Attackers might exploit this by causing a denial of service (DoS).",
        "file_name": "412117.sol"
    },
    {
        "function_name": "dnsc_load_local_data",
        "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code calculates the length for rrlen based on the sum of various string lengths and struct sizes, but does not account for null terminator explicitly in snprintf. If the length of dnscenv->provider_name or other components change, it may lead to writing outside the allocated buffer, causing a buffer overflow. This could be exploited by an attacker to execute arbitrary code.",
        "file_name": "412117.sol"
    },
    {
        "function_name": "dnsc_load_local_data",
        "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
        "vulnerability": "Improper bounds checking in snprintf",
        "reason": "The use of snprintf with rrlen - 1 - strlen(rr) as the size is unsafe because strlen(rr) is recalculated on each iteration, leading to potential incorrect bounds calculation. If strlen(rr) exceeds rrlen - 1, it may result in buffer overflow. An attacker could exploit this to influence the control flow or crash the application.",
        "file_name": "412117.sol"
    },
    {
        "function_name": "dnsc_load_local_data",
        "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
        "vulnerability": "Format String Vulnerability",
        "reason": "The code uses snprintf with a user-controlled string (dnscenv->provider_name) without proper sanitation or validation. If dnscenv->provider_name contains format specifiers, it could lead to unexpected behavior or potential code execution.",
        "file_name": "412117.sol"
    },
    {
        "function_name": "dnsc_load_local_data",
        "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
        "vulnerability": "Integer Overflow and Insufficient Memory Allocation",
        "reason": "The calculation of rrlen is based on the length of dnscenv->provider_name and other constants. If dnscenv->provider_name is large enough, it can cause an integer overflow, leading to insufficient memory allocation for rr. This could result in a buffer overflow when data is written to rr, allowing for potential exploitation by an attacker.",
        "file_name": "412117.sol"
    },
    {
        "function_name": "dnsc_load_local_data",
        "code": "dnsc_load_local_data(struct dnsc_env* dnscenv, struct config_file *cfg)\n{\n    size_t i, j;\n    if(!cfg_str2list_insert(&cfg->local_zones,\n                            strdup(dnscenv->provider_name),\n                            strdup(\"deny\"))) {\n        log_err(\"Could not load dnscrypt local-zone: %s deny\",\n                dnscenv->provider_name);\n        return -1;\n    }\n    for(i=0; i<dnscenv->signed_certs_count; i++) {\n        const char *ttl_class_type = \" 86400 IN TXT \\\"\";\n        int rotated_cert = 0;\n\tuint32_t serial;\n\tuint16_t rrlen;\n\tchar* rr;\n        struct SignedCert *cert = dnscenv->signed_certs + i;\n        for(j=0; j<dnscenv->rotated_certs_count; j++){\n            if(cert == dnscenv->rotated_certs[j]) {\n                rotated_cert = 1;\n                break;\n            }\n        }\n\t\tmemcpy(&serial, cert->serial, sizeof serial);\n\t\tserial = htonl(serial);\n        if(rotated_cert) {\n            verbose(VERB_OPS,\n                \"DNSCrypt: not adding cert with serial #%\"\n                PRIu32\n                \" to local-data as it is rotated\",\n                serial\n            );\n            continue;\n        }\n\tif((unsigned)strlen(dnscenv->provider_name) >= (unsigned)0xffff0000) {\n\t\tverbose(VERB_OPS, \"cert #%\" PRIu32 \" is too long\", serial);\n\t\tcontinue\n\t}\n        rrlen = strlen(dnscenv->provider_name) +\n                         strlen(ttl_class_type) +\n                         4 * sizeof(struct SignedCert) + \n                         1 + \n                         1;\n        rr = malloc(rrlen);\n        if(!rr) {\n            log_err(\"Could not allocate memory\");\n            return -2;\n        }\n        snprintf(rr, rrlen - 1, \"%s 86400 IN TXT \\\"\", dnscenv->provider_name);\n        for(j=0; j<sizeof(struct SignedCert); j++) {\n\t\t\tint c = (int)*((const uint8_t *) cert + j);\n            if (isprint(c) && c != '\"' && c != '\\\\') {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"%c\", c);\n            } else {\n                snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\\%03d\", c);\n            }\n        }\n        verbose(VERB_OPS,\n\t\t\t\"DNSCrypt: adding cert with serial #%\"\n\t\t\tPRIu32\n\t\t\t\" to local-data to config: %s\",\n\t\t\tserial, rr\n\t\t);\n        snprintf(rr + strlen(rr), rrlen - 1 - strlen(rr), \"\\\"\");\n        cfg_strlist_insert(&cfg->local_data, strdup(rr));\n        free(rr);\n    }\n    return dnscenv->signed_certs_count;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code uses snprintf in a loop to append characters to rr. However, there's no check to ensure that the buffer rr is not overrun. If the calculated rrlen is incorrect or if the input data is crafted in a way to exceed the buffer size, it can lead to a buffer overflow, potentially allowing an attacker to execute arbitrary code.",
        "file_name": "412117.sol"
    }
]