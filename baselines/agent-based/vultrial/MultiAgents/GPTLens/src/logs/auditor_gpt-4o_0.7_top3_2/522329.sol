[
    {
        "function_name": "GmfOpenMesh",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code checks if the length of FilNam plus 7 is greater than or equal to GmfStrSiz, but it uses strcpy to copy FilNam into msh->FilNam without ensuring that msh->FilNam is large enough to hold the content. This can lead to a buffer overflow if FilNam is large enough, potentially allowing an attacker to overwrite memory and execute arbitrary code.",
        "file_name": "522329.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "vulnerability": "Unsafe File Handling",
        "reason": "The file handling does not validate the content being read from the file. If an attacker can control the content of the file being opened, they could craft a file that causes the application to behave unexpectedly, potentially leading to code execution or data corruption.",
        "file_name": "522329.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "vulnerability": "Uncontrolled Format String",
        "reason": "The usage of variable argument lists (va_list) without proper validation or control over the format specifiers can lead to format string vulnerabilities. If an attacker can manipulate the input to include unexpected format specifiers, they may be able to read or write arbitrary memory locations.",
        "file_name": "522329.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code checks if the length of 'FilNam' plus 7 is greater than or equal to 'GmfStrSiz' before copying it into 'msh->FilNam'. However, the check does not prevent buffer overflow if 'FilNam' is exactly 'GmfStrSiz - 1' characters long. The subsequent 'strcpy' operation can overflow 'msh->FilNam', which can lead to data corruption and potential remote code execution.",
        "file_name": "522329.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "vulnerability": "Format String Vulnerability",
        "reason": "The function uses 'fscanf' to read input into 'str' without proper validation. If 'str' contains format specifiers, it can lead to undefined behavior or allow an attacker to read/write arbitrary memory locations through crafted input files.",
        "file_name": "522329.sol"
    },
    {
        "function_name": "GmfOpenMesh",
        "code": "int64_t GmfOpenMesh(const char *FilNam, int mod, ...)\n{\n   int      KwdCod, res, *PtrVer, *PtrDim, err;\n   int64_t  MshIdx;\n   char     str[ GmfStrSiz ];\n   va_list  VarArg;\n   GmfMshSct *msh;\n   if(!(msh = calloc(1, sizeof(GmfMshSct))))\n      return(0);\n   MshIdx = (int64_t)msh;\n   if( (err = setjmp(msh->err)) != 0)\n   {\n#ifdef GMFDEBUG\n      printf(\"libMeshb : mesh %p : error %d\\n\", msh, err);\n#endif\n      if(msh->hdl != NULL)\n         fclose(msh->hdl);\n      if(msh->FilDes != 0)\n#ifdef GMF_WINDOWS\n         _close(msh->FilDes);\n#else\n         close(msh->FilDes);\n#endif\n      free(msh);\n      return(0);\n   }\n   if(strlen(FilNam) + 7 >= GmfStrSiz)\n      longjmp(msh->err, -4);\n   strcpy(msh->FilNam, FilNam);\n   msh->mod = mod;\n   msh->buf = (void *)msh->DblBuf;\n   msh->FltBuf = (void *)msh->DblBuf;\n   msh->IntBuf = (void *)msh->DblBuf;\n   if(strstr(msh->FilNam, \".meshb\"))\n      msh->typ |= (Bin | MshFil);\n   else if(strstr(msh->FilNam, \".mesh\"))\n      msh->typ |= (Asc | MshFil);\n   else if(strstr(msh->FilNam, \".solb\"))\n      msh->typ |= (Bin | SolFil);\n   else if(strstr(msh->FilNam, \".sol\"))\n      msh->typ |= (Asc | SolFil);\n   else\n      longjmp(msh->err, -5);\n   if(msh->mod == GmfRead)\n   {\n      va_start(VarArg, mod);\n      PtrVer = va_arg(VarArg, int *);\n      PtrDim = va_arg(VarArg, int *);\n      va_end(VarArg);\n      if(msh->typ & Bin)\n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -6);\n         if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz)\n            longjmp(msh->err, -7);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -8);\n         safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err);\n#endif\n         if( (msh->cod != 1) && (msh->cod != 16777216) )\n            longjmp(msh->err, -9);\n         ScaWrd(msh, (unsigned char *)&msh->ver);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -10);\n         if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n            longjmp(msh->err, -11);\n         ScaWrd(msh, (unsigned char *)&KwdCod);\n         if(KwdCod != GmfDimension)\n            longjmp(msh->err, -12);\n         GetPos(msh);\n         ScaWrd(msh, (unsigned char *)&msh->dim);\n      }\n      else\n      {\n         if(!(msh->hdl = fopen(msh->FilNam, \"rb\")))\n            longjmp(msh->err, -13);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"MeshVersionFormatted\") );\n         if(res == EOF)\n            longjmp(msh->err, -14);\n         safe_fscanf(msh->hdl, \"%d\", &msh->ver, msh->err);\n         if( (msh->ver < 1) || (msh->ver > 4) )\n            longjmp(msh->err, -15);\n         do\n         {\n            res = fscanf(msh->hdl, \"%100s\", str);\n         }while( (res != EOF) && strcmp(str, \"Dimension\") );\n         if(res == EOF)\n            longjmp(msh->err, -16);\n         safe_fscanf(msh->hdl, \"%d\", &msh->dim, msh->err);\n      }\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -17);\n      (*PtrVer) = msh->ver;\n      (*PtrDim) = msh->dim;\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(!ScaKwdTab(msh))\n         return(0);\n      return(MshIdx);\n   }\n   else if(msh->mod == GmfWrite)\n   {\n      msh->cod = 1;\n      va_start(VarArg, mod);\n      msh->ver = va_arg(VarArg, int);\n      msh->dim = va_arg(VarArg, int);\n      va_end(VarArg);\n      if( (msh->ver < 1) || (msh->ver > 4) )\n         longjmp(msh->err, -18);\n      if( (msh->ver >= 3) && (sizeof(int64_t) != 8) )\n         longjmp(msh->err, -19);\n      if( (msh->dim != 2) && (msh->dim != 3) )\n         longjmp(msh->err, -20);\n      if(msh->ver == 1)\n         msh->FltSiz = 32;\n      else\n         msh->FltSiz = 64;\n      if(msh->typ & Bin) \n      {\n#ifdef WITH_GMF_AIO\n         msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE);\n         if(msh->FilDes <= 0)\n            longjmp(msh->err, -21);\n#else\n         if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n            longjmp(msh->err, -22);\n#endif\n      }\n      else if(!(msh->hdl = fopen(msh->FilNam, \"wb\")))\n         longjmp(msh->err, -23);\n      if(msh->typ & Asc)\n      {\n         fprintf(msh->hdl, \"%s %d\\n\\n\",\n               GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver);\n         fprintf(msh->hdl, \"%s %d\\n\",\n               GmfKwdFmt[ GmfDimension ][0], msh->dim);\n      }\n      else\n      {\n         RecWrd(msh, (unsigned char *)&msh->cod);\n         RecWrd(msh, (unsigned char *)&msh->ver);\n         GmfSetKwd(MshIdx, GmfDimension, 0);\n         RecWrd(msh, (unsigned char *)&msh->dim);\n      }\n      return(MshIdx);\n   }\n   else\n   {\n      free(msh);\n      return(0);\n   }\n}",
        "vulnerability": "Improper Error Handling",
        "reason": "If 'calloc' fails and returns NULL, the function returns 0, which might be interpreted as success by the calling code. This can lead to dereferencing of a NULL pointer in subsequent operations, potentially causing a crash or allowing an attacker to control execution flow.",
        "file_name": "522329.sol"
    }
]