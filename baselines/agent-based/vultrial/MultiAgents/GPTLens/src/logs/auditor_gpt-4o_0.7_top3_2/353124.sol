[
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The calculation of surface_width * surface_height can lead to an integer overflow, especially considering that surface_width and surface_height are cast to unsigned long before multiplication. This might cause the condition to be bypassed unintentionally, leading to excessive memory allocation or buffer overflow, which an attacker could exploit to execute arbitrary code or cause a denial of service.",
        "file_name": "353124.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Unchecked Memory Allocation",
        "reason": "The allocation of a new SplashBitmap object is based on surface_width and surface_height, which are derived from potentially manipulated inputs. If these values are large, it could lead to a large memory allocation request, resulting in memory exhaustion or a failure to allocate memory. This condition is checked later, but an attacker could manipulate inputs to cause the system to allocate excessive memory or crash, leading to a denial of service.",
        "file_name": "353124.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Floating Point Precision/Validation Issue",
        "reason": "The concatenation of transformation matrices with potentially large or infinite values (kx and ky) without proper validation or normalization can lead to undefined behavior in graphics rendering. This could be exploited to cause rendering anomalies or to bypass security checks based on coordinate transformations, potentially leading to information disclosure or manipulation of rendered content.",
        "file_name": "353124.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Denial of Service (DoS) via large loop iteration",
        "reason": "The code checks if the product of surface_width and surface_height exceeds a certain threshold but then attempts to reduce kx and ky by repeatedly halving m1.m[0] and m1.m[3] within a while loop. If kx and ky are initially very large and close to threshold limits, this loop may iterate a large number of times, potentially causing a denial of service by consuming excessive CPU resources.",
        "file_name": "353124.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Memory allocation failure not properly handled",
        "reason": "The code attempts to allocate a new SplashBitmap with potentially large dimensions (surface_width, surface_height). If the allocation fails, it checks for a null data pointer and attempts to recover by deleting the bitmap and restoring the CTM state. However, this may not be sufficient if the allocation failure was due to running out of memory, potentially leading to application instability or crash.",
        "file_name": "353124.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    if (unlikely(surface_width == 0 || surface_height == 0)) {\n        state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n        return false;\n    }\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Unsigned integer underflow leading to incorrect logical conditions",
        "reason": "The code checks if surface_width or surface_height is zero, which could occur if negative values were inadvertently assigned or calculated due to underflow. This could cause incorrect behavior or bypassing of certain logical conditions, potentially leading to undefined behavior or incorrect rendering operations.",
        "file_name": "353124.sol"
    }
]