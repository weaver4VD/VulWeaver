[
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The multiplication of surface_width and surface_height is cast to an unsigned long. If the result exceeds the maximum value for a long, it can wrap around, bypassing the check and leading to excessive memory allocations, which can be exploited for denial of service or memory corruption.",
        "file_name": "204137.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Improper Memory Handling",
        "reason": "There is a potential for a null pointer dereference if the allocation for the new SplashBitmap fails and getDataPtr() returns nullptr. Additionally, deleting the bitmap without checking can lead to undefined behavior if the allocation was unsuccessful.",
        "file_name": "204137.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Use After Free",
        "reason": "The tBitmap is deleted after the loop, but splash->blitImage might still access it depending on how splash is implemented. This could lead to use-after-free vulnerabilities, where an attacker can manipulate the memory previously held by tBitmap.",
        "file_name": "204137.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Heap-based buffer overflow",
        "reason": "The code allocates a new SplashBitmap object with dimensions surface_width and surface_height. There is a lack of comprehensive bounds checking on these dimensions, especially since they are derived from user-controllable inputs such as bbox and state transformations. This could potentially lead to extremely large allocations, causing a heap overflow if an attacker provides malicious input that results in excessively large or negative values.",
        "file_name": "204137.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Floating point precision error leading to logic errors",
        "reason": "The transformation matrix concatenation involves kx and ky, which are calculated with floating-point operations. Small precision errors in floating-point arithmetic can accumulate, leading to incorrect matrix transformations. If an attacker can carefully manipulate inputs to exploit these precision errors, they might influence rendering results unpredictably, potentially bypassing intended restrictions or protections.",
        "file_name": "204137.sol"
    },
    {
        "function_name": "SplashOutputDev::tilingPatternFill",
        "code": "bool SplashOutputDev::tilingPatternFill(GfxState *state, Gfx *gfxA, Catalog *catalog, Object *str,\n\t\t\t\t\tconst double *ptm, int paintType, int , Dict *resDict,\n\t\t\t\t\tconst double *mat, const double *bbox,\n\t\t\t\t\tint x0, int y0, int x1, int y1,\n\t\t\t\t\tdouble xStep, double yStep)\n{\n  PDFRectangle box;\n  Gfx *gfx;\n  Splash *formerSplash = splash;\n  SplashBitmap *formerBitmap = bitmap;\n  double width, height;\n  int surface_width, surface_height, result_width, result_height, i;\n  int repeatX, repeatY;\n  SplashCoord matc[6];\n  Matrix m1;\n  const double *ctm;\n  double savedCTM[6];\n  double kx, ky, sx, sy;\n  bool retValue = false;\n  width = bbox[2] - bbox[0];\n  height = bbox[3] - bbox[1];\n  if (xStep != width || yStep != height)\n    return false;\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    savedCTM[i] = ctm[i];\n  }\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(1, 0, 0, 1, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  for (i = 0; i < 6; ++i) {\n    if (!std::isfinite(ctm[i])) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n  }\n  matc[4] = x0 * xStep * ctm[0] + y0 * yStep * ctm[2] + ctm[4];\n  matc[5] = x0 * xStep * ctm[1] + y0 * yStep * ctm[3] + ctm[5];\n  if (splashAbs(ctm[1]) > splashAbs(ctm[0])) {\n    kx = -ctm[1];\n    ky = ctm[2] - (ctm[0] * ctm[3]) / ctm[1];\n  } else {\n    kx = ctm[0];\n    ky = ctm[3] - (ctm[1] * ctm[2]) / ctm[0];\n  }\n  result_width = (int) ceil(fabs(kx * width * (x1 - x0)));\n  result_height = (int) ceil(fabs(ky * height * (y1 - y0)));\n  kx = state->getHDPI() / 72.0;\n  ky = state->getVDPI() / 72.0;\n  m1.m[0] = (ptm[0] == 0) ? fabs(ptm[2]) * kx : fabs(ptm[0]) * kx;\n  m1.m[1] = 0;\n  m1.m[2] = 0;\n  m1.m[3] = (ptm[3] == 0) ? fabs(ptm[1]) * ky : fabs(ptm[3]) * ky;\n  m1.m[4] = 0;\n  m1.m[5] = 0;\n  m1.transform(width, height, &kx, &ky);\n  surface_width = (int) ceil (fabs(kx));\n  surface_height = (int) ceil (fabs(ky));\n  sx = (double) result_width / (surface_width * (x1 - x0));\n  sy = (double) result_height / (surface_height * (y1 - y0));\n  m1.m[0] *= sx;\n  m1.m[3] *= sy;\n  m1.transform(width, height, &kx, &ky);\n  if(fabs(kx) < 1 && fabs(ky) < 1) {\n    kx = std::min<double>(kx, ky);\n    ky = 2 / kx;\n    m1.m[0] *= ky;\n    m1.m[3] *= ky;\n    m1.transform(width, height, &kx, &ky);\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = x1 - x0;\n    repeatY = y1 - y0;\n  } else {\n    if ((unsigned long) surface_width * surface_height > 0x800000L) {\n      state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n      return false;\n    }\n    while(fabs(kx) > 16384 || fabs(ky) > 16384) {\n      m1.m[0] /= 2;\n      m1.m[3] /= 2;\n      m1.transform(width, height, &kx, &ky);\n    }\n    surface_width = (int) ceil (fabs(kx));\n    surface_height = (int) ceil (fabs(ky));\n    repeatX = result_width / surface_width;\n    repeatY = result_height / surface_height;\n    if (surface_width * repeatX < result_width)\n      repeatX++;\n    if (surface_height * repeatY < result_height)\n      repeatY++;\n    if (x1 - x0 > repeatX)\n      repeatX = x1 - x0;\n    if (y1 - y0 > repeatY)\n      repeatY = y1 - y0;\n  }\n  state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n  state->concatCTM(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);\n  state->concatCTM(width * repeatX, 0, 0, height * repeatY, bbox[0], bbox[1]);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  if (surface_width == 0 || surface_height == 0 || repeatX * repeatY <= 4) {\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  m1.transform(bbox[0], bbox[1], &kx, &ky);\n  m1.m[4] = -kx;\n  m1.m[5] = -ky;\n  bitmap = new SplashBitmap(surface_width, surface_height, 1,\n                            (paintType == 1) ? colorMode : splashModeMono8, true);\n  if (bitmap->getDataPtr() == nullptr) {\n    SplashBitmap *tBitmap = bitmap;\n    bitmap = formerBitmap;\n    delete tBitmap;\n    state->setCTM(savedCTM[0], savedCTM[1], savedCTM[2], savedCTM[3], savedCTM[4], savedCTM[5]);\n    return false;\n  }\n  splash = new Splash(bitmap, true);\n  if (paintType == 2) {\n    SplashColor clearColor;\n#ifdef SPLASH_CMYK\n    clearColor[0] = (colorMode == splashModeCMYK8 || colorMode == splashModeDeviceN8) ? 0x00 : 0xFF;\n#else\n    clearColor[0] = 0xFF;\n#endif\n    splash->clear(clearColor, 0);\n  } else {\n    splash->clear(paperColor, 0);\n  }\n  splash->setThinLineMode(formerSplash->getThinLineMode());\n  splash->setMinLineWidth(s_minLineWidth);\n  box.x1 = bbox[0]; box.y1 = bbox[1];\n  box.x2 = bbox[2]; box.y2 = bbox[3];\n  gfx = new Gfx(doc, this, resDict, &box, nullptr, nullptr, nullptr, gfxA);\n  gfx->getState()->setCTM(m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  updateCTM(gfx->getState(), m1.m[0], m1.m[1], m1.m[2], m1.m[3], m1.m[4], m1.m[5]);\n  gfx->display(str);\n  delete splash;\n  splash = formerSplash;\n  TilingSplashOutBitmap imgData;\n  imgData.bitmap = bitmap;\n  imgData.paintType = paintType;\n  imgData.pattern = splash->getFillPattern();\n  imgData.colorMode = colorMode;\n  imgData.y = 0;\n  imgData.repeatX = repeatX;\n  imgData.repeatY = repeatY;\n  SplashBitmap *tBitmap = bitmap;\n  bitmap = formerBitmap;\n  result_width = tBitmap->getWidth() * imgData.repeatX;\n  result_height = tBitmap->getHeight() * imgData.repeatY;\n  if (splashAbs(matc[1]) > splashAbs(matc[0])) {\n    kx = -matc[1];\n    ky = matc[2] - (matc[0] * matc[3]) / matc[1];\n  } else {\n    kx = matc[0];\n    ky = matc[3] - (matc[1] * matc[2]) / matc[0];\n  }\n  kx = result_width / (fabs(kx) + 1);\n  ky = result_height / (fabs(ky) + 1);\n  state->concatCTM(kx, 0, 0, ky, 0, 0);\n  ctm = state->getCTM();\n  matc[0] = ctm[0];\n  matc[1] = ctm[1];\n  matc[2] = ctm[2];\n  matc[3] = ctm[3];\n  bool minorAxisZero = matc[1] == 0 && matc[2] == 0;\n  if (matc[0] > 0 && minorAxisZero && matc[3] > 0) {\n    for (int y = 0; y < imgData.repeatY; ++y) {\n      for (int x = 0; x < imgData.repeatX; ++x) {\n        x0 = splashFloor(matc[4]) + x * tBitmap->getWidth();\n        y0 = splashFloor(matc[5]) + y * tBitmap->getHeight();\n        splash->blitImage(tBitmap, true, x0, y0);\n      }\n    }\n    retValue = true;\n  } else {\n    retValue = splash->drawImage(&tilingBitmapSrc, nullptr, &imgData, colorMode, true, result_width, result_height, matc, false, true) == splashOk;\n  }\n  delete tBitmap;\n  delete gfx;\n  return retValue;\n}",
        "vulnerability": "Denial of service via infinite loop",
        "reason": "This loop attempts to reduce kx and ky to be within a certain range by halving m1.m[0] and m1.m[3]. However, if these values are set to extremely large numbers (especially near the limits of double precision), the loop might not complete within a reasonable time, potentially causing a denial of service by consuming excessive CPU resources.",
        "file_name": "204137.sol"
    }
]