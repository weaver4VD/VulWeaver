[
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Integer Overflow Leading to Buffer Overflow",
        "criticism": "The reasoning correctly identifies a potential integer overflow in the calculation of 'len' during RLE decoding. However, the code does include a check 'if (end - ptr < len)' to prevent buffer overflow, which mitigates the risk. The vulnerability is plausible but not as severe as described because the check is in place. The severity is moderate due to the potential for bypassing the check if integer overflow occurs, but the likelihood is lower due to the check.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The length of data to be copied into the buffer is calculated based on user-controllable input from the compressed stream. If an attacker provides crafted input that causes the calculation of 'len' to overflow, the condition 'if (end - ptr < len)' may be bypassed, leading to a buffer overflow. This can allow an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution or a crash.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Improper Input Validation",
        "criticism": "The reasoning is correct in identifying that the 'length' variable is read directly from the input stream without validation, which can lead to excessive memory allocation. This is a valid concern as it can lead to denial-of-service conditions. The severity is moderate because it primarily affects availability rather than confidentiality or integrity.",
        "correctness": 8,
        "severity": 6,
        "profitability": 3,
        "reason": "The 'length' variable is read directly from the input stream and used to set the underlying buffer size for the 'zis' object without validation. An attacker could supply a very large length value, leading to excessive memory allocation, which could result in a denial-of-service condition or potentially facilitate further attacks by exhausting system resources.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Potential Out-of-Bounds Write to Palette Array",
        "criticism": "The reasoning correctly identifies that 'palSize' is derived from user input and could exceed the bounds of the 'palette' array. This is a critical vulnerability as it can lead to memory corruption and potentially arbitrary code execution. The severity is high due to the potential impact on system integrity.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The 'palSize' value is derived from user-controlled input without validation, allowing for the possibility of writing beyond the bounds of the 'palette' array if 'palSize' exceeds 128. This could lead to arbitrary memory corruption, as an attacker could overwrite adjacent memory structures, potentially leading to arbitrary code execution or other malicious behavior.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Integer Overflow in RLE Length Calculation",
        "criticism": "The reasoning correctly identifies a potential integer overflow in the RLE length calculation. However, the code includes a check 'if (end - ptr < len)' to prevent buffer overflow, which mitigates the risk. The vulnerability is plausible but not as severe as described because the check is in place. The severity is moderate due to the potential for bypassing the check if integer overflow occurs, but the likelihood is lower due to the check.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The RLE length calculation does not account for potential integer overflow when accumulating the length with repeated additions of 255. This could enable an attacker to craft input that causes the length to wrap around, leading to a situation where 'len' becomes larger than the remaining buffer space, allowing for a buffer overflow.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Buffer Overflow",
        "criticism": "The reasoning correctly identifies that 'zis->readBytes' could lead to a buffer overflow if 't.area() * (BPP / 8)' exceeds the size of 'buf'. This is a valid concern, especially if 'BPP' is higher than expected. The severity is high due to the potential for memory corruption and arbitrary code execution.",
        "correctness": 9,
        "severity": 8,
        "profitability": 7,
        "reason": "The use of 'zis->readBytes' directly into 'buf' without proper bounds checking can result in a buffer overflow. Since 'buf' is statically allocated for 64*64 pixels, if 't.area() * (BPP / 8)' exceeds this size, it will overwrite adjacent memory. This is particularly dangerous if 'BPP' (Bits Per Pixel) is higher than expected.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol"
    },
    {
        "function_name": "ZRLE_DECODE",
        "vulnerability": "Improper Length Handling",
        "criticism": "The reasoning is correct in identifying that the length used for setting the underlying stream is read directly from the input stream without validation. This can lead to excessive memory allocation or resource exhaustion. The severity is moderate because it primarily affects availability rather than confidentiality or integrity.",
        "correctness": 8,
        "severity": 6,
        "profitability": 3,
        "reason": "The length used for setting the underlying stream is read directly from the input stream without validation. If an attacker controls the input, they could specify an overly large length, potentially leading to excessive memory allocation or attempts to process more data than is available, resulting in resource exhaustion or denial of service.",
        "code": "void ZRLE_DECODE (const Rect& r, rdr::InStream* is,\n                  rdr::ZlibInStream* zis,\n                  const PixelFormat& pf, ModifiablePixelBuffer* pb)\n{\n  int length = is->readU32();\n  zis->setUnderlying(is, length);\n  Rect t;\n  PIXEL_T buf[64 * 64];\n  for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) {\n    t.br.y = __rfbmin(r.br.y, t.tl.y + 64);\n    for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) {\n      t.br.x = __rfbmin(r.br.x, t.tl.x + 64);\n      int mode = zis->readU8();\n      bool rle = mode & 128;\n      int palSize = mode & 127;\n      PIXEL_T palette[128];\n      for (int i = 0; i < palSize; i++) {\n        palette[i] = READ_PIXEL(zis);\n      }\n      if (palSize == 1) {\n        PIXEL_T pix = palette[0];\n        pb->fillRect(pf, t, &pix);\n        continue;\n      }\n      if (!rle) {\n        if (palSize == 0) {\n#ifdef CPIXEL\n          for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) {\n            *ptr = READ_PIXEL(zis);\n          }\n#else\n          zis->readBytes(buf, t.area() * (BPP / 8));\n#endif\n        } else {\n          int bppp = ((palSize > 16) ? 8 :\n                      ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1)));\n          PIXEL_T* ptr = buf;\n          for (int i = 0; i < t.height(); i++) {\n            PIXEL_T* eol = ptr + t.width();\n            rdr::U8 byte = 0;\n            rdr::U8 nbits = 0;\n            while (ptr < eol) {\n              if (nbits == 0) {\n                byte = zis->readU8();\n                nbits = 8;\n              }\n              nbits -= bppp;\n              rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127;\n              *ptr++ = palette[index];\n            }\n          }\n        }\n      } else {\n        if (palSize == 0) {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            PIXEL_T pix = READ_PIXEL(zis);\n            int len = 1;\n            int b;\n            do {\n              b = zis->readU8();\n              len += b;\n            } while (b == 255);\n            if (end - ptr < len) {\n              throw Exception (\"ZRLE decode error\");\n            }\n            while (len-- > 0) *ptr++ = pix;\n          }\n        } else {\n          PIXEL_T* ptr = buf;\n          PIXEL_T* end = ptr + t.area();\n          while (ptr < end) {\n            int index = zis->readU8();\n            int len = 1;\n            if (index & 128) {\n              int b;\n              do {\n                b = zis->readU8();\n                len += b;\n              } while (b == 255);\n              if (end - ptr < len) {\n                throw Exception (\"ZRLE decode error\");\n              }\n            }\n            index &= 127;\n            PIXEL_T pix = palette[index];\n            while (len-- > 0) *ptr++ = pix;\n          }\n        }\n      }\n      pb->imageRect(pf, t, buf);\n    }\n  }\n  zis->flushUnderlying();\n  zis->setUnderlying(NULL, 0);\n}",
        "file_name": "376682.sol"
    }
]