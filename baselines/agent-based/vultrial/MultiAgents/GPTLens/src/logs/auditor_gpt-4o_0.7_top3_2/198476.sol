[
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Improper error handling and unchecked error propagation",
        "reason": "The function checks if the value is an error and goes to a failed label, but the subsequent error handling is insufficient and could lead to unintended consequences. A more robust error handling mechanism should be in place to ensure no sensitive information is leaked and the system remains stable.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Potential use-after-free vulnerability",
        "reason": "The function modifies the context's capability and clears it at the end. If the context is freed before all references are cleared, it could lead to use-after-free vulnerabilities. This is exploitable if an attacker can control the context's lifecycle, potentially leading to arbitrary code execution.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Improper state restoration leading to logical errors",
        "reason": "The function saves and restores the VM state (e.g., local, closure, temp levels, top frame) but does not account for concurrent modifications that might occur during `njs_vmcode_interpreter`. This can lead to inconsistent states being restored, which attackers could exploit to corrupt memory or control flow.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Lack of input validation",
        "reason": "The function does not validate the input arguments, particularly 'args' and 'nargs'. This could lead to various issues like buffer overflow or use of uninitialized memory, allowing attackers to manipulate the execution flow or cause crashes.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Improper error handling",
        "reason": "The function uses 'goto' for error handling, which can lead to complex and unmanageable code paths, making it easy to overlook certain error conditions. This can be exploited by attackers to bypass security checks or cause unexpected behavior.",
        "file_name": "198476.sol"
    },
    {
        "function_name": "njs_await_fulfilled",
        "code": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n    ctx = vm->top_frame->function->context;\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n    function = async->function;\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n    vm->top_frame->retval = &vm->retval;\n    function->context = ctx->capability;\n    function->await = ctx;\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n    function->context = NULL;\n    function->await = NULL;\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n    vm->top_frame = top;\n    vm->active_frame = frame;\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),\n                            &njs_value_undefined, &vm->retval, 1, &vm->retval);\n        njs_async_context_free(vm, ctx);\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n        value = &vm->retval;\n        goto failed;\n    }\n    return ret;\nfailed:\n    (void) njs_function_call(vm, njs_function(&ctx->capability->reject),\n                             &njs_value_undefined, value, 1, &vm->retval);\n    njs_async_context_free(vm, ctx);\n    return NJS_ERROR;\n}",
        "vulnerability": "Potential use of null pointer dereference",
        "reason": "The function assumes certain pointers like 'ctx' and 'function' are not null without checking them. If these pointers are null due to an unexpected state, dereferencing them would lead to a crash, opening up the possibility for denial of service attacks.",
        "file_name": "198476.sol"
    }
]