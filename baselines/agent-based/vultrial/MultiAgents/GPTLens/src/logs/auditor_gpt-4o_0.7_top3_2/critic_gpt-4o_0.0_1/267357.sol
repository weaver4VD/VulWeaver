[
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Uncontrolled Environment Variable",
        "criticism": "The reasoning correctly identifies that the environment variable 'LISTEN_FDS' is read without validation. However, the impact of this vulnerability is somewhat overstated. While setting 'LISTEN_FDS' to a high value could lead to resource exhaustion, the likelihood of this causing significant harm depends on the context in which the function is used. The function does not directly execute commands based on this variable, limiting the potential for arbitrary code execution. The severity is moderate due to potential resource exhaustion, but the profitability is low as it requires specific conditions to exploit effectively.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The code reads the environment variable \"LISTEN_FDS\" without validating its content. An attacker can set this environment variable to a very high value or a malicious value that could affect the behavior of the program, leading to resource exhaustion or unintended behavior.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Unchecked Argument Copying",
        "criticism": "The reasoning suggests a command injection risk due to unchecked copying of command-line arguments. However, the function does not directly execute system commands with these arguments, reducing the risk of command injection. The arguments are copied into a structure for further processing, which may not inherently lead to command execution. The severity is low as the function does not directly execute commands, and the profitability is also low due to the lack of direct execution paths.",
        "correctness": 6,
        "severity": 2,
        "profitability": 2,
        "reason": "The code copies command-line arguments to the 'process->args' array without validating or sanitizing them. This may lead to command injection vulnerabilities if these arguments are used to execute system commands, as an attacker can manipulate the inputs to execute arbitrary code.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Environment Variable Injection",
        "criticism": "The reasoning correctly identifies that environment variables are assigned from user-controlled data without validation. This could lead to environment variable injection if the variables influence the behavior of executed processes. The severity is moderate as it depends on how these environment variables are used in the execution context. The profitability is moderate as well, as it requires specific conditions to exploit effectively.",
        "correctness": 8,
        "severity": 5,
        "profitability": 4,
        "reason": "The 'env' and 'env_len' are assigned from user-controlled data in 'exec_options.env' and 'exec_options.env_size' without validation. This could lead to an environment variable injection if an attacker can provide malicious environment variables, potentially influencing the behavior of executed processes or exploiting vulnerabilities in the execution environment.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Unchecked Command-Line Argument Parsing",
        "criticism": "The reasoning suggests a risk of argument injection due to lack of validation in 'argp_parse'. However, 'argp_parse' is a standard function for parsing command-line arguments and typically includes its own validation mechanisms. The risk of argument injection is low unless the parsed arguments are used in a vulnerable context, which is not evident in the provided code. The severity and profitability are both low due to the lack of direct execution paths.",
        "correctness": 5,
        "severity": 2,
        "profitability": 1,
        "reason": "The call to argp_parse does not include any input validation or sanitization of the command-line arguments (argv). This can lead to argument injection vulnerabilities where an attacker can provide malicious input to execute unauthorized commands or perform actions outside intended permissions. Proper validation and sanitization of input should be done to prevent such attacks.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Potential Buffer Overflow",
        "criticism": "The reasoning identifies a potential buffer overflow due to unchecked copying of arguments. However, the allocation for 'process->args' is based on 'argc', which should match the number of arguments in 'argv'. The loop correctly iterates over the arguments, reducing the likelihood of overflow. The severity is low as the allocation and copying are aligned, and the profitability is also low due to the lack of direct execution paths.",
        "correctness": 6,
        "severity": 2,
        "profitability": 1,
        "reason": "The allocation of memory for process->args is based on argc, but the loop copies data from argv directly into it without bounds checking. If argc is manipulated or if argv contains more data than expected, this could lead to a buffer overflow, allowing an attacker to overwrite memory and potentially execute arbitrary code.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    },
    {
        "function_name": "crun_command_exec",
        "vulnerability": "Unchecked Environment Variable Usage",
        "criticism": "The reasoning correctly identifies that 'LISTEN_FDS' is read and converted without validation, which could lead to integer overflow or erroneous behavior. The severity is moderate due to potential denial of service, but the profitability is low as it requires specific conditions to exploit effectively.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The environment variable LISTEN_FDS is read and converted to a long integer without proper validation. An attacker could set this environment variable to a large value or invalid input, which could lead to integer overflow or erroneous behavior in the application, potentially causing denial of service or other unexpected behavior.",
        "code": "crun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n          process->capabilities = capabilities;\n        }\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n      exec_opts.process = process;\n    }\n  exec_opts.cgroup = exec_options.cgroup;\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}",
        "file_name": "267357.sol"
    }
]