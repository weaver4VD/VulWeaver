[
    {
        "function_name": "parseDragons",
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
        "vulnerability": "Potential buffer overflow",
        "reason": "The code allocates memory for a buffer of 'size' bytes and then reads data from 'buf' into this buffer. If 'r_buf_read_at' does not properly handle the size, it may lead to a buffer overflow, especially if 'available' does not match 'size', potentially overwriting adjacent memory.",
        "file_name": "437671.sol"
    },
    {
        "function_name": "parseDragons",
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
        "vulnerability": "Negative offset vulnerability",
        "reason": "The function attempts to read from 'buf' with an offset of 'off - 8'. If 'off' is less than 8, this will result in a negative offset, which can lead to undefined behavior or out-of-bounds access, potentially allowing attackers to read or manipulate unintended memory regions.",
        "file_name": "437671.sol"
    },
    {
        "function_name": "parseDragons",
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
        "vulnerability": "Improper magic number validation",
        "reason": "The code checks for specific magic numbers but does not handle cases where the magic numbers appear at unexpected locations, relying on 'magicCombo' to be exactly 2. This logic may be bypassed or exploited by attackers to trick the function into processing malicious data, especially if the magic numbers are manipulated or crafted in a specific pattern.",
        "file_name": "437671.sol"
    },
    {
        "function_name": "parseDragons",
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
        "vulnerability": "memory_leak",
        "reason": "If r_buf_read_at fails and returns without freeing the allocated memory, this would lead to a memory leak. In a real-world scenario, repeated calls or large data could exhaust system memory, causing crashes or denial of service.",
        "file_name": "437671.sol"
    },
    {
        "function_name": "parseDragons",
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
        "vulnerability": "out_of_bounds_read",
        "reason": "The code attempts to read from an offset `off - 8` without checking if this results in a negative value or goes out of bounds of the buffer's size. This can lead to out-of-bounds memory access, potentially exposing or corrupting memory and leading to undefined behavior.",
        "file_name": "437671.sol"
    },
    {
        "function_name": "parseDragons",
        "code": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;\n\t}\n#if 0\n\t0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..\n                         n_segments ----.          .--- how many sections ?\n\t0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........\n\t             .---- how many symbols? 0xc7\n\t0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................\n\t0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..\n\t0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..\n\t0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............\n\t0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................\n\t0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..\n\t0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................\n\t0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..\n\t0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................\n\t0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..\n\t0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................\n\t0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED\n\t0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..\n#endif\n\tint magicCombo = 0;\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\tmagicCombo++;\n\t}\n\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b + 8, 4)) {\n\t\tmagicCombo++;\n\t}\n\tif (magicCombo != 2) {\n\t\tavailable = r_buf_read_at (buf, off - 8, b, size);\n\t\tif (available != size) {\n\t\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!memcmp (\"\\x1a\\x2b\\xb2\\xa1\", b, 4)) { \n\t\t\toff -= 8;\n\t\t} else {\n\t\t\teprintf (\"0x%08x  parsing error: invalid magic retry\\n\", off);\n\t\t}\n\t}\n\tD eprintf (\"0x%08x  magic  OK\\n\", off);\n\tD {\n\t\tconst int e0ss = r_read_le32 (b + 12);\n\t\teprintf (\"0x%08x  eoss   0x%x\\n\", off + 12, e0ss);\n\t}\n\tfree (b);\n\treturn r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);\n}",
        "vulnerability": "use_after_free",
        "reason": "The buffer `b` is freed before returning a new cache element. If `r_coresym_cache_element_new` or any subsequent operation attempts to use `b`, this could lead to a use-after-free vulnerability, which can be exploited for arbitrary code execution or crashes.",
        "file_name": "437671.sol"
    }
]