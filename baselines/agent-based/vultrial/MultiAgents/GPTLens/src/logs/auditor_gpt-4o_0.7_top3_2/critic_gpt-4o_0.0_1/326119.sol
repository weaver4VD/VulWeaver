[
    {
        "function_name": "regmatch",
        "vulnerability": "Unchecked return values",
        "criticism": "The reasoning correctly identifies that the function regmatch does not adequately check the return values of functions like ga_grow and regstack_push. These functions can fail, and without proper error handling, this can lead to undefined behavior or crashes. The reasoning is accurate in identifying a potential vulnerability, but it could be more specific about the consequences of such failures. The severity is moderate because it can lead to crashes, but exploitation is less likely without specific conditions. Profitability is low as exploiting this would require specific conditions and may not lead to significant gain.",
        "correctness": 8,
        "severity": 5,
        "profitability": 3,
        "reason": "The function regmatch lacks proper checks for the return values of several function calls such as ga_grow and regstack_push. These functions may fail and return NULL, indicating memory allocation failure or other issues. Without proper error handling, this can lead to undefined behavior, crashes, or potential exploitation by attackers who can manipulate application state or memory.",
        "code": "regmatch(\n    char_u\t*scan,\t\t    \n    proftime_T\t*tm UNUSED,\t    \n    int\t\t*timed_out UNUSED)  \n{\n  char_u\t*next;\t\t\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n  for (;;)\n  {\n    fast_breakcheck();\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\top = OP(scan);\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_BOF:\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case CURSOR:\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_MARK:\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\t\tif (pos == NULL\t\t     \n\t\t\t|| pos->lnum <= 0)   \n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case BOW:\t\n\t    if (c == NUL)\t\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  \n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  \n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case EOW:\t\n\t    if (rex.input == rex.line)    \n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; \n\t  case ANY:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\t\topnd = OPERAND(scan);\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\t\topnd = OPERAND(scan);\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\t  case NOTHING:\n\t    break;\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    status = RA_NOMATCH;\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\t  case MOPEN + 0:   \n\t  case MOPEN + 1:   \n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t}\n\t    }\n\t    break;\n\t  case NOPEN:\t    \n\t  case NCLOSE:\t    \n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\tbreak;\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case MCLOSE + 0:  \n\t  case MCLOSE + 1:  \n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t}\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  \n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\trex.input += len;\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) \n\t\t    next = OPERAND(scan);\t\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t    }\n\t    break;\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t}\n\t    }\n\t    break;\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\t  case END:\n\t    status = RA_MATCH;\t\n\t    break;\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\tif (status != RA_CONT)\n\t    break;\n\tscan = next;\n    } \n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_MOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_MCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_BRCPLX_MORE:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_BRCPLX_LONG:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BRCPLX_SHORT:\n\t    if (status == RA_NOMATCH)\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\t  case RS_NOMATCH:\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\t\trp->rs_state = RS_BEHIND2;\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\t  case RS_BEHIND2:\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n    if (status == RA_CONT)\n\tcontinue;\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n  } \n}",
        "file_name": "326119.sol"
    },
    {
        "function_name": "regmatch",
        "vulnerability": "Integer overflow",
        "criticism": "The reasoning identifies a potential integer overflow in the expression (long)((unsigned)regstack.ga_len >> 10). However, the likelihood of this causing a significant issue is low because the shift operation reduces the risk of overflow, and the context suggests that this is a memory usage check. The severity is low because the overflow is unlikely to lead to a buffer overflow or other critical issue. Profitability is also low as exploiting this would be complex and unlikely to yield significant results.",
        "correctness": 6,
        "severity": 3,
        "profitability": 2,
        "reason": "The expression (long)((unsigned)regstack.ga_len >> 10) is prone to integer overflow, especially if regstack.ga_len is a large value. This can lead to incorrect memory checks and potential buffer overflows, which can be exploited by attackers to execute arbitrary code or cause denial of service by manipulating memory usage.",
        "code": "regmatch(\n    char_u\t*scan,\t\t    \n    proftime_T\t*tm UNUSED,\t    \n    int\t\t*timed_out UNUSED)  \n{\n  char_u\t*next;\t\t\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n  for (;;)\n  {\n    fast_breakcheck();\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\top = OP(scan);\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_BOF:\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case CURSOR:\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_MARK:\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\t\tif (pos == NULL\t\t     \n\t\t\t|| pos->lnum <= 0)   \n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case BOW:\t\n\t    if (c == NUL)\t\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  \n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  \n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case EOW:\t\n\t    if (rex.input == rex.line)    \n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; \n\t  case ANY:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\t\topnd = OPERAND(scan);\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\t\topnd = OPERAND(scan);\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\t  case NOTHING:\n\t    break;\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    status = RA_NOMATCH;\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\t  case MOPEN + 0:   \n\t  case MOPEN + 1:   \n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t}\n\t    }\n\t    break;\n\t  case NOPEN:\t    \n\t  case NCLOSE:\t    \n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\tbreak;\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case MCLOSE + 0:  \n\t  case MCLOSE + 1:  \n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t}\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  \n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\trex.input += len;\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) \n\t\t    next = OPERAND(scan);\t\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t    }\n\t    break;\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t}\n\t    }\n\t    break;\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\t  case END:\n\t    status = RA_MATCH;\t\n\t    break;\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\tif (status != RA_CONT)\n\t    break;\n\tscan = next;\n    } \n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_MOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_MCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_BRCPLX_MORE:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_BRCPLX_LONG:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BRCPLX_SHORT:\n\t    if (status == RA_NOMATCH)\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\t  case RS_NOMATCH:\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\t\trp->rs_state = RS_BEHIND2;\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\t  case RS_BEHIND2:\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n    if (status == RA_CONT)\n\tcontinue;\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n  } \n}",
        "file_name": "326119.sol"
    },
    {
        "function_name": "regmatch",
        "vulnerability": "Use of uninitialized variables",
        "criticism": "The reasoning incorrectly identifies variables such as next, op, c, rp, and no as uninitialized. These variables are initialized before use within the function. The reasoning is incorrect, and there is no vulnerability related to uninitialized variables in this context. The severity and profitability are both zero because there is no actual vulnerability to exploit.",
        "correctness": 2,
        "severity": 0,
        "profitability": 0,
        "reason": "The variables next, op, c, rp, no are declared but not initialized before use in the function regmatch. If these variables are used without proper initialization, it can lead to unpredictable behavior, crashes, or leakage of sensitive information. An attacker may exploit this behavior to cause undefined behavior or control the flow of execution.",
        "code": "regmatch(\n    char_u\t*scan,\t\t    \n    proftime_T\t*tm UNUSED,\t    \n    int\t\t*timed_out UNUSED)  \n{\n  char_u\t*next;\t\t\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n  for (;;)\n  {\n    fast_breakcheck();\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\top = OP(scan);\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_BOF:\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case CURSOR:\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_MARK:\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\t\tif (pos == NULL\t\t     \n\t\t\t|| pos->lnum <= 0)   \n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case BOW:\t\n\t    if (c == NUL)\t\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  \n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  \n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case EOW:\t\n\t    if (rex.input == rex.line)    \n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; \n\t  case ANY:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\t\topnd = OPERAND(scan);\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\t\topnd = OPERAND(scan);\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\t  case NOTHING:\n\t    break;\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    status = RA_NOMATCH;\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\t  case MOPEN + 0:   \n\t  case MOPEN + 1:   \n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t}\n\t    }\n\t    break;\n\t  case NOPEN:\t    \n\t  case NCLOSE:\t    \n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\tbreak;\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case MCLOSE + 0:  \n\t  case MCLOSE + 1:  \n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t}\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  \n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\trex.input += len;\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) \n\t\t    next = OPERAND(scan);\t\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t    }\n\t    break;\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t}\n\t    }\n\t    break;\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\t  case END:\n\t    status = RA_MATCH;\t\n\t    break;\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\tif (status != RA_CONT)\n\t    break;\n\tscan = next;\n    } \n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_MOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_MCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_BRCPLX_MORE:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_BRCPLX_LONG:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BRCPLX_SHORT:\n\t    if (status == RA_NOMATCH)\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\t  case RS_NOMATCH:\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\t\trp->rs_state = RS_BEHIND2;\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\t  case RS_BEHIND2:\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n    if (status == RA_CONT)\n\tcontinue;\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n  } \n}",
        "file_name": "326119.sol"
    },
    {
        "function_name": "regmatch",
        "vulnerability": "Buffer overflow",
        "criticism": "The reasoning suggests a potential buffer overflow due to unchecked pointer manipulations. However, the function appears to handle input and line boundaries carefully, and there are checks in place to prevent overflows. The reasoning overstates the risk, and the likelihood of a buffer overflow is low. The severity is low because the function includes mechanisms to handle input safely. Profitability is also low as exploiting this would be difficult and unlikely to yield significant results.",
        "correctness": 4,
        "severity": 2,
        "profitability": 1,
        "reason": "The code does not explicitly check the bounds of buffers when manipulating pointers like 'rex.input' and 'rex.line'. This can potentially lead to a buffer overflow if an attacker can influence the input to exceed expected sizes, allowing for arbitrary code execution or crashing the application.",
        "code": "regmatch(\n    char_u\t*scan,\t\t    \n    proftime_T\t*tm UNUSED,\t    \n    int\t\t*timed_out UNUSED)  \n{\n  char_u\t*next;\t\t\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n  for (;;)\n  {\n    fast_breakcheck();\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\top = OP(scan);\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_BOF:\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case CURSOR:\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_MARK:\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\t\tif (pos == NULL\t\t     \n\t\t\t|| pos->lnum <= 0)   \n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case BOW:\t\n\t    if (c == NUL)\t\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  \n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  \n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case EOW:\t\n\t    if (rex.input == rex.line)    \n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; \n\t  case ANY:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\t\topnd = OPERAND(scan);\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\t\topnd = OPERAND(scan);\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\t  case NOTHING:\n\t    break;\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    status = RA_NOMATCH;\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\t  case MOPEN + 0:   \n\t  case MOPEN + 1:   \n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t}\n\t    }\n\t    break;\n\t  case NOPEN:\t    \n\t  case NCLOSE:\t    \n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\tbreak;\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case MCLOSE + 0:  \n\t  case MCLOSE + 1:  \n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t}\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  \n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\trex.input += len;\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) \n\t\t    next = OPERAND(scan);\t\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t    }\n\t    break;\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t}\n\t    }\n\t    break;\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\t  case END:\n\t    status = RA_MATCH;\t\n\t    break;\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\tif (status != RA_CONT)\n\t    break;\n\tscan = next;\n    } \n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_MOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_MCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_BRCPLX_MORE:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_BRCPLX_LONG:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BRCPLX_SHORT:\n\t    if (status == RA_NOMATCH)\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\t  case RS_NOMATCH:\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\t\trp->rs_state = RS_BEHIND2;\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\t  case RS_BEHIND2:\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n    if (status == RA_CONT)\n\tcontinue;\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n  } \n}",
        "file_name": "326119.sol"
    },
    {
        "function_name": "regmatch",
        "vulnerability": "Use of uninitialized variables",
        "criticism": "The reasoning identifies bl_minval and bl_maxval as potentially uninitialized, which is correct in the context of BRACE_SIMPLE and BRACE_LIMITS operations. However, the function does initialize these variables when they are used, so the risk is overstated. The severity is low because the function logic ensures these variables are set before use. Profitability is also low as exploiting this would be complex and unlikely to yield significant results.",
        "correctness": 5,
        "severity": 2,
        "profitability": 1,
        "reason": "Variables such as 'bl_minval' and 'bl_maxval' might be used without proper initialization, especially in the case of 'BRACE_SIMPLE' and 'BRACE_LIMITS' operations. This can lead to undefined behavior and potential security vulnerabilities if the values are manipulated by an attacker.",
        "code": "regmatch(\n    char_u\t*scan,\t\t    \n    proftime_T\t*tm UNUSED,\t    \n    int\t\t*timed_out UNUSED)  \n{\n  char_u\t*next;\t\t\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n  for (;;)\n  {\n    fast_breakcheck();\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\top = OP(scan);\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_BOF:\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case CURSOR:\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_MARK:\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\t\tif (pos == NULL\t\t     \n\t\t\t|| pos->lnum <= 0)   \n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case BOW:\t\n\t    if (c == NUL)\t\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  \n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  \n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case EOW:\t\n\t    if (rex.input == rex.line)    \n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; \n\t  case ANY:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\t\topnd = OPERAND(scan);\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\t\topnd = OPERAND(scan);\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\t  case NOTHING:\n\t    break;\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    status = RA_NOMATCH;\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\t  case MOPEN + 0:   \n\t  case MOPEN + 1:   \n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t}\n\t    }\n\t    break;\n\t  case NOPEN:\t    \n\t  case NCLOSE:\t    \n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\tbreak;\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case MCLOSE + 0:  \n\t  case MCLOSE + 1:  \n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t}\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  \n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\trex.input += len;\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) \n\t\t    next = OPERAND(scan);\t\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t    }\n\t    break;\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t}\n\t    }\n\t    break;\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\t  case END:\n\t    status = RA_MATCH;\t\n\t    break;\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\tif (status != RA_CONT)\n\t    break;\n\tscan = next;\n    } \n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_MOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_MCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_BRCPLX_MORE:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_BRCPLX_LONG:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BRCPLX_SHORT:\n\t    if (status == RA_NOMATCH)\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\t  case RS_NOMATCH:\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\t\trp->rs_state = RS_BEHIND2;\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\t  case RS_BEHIND2:\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n    if (status == RA_CONT)\n\tcontinue;\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n  } \n}",
        "file_name": "326119.sol"
    },
    {
        "function_name": "regmatch",
        "vulnerability": "Integer overflow",
        "criticism": "The reasoning identifies potential integer overflow issues with regstack.ga_len. However, the function includes checks to prevent excessive memory usage, and the risk of overflow leading to a security issue is low. The severity is low because the function logic includes safeguards against excessive memory usage. Profitability is also low as exploiting this would be complex and unlikely to yield significant results.",
        "correctness": 5,
        "severity": 2,
        "profitability": 1,
        "reason": "The calculation of 'regstack.ga_len' and operations involving this variable do not appear to check for potential integer overflows. This could result in improper memory allocation and potential exploitation by attackers to overwrite memory boundaries.",
        "code": "regmatch(\n    char_u\t*scan,\t\t    \n    proftime_T\t*tm UNUSED,\t    \n    int\t\t*timed_out UNUSED)  \n{\n  char_u\t*next;\t\t\n  int\t\top;\n  int\t\tc;\n  regitem_T\t*rp;\n  int\t\tno;\n  int\t\tstatus;\t\t\n#ifdef FEAT_RELTIME\n  int\t\ttm_count = 0;\n#endif\n  regstack.ga_len = 0;\n  backpos.ga_len = 0;\n  for (;;)\n  {\n    fast_breakcheck();\n#ifdef DEBUG\n    if (scan != NULL && regnarrate)\n    {\n\tmch_errmsg((char *)regprop(scan));\n\tmch_errmsg(\"(\\n\");\n    }\n#endif\n    for (;;)\n    {\n\tif (got_int || scan == NULL)\n\t{\n\t    status = RA_FAIL;\n\t    break;\n\t}\n#ifdef FEAT_RELTIME\n\tif (tm != NULL && ++tm_count == 100)\n\t{\n\t    tm_count = 0;\n\t    if (profile_passed_limit(tm))\n\t    {\n\t\tif (timed_out != NULL)\n\t\t    *timed_out = TRUE;\n\t\tstatus = RA_FAIL;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tstatus = RA_CONT;\n#ifdef DEBUG\n\tif (regnarrate)\n\t{\n\t    mch_errmsg((char *)regprop(scan));\n\t    mch_errmsg(\"...\\n\");\n# ifdef FEAT_SYN_HL\n\t    if (re_extmatch_in != NULL)\n\t    {\n\t\tint i;\n\t\tmch_errmsg(_(\"External submatches:\\n\"));\n\t\tfor (i = 0; i < NSUBEXP; i++)\n\t\t{\n\t\t    mch_errmsg(\"    \\\"\");\n\t\t    if (re_extmatch_in->matches[i] != NULL)\n\t\t\tmch_errmsg((char *)re_extmatch_in->matches[i]);\n\t\t    mch_errmsg(\"\\\"\\n\");\n\t\t}\n\t    }\n# endif\n\t}\n#endif\n\tnext = regnext(scan);\n\top = OP(scan);\n\tif (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI\n\t\t\t     && *rex.input == NUL && rex.lnum <= rex.reg_maxline)\n\t{\n\t    reg_nextline();\n\t}\n\telse if (rex.reg_line_lbr && WITH_NL(op) && *rex.input == '\\n')\n\t{\n\t    ADVANCE_REGINPUT();\n\t}\n\telse\n\t{\n\t  if (WITH_NL(op))\n\t      op -= ADD_NL;\n\t  if (has_mbyte)\n\t      c = (*mb_ptr2char)(rex.input);\n\t  else\n\t      c = *rex.input;\n\t  switch (op)\n\t  {\n\t  case BOL:\n\t    if (rex.input != rex.line)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case EOL:\n\t    if (c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_BOF:\n\t    if (rex.lnum != 0 || rex.input != rex.line\n\t\t\t\t       || (REG_MULTI && rex.reg_firstlnum > 1))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_EOF:\n\t    if (rex.lnum != rex.reg_maxline || c != NUL)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case CURSOR:\n\t    if (rex.reg_win == NULL\n\t\t    || (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t != rex.reg_win->w_cursor.lnum)\n\t\t    || ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t != rex.reg_win->w_cursor.col))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_MARK:\n\t    {\n\t\tint\tmark = OPERAND(scan)[0];\n\t\tint\tcmp = OPERAND(scan)[1];\n\t\tpos_T\t*pos;\n\t\tsize_t\tcol = REG_MULTI ? rex.input - rex.line : 0;\n\t\tpos = getmark_buf(rex.reg_buf, mark, FALSE);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\t\tif (pos == NULL\t\t     \n\t\t\t|| pos->lnum <= 0)   \n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t\telse\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\t\t    if ((pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? (cmp == '<' || cmp == '>')\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? cmp != '>'\n\t\t\t\t\t: cmp != '<'))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? cmp != '>'\n\t\t\t\t    : cmp != '<')))\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t  case RE_VISUAL:\n\t    if (!reg_match_visual())\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_LNUM:\n\t    if (!REG_MULTI || !re_num_cmp((long_u)(rex.lnum + rex.reg_firstlnum),\n\t\t\t\t\t\t\t\t\tscan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COL:\n\t    if (!re_num_cmp((long_u)(rex.input - rex.line) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_VCOL:\n\t    if (!re_num_cmp((long_u)win_linetabsize(\n\t\t\t    rex.reg_win == NULL ? curwin : rex.reg_win,\n\t\t\t    rex.line, (colnr_T)(rex.input - rex.line)) + 1, scan))\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case BOW:\t\n\t    if (c == NUL)\t\n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tif (this_class <= 1)\n\t\t    status = RA_NOMATCH;  \n\t\telse if (reg_prev_class() == this_class)\n\t\t    status = RA_NOMATCH;  \n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(c, rex.reg_buf) || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case EOW:\t\n\t    if (rex.input == rex.line)    \n\t\tstatus = RA_NOMATCH;\n\t    else if (has_mbyte)\n\t    {\n\t\tint this_class, prev_class;\n\t\tthis_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\tprev_class = reg_prev_class();\n\t\tif (this_class == prev_class\n\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else\n\t    {\n\t\tif (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t   && vim_iswordc_buf(c, rex.reg_buf)))\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break; \n\t  case ANY:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case IDENT:\n\t    if (!vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SIDENT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isIDc(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case KWORD:\n\t    if (!vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SKWORD:\n\t    if (VIM_ISDIGIT(*rex.input)\n\t\t\t\t    || !vim_iswordp_buf(rex.input, rex.reg_buf))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case FNAME:\n\t    if (!vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SFNAME:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isfilec(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case PRINT:\n\t    if (!vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case SPRINT:\n\t    if (VIM_ISDIGIT(*rex.input) || !vim_isprintc(PTR2CHAR(rex.input)))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WHITE:\n\t    if (!VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWHITE:\n\t    if (c == NUL || VIM_ISWHITE(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case DIGIT:\n\t    if (!ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NDIGIT:\n\t    if (c == NUL || ri_digit(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEX:\n\t    if (!ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEX:\n\t    if (c == NUL || ri_hex(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case OCTAL:\n\t    if (!ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NOCTAL:\n\t    if (c == NUL || ri_octal(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case WORD:\n\t    if (!ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NWORD:\n\t    if (c == NUL || ri_word(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case HEAD:\n\t    if (!ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NHEAD:\n\t    if (c == NUL || ri_head(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case ALPHA:\n\t    if (!ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NALPHA:\n\t    if (c == NUL || ri_alpha(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case LOWER:\n\t    if (!ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NLOWER:\n\t    if (c == NUL || ri_lower(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case UPPER:\n\t    if (!ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case NUPPER:\n\t    if (c == NUL || ri_upper(c))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case EXACTLY:\n\t    {\n\t\tint\tlen;\n\t\tchar_u\t*opnd;\n\t\topnd = OPERAND(scan);\n\t\tif (*opnd != *rex.input\n\t\t\t&& (!rex.reg_ic\n\t\t\t    || (!enc_utf8\n\t\t\t      && MB_TOLOWER(*opnd) != MB_TOLOWER(*rex.input))))\n\t\t    status = RA_NOMATCH;\n\t\telse if (*opnd == NUL)\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (opnd[1] == NUL && !(enc_utf8 && rex.reg_ic))\n\t\t    {\n\t\t\tlen = 1;\t\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)STRLEN(opnd);\n\t\t\tif (cstrncmp(opnd, rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH\n\t\t\t    && enc_utf8\n\t\t\t    && UTF_COMPOSINGLIKE(rex.input, rex.input + len)\n\t\t\t    && !rex.reg_icombine\n\t\t\t    && OP(next) != RE_COMPOSING)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t    }\n\t\t    if (status != RA_NOMATCH)\n\t\t\trex.input += len;\n\t\t}\n\t    }\n\t    break;\n\t  case ANYOF:\n\t  case ANYBUT:\n\t    if (c == NUL)\n\t\tstatus = RA_NOMATCH;\n\t    else if ((cstrchr(OPERAND(scan), c) == NULL) == (op == ANYOF))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t\tADVANCE_REGINPUT();\n\t    break;\n\t  case MULTIBYTECODE:\n\t    if (has_mbyte)\n\t    {\n\t\tint\ti, len;\n\t\tchar_u\t*opnd;\n\t\tint\topndc = 0, inpc;\n\t\topnd = OPERAND(scan);\n\t\tif ((len = (*mb_ptr2len)(opnd)) < 2)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    break;\n\t\t}\n\t\tif (enc_utf8)\n\t\t    opndc = utf_ptr2char(opnd);\n\t\tif (enc_utf8 && utf_iscomposing(opndc))\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    for (i = 0; rex.input[i] != NUL;\n\t\t\t\t\t\ti += utf_ptr2len(rex.input + i))\n\t\t    {\n\t\t\tinpc = utf_ptr2char(rex.input + i);\n\t\t\tif (!utf_iscomposing(inpc))\n\t\t\t{\n\t\t\t    if (i > 0)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (opndc == inpc)\n\t\t\t{\n\t\t\t    len = i + utfc_ptr2len(rex.input + i);\n\t\t\t    status = RA_MATCH;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    for (i = 0; i < len; ++i)\n\t\t\tif (opnd[i] != rex.input[i])\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    break;\n\t\t\t}\n\t\trex.input += len;\n\t    }\n\t    else\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case RE_COMPOSING:\n\t    if (enc_utf8)\n\t    {\n\t\twhile (utf_iscomposing(utf_ptr2char(rex.input)))\n\t\t    MB_CPTR_ADV(rex.input);\n\t    }\n\t    break;\n\t  case NOTHING:\n\t    break;\n\t  case BACK:\n\t    {\n\t\tint\t\ti;\n\t\tbackpos_T\t*bp;\n\t\tbp = (backpos_T *)backpos.ga_data;\n\t\tfor (i = 0; i < backpos.ga_len; ++i)\n\t\t    if (bp[i].bp_scan == scan)\n\t\t\tbreak;\n\t\tif (i == backpos.ga_len)\n\t\t{\n\t\t    if (ga_grow(&backpos, 1) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tbp = (backpos_T *)backpos.ga_data;\n\t\t\tbp[i].bp_scan = scan;\n\t\t\t++backpos.ga_len;\n\t\t    }\n\t\t}\n\t\telse if (reg_save_equal(&bp[i].bp_pos))\n\t\t    status = RA_NOMATCH;\n\t\tif (status != RA_FAIL && status != RA_NOMATCH)\n\t\t    reg_save(&bp[i].bp_pos, &backpos);\n\t    }\n\t    break;\n\t  case MOPEN + 0:   \n\t  case MOPEN + 1:   \n\t  case MOPEN + 2:\n\t  case MOPEN + 3:\n\t  case MOPEN + 4:\n\t  case MOPEN + 5:\n\t  case MOPEN + 6:\n\t  case MOPEN + 7:\n\t  case MOPEN + 8:\n\t  case MOPEN + 9:\n\t    {\n\t\tno = op - MOPEN;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],\n\t\t\t\t\t\t\t  &rex.reg_startp[no]);\n\t\t}\n\t    }\n\t    break;\n\t  case NOPEN:\t    \n\t  case NCLOSE:\t    \n\t\tif (regstack_push(RS_NOPEN, scan) == NULL)\n\t\t    status = RA_FAIL;\n\t\tbreak;\n#ifdef FEAT_SYN_HL\n\t  case ZOPEN + 1:\n\t  case ZOPEN + 2:\n\t  case ZOPEN + 3:\n\t  case ZOPEN + 4:\n\t  case ZOPEN + 5:\n\t  case ZOPEN + 6:\n\t  case ZOPEN + 7:\n\t  case ZOPEN + 8:\n\t  case ZOPEN + 9:\n\t    {\n\t\tno = op - ZOPEN;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZOPEN, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_startzpos[no],\n\t\t\t\t\t\t\t     &reg_startzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case MCLOSE + 0:  \n\t  case MCLOSE + 1:  \n\t  case MCLOSE + 2:\n\t  case MCLOSE + 3:\n\t  case MCLOSE + 4:\n\t  case MCLOSE + 5:\n\t  case MCLOSE + 6:\n\t  case MCLOSE + 7:\n\t  case MCLOSE + 8:\n\t  case MCLOSE + 9:\n\t    {\n\t\tno = op - MCLOSE;\n\t\tcleanup_subexpr();\n\t\trp = regstack_push(RS_MCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],\n\t\t\t\t\t\t\t    &rex.reg_endp[no]);\n\t\t}\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZCLOSE + 1:  \n\t  case ZCLOSE + 2:\n\t  case ZCLOSE + 3:\n\t  case ZCLOSE + 4:\n\t  case ZCLOSE + 5:\n\t  case ZCLOSE + 6:\n\t  case ZCLOSE + 7:\n\t  case ZCLOSE + 8:\n\t  case ZCLOSE + 9:\n\t    {\n\t\tno = op - ZCLOSE;\n\t\tcleanup_zsubexpr();\n\t\trp = regstack_push(RS_ZCLOSE, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    rp->rs_no = no;\n\t\t    save_se(&rp->rs_un.sesave, &reg_endzpos[no],\n\t\t\t\t\t\t\t      &reg_endzp[no]);\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BACKREF + 1:\n\t  case BACKREF + 2:\n\t  case BACKREF + 3:\n\t  case BACKREF + 4:\n\t  case BACKREF + 5:\n\t  case BACKREF + 6:\n\t  case BACKREF + 7:\n\t  case BACKREF + 8:\n\t  case BACKREF + 9:\n\t    {\n\t\tint\t\tlen;\n\t\tno = op - BACKREF;\n\t\tcleanup_subexpr();\n\t\tif (!REG_MULTI)\t\t\n\t\t{\n\t\t    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tlen = (int)(rex.reg_endp[no] - rex.reg_startp[no]);\n\t\t\tif (cstrncmp(rex.reg_startp[no], rex.input, &len) != 0)\n\t\t\t    status = RA_NOMATCH;\n\t\t    }\n\t\t}\n\t\telse\t\t\t\t\n\t\t{\n\t\t    if (rex.reg_startpos[no].lnum < 0\n\t\t\t\t\t\t|| rex.reg_endpos[no].lnum < 0)\n\t\t    {\n\t\t\tlen = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (rex.reg_startpos[no].lnum == rex.lnum\n\t\t\t\t&& rex.reg_endpos[no].lnum == rex.lnum)\n\t\t\t{\n\t\t\t    len = rex.reg_endpos[no].col\n\t\t\t\t\t\t    - rex.reg_startpos[no].col;\n\t\t\t    if (cstrncmp(rex.line + rex.reg_startpos[no].col,\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\t\tstatus = RA_NOMATCH;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    int r = match_with_backref(\n\t\t\t\t\t    rex.reg_startpos[no].lnum,\n\t\t\t\t\t    rex.reg_startpos[no].col,\n\t\t\t\t\t    rex.reg_endpos[no].lnum,\n\t\t\t\t\t    rex.reg_endpos[no].col,\n\t\t\t\t\t    &len);\n\t\t\t    if (r != RA_MATCH)\n\t\t\t\tstatus = r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\trex.input += len;\n\t    }\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case ZREF + 1:\n\t  case ZREF + 2:\n\t  case ZREF + 3:\n\t  case ZREF + 4:\n\t  case ZREF + 5:\n\t  case ZREF + 6:\n\t  case ZREF + 7:\n\t  case ZREF + 8:\n\t  case ZREF + 9:\n\t    {\n\t\tint\tlen;\n\t\tcleanup_zsubexpr();\n\t\tno = op - ZREF;\n\t\tif (re_extmatch_in != NULL\n\t\t\t&& re_extmatch_in->matches[no] != NULL)\n\t\t{\n\t\t    len = (int)STRLEN(re_extmatch_in->matches[no]);\n\t\t    if (cstrncmp(re_extmatch_in->matches[no],\n\t\t\t\t\t\t\t  rex.input, &len) != 0)\n\t\t\tstatus = RA_NOMATCH;\n\t\t    else\n\t\t\trex.input += len;\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t    }\n\t    break;\n#endif\n\t  case BRANCH:\n\t    {\n\t\tif (OP(next) != BRANCH) \n\t\t    next = OPERAND(scan);\t\n\t\telse\n\t\t{\n\t\t    rp = regstack_push(RS_BRANCH, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t\tstatus = RA_BREAK;\t\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_LIMITS:\n\t    {\n\t\tif (OP(next) == BRACE_SIMPLE)\n\t\t{\n\t\t    bl_minval = OPERAND_MIN(scan);\n\t\t    bl_maxval = OPERAND_MAX(scan);\n\t\t}\n\t\telse if (OP(next) >= BRACE_COMPLEX\n\t\t\t&& OP(next) < BRACE_COMPLEX + 10)\n\t\t{\n\t\t    no = OP(next) - BRACE_COMPLEX;\n\t\t    brace_min[no] = OPERAND_MIN(scan);\n\t\t    brace_max[no] = OPERAND_MAX(scan);\n\t\t    brace_count[no] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    internal_error(\"BRACE_LIMITS\");\n\t\t    status = RA_FAIL;\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_COMPLEX + 0:\n\t  case BRACE_COMPLEX + 1:\n\t  case BRACE_COMPLEX + 2:\n\t  case BRACE_COMPLEX + 3:\n\t  case BRACE_COMPLEX + 4:\n\t  case BRACE_COMPLEX + 5:\n\t  case BRACE_COMPLEX + 6:\n\t  case BRACE_COMPLEX + 7:\n\t  case BRACE_COMPLEX + 8:\n\t  case BRACE_COMPLEX + 9:\n\t    {\n\t\tno = op - BRACE_COMPLEX;\n\t\t++brace_count[no];\n\t\tif (brace_count[no] <= (brace_min[no] <= brace_max[no]\n\t\t\t\t\t     ? brace_min[no] : brace_max[no]))\n\t\t{\n\t\t    rp = regstack_push(RS_BRCPLX_MORE, scan);\n\t\t    if (rp == NULL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\trp->rs_no = no;\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tnext = OPERAND(scan);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\tif (brace_min[no] <= brace_max[no])\n\t\t{\n\t\t    if (brace_count[no] <= brace_max[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_LONG, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    rp->rs_no = no;\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t    next = OPERAND(scan);\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (brace_count[no] <= brace_min[no])\n\t\t    {\n\t\t\trp = regstack_push(RS_BRCPLX_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t  case BRACE_SIMPLE:\n\t  case STAR:\n\t  case PLUS:\n\t    {\n\t\tregstar_T\trst;\n\t\tif (OP(next) == EXACTLY)\n\t\t{\n\t\t    rst.nextb = *OPERAND(next);\n\t\t    if (rex.reg_ic)\n\t\t    {\n\t\t\tif (MB_ISUPPER(rst.nextb))\n\t\t\t    rst.nextb_ic = MB_TOLOWER(rst.nextb);\n\t\t\telse\n\t\t\t    rst.nextb_ic = MB_TOUPPER(rst.nextb);\n\t\t    }\n\t\t    else\n\t\t\trst.nextb_ic = rst.nextb;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.nextb = NUL;\n\t\t    rst.nextb_ic = NUL;\n\t\t}\n\t\tif (op != BRACE_SIMPLE)\n\t\t{\n\t\t    rst.minval = (op == STAR) ? 0 : 1;\n\t\t    rst.maxval = MAX_LIMIT;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rst.minval = bl_minval;\n\t\t    rst.maxval = bl_maxval;\n\t\t}\n\t\trst.count = regrepeat(OPERAND(scan), rst.maxval);\n\t\tif (got_int)\n\t\t{\n\t\t    status = RA_FAIL;\n\t\t    break;\n\t\t}\n\t\tif (rst.minval <= rst.maxval\n\t\t\t  ? rst.count >= rst.minval : rst.count >= rst.maxval)\n\t\t{\n\t\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t\t    {\n\t\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\t\tstatus = RA_FAIL;\n\t\t    }\n\t\t    else if (ga_grow(&regstack, sizeof(regstar_T)) == FAIL)\n\t\t\tstatus = RA_FAIL;\n\t\t    else\n\t\t    {\n\t\t\tregstack.ga_len += sizeof(regstar_T);\n\t\t\trp = regstack_push(rst.minval <= rst.maxval\n\t\t\t\t\t? RS_STAR_LONG : RS_STAR_SHORT, scan);\n\t\t\tif (rp == NULL)\n\t\t\t    status = RA_FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    *(((regstar_T *)rp) - 1) = rst;\n\t\t\t    status = RA_BREAK;\t    \n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    break;\n\t  case NOMATCH:\n\t  case MATCH:\n\t  case SUBPAT:\n\t    rp = regstack_push(RS_NOMATCH, scan);\n\t    if (rp == NULL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\trp->rs_no = op;\n\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\tnext = OPERAND(scan);\n\t    }\n\t    break;\n\t  case BEHIND:\n\t  case NOBEHIND:\n\t    if ((long)((unsigned)regstack.ga_len >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_pattern_uses_more_memory_than_maxmempattern));\n\t\tstatus = RA_FAIL;\n\t    }\n\t    else if (ga_grow(&regstack, sizeof(regbehind_T)) == FAIL)\n\t\tstatus = RA_FAIL;\n\t    else\n\t    {\n\t\tregstack.ga_len += sizeof(regbehind_T);\n\t\trp = regstack_push(RS_BEHIND1, scan);\n\t\tif (rp == NULL)\n\t\t    status = RA_FAIL;\n\t\telse\n\t\t{\n\t\t    save_subexpr(((regbehind_T *)rp) - 1);\n\t\t    rp->rs_no = op;\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t}\n\t    }\n\t    break;\n\t  case BHPOS:\n\t    if (REG_MULTI)\n\t    {\n\t\tif (behind_pos.rs_u.pos.col != (colnr_T)(rex.input - rex.line)\n\t\t\t|| behind_pos.rs_u.pos.lnum != rex.lnum)\n\t\t    status = RA_NOMATCH;\n\t    }\n\t    else if (behind_pos.rs_u.ptr != rex.input)\n\t\tstatus = RA_NOMATCH;\n\t    break;\n\t  case NEWL:\n\t    if ((c != NUL || !REG_MULTI || rex.lnum > rex.reg_maxline\n\t\t\t     || rex.reg_line_lbr)\n\t\t\t\t\t   && (c != '\\n' || !rex.reg_line_lbr))\n\t\tstatus = RA_NOMATCH;\n\t    else if (rex.reg_line_lbr)\n\t\tADVANCE_REGINPUT();\n\t    else\n\t\treg_nextline();\n\t    break;\n\t  case END:\n\t    status = RA_MATCH;\t\n\t    break;\n\t  default:\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Illegal op code %d\\n\", op);\n#endif\n\t    status = RA_FAIL;\n\t    break;\n\t  }\n\t}\n\tif (status != RA_CONT)\n\t    break;\n\tscan = next;\n    } \n    while (regstack.ga_len > 0 && status != RA_FAIL)\n    {\n\trp = (regitem_T *)((char *)regstack.ga_data + regstack.ga_len) - 1;\n\tswitch (rp->rs_state)\n\t{\n\t  case RS_NOPEN:\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_MOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],\n\t\t\t\t\t\t  &rex.reg_startp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZOPEN:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_startzpos[rp->rs_no],\n\t\t\t\t\t\t &reg_startzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_MCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],\n\t\t\t\t\t\t    &rex.reg_endp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#ifdef FEAT_SYN_HL\n\t  case RS_ZCLOSE:\n\t    if (status == RA_NOMATCH)\n\t\trestore_se(&rp->rs_un.sesave, &reg_endzpos[rp->rs_no],\n\t\t\t\t\t\t   &reg_endzp[rp->rs_no]);\n\t    regstack_pop(&scan);\n\t    break;\n#endif\n\t  case RS_BRANCH:\n\t    if (status == RA_MATCH)\n\t\tregstack_pop(&scan);\n\t    else\n\t    {\n\t\tif (status != RA_BREAK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = rp->rs_scan;\n\t\t}\n\t\tif (scan == NULL || OP(scan) != BRANCH)\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    regstack_pop(&scan);\n\t\t}\n\t\telse\n\t\t{\n\t\t    rp->rs_scan = regnext(scan);\n\t\t    reg_save(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(scan);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_BRCPLX_MORE:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\t\n\t    }\n\t    regstack_pop(&scan);\n\t    break;\n\t  case RS_BRCPLX_LONG:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\t--brace_count[rp->rs_no];\n\t\tstatus = RA_CONT;\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BRCPLX_SHORT:\n\t    if (status == RA_NOMATCH)\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t    regstack_pop(&scan);\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tscan = OPERAND(scan);\n\t\tstatus = RA_CONT;\n\t    }\n\t    break;\n\t  case RS_NOMATCH:\n\t    if (status == (rp->rs_no == NOMATCH ? RA_MATCH : RA_NOMATCH))\n\t\tstatus = RA_NOMATCH;\n\t    else\n\t    {\n\t\tstatus = RA_CONT;\n\t\tif (rp->rs_no != SUBPAT)\t\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t    }\n\t    regstack_pop(&scan);\n\t    if (status == RA_CONT)\n\t\tscan = regnext(scan);\n\t    break;\n\t  case RS_BEHIND1:\n\t    if (status == RA_NOMATCH)\n\t    {\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\treg_save(&(((regbehind_T *)rp) - 1)->save_after, &backpos);\n\t\t(((regbehind_T *)rp) - 1)->save_behind = behind_pos;\n\t\tbehind_pos = rp->rs_un.regsave;\n\t\trp->rs_state = RS_BEHIND2;\n\t\treg_restore(&rp->rs_un.regsave, &backpos);\n\t\tscan = OPERAND(rp->rs_scan) + 4;\n\t    }\n\t    break;\n\t  case RS_BEHIND2:\n\t    if (status == RA_MATCH && reg_save_equal(&behind_pos))\n\t    {\n\t\tbehind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\tif (rp->rs_no == BEHIND)\n\t\t    reg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\telse\n\t\t{\n\t\t    status = RA_NOMATCH;\n\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t}\n\t\tregstack_pop(&scan);\n\t\tregstack.ga_len -= sizeof(regbehind_T);\n\t    }\n\t    else\n\t    {\n\t\tlong limit;\n\t\tno = OK;\n\t\tlimit = OPERAND_MIN(rp->rs_scan);\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    if (limit > 0\n\t\t\t    && ((rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t\t    < behind_pos.rs_u.pos.lnum\n\t\t\t\t    ? (colnr_T)STRLEN(rex.line)\n\t\t\t\t    : behind_pos.rs_u.pos.col)\n\t\t\t\t- rp->rs_un.regsave.rs_u.pos.col >= limit))\n\t\t\tno = FAIL;\n\t\t    else if (rp->rs_un.regsave.rs_u.pos.col == 0)\n\t\t    {\n\t\t\tif (rp->rs_un.regsave.rs_u.pos.lnum\n\t\t\t\t\t< behind_pos.rs_u.pos.lnum\n\t\t\t\t|| reg_getline(\n\t\t\t\t\t--rp->rs_un.regsave.rs_u.pos.lnum)\n\t\t\t\t\t\t\t\t  == NULL)\n\t\t\t    no = FAIL;\n\t\t\telse\n\t\t\t{\n\t\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col =\n\t\t\t\t\t\t (colnr_T)STRLEN(rex.line);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t{\n\t\t\t    char_u *line =\n\t\t\t\t  reg_getline(rp->rs_un.regsave.rs_u.pos.lnum);\n\t\t\t    rp->rs_un.regsave.rs_u.pos.col -=\n\t\t\t\t(*mb_head_off)(line, line\n\t\t\t\t    + rp->rs_un.regsave.rs_u.pos.col - 1) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t    --rp->rs_un.regsave.rs_u.pos.col;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (rp->rs_un.regsave.rs_u.ptr == rex.line)\n\t\t\tno = FAIL;\n\t\t    else\n\t\t    {\n\t\t\tMB_PTR_BACK(rex.line, rp->rs_un.regsave.rs_u.ptr);\n\t\t\tif (limit > 0 && (long)(behind_pos.rs_u.ptr\n\t\t\t\t     - rp->rs_un.regsave.rs_u.ptr) > limit)\n\t\t\t    no = FAIL;\n\t\t    }\n\t\t}\n\t\tif (no == OK)\n\t\t{\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\t    scan = OPERAND(rp->rs_scan) + 4;\n\t\t    if (status == RA_MATCH)\n\t\t    {\n\t\t\tstatus = RA_NOMATCH;\n\t\t\trestore_subexpr(((regbehind_T *)rp) - 1);\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    behind_pos = (((regbehind_T *)rp) - 1)->save_behind;\n\t\t    if (rp->rs_no == NOBEHIND)\n\t\t    {\n\t\t\treg_restore(&(((regbehind_T *)rp) - 1)->save_after,\n\t\t\t\t\t\t\t\t    &backpos);\n\t\t\tstatus = RA_MATCH;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (status == RA_MATCH)\n\t\t\t{\n\t\t\t    status = RA_NOMATCH;\n\t\t\t    restore_subexpr(((regbehind_T *)rp) - 1);\n\t\t\t}\n\t\t    }\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regbehind_T);\n\t\t}\n\t    }\n\t    break;\n\t  case RS_STAR_LONG:\n\t  case RS_STAR_SHORT:\n\t    {\n\t\tregstar_T\t    *rst = ((regstar_T *)rp) - 1;\n\t\tif (status == RA_MATCH)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    break;\n\t\t}\n\t\tif (status != RA_BREAK)\n\t\t    reg_restore(&rp->rs_un.regsave, &backpos);\n\t\tfor (;;)\n\t\t{\n\t\t    if (status != RA_BREAK)\n\t\t    {\n\t\t\tif (rp->rs_state == RS_STAR_LONG)\n\t\t\t{\n\t\t\t    if (--rst->count < rst->minval)\n\t\t\t\tbreak;\n\t\t\t    if (rex.input == rex.line)\n\t\t\t    {\n\t\t\t\tif (rex.lnum == 0)\n\t\t\t\t{\n\t\t\t\t    status = RA_NOMATCH;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\t--rex.lnum;\n\t\t\t\trex.line = reg_getline(rex.lnum);\n\t\t\t\tif (rex.line == NULL)\n\t\t\t\t    break;\n\t\t\t\trex.input = rex.line + STRLEN(rex.line);\n\t\t\t\tfast_breakcheck();\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tMB_PTR_BACK(rex.line, rex.input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (rst->count == rst->minval\n\t\t\t\t  || regrepeat(OPERAND(rp->rs_scan), 1L) == 0)\n\t\t\t\tbreak;\n\t\t\t    ++rst->count;\n\t\t\t}\n\t\t\tif (got_int)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t\tstatus = RA_NOMATCH;\n\t\t    if (rst->nextb == NUL || *rex.input == rst->nextb\n\t\t\t\t\t     || *rex.input == rst->nextb_ic)\n\t\t    {\n\t\t\treg_save(&rp->rs_un.regsave, &backpos);\n\t\t\tscan = regnext(rp->rs_scan);\n\t\t\tstatus = RA_CONT;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (status != RA_CONT)\n\t\t{\n\t\t    regstack_pop(&scan);\n\t\t    regstack.ga_len -= sizeof(regstar_T);\n\t\t    status = RA_NOMATCH;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tif (status == RA_CONT || rp == (regitem_T *)\n\t\t\t     ((char *)regstack.ga_data + regstack.ga_len) - 1)\n\t    break;\n    }\n    if (status == RA_CONT)\n\tcontinue;\n    if (regstack.ga_len == 0 || status == RA_FAIL)\n    {\n\tif (scan == NULL)\n\t{\n\t    iemsg(_(e_corrupted_regexp_program));\n#ifdef DEBUG\n\t    printf(\"Premature EOL\\n\");\n#endif\n\t}\n\treturn (status == RA_MATCH);\n    }\n  } \n}",
        "file_name": "326119.sol"
    }
]