[
    {
        "function_name": "_inplace_src_spans",
        "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n    return CAIRO_STATUS_SUCCESS;\n}",
        "vulnerability": "Out-of-bounds access",
        "reason": "The code accesses spans[1] without first ensuring that num_spans is greater than 1. If num_spans is 1, this will result in an out-of-bounds read, which can lead to undefined behavior and potential exploitation by attackers through crafted input.",
        "file_name": "202125.sol"
    },
    {
        "function_name": "_inplace_src_spans",
        "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n    return CAIRO_STATUS_SUCCESS;\n}",
        "vulnerability": "Buffer overflow",
        "reason": "The code increments the pointer 'm' without checking if it exceeds the boundaries of the buffer 'r->_buf'. This can lead to buffer overflow if 'len' is large, allowing attackers to overwrite adjacent memory with the coverage value, potentially leading to arbitrary code execution.",
        "file_name": "202125.sol"
    },
    {
        "function_name": "_inplace_src_spans",
        "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n    return CAIRO_STATUS_SUCCESS;\n}",
        "vulnerability": "Conditional compilation issue",
        "reason": "The code uses conditional compilation with PIXMAN_HAS_OP_LERP without ensuring that the relevant operations are consistently secure across all branches. If different branches exhibit different behavior or vulnerabilities, attackers might exploit these discrepancies, especially if certain operations are less secure than others.",
        "file_name": "202125.sol"
    },
    {
        "function_name": "_inplace_src_spans",
        "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n    return CAIRO_STATUS_SUCCESS;\n}",
        "vulnerability": "Out-of-Bounds Read",
        "reason": "The code does not validate the bounds of the `spans` array. Specifically, accesses like `spans[1].x` assume that there are at least two elements in the `spans` array, which may not be the case. If `num_spans` is 1, this will lead to an out-of-bounds read, potentially exposing memory contents.",
        "file_name": "202125.sol"
    },
    {
        "function_name": "_inplace_src_spans",
        "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n    return CAIRO_STATUS_SUCCESS;\n}",
        "vulnerability": "Out-of-Bounds Write",
        "reason": "The line `*m++ = spans[0].coverage;` writes to `m` without checking if `r->_buf` has enough space to accommodate this write. This can lead to an out-of-bounds write if `r->_buf` is not properly sized, potentially corrupting memory and leading to code execution.",
        "file_name": "202125.sol"
    },
    {
        "function_name": "_inplace_src_spans",
        "code": "_inplace_src_spans (void *abstract_renderer, int y, int h,\n\t\t    const cairo_half_open_span_t *spans,\n\t\t    unsigned num_spans)\n{\n    cairo_image_span_renderer_t *r = abstract_renderer;\n    uint8_t *m;\n    int x0;\n    if (num_spans == 0)\n\treturn CAIRO_STATUS_SUCCESS;\n    x0 = spans[0].x;\n    m = r->_buf;\n    do {\n\tint len = spans[1].x - spans[0].x;\n\tif (len >= r->u.composite.run_length && spans[0].coverage == 0xff) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    pixman_image_composite32 (PIXMAN_OP_SRC,\n\t\t\t\t      r->src, NULL, r->u.composite.dst,\n\t\t\t\t      spans[0].x + r->u.composite.src_x,\n\t\t\t\t      y + r->u.composite.src_y,\n\t\t\t\t      0, 0,\n\t\t\t\t      spans[0].x, y,\n\t\t\t\t      spans[1].x - spans[0].x, h);\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else if (spans[0].coverage == 0x0) {\n\t    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\t\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#else\n\t\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n\t\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t\t  0, 0,\n\t\t\t\t\t  x0, y,\n\t\t\t\t\t  spans[0].x - x0, h);\n#endif\n\t    }\n\t    m = r->_buf;\n\t    x0 = spans[1].x;\n\t} else {\n\t    *m++ = spans[0].coverage;\n\t    if (len > 1) {\n\t\tmemset (m, spans[0].coverage, --len);\n\t\tm += len;\n\t    }\n\t}\n\tspans++;\n    } while (--num_spans > 1);\n    if (spans[0].x != x0) {\n#if PIXMAN_HAS_OP_LERP\n\tpixman_image_composite32 (PIXMAN_OP_LERP_SRC,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#else\n\tpixman_image_composite32 (PIXMAN_OP_OUT_REVERSE,\n\t\t\t\t  r->mask, NULL, r->u.composite.dst,\n\t\t\t\t  0, 0,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n\tpixman_image_composite32 (PIXMAN_OP_ADD,\n\t\t\t\t  r->src, r->mask, r->u.composite.dst,\n\t\t\t\t  x0 + r->u.composite.src_x,\n\t\t\t\t  y + r->u.composite.src_y,\n\t\t\t\t  0, 0,\n\t\t\t\t  x0, y,\n\t\t\t\t  spans[0].x - x0, h);\n#endif\n    }\n    return CAIRO_STATUS_SUCCESS;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The calculation `len = spans[1].x - spans[0].x` can result in an integer overflow if `spans[1].x` is less than `spans[0].x`. This can lead to unexpected behavior in subsequent operations that rely on `len`, such as memory allocations or loops.",
        "file_name": "202125.sol"
    }
]