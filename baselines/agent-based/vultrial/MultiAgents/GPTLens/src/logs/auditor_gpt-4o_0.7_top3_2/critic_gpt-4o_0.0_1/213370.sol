[
    {
        "function_name": "g_socket_client_connected_callback",
        "vulnerability": "Improper error handling",
        "criticism": "The reasoning correctly identifies that the error handling could be improved, especially in the case of canceled connections where errors are cleared without logging. However, the claim that this could lead to exploitation is overstated. While it may hinder debugging, it does not directly expose the system to attacks. The severity is low as it primarily affects debugging and not security. Profitability for an attacker is minimal.",
        "correctness": 7,
        "severity": 2,
        "profitability": 1,
        "reason": "The error handling logic here clears the error without comprehensive logging or corrective measures, especially when the connection is canceled. This can lead to silent failures and loss of debugging information, making it difficult to trace the source of the problem, potentially allowing attackers to exploit unlogged exceptions.",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (data && g_task_return_error_if_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n        }\n      else\n        g_clear_error (&error);\n      if (data)\n        {\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n        }\n      else\n        connection_attempt_unref (attempt);\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      attempt_entry->data = NULL;\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data);\n    }\n}",
        "file_name": "213370.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "vulnerability": "Inadequate protocol validation",
        "criticism": "The reasoning suggests that the code does not adequately validate protocols, which could lead to unexpected behavior. However, the code does check if the connection is TCP-based and handles unsupported protocols by setting an error. The risk of data leakage or manipulation is low because unsupported protocols are not processed further. The severity and profitability are low.",
        "correctness": 5,
        "severity": 3,
        "profitability": 2,
        "reason": "The code assumes that the protocol is valid and supports proxying, but it only checks whether the connection is TCP-based. This oversight may allow attackers to introduce unexpected protocols, potentially leading to data leakage or manipulation if the proxying mechanism is not robustly verified.",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (data && g_task_return_error_if_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n        }\n      else\n        g_clear_error (&error);\n      if (data)\n        {\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n        }\n      else\n        connection_attempt_unref (attempt);\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      attempt_entry->data = NULL;\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data);\n    }\n}",
        "file_name": "213370.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "vulnerability": "Lack of default proxy handling",
        "criticism": "The reasoning points out that there is no fallback if no proxy is available for a protocol. However, the code does handle this by setting an error and moving to the next enumerator. The potential for denial-of-service is minimal as the function does not assume a proxy will always be available. The severity and profitability are low.",
        "correctness": 6,
        "severity": 2,
        "profitability": 1,
        "reason": "The function assumes a proxy will be available for any protocol without a fallback mechanism if `g_proxy_get_default_for_protocol` returns `NULL`. This could lead to failure in establishing a connection without proper fallback or logging, potentially allowing denial-of-service conditions if an attacker can manipulate proxy settings or protocol strings.",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (data && g_task_return_error_if_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n        }\n      else\n        g_clear_error (&error);\n      if (data)\n        {\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n        }\n      else\n        connection_attempt_unref (attempt);\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      attempt_entry->data = NULL;\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data);\n    }\n}",
        "file_name": "213370.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "vulnerability": "Improper error handling",
        "criticism": "This reasoning is similar to the first vulnerability, focusing on error handling. The claim that sensitive error information could be exposed is not well-supported, as errors are cleared or set appropriately. The impact on security is minimal, affecting mainly debugging. The severity and profitability are low.",
        "correctness": 6,
        "severity": 2,
        "profitability": 1,
        "reason": "The error returned by g_socket_connection_connect_finish is not always cleared properly, potentially leaving sensitive error information accessible. This can lead to information disclosure or improper handling of failed connections.",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (data && g_task_return_error_if_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n        }\n      else\n        g_clear_error (&error);\n      if (data)\n        {\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n        }\n      else\n        connection_attempt_unref (attempt);\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      attempt_entry->data = NULL;\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data);\n    }\n}",
        "file_name": "213370.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "vulnerability": "Insecure proxy handling",
        "criticism": "The reasoning suggests that the code does not verify the security of proxies, which could lead to man-in-the-middle attacks. However, the function relies on GLib's proxy mechanisms, which are expected to handle security. The risk is more theoretical unless the underlying library is flawed. The severity is moderate, but profitability is low.",
        "correctness": 5,
        "severity": 4,
        "profitability": 2,
        "reason": "The code attempts to connect using a proxy without verifying the validity or security of the proxy. This could allow an attacker to intercept or manipulate the connection, leading to man-in-the-middle attacks.",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (data && g_task_return_error_if_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n        }\n      else\n        g_clear_error (&error);\n      if (data)\n        {\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n        }\n      else\n        connection_attempt_unref (attempt);\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      attempt_entry->data = NULL;\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data);\n    }\n}",
        "file_name": "213370.sol"
    },
    {
        "function_name": "g_socket_client_connected_callback",
        "vulnerability": "Potential denial of service",
        "criticism": "The reasoning highlights the risk of setting the socket to blocking mode without timeout handling. This could indeed lead to resource exhaustion if exploited. However, the function does manage timeouts earlier, reducing the likelihood of such an attack. The severity is moderate, but profitability is low.",
        "correctness": 7,
        "severity": 5,
        "profitability": 3,
        "reason": "Setting the socket to blocking mode without proper timeout handling can lead to a denial of service. An attacker could potentially exploit this by keeping the connection open and unresponsive, consuming resources and affecting service availability.",
        "code": "g_socket_client_connected_callback (GObject      *source,\n\t\t\t\t    GAsyncResult *result,\n\t\t\t\t    gpointer      user_data)\n{\n  ConnectionAttempt *attempt = user_data;\n  GSocketClientAsyncConnectData *data = attempt->data;\n  GSList *l;\n  GError *error = NULL;\n  GProxy *proxy;\n  const gchar *protocol;\n  if (data && g_task_return_error_if_cancelled (data->task))\n    {\n      g_object_unref (data->task);\n      connection_attempt_unref (attempt);\n      return;\n    }\n  if (attempt->timeout_source)\n    {\n      g_source_destroy (attempt->timeout_source);\n      g_clear_pointer (&attempt->timeout_source, g_source_unref);\n    }\n  if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source),\n\t\t\t\t\t   result, &error))\n    {\n      if (!g_cancellable_is_cancelled (attempt->cancellable))\n        {\n          clarify_connect_error (error, data->connectable, attempt->address);\n          set_last_error (data, error);\n        }\n      else\n        g_clear_error (&error);\n      if (data)\n        {\n          connection_attempt_remove (attempt);\n          enumerator_next_async (data);\n        }\n      else\n        connection_attempt_unref (attempt);\n      return;\n    }\n  data->socket = g_steal_pointer (&attempt->socket);\n  data->connection = g_steal_pointer (&attempt->connection);\n  for (l = data->connection_attempts; l; l = g_slist_next (l))\n    {\n      ConnectionAttempt *attempt_entry = l->data;\n      g_cancellable_cancel (attempt_entry->cancellable);\n      attempt_entry->data = NULL;\n      connection_attempt_unref (attempt_entry);\n    }\n  g_slist_free (data->connection_attempts);\n  data->connection_attempts = NULL;\n  connection_attempt_unref (attempt);\n  g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL);\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection);\n  g_socket_set_blocking (data->socket, TRUE);\n  if (!data->proxy_addr)\n    {\n      g_socket_client_tls_handshake (data);\n      return;\n    }\n  protocol = g_proxy_address_get_protocol (data->proxy_addr);\n  if (!G_IS_TCP_CONNECTION (data->connection))\n    {\n      g_critical (\"Trying to proxy over non-TCP connection, this is \"\n          \"most likely a bug in GLib IO library.\");\n      g_set_error_literal (&data->last_error,\n          G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxying over a non-TCP connection is not supported.\"));\n      enumerator_next_async (data);\n    }\n  else if (g_hash_table_contains (data->client->priv->app_proxies, protocol))\n    {\n      g_socket_client_async_connect_complete (data);\n    }\n  else if ((proxy = g_proxy_get_default_for_protocol (protocol)))\n    {\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection);\n      g_proxy_connect_async (proxy,\n                             data->connection,\n                             data->proxy_addr,\n                             g_task_get_cancellable (data->task),\n                             g_socket_client_proxy_connect_callback,\n                             data);\n      g_object_unref (proxy);\n    }\n  else\n    {\n      g_clear_error (&data->last_error);\n      g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,\n          _(\"Proxy protocol \u201c%s\u201d is not supported.\"),\n          protocol);\n      enumerator_next_async (data);\n    }\n}",
        "file_name": "213370.sol"
    }
]