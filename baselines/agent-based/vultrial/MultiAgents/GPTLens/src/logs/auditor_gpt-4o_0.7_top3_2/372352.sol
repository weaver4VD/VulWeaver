[
    {
        "function_name": "sdb_edit",
        "code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "vulnerability": "Insecure temporary file creation",
        "reason": "The use of mkstemp provides a secure way to create a temporary file by generating a unique filename. However, immediately after its creation, there is no further check on its permissions. If any other process can write to the temporary file, it could lead to a security vulnerability where an attacker could replace the file's content.",
        "file_name": "372352.sol"
    },
    {
        "function_name": "sdb_edit",
        "code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "vulnerability": "Environment variable manipulation",
        "reason": "The code retrieves the editor to be used from the environment variables 'EDITOR' and 'VISUAL'. An attacker could manipulate these environment variables to execute arbitrary commands by setting them to a malicious program or script.",
        "file_name": "372352.sol"
    },
    {
        "function_name": "sdb_edit",
        "code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "vulnerability": "Command injection and unsafe use of system()",
        "reason": "The use of system() with a constructed command string is dangerous as it allows for command injection if the 'editor' variable is manipulated. Even though execlp is used when there's no space in 'editor', the code defaults to system() when there is a space, thus allowing an attacker to execute arbitrary commands if they can control the 'editor' variable.",
        "file_name": "372352.sol"
    },
    {
        "function_name": "sdb_edit",
        "code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "vulnerability": "Insecure Temporary File Creation",
        "reason": "The function uses mkstemp to create a temporary file. While mkstemp itself is secure against race conditions, the temporary file is created in a world-writable directory, /tmp, which can be exploited by an attacker to perform a symlink attack if the permissions on the file are not set correctly after its creation.",
        "file_name": "372352.sol"
    },
    {
        "function_name": "sdb_edit",
        "code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "vulnerability": "Command Injection",
        "reason": "The code uses the environment variables EDITOR and VISUAL to determine which editor to use, and then constructs a command string using sprintf and executes it with system(). If an attacker can control the EDITOR or VISUAL environment variable, they can execute arbitrary commands with the privileges of the running process, leading to a command injection vulnerability.",
        "file_name": "372352.sol"
    },
    {
        "function_name": "sdb_edit",
        "code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code allocates memory based on the length of the file content but does not check whether the file has changed between writing and reading or verify file size assumptions. If an attacker manipulates the file while the program is running, it could lead to a buffer overflow, allowing for potential arbitrary code execution or data corruption.",
        "file_name": "372352.sol"
    }
]