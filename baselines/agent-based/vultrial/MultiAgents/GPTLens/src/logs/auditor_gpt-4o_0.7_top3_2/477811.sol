[
    {
        "function_name": "kvmppc_rtas_hcall",
        "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}",
        "vulnerability": "Out-of-bounds Access",
        "reason": "The function does not adequately verify that 'args.nargs' is within the bounds of 'args.args' before using it to index the array. If 'args.nargs' is greater than or equal to 'ARRAY_SIZE(args.args)', the assignment 'args.rets = &args.args[be32_to_cpu(args.nargs)];' could result in an out-of-bounds access. This could be exploited to read or write beyond the allocated memory, potentially leading to information disclosure or code execution.",
        "file_name": "477811.sol"
    },
    {
        "function_name": "kvmppc_rtas_hcall",
        "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}",
        "vulnerability": "Improper Validation of Guest-controlled Data",
        "reason": "The code reads data from a guest-controlled address 'args_phys' without verifying its validity or ensuring that the read operation retrieves expected data. Similarly, the data is written back to the guest without additional validation post-manipulation. An attacker could manipulate 'args_phys' to cause the hypervisor to read from or write to unintended memory locations, potentially leading to data corruption or privilege escalation.",
        "file_name": "477811.sol"
    },
    {
        "function_name": "kvmppc_rtas_hcall",
        "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}",
        "vulnerability": "Unchecked Function Pointer Dereference",
        "reason": "The function pointer 'd->handler->handler' is called without checking if it is NULL or if it points to a valid function. If an attacker can manipulate 'd' or 'vcpu->kvm->arch.rtas_tokens', they could potentially execute arbitrary code by directing the execution to a crafted function pointer.",
        "file_name": "477811.sol"
    },
    {
        "function_name": "kvmppc_rtas_hcall",
        "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}",
        "vulnerability": "Lack of validation on guest memory read",
        "reason": "The function reads input from guest memory without validating if the address is within a valid range or if the read operation was successful before proceeding. This may lead to reading untrusted data or causing undefined behavior if the address is invalid.",
        "file_name": "477811.sol"
    },
    {
        "function_name": "kvmppc_rtas_hcall",
        "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}",
        "vulnerability": "Potential out-of-bounds access",
        "reason": "The code calculates a pointer based on `args.nargs` without sufficient bounds checking. If `args.nargs` is large enough, it could cause `args.rets` to point outside of the `args.args` array, leading to memory corruption or information leakage.",
        "file_name": "477811.sol"
    },
    {
        "function_name": "kvmppc_rtas_hcall",
        "code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}",
        "vulnerability": "Callback function execution without validation",
        "reason": "A function pointer retrieved from the `rtas_tokens` list is called without validating its legitimacy or checking if the handler is set correctly. This could lead to arbitrary code execution if an attacker can manipulate the `rtas_tokens` list or its entries.",
        "file_name": "477811.sol"
    }
]