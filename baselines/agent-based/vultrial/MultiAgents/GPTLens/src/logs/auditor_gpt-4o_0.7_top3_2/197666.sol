[
    {
        "function_name": "njs_object_iterate_reverse",
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n    value = args->value;\n    from = args->from;\n    to = args->to;\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n        from += 1;\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n                    entry = &prop;\n                }\n                ret = handler(vm, args, entry, from);\n            }\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n                return NJS_ERROR;\n            }\n        }\n        return NJS_OK;\n    }\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n            njs_set_object_value(&string_obj, object);\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n        if ((size_t) length == string_prop.size) {\n            p = string_prop.start + from;\n            i = from + 1;\n            while (i-- > to) {\n                (void) njs_string_new(vm, &character, p, 1, 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p--;\n            }\n        } else {\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n            i = from + 1;\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p = pos;\n            }\n        }\n        return NJS_OK;\n    }\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\nprocess_object:\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n        i = keys->length;\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n            if (idx < to || idx > from) {\n                continue;\n            }\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n        njs_array_destroy(vm, keys);\n        return NJS_OK;\n    }\n    i = from + 1;\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    return NJS_OK;\n}",
        "vulnerability": "Improper bounds checking",
        "reason": "In the iteration over the array, the code assumes that 'from' is always a valid index without proper bounds checking against the actual array length. If 'from' is greater than 'array->length', it may lead to out-of-bounds access, resulting in undefined behavior, potential memory corruption, or information disclosure.",
        "file_name": "197666.sol"
    },
    {
        "function_name": "njs_object_iterate_reverse",
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n    value = args->value;\n    from = args->from;\n    to = args->to;\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n        from += 1;\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n                    entry = &prop;\n                }\n                ret = handler(vm, args, entry, from);\n            }\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n                return NJS_ERROR;\n            }\n        }\n        return NJS_OK;\n    }\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n            njs_set_object_value(&string_obj, object);\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n        if ((size_t) length == string_prop.size) {\n            p = string_prop.start + from;\n            i = from + 1;\n            while (i-- > to) {\n                (void) njs_string_new(vm, &character, p, 1, 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p--;\n            }\n        } else {\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n            i = from + 1;\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p = pos;\n            }\n        }\n        return NJS_OK;\n    }\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\nprocess_object:\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n        i = keys->length;\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n            if (idx < to || idx > from) {\n                continue;\n            }\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n        njs_array_destroy(vm, keys);\n        return NJS_OK;\n    }\n    i = from + 1;\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    return NJS_OK;\n}",
        "vulnerability": "Memory leak",
        "reason": "The code allocates memory for a new object using 'njs_object_value_alloc' but fails to manage its lifecycle properly. If the function returns an error after allocation, the allocated memory is not freed, leading to a memory leak. This could be exploited by repeatedly triggering the error condition to exhaust system resources.",
        "file_name": "197666.sol"
    },
    {
        "function_name": "njs_object_iterate_reverse",
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n    value = args->value;\n    from = args->from;\n    to = args->to;\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n        from += 1;\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n                    entry = &prop;\n                }\n                ret = handler(vm, args, entry, from);\n            }\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n                return NJS_ERROR;\n            }\n        }\n        return NJS_OK;\n    }\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n            njs_set_object_value(&string_obj, object);\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n        if ((size_t) length == string_prop.size) {\n            p = string_prop.start + from;\n            i = from + 1;\n            while (i-- > to) {\n                (void) njs_string_new(vm, &character, p, 1, 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p--;\n            }\n        } else {\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n            i = from + 1;\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p = pos;\n            }\n        }\n        return NJS_OK;\n    }\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\nprocess_object:\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n        i = keys->length;\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n            if (idx < to || idx > from) {\n                continue;\n            }\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n        njs_array_destroy(vm, keys);\n        return NJS_OK;\n    }\n    i = from + 1;\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    return NJS_OK;\n}",
        "vulnerability": "Buffer overflow",
        "reason": "The code assumes 'from' as a valid index for 'string_prop.start' without ensuring it is within bounds. Particularly in the UTF-8 handling section, decrementing 'p' without boundary checks can cause buffer overflow if 'from' exceeds 'string_prop.size'. This can lead to memory corruption, potentially allowing attackers to execute arbitrary code.",
        "file_name": "197666.sol"
    },
    {
        "function_name": "njs_object_iterate_reverse",
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n    value = args->value;\n    from = args->from;\n    to = args->to;\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n        from += 1;\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n                    entry = &prop;\n                }\n                ret = handler(vm, args, entry, from);\n            }\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n                return NJS_ERROR;\n            }\n        }\n        return NJS_OK;\n    }\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n            njs_set_object_value(&string_obj, object);\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n        if ((size_t) length == string_prop.size) {\n            p = string_prop.start + from;\n            i = from + 1;\n            while (i-- > to) {\n                (void) njs_string_new(vm, &character, p, 1, 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p--;\n            }\n        } else {\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n            i = from + 1;\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p = pos;\n            }\n        }\n        return NJS_OK;\n    }\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\nprocess_object:\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n        i = keys->length;\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n            if (idx < to || idx > from) {\n                continue;\n            }\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n        njs_array_destroy(vm, keys);\n        return NJS_OK;\n    }\n    i = from + 1;\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    return NJS_OK;\n}",
        "vulnerability": "Out-of-bounds Read",
        "reason": "The function does not check if 'from' exceeds the string length, potentially allowing 'p' to point outside of the string's memory bounds. This can lead to reading memory beyond the intended buffer, causing undefined behavior and potential information disclosure.",
        "file_name": "197666.sol"
    },
    {
        "function_name": "njs_object_iterate_reverse",
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n    value = args->value;\n    from = args->from;\n    to = args->to;\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n        from += 1;\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n                    entry = &prop;\n                }\n                ret = handler(vm, args, entry, from);\n            }\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n                return NJS_ERROR;\n            }\n        }\n        return NJS_OK;\n    }\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n            njs_set_object_value(&string_obj, object);\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n        if ((size_t) length == string_prop.size) {\n            p = string_prop.start + from;\n            i = from + 1;\n            while (i-- > to) {\n                (void) njs_string_new(vm, &character, p, 1, 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p--;\n            }\n        } else {\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n            i = from + 1;\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p = pos;\n            }\n        }\n        return NJS_OK;\n    }\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\nprocess_object:\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n        i = keys->length;\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n            if (idx < to || idx > from) {\n                continue;\n            }\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n        njs_array_destroy(vm, keys);\n        return NJS_OK;\n    }\n    i = from + 1;\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    return NJS_OK;\n}",
        "vulnerability": "Memory Allocation Failure",
        "reason": "The function allocates memory for 'object' without checking the size of the input value. If 'value' is extremely large, it may lead to memory allocation failure or exhaustion, causing the application to crash or become unresponsive.",
        "file_name": "197666.sol"
    },
    {
        "function_name": "njs_object_iterate_reverse",
        "code": "njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_iterator_handler_t handler)\n{\n    double              idx;\n    int64_t             i, from, to, length;\n    njs_int_t           ret;\n    njs_array_t         *array, *keys;\n    njs_value_t         *entry, *value, prop, character, string_obj;\n    const u_char        *p, *end, *pos;\n    njs_string_prop_t   string_prop;\n    njs_object_value_t  *object;\n    value = args->value;\n    from = args->from;\n    to = args->to;\n    if (njs_is_array(value)) {\n        array = njs_array(value);\n        from += 1;\n        while (from-- > to) {\n            if (njs_slow_path(!array->object.fast_array)) {\n                goto process_object;\n            }\n            if (njs_fast_path(from < array->length\n                              && njs_is_valid(&array->start[from])))\n            {\n                ret = handler(vm, args, &array->start[from], from);\n            } else {\n                entry = njs_value_arg(&njs_value_invalid);\n                ret = njs_value_property_i64(vm, value, from, &prop);\n                if (njs_slow_path(ret != NJS_DECLINED)) {\n                    if (ret == NJS_ERROR) {\n                        return NJS_ERROR;\n                    }\n                    entry = &prop;\n                }\n                ret = handler(vm, args, entry, from);\n            }\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DONE) {\n                    return NJS_DONE;\n                }\n                return NJS_ERROR;\n            }\n        }\n        return NJS_OK;\n    }\n    if (njs_is_string(value) || njs_is_object_string(value)) {\n        if (njs_is_string(value)) {\n            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);\n            if (njs_slow_path(object == NULL)) {\n                return NJS_ERROR;\n            }\n            njs_set_object_value(&string_obj, object);\n            args->value = &string_obj;\n        }\n        else {\n            value = njs_object_value(value);\n        }\n        length = njs_string_prop(&string_prop, value);\n        end = string_prop.start + string_prop.size;\n        if ((size_t) length == string_prop.size) {\n            p = string_prop.start + from;\n            i = from + 1;\n            while (i-- > to) {\n                (void) njs_string_new(vm, &character, p, 1, 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p--;\n            }\n        } else {\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n            i = from + 1;\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {\n                        return NJS_DONE;\n                    }\n                    return NJS_ERROR;\n                }\n                p = pos;\n            }\n        }\n        return NJS_OK;\n    }\n    if (!njs_is_object(value)) {\n        return NJS_OK;\n    }\nprocess_object:\n    if (!njs_fast_object(from - to)) {\n        keys = njs_array_indices(vm, value);\n        if (njs_slow_path(keys == NULL)) {\n            return NJS_ERROR;\n        }\n        i = keys->length;\n        while (i > 0) {\n            idx = njs_string_to_index(&keys->start[--i]);\n            if (idx < to || idx > from) {\n                continue;\n            }\n            ret = njs_iterator_object_handler(vm, handler, args,\n                                              &keys->start[i], idx);\n            if (njs_slow_path(ret != NJS_OK)) {\n                njs_array_destroy(vm, keys);\n                return ret;\n            }\n        }\n        njs_array_destroy(vm, keys);\n        return NJS_OK;\n    }\n    i = from + 1;\n    while (i-- > to) {\n        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    return NJS_OK;\n}",
        "vulnerability": "Unchecked Handler Execution",
        "reason": "The 'handler' function is called with elements from the array without checking if the handler itself is secure. This can lead to arbitrary code execution if a malicious handler is provided, as the function does not validate the handler's integrity or origin.",
        "file_name": "197666.sol"
    }
]