[
    {
        "function_name": "ismt_access",
        "code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\tdesc = &priv->hw[priv->head];\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\treinit_completion(&priv->cmp);\n\tismt_submit_desc(priv);\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\nout:\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\treturn ret;\n}",
        "vulnerability": "Potential Buffer Overflow",
        "reason": "The memcpy function copies data from 'data->block[1]' to 'dma_buffer[1]' without verifying the actual size of 'dma_buffer'. If 'dma_size' is larger than the allocated buffer size, it could lead to a buffer overflow, allowing attackers to overwrite adjacent memory and potentially execute arbitrary code.",
        "file_name": "212083.sol"
    },
    {
        "function_name": "ismt_access",
        "code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\tdesc = &priv->hw[priv->head];\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\treinit_completion(&priv->cmp);\n\tismt_submit_desc(priv);\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\nout:\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\treturn ret;\n}",
        "vulnerability": "Unchecked Data Length",
        "reason": "The 'data->block[0]' is used directly for the length in memcpy without ensuring it's within the bounds of the allocated 'dma_buffer'. If 'data->block[0]' is manipulated to be larger than the buffer can accommodate, it can cause a buffer overflow, leading to memory corruption and potential code execution.",
        "file_name": "212083.sol"
    },
    {
        "function_name": "ismt_access",
        "code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\tdesc = &priv->hw[priv->head];\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\treinit_completion(&priv->cmp);\n\tismt_submit_desc(priv);\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\nout:\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\treturn ret;\n}",
        "vulnerability": "Improper DMA Address Handling",
        "reason": "The DMA address is obtained using 'dma_map_single' but is not properly validated before being used. An attacker could potentially manipulate the system to return a valid DMA address pointing to unintended memory regions, causing unauthorized access or data leakage.",
        "file_name": "212083.sol"
    },
    {
        "function_name": "ismt_access",
        "code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\tdesc = &priv->hw[priv->head];\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\treinit_completion(&priv->cmp);\n\tismt_submit_desc(priv);\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\nout:\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\treturn ret;\n}",
        "vulnerability": "Potential Buffer Overflow",
        "reason": "The function uses memcpy with data from user-controlled input 'data->block' without verifying if the size 'dma_size - 1' fits into the destination buffer 'dma_buffer'. This can lead to buffer overflows, especially if 'dma_buffer' is smaller than 'dma_size'. This vulnerability can be exploited by an attacker to execute arbitrary code or cause a denial of service.",
        "file_name": "212083.sol"
    },
    {
        "function_name": "ismt_access",
        "code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\tdesc = &priv->hw[priv->head];\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\treinit_completion(&priv->cmp);\n\tismt_submit_desc(priv);\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\nout:\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\treturn ret;\n}",
        "vulnerability": "DMA Mapping Error Handling",
        "reason": "The function checks for DMA mapping errors using 'dma_mapping_error', but it does not handle all potential issues. If the mapping is incorrect or if the DMA operation is performed on an invalid address, it could lead to undefined behavior or system crashes. Improper handling of DMA addresses may allow attackers to manipulate data transfer, leading to potential data leakage or corruption.",
        "file_name": "212083.sol"
    },
    {
        "function_name": "ismt_access",
        "code": "static int ismt_access(struct i2c_adapter *adap, u16 addr,\n\t\t       unsigned short flags, char read_write, u8 command,\n\t\t       int size, union i2c_smbus_data *data)\n{\n\tint ret;\n\tunsigned long time_left;\n\tdma_addr_t dma_addr = 0; \n\tu8 dma_size = 0;\n\tenum dma_data_direction dma_direction = 0;\n\tstruct ismt_desc *desc;\n\tstruct ismt_priv *priv = i2c_get_adapdata(adap);\n\tstruct device *dev = &priv->pci_dev->dev;\n\tu8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16);\n\tdesc = &priv->hw[priv->head];\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\tmemset(desc, 0, sizeof(struct ismt_desc));\n\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write);\n\tmemset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32));\n\tif (likely(pci_dev_msi_enabled(priv->pci_dev)))\n\t\tdesc->control = ISMT_DESC_INT | ISMT_DESC_FAIR;\n\telse\n\t\tdesc->control = ISMT_DESC_FAIR;\n\tif ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK)\n\t    && (size != I2C_SMBUS_I2C_BLOCK_DATA))\n\t\tdesc->control |= ISMT_DESC_PEC;\n\tswitch (size) {\n\tcase I2C_SMBUS_QUICK:\n\t\tdev_dbg(dev, \"I2C_SMBUS_QUICK\\n\");\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  WRITE\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE:  READ\\n\");\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = 1;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BYTE_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->byte;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BYTE_DATA:  READ\\n\");\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->rd_len = 1;\n\t\t\tdma_size = 1;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_WORD_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  WRITE\\n\");\n\t\t\tdesc->wr_len_cmd = 3;\n\t\t\tdma_size = 3;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdma_buffer[0] = command;\n\t\t\tdma_buffer[1] = data->word & 0xff;\n\t\t\tdma_buffer[2] = data->word >> 8;\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_WORD_DATA:  READ\\n\");\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= ISMT_DESC_CWRL;\n\t\t\tdesc->rd_len = 2;\n\t\t\tdma_size = 2;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_PROC_CALL\\n\");\n\t\tdesc->wr_len_cmd = 3;\n\t\tdesc->rd_len = 2;\n\t\tdma_size = 3;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tdma_buffer[1] = data->word & 0xff;\n\t\tdma_buffer[2] = data->word >> 8;\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_DATA:\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_BLK;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL);\n\t\t}\n\t\tbreak;\n\tcase I2C_SMBUS_BLOCK_PROC_CALL:\n\t\tdev_dbg(dev, \"I2C_SMBUS_BLOCK_PROC_CALL\\n\");\n\t\tdma_size = I2C_SMBUS_BLOCK_MAX;\n\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1);\n\t\tdesc->wr_len_cmd = data->block[0] + 1;\n\t\tdesc->rd_len = dma_size;\n\t\tdesc->control |= ISMT_DESC_BLK;\n\t\tdma_direction = DMA_BIDIRECTIONAL;\n\t\tdma_buffer[0] = command;\n\t\tmemcpy(&dma_buffer[1], &data->block[1], data->block[0]);\n\t\tbreak;\n\tcase I2C_SMBUS_I2C_BLOCK_DATA:\n\t\tif (data->block[0] < 1)\n\t\t\tdata->block[0] = 1;\n\t\tif (data->block[0] > I2C_SMBUS_BLOCK_MAX)\n\t\t\tdata->block[0] = I2C_SMBUS_BLOCK_MAX;\n\t\tif (read_write == I2C_SMBUS_WRITE) {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\\n\");\n\t\t\tdma_size = data->block[0] + 1;\n\t\t\tdma_direction = DMA_TO_DEVICE;\n\t\t\tdesc->wr_len_cmd = dma_size;\n\t\t\tdesc->control |= ISMT_DESC_I2C;\n\t\t\tdma_buffer[0] = command;\n\t\t\tmemcpy(&dma_buffer[1], &data->block[1], dma_size - 1);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"I2C_SMBUS_I2C_BLOCK_DATA:  READ\\n\");\n\t\t\tdma_size = data->block[0];\n\t\t\tdma_direction = DMA_FROM_DEVICE;\n\t\t\tdesc->rd_len = dma_size;\n\t\t\tdesc->wr_len_cmd = command;\n\t\t\tdesc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL);\n\t\t\tdesc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported transaction %d\\n\",\n\t\t\tsize);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (dma_size != 0) {\n\t\tdev_dbg(dev, \" dev=%p\\n\", dev);\n\t\tdev_dbg(dev, \" data=%p\\n\", data);\n\t\tdev_dbg(dev, \" dma_buffer=%p\\n\", dma_buffer);\n\t\tdev_dbg(dev, \" dma_size=%d\\n\", dma_size);\n\t\tdev_dbg(dev, \" dma_direction=%d\\n\", dma_direction);\n\t\tdma_addr = dma_map_single(dev,\n\t\t\t\t      dma_buffer,\n\t\t\t\t      dma_size,\n\t\t\t\t      dma_direction);\n\t\tif (dma_mapping_error(dev, dma_addr)) {\n\t\t\tdev_err(dev, \"Error in mapping dma buffer %p\\n\",\n\t\t\t\tdma_buffer);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(dev, \" dma_addr = %pad\\n\", &dma_addr);\n\t\tdesc->dptr_low = lower_32_bits(dma_addr);\n\t\tdesc->dptr_high = upper_32_bits(dma_addr);\n\t}\n\treinit_completion(&priv->cmp);\n\tismt_submit_desc(priv);\n\ttime_left = wait_for_completion_timeout(&priv->cmp, HZ*1);\n\tif (dma_size != 0)\n\t\tdma_unmap_single(dev, dma_addr, dma_size, dma_direction);\n\tif (unlikely(!time_left)) {\n\t\tdev_err(dev, \"completion wait timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\tret = ismt_process_desc(desc, data, priv, size, read_write);\nout:\n\tpriv->head++;\n\tpriv->head %= ISMT_DESC_ENTRIES;\n\treturn ret;\n}",
        "vulnerability": "Time-of-check to time-of-use (TOCTOU) race condition",
        "reason": "The use of wait_for_completion_timeout could introduce a race condition. If an attacker can predict or influence the timing of the completion event, they might be able to exploit this race condition to alter the behavior of the system or cause it to process incorrect or malicious data. This can lead to potential data integrity issues or unexpected behavior.",
        "file_name": "212083.sol"
    }
]