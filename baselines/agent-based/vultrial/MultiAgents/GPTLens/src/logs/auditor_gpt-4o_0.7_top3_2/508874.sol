[
    {
        "function_name": "st_select_lex::optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Improper Null Pointer Check",
        "reason": "The code repeatedly assigns and checks `next_unit` without ensuring `un->next_unit()` is non-null. If `un->next_unit()` returns null and `next_unit` is assigned null, it could lead to dereferencing a null pointer, causing a crash or undefined behavior. Proper checks should be performed to ensure `next_unit` is valid before using it.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "st_select_lex::optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Unchecked Function Return Value",
        "reason": "The function `inner_join->optimize()` is called and its return value is used immediately to return from the current function if true, without considering potential error codes or handling different outcomes. Without proper error handling, this could lead to unexpected behavior or security issues if the `optimize()` function fails or returns an error code that needs specific handling.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "st_select_lex::optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Improper Use of Bitwise Operations for Flags",
        "reason": "The code uses bitwise operations to manipulate the `uncacheable` flag without ensuring that the operations do not unintentionally affect other bits. This can lead to logic errors or unintended behavior if other flags are stored within the same variable, resulting in incorrect caching behavior that could be exploited for performance degradation or information leakage.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "st_select_lex::optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Potential null pointer dereference",
        "reason": "The code makes use of pointers like 'un' and 'inner_join' without ensuring they are not null before dereference. If 'first_inner_unit' or 'sl->join' returns null, dereferencing them could lead to a crash, which could be exploited by an attacker to cause a denial of service.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "st_select_lex::optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Unchecked return value",
        "reason": "The function 'inner_join->optimize()' is called, and its return value is checked for success. However, this check is performed after a null check for 'inner_join', but there is no guarantee that 'optimize()' itself handles all failure modes gracefully. This could lead to undefined behavior if 'optimize()' fails in unexpected ways, potentially allowing an attacker to influence query execution.",
        "file_name": "508874.sol"
    },
    {
        "function_name": "st_select_lex::optimize_unflattened_subqueries",
        "code": "bool st_select_lex::optimize_unflattened_subqueries(bool const_only)\n{\n  SELECT_LEX_UNIT *next_unit= NULL;\n  for (SELECT_LEX_UNIT *un= first_inner_unit();\n       un;\n       un= next_unit ? next_unit : un->next_unit())\n  {\n    Item_subselect *subquery_predicate= un->item;\n    next_unit= NULL;\n    if (subquery_predicate)\n    {\n      if (!subquery_predicate->fixed)\n      {\n\tnext_unit= un->next_unit();\n\tun->exclude_level();\n\tif (next_unit)\n\t  continue;\n\tbreak;\n      }\n      if (subquery_predicate->substype() == Item_subselect::IN_SUBS)\n      {\n        Item_in_subselect *in_subs= (Item_in_subselect*) subquery_predicate;\n        if (in_subs->is_jtbm_merged)\n          continue;\n      }\n      if (const_only && !subquery_predicate->const_item())\n      {\n        continue;\n      }\n      bool empty_union_result= true;\n      bool is_correlated_unit= false;\n      bool first= true;\n      bool union_plan_saved= false;\n      for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n      {\n        JOIN *inner_join= sl->join;\n        if (first)\n          first= false;\n        else\n        {\n          if (!union_plan_saved)\n          {\n            union_plan_saved= true;\n            if (un->save_union_explain(un->thd->lex->explain))\n              return true; \n          }\n        }\n        if (!inner_join)\n          continue;\n        SELECT_LEX *save_select= un->thd->lex->current_select;\n        ulonglong save_options;\n        int res;\n        un->set_limit(un->global_parameters());\n        un->thd->lex->current_select= sl;\n        save_options= inner_join->select_options;\n        if (options & SELECT_DESCRIBE)\n        {\n          sl->set_explain_type(FALSE);\n          sl->options|= SELECT_DESCRIBE;\n          inner_join->select_options|= SELECT_DESCRIBE;\n        }\n        if ((res= inner_join->optimize()))\n          return TRUE;\n        if (!inner_join->cleaned)\n          sl->update_used_tables();\n        sl->update_correlated_cache();\n        is_correlated_unit|= sl->is_correlated;\n        inner_join->select_options= save_options;\n        un->thd->lex->current_select= save_select;\n        Explain_query *eq;\n        if ((eq= inner_join->thd->lex->explain))\n        {\n          Explain_select *expl_sel;\n          if ((expl_sel= eq->get_select(inner_join->select_lex->select_number)))\n          {\n            sl->set_explain_type(TRUE);\n            expl_sel->select_type= sl->type;\n          }\n        }\n        if (empty_union_result)\n        {\n          empty_union_result= inner_join->empty_result();\n        }\n        if (res)\n          return TRUE;\n      }\n      if (empty_union_result)\n        subquery_predicate->no_rows_in_result();\n      if (is_correlated_unit)\n      {\n        for (SELECT_LEX *sl= un->first_select(); sl; sl= sl->next_select())\n          sl->uncacheable |= UNCACHEABLE_DEPENDENT;\n      }\n      else\n        un->uncacheable&= ~UNCACHEABLE_DEPENDENT;\n      subquery_predicate->is_correlated= is_correlated_unit;\n    }\n  }\n  return FALSE;\n}",
        "vulnerability": "Inconsistent state restoration",
        "reason": "The code modifies 'inner_join->select_options' and then restores it to 'save_options'. If an error occurs between these two actions, the state may not be properly restored, leading to inconsistent behavior or state leakage. An attacker could exploit this by causing an error during the optimization process, potentially leading to information disclosure or further logical errors.",
        "file_name": "508874.sol"
    }
]