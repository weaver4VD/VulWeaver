[
    {
        "function_name": "r_bin_java_inner_classes_attr_new",
        "vulnerability": "Null Pointer Dereference",
        "criticism": "The reasoning correctly identifies that if 'r_bin_java_default_attr_new' returns NULL, subsequent operations on 'attr' will lead to a null pointer dereference. However, the code does check for 'attr == NULL' immediately after the function call, which means the reasoning is incorrect. The vulnerability is not present as described.",
        "correctness": 2,
        "severity": 1,
        "profitability": 1,
        "reason": "The code does not check if the return value of r_bin_java_default_attr_new is NULL before using it. If this function fails and returns NULL, subsequent operations on 'attr' will lead to a null pointer dereference, potentially causing a crash and denial of service.",
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}",
        "file_name": "477380.sol"
    },
    {
        "function_name": "r_bin_java_inner_classes_attr_new",
        "vulnerability": "Use of Unchecked Return Value",
        "criticism": "The reasoning is partially correct. The code does check if 'icattr->name' is NULL after attempting to retrieve it, and it handles the case by trying another index. However, if both attempts fail, it assigns a default 'NULL' string. The reasoning overstates the risk, as the code does handle the NULL case, albeit not optimally.",
        "correctness": 5,
        "severity": 3,
        "profitability": 2,
        "reason": "The function r_bin_java_get_item_name_from_bin_cp_list can return NULL if the item is not found. The code does not check if icattr->name is NULL after this call before using it, which could lead to dereferencing a NULL pointer and cause a crash.",
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}",
        "file_name": "477380.sol"
    },
    {
        "function_name": "r_bin_java_inner_classes_attr_new",
        "vulnerability": "Memory Leak",
        "criticism": "The reasoning is correct in identifying that 'icattr' is not freed if the loop breaks due to a failure in resolving 'icattr->name'. This can lead to a memory leak if the function is called repeatedly. The vulnerability is accurately described.",
        "correctness": 8,
        "severity": 4,
        "profitability": 3,
        "reason": "In cases where icattr->name cannot be resolved and remains NULL, the function prematurely breaks out of the loop without freeing icattr. This could lead to memory leaks if the function is called repeatedly or in a loop, eventually exhausting system resources.",
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}",
        "file_name": "477380.sol"
    },
    {
        "function_name": "r_bin_java_inner_classes_attr_new",
        "vulnerability": "Integer Overflow Leading to Buffer Overflow",
        "criticism": "The reasoning correctly identifies a potential integer overflow in the condition 'buf_offset + offset + 8 > sz'. However, the likelihood of this overflow occurring in practice is low due to the use of 'ut64' for offsets, which provides a large range. The severity and profitability are overstated.",
        "correctness": 7,
        "severity": 3,
        "profitability": 2,
        "reason": "The condition checks if the buffer offset plus a constant is greater than the buffer size. However, if 'buf_offset + offset + 8' overflows, it could bypass this check, potentially leading to reading or writing out-of-bounds memory, which can be exploited by an attacker to manipulate memory, causing unexpected behavior or system crashes.",
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}",
        "file_name": "477380.sol"
    },
    {
        "function_name": "r_bin_java_inner_classes_attr_new",
        "vulnerability": "Use of NULL Pointers",
        "criticism": "The reasoning correctly identifies that 'r_str_dup(NULL, \"NULL\")' is problematic if 'r_str_dup' does not handle NULL pointers safely. However, the impact depends on the implementation of 'r_str_dup'. The reasoning is valid but lacks context on the function's behavior.",
        "correctness": 7,
        "severity": 4,
        "profitability": 3,
        "reason": "This line attempts to duplicate a string from a NULL pointer, which can lead to unexpected behavior or crashes. If 'r_str_dup' is not designed to handle NULL pointers safely, it could result in memory corruption or segmentation faults, potentially exploitable by an attacker.",
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}",
        "file_name": "477380.sol"
    },
    {
        "function_name": "r_bin_java_inner_classes_attr_new",
        "vulnerability": "Unchecked NULL Pointer Dereference",
        "criticism": "The reasoning is incorrect. The code does check if 'obj' is NULL after retrieving it from the list and handles the case by attempting to retrieve another object. The vulnerability is not present as described.",
        "correctness": 2,
        "severity": 1,
        "profitability": 1,
        "reason": "The code retrieves an object from a list and checks if it is NULL, but it proceeds to use the object without handling the NULL case. This can lead to a NULL pointer dereference, causing the program to crash or behave unexpectedly, which can be leveraged by attackers to disrupt service or execute arbitrary code.",
        "code": "R_API RBinJavaAttrInfo *r_bin_java_inner_classes_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaClassesAttribute *icattr;\n\tRBinJavaAttrInfo *attr = NULL;\n\tRBinJavaCPTypeObj *obj;\n\tut32 i = 0;\n\tut64 offset = 0, curpos;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (buf_offset + offset + 8 > sz) {\n\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\treturn NULL;\n\t}\n\tif (attr == NULL) {\n\t\treturn attr;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_INNER_CLASSES_ATTR;\n\tattr->info.inner_classes_attr.number_of_classes = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.inner_classes_attr.classes = r_list_newf (r_bin_java_inner_classes_attr_entry_free);\n\tfor (i = 0; i < attr->info.inner_classes_attr.number_of_classes; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tif (buf_offset + offset + 8 > sz) {\n\t\t\teprintf (\"Invalid amount of inner classes\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ticattr = R_NEW0 (RBinJavaClassesAttribute);\n\t\tif (!icattr) {\n\t\t\tbreak;\n\t\t}\n\t\ticattr->inner_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->outer_class_info_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_name_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->inner_class_access_flags = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\ticattr->flags_str = retrieve_class_method_access_string (icattr->inner_class_access_flags);\n\t\ticattr->file_offset = curpos;\n\t\ticattr->size = 8;\n\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_name_idx);\n\t\tif (obj == NULL) {\n\t\t\teprintf (\"BINCPLIS IS HULL %d\\n\", icattr->inner_name_idx);\n\t\t}\n\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\tif (!icattr->name) {\n\t\t\tobj = r_bin_java_get_item_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, icattr->inner_class_info_idx);\n\t\t\tif (!obj) {\n\t\t\t\teprintf (\"BINCPLIST IS NULL %d\\n\", icattr->inner_class_info_idx);\n\t\t\t}\n\t\t\ticattr->name = r_bin_java_get_item_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, obj);\n\t\t\tif (!icattr->name) {\n\t\t\t\ticattr->name = r_str_dup (NULL, \"NULL\");\n\t\t\t\teprintf (\"r_bin_java_inner_classes_attr: Unable to find the name for %d index.\\n\", icattr->inner_name_idx);\n\t\t\t\tfree (icattr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tIFDBG eprintf(\"r_bin_java_inner_classes_attr: Inner class name %d is %s.\\n\", icattr->inner_name_idx, icattr->name);\n\t\tr_list_append (attr->info.inner_classes_attr.classes, (void *) icattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}",
        "file_name": "477380.sol"
    }
]