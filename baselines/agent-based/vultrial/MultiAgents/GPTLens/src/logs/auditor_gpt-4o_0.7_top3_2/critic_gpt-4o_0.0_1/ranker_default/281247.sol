[
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Heap-based Buffer Overflow",
        "criticism": "The reasoning correctly identifies a potential heap-based buffer overflow due to the lack of validation on 'header->ordnum'. However, the code does check if 'header->ordnum' is within a reasonable limit by ensuring it does not exceed 'MP_MAXINS'. The vulnerability is plausible but not as severe as described because there is some level of validation. The potential for arbitrary code execution is low without further exploitation vectors.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The code allocates memory for 'orders' based on 'header->ordnum', which is directly read from the file. If 'header->ordnum' is larger than expected, reading data into 'orders' without proper validation can cause a buffer overflow, leading to memory corruption or arbitrary code execution.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol",
        "final_score": 5.75
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Improper Validation of Index",
        "criticism": "The reasoning correctly identifies a potential issue with the use of 'pi' to determine 'chn', which is used as an index. However, the code does perform some checks to ensure 'chn' does not exceed 'header->channum'. The risk of out-of-bounds access is present but mitigated by these checks. The potential for arbitrary code execution is low without further exploitation vectors.",
        "correctness": 7,
        "severity": 5,
        "profitability": 4,
        "reason": "The code uses 'pi' to determine 'chn', which is then used as an index to access the 'pattern' array. There is insufficient validation to ensure 'chn' is within bounds, which could lead to an out-of-bounds access if 'pi' is manipulated by an attacker, potentially leading to arbitrary code execution.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol",
        "final_score": 5.75
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Integer Overflow Leading to Out-of-Bounds Access",
        "criticism": "The reasoning is partially correct. While 'header->insnum' is used to allocate memory, the code does check if 'header->insnum' exceeds 'MP_MAXINS', which mitigates the risk of integer overflow. However, if 'MP_MAXINS' is not properly defined, there could still be a risk. The potential for information leakage or denial of service is present but limited by the existing checks.",
        "correctness": 6,
        "severity": 4,
        "profitability": 3,
        "reason": "The variable 'header->insnum' is read from the file and used to allocate memory for 'insParaPtrs'. If 'header->insnum' is too large, it can cause an integer overflow when computing the allocation size, resulting in out-of-bounds access during 'f.readWords'. This can be exploited to leak information or cause a denial of service.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol",
        "final_score": 4.75
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Potential Out-of-Bounds Write",
        "criticism": "The reasoning is similar to the first vulnerability regarding 'ordnum'. The code does allocate memory based on 'header->ordnum', but it also checks if 'header->ordnum' is within a reasonable limit. The risk of out-of-bounds write is mitigated by these checks, making the vulnerability less severe than described.",
        "correctness": 6,
        "severity": 4,
        "profitability": 3,
        "reason": "The code reads 'ordnum' from the file and uses it to allocate memory for 'orders'. There is no check to ensure 'ordnum' is within a reasonable limit, which could lead to an out-of-bounds write if 'ordnum' is larger than expected or corrupted. This can be exploited by an attacker to execute arbitrary code.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol",
        "final_score": 4.75
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Potential Integer Overflow",
        "criticism": "The reasoning is similar to the second vulnerability regarding 'insnum'. The code checks if 'insnum' exceeds 'MP_MAXINS', which reduces the risk of integer overflow. However, if 'MP_MAXINS' is not properly defined, there could still be a risk. The potential for memory corruption is present but limited by the existing checks.",
        "correctness": 6,
        "severity": 4,
        "profitability": 3,
        "reason": "The code reads 'insnum' from the file and uses it to allocate memory for 'insParaPtrs'. If 'insnum' is extremely large, it could cause an integer overflow when calculating the size of the allocation, leading to a smaller buffer than expected. Subsequent operations could then lead to memory corruption.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol",
        "final_score": 4.75
    },
    {
        "function_name": "LoaderS3M::load",
        "vulnerability": "Improper Handling of Memory Allocation Failure",
        "criticism": "The reasoning is incorrect. The code does check for allocation failure immediately after attempting to allocate memory for 'pattern'. The check is performed correctly, and subsequent operations on 'pattern' are guarded by this check. Therefore, the described vulnerability does not exist.",
        "correctness": 2,
        "severity": 1,
        "profitability": 1,
        "reason": "The pattern array is allocated with a fixed size, but the allocation failure check is performed after the allocation. If the allocation fails and 'pattern' is NULL, subsequent operations on 'pattern' can lead to undefined behavior, potentially allowing an attacker to crash the application or execute arbitrary code.",
        "code": "mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module)\n{\t\n\tmodule->cleanUp();\n\tTXMHeader*\t\theader = &module->header;\n\tTXMInstrument*\tinstr  = module->instr;\n\tTXMSample*\t\tsmp\t   = module->smp;\n\tTXMPattern*\t\tphead  = module->phead;\t\n\tif (!phead || !instr || !smp)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.read(&header->name,1,28);\n\theader->whythis1a = f.readByte();\n\tif (f.readByte() != 16) \n\t\treturn MP_LOADER_FAILED;\t\n\tf.readByte(); \n\tf.readByte(); \n\theader->ordnum = f.readWord(); \n\tmp_ubyte* orders = new mp_ubyte[header->ordnum];\n\tif (orders == NULL) \n\t\treturn MP_OUT_OF_MEMORY;\n\theader->insnum = f.readWord(); \n\tif (header->insnum > MP_MAXINS)\n\t\treturn MP_LOADER_FAILED;\n\theader->patnum = f.readWord(); \n\tif (header->patnum > 256)\n\t\treturn MP_LOADER_FAILED;\n\tmp_sint32 flags = f.readWord(); \n\tmp_sint32 Cvt = f.readWord();\n\theader->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS;\n\tif (Cvt == 0x1300 || (flags & 64))\n\t\theader->flags |= module->MODULE_OLDS3MVOLSLIDES;\n\theader->flags |= module->MODULE_ST3NOTECUT;\n\tf.readWord();\n\tf.read(header->sig,1,4);\n\theader->mainvol = module->vol64to255(f.readByte()); \n\theader->tempo = f.readByte(); \n\theader->speed = f.readByte(); \n\tf.readByte(); \n\tf.readByte(); \n\tf.readByte();\n\tf.readDword();\t\n\tf.readDword();\t\n\tf.readWord();\t\n\tmp_ubyte channelSettings[32];\n\tf.read(channelSettings,1,32);\n\tmp_sint32 numChannels = 0;\n\tfor (numChannels = 0; numChannels < 32; numChannels++)\n\t\tif (channelSettings[numChannels] == 255)\n\t\t\tbreak;\n\theader->channum = numChannels; \n\tf.read(orders,1,header->ordnum);\n\tmp_sint32 j = 0, i = 0;\n\tfor (i = 0; i < header->ordnum; i++)\n\t{\n\t\tif (orders[i] == 255) \n\t\t\tbreak;\n\t\theader->ord[j++] = orders[i];\t\t\n\t}\n\theader->ordnum = j; \n\tdelete[] orders;\n\tmp_uword* insParaPtrs = new mp_uword[header->insnum];\n\tif (insParaPtrs == NULL)\n\t\treturn MP_OUT_OF_MEMORY;\n\tf.readWords(insParaPtrs,header->insnum);\n\tmp_uword* patParaPtrs = new mp_uword[header->patnum];\n\tif (patParaPtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tf.readWords(patParaPtrs,header->patnum);\n\tmp_uint32* samplePtrs = new mp_uint32[header->insnum];\n\tif (samplePtrs == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmemset(samplePtrs,0,sizeof(mp_uint32)*header->insnum);\n\tmp_sint32 s = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 insOffs = insParaPtrs[i]*16;\n\t\tif (insOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(insOffs);\n\t\t\tmp_ubyte type = f.readByte();\n\t\t\tif (type == 1)\n\t\t\t{\n\t\t\t\tf.read(smp[s].name,1,12);\t\n\t\t\t\tmp_ubyte bOffs = f.readByte();\n\t\t\t\tmp_uword wOffs = f.readWord();\n\t\t\t\tsamplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16;\n\t\t\t\tsmp[s].flags = 1;\n\t\t\t\tsmp[s].pan = 0x80;\n\t\t\t\tsmp[s].samplen = f.readDword();\n\t\t\t\tsmp[s].loopstart = f.readDword();\n\t\t\t\tmp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart);\n\t\t\t\tif (looplen < 0) \n\t\t\t\t\tlooplen = 0;\n\t\t\t\tsmp[s].looplen = looplen;\n\t\t\t\tsmp[s].vol = module->vol64to255(f.readByte());\n\t\t\t\tf.readByte(); \n\t\t\t\tsmp[s].res = f.readByte() == 0x04 ? 0xAD : 0; \n\t\t\t\tmp_ubyte flags = f.readByte();\n\t\t\t\tif (flags & 1)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type = 1;\t\n\t\t\t\t}\n\t\t\t\tif (flags & 4)\n\t\t\t\t{\n\t\t\t\t\tsmp[s].type |= 16;\n\t\t\t\t\tsmp[s].samplen >>= 1;\n\t\t\t\t\tsmp[s].loopstart >>= 1;\n\t\t\t\t\tsmp[s].looplen >>= 1;\n\t\t\t\t}\n\t\t\t\tmp_uint32 c4spd = f.readDword();\n\t\t\t\tXModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote);\n#ifdef VERBOSE\n\t\t\t\tprintf(\"%i, %i\\n\",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune));\t\t\t\t\n#endif\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t\tif (samplePtrs[i] && smp[s].samplen)\n\t\t\t\t{\n\t\t\t\t\tinstr[i].samp=1;\n\t\t\t\t\tfor (j=0;j<120;j++) \n\t\t\t\t\t\tinstr[i].snum[j] = s;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type == 0)\n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t\tmp_ubyte buffer[12];\n\t\t\t\tf.read(buffer,1,12);\t\n\t\t\t\tf.readByte();\n\t\t\t\tf.readWord();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readByte();\n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte(); \n\t\t\t\tf.readByte();\n\t\t\t\tf.readDword();\n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.readDword(); \n\t\t\t\tf.read(instr[i].name,1,28); \n\t\t\t\tf.readDword(); \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsamplePtrs[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmp_ubyte* pattern = new mp_ubyte[64*32*5];\n\tif (pattern == NULL)\n\t{\n\t\tdelete[] insParaPtrs;\n\t\tdelete[] patParaPtrs;\n\t\tdelete[] samplePtrs;\n\t\treturn MP_OUT_OF_MEMORY;\n\t}\n\tmp_uint32 songMaxChannels = 1;\n\tfor (i = 0; i < header->patnum; i++)\n\t{\n\t\tfor (j = 0; j < 32*64; j++)\n\t\t{\n\t\t\tpattern[j*5] = 0xFF;\n\t\t\tpattern[j*5+1] = 0;\n\t\t\tpattern[j*5+2] = 0xFF;\n\t\t\tpattern[j*5+3] = 0xFF;\n\t\t\tpattern[j*5+4] = 0;\n\t\t}\n\t\tmp_uint32 patOffs = patParaPtrs[i]*16;\n\t\tmp_uint32 maxChannels = 1;\t\t\t\n\t\tif (patOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(patOffs);\n\t\t\tmp_uint32 size = f.readWord();\n\t\t\tif (size > 2)\n\t\t\t{\n\t\t\t\tsize-=2;\n\t\t\t\tmp_ubyte* packed = new mp_ubyte[size+5];\n\t\t\t\tif (packed == NULL)\n\t\t\t\t{\n\t\t\t\t\tdelete[] insParaPtrs;\n\t\t\t\t\tdelete[] patParaPtrs;\n\t\t\t\t\tdelete[] samplePtrs;\n\t\t\t\t\tdelete[] pattern;\n\t\t\t\t\treturn MP_OUT_OF_MEMORY;\t\t\t\t\n\t\t\t\t}\n\t\t\t\tmemset(packed, 0, size);\n\t\t\t\tf.read(packed, 1, size);\n\t\t\t\tmp_uint32 index = 0;\n\t\t\t\tmp_uint32 row = 0;\n\t\t\t\twhile (index<size)\n\t\t\t\t{\n\t\t\t\t\tmp_ubyte pi = safeRead(packed, index, size);\n\t\t\t\t\tif (pi == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\trow++;\n\t\t\t\t\t\tif (row >= 64)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i = 0;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmp_uint32 chn = pi&31;\n\t\t\t\t\tif (chn>maxChannels && (pi & (32+64+128)))\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxChannels = chn;\n\t\t\t\t\t}\n\t\t\t\t\tmp_ubyte* slot = pattern+(row*32*5)+chn*5;\n\t\t\t\t\tif (pi & 32)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[0] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[1] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 64)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[2] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t}\n\t\t\t\t\tif (pi & 128)\n\t\t\t\t\t{\n\t\t\t\t\t\tslot[3] = safeRead(packed, index, size, 0xFF);\n\t\t\t\t\t\tslot[4] = safeRead(packed, index, size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmaxChannels++;\n\t\t\t\tif (maxChannels > header->channum)\n\t\t\t\t\tmaxChannels = header->channum;\n\t\t\t\tdelete[] packed;\n\t\t\t}\n\t\t\tif (maxChannels > songMaxChannels)\n\t\t\t\tsongMaxChannels = maxChannels;\n\t\t}\n\t\tconvertS3MPattern(&phead[i], pattern, maxChannels, i);\n\t}\n\tif (header->channum > songMaxChannels)\n\t\theader->channum = songMaxChannels;\n\tdelete[] pattern;\n\tdelete[] insParaPtrs;\n\tdelete[] patParaPtrs;\n\ts = 0;\n\tfor (i = 0; i < header->insnum; i++)\n\t{\n\t\tmp_uint32 smpOffs = samplePtrs[i];\n\t\tif (smpOffs)\n\t\t{\n\t\t\tf.seekWithBaseOffset(smpOffs);\n\t\t\tif (!smp[s].samplen)\n\t\t\t\tcontinue;\n\t\t\tbool adpcm = (smp[s].res == 0xAD);\n\t\t\tmp_sint32 result = module->loadModuleSample(f, s, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED, \n\t\t\t\t\t\t\t\t\t\t  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED));\n\t\t\tif (result != MP_OK)\n\t\t\t{\n\t\t\t\tdelete[] samplePtrs;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (adpcm)\n\t\t\t\tsmp[s].res = 0;\t\t\t\n\t\t\ts++;\n\t\t}\n\t}\n\tdelete[] samplePtrs;\n\theader->smpnum = s;\n\tstrcpy(header->tracker,\"Screamtracker 3\");\n\tmodule->setDefaultPanning();\n\tmodule->postProcessSamples();\n\treturn MP_OK;\t\n}",
        "file_name": "281247.sol",
        "final_score": 1.5
    }
]