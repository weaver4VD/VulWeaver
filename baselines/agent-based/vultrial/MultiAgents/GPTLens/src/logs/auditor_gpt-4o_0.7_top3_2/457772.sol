[
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The code calculates `copy_len` as `len - 24 + 1` and then copies `copy_len` bytes from `input` to `url->errormsg` using `memcpy`. However, if `copy_len` is greater than the size of `url->errormsg`, it could lead to a buffer overflow, allowing an attacker to overwrite adjacent memory, potentially leading to arbitrary code execution.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The value of `limit` is directly added to the current time using `time(NULL) + limit` without any boundary checks. If `limit` is a large positive value, this could cause an integer overflow, resulting in an incorrect `discon_time` value that could disrupt the application's logic or security constraints.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Authentication Bypass",
        "reason": "The code marks the client as authenticated if the header matches `url->auth_header`. This simplistic comparison does not involve any cryptographic verification or secure token exchange, making it susceptible to spoofing attacks where an attacker could manipulate request headers to impersonate an authenticated user.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Integer Overflow",
        "reason": "The use of 'sscanf' to parse an unsigned integer from user-controlled input (the timelimit header) can lead to an integer overflow if a large value is provided. This can cause unexpected behavior when calculating 'client->con->discon_time', potentially allowing attackers to set unintended disconnection times.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The calculation of 'copy_len' is based on 'len - 24 + 1', which does not account for the null terminator properly when copying data to 'url->errormsg'. If 'copy_len' exceeds the size of 'url->errormsg', it can lead to a buffer overflow, allowing an attacker to overwrite adjacent memory.",
        "file_name": "457772.sol"
    },
    {
        "function_name": "handle_returned_header",
        "code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t len = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client) {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (url->auth_header && len >= url->auth_header_len && strncasecmp(ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (url->timelimit_header && len > url->timelimit_header_len && strncasecmp(ptr, url->timelimit_header, url->timelimit_header_len) == 0) {\n            const char *input = ptr;\n            unsigned int limit = 0;\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += url->timelimit_header_len;\n                if (sscanf(input, \"%u\\r\\n\", &limit) == 1) {\n                    client->con->discon_time = time(NULL) + limit;\n                } else {\n                    ICECAST_LOG_ERROR(\"Auth backend returned invalid timeline header: Can not parse limit\");\n                }\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid timelimit header.\");\n            }\n        }\n        if (len > 24 && strncasecmp(ptr, \"icecast-auth-message: \", 22) == 0) {\n            const char *input = ptr;\n            size_t copy_len = len - 24 + 1; \n            if (copy_len > sizeof(url->errormsg)) {\n                copy_len = sizeof(url->errormsg);\n            }\n            if (len >= 2 && input[len - 2] == '\\r' && input[len - 1] == '\\n') {\n                input += 22;\n                memcpy(url->errormsg, input, copy_len);\n                url->errormsg[copy_len-1] = 0;\n            } else {\n                ICECAST_LOG_ERROR(\"Auth backend returned invalid message header.\");\n            }\n        }\n    }\n    return len;\n}",
        "vulnerability": "Improper Authentication Validation",
        "reason": "The authentication check using 'strncasecmp' only checks for a case-insensitive match on a portion of the header without validating the entire context or ensuring the header is not part of a larger, potentially malicious payload. This could potentially allow unauthorized access if the header is spoofed correctly.",
        "file_name": "457772.sol"
    }
]