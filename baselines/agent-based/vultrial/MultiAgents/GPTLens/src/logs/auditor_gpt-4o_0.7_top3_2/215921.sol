[
    {
        "function_name": "bmexec_trans",
        "code": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n  if (size > 12 * len)\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n  return -1;\n}",
        "vulnerability": "Null Pointer Dereference",
        "reason": "The code does not check if 'kwset' is NULL before dereferencing it to access 'kwset->mind'. If 'kwset' is NULL, this will lead to a null pointer dereference, potentially causing a crash or unexpected behavior. This issue can be exploited to cause a denial of service.",
        "file_name": "215921.sol"
    },
    {
        "function_name": "bmexec_trans",
        "code": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n  if (size > 12 * len)\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n  return -1;\n}",
        "vulnerability": "Out-of-Bounds Read",
        "reason": "The code uses 'tp[-1]' without bounds checking, which can lead to an out-of-bounds read if 'tp' is at the start of 'text'. This can be exploited to read memory contents outside the intended buffer, potentially exposing sensitive information.",
        "file_name": "215921.sol"
    },
    {
        "function_name": "bmexec_trans",
        "code": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n  if (size > 12 * len)\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n  return -1;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The loop increments 'tp' and then accesses 'tp[-1]' without ensuring that 'tp' remains within the bounds of 'text'. This can lead to a buffer overflow, allowing an attacker to overwrite memory beyond the allocated buffer, potentially leading to arbitrary code execution.",
        "file_name": "215921.sol"
    },
    {
        "function_name": "bmexec_trans",
        "code": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n  if (size > 12 * len)\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n  return -1;\n}",
        "vulnerability": "Out-of-bounds read",
        "reason": "The expression `d1[U(tp[-1])]` accesses the `d1` array using an index derived from `tp[-1]`. If `tp` is not properly bounded within `text`, this can lead to out-of-bounds reads, potentially exposing memory contents or causing a segmentation fault.",
        "file_name": "215921.sol"
    },
    {
        "function_name": "bmexec_trans",
        "code": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n  if (size > 12 * len)\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n  return -1;\n}",
        "vulnerability": "Incorrect pointer arithmetic",
        "reason": "The operation `tp = memchr_kwset (tp, text + size - tp, kwset);` assumes `tp` is within valid bounds. If `tp` is already near or beyond `text + size`, this can lead to incorrect memory access or segmentation faults. Improper bounds checking before this operation can be exploited to read or write beyond allocated memory.",
        "file_name": "215921.sol"
    },
    {
        "function_name": "bmexec_trans",
        "code": "bmexec_trans (kwset_t kwset, char const *text, size_t size)\n{\n  unsigned char const *d1;\n  char const *ep, *sp, *tp;\n  int d;\n  int len = kwset->mind;\n  char const *trans = kwset->trans;\n  if (len == 0)\n    return 0;\n  if (len > size)\n    return -1;\n  if (len == 1)\n    {\n      tp = memchr_kwset (text, size, kwset);\n      return tp ? tp - text : -1;\n    }\n  d1 = kwset->delta;\n  sp = kwset->target + len;\n  tp = text + len;\n  char gc1 = kwset->gc1;\n  char gc2 = kwset->gc2;\n  if (size > 12 * len)\n    for (ep = text + size - 11 * len; tp <= ep; )\n      {\n        char const *tp0 = tp;\n        d = d1[U(tp[-1])], tp += d;\n        d = d1[U(tp[-1])], tp += d;\n        if (d != 0)\n          {\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            d = d1[U(tp[-1])], tp += d;\n            if (d != 0)\n              {\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                d = d1[U(tp[-1])], tp += d;\n                if (d != 0)\n                  {\n                    d = d1[U(tp[-1])], tp += d;\n                    d = d1[U(tp[-1])], tp += d;\n                    int advance_heuristic = 16 * sizeof (long);\n                    if (advance_heuristic <= tp - tp0)\n                      goto big_advance;\n                    tp--;\n                    tp = memchr_kwset (tp, text + size - tp, kwset);\n                    if (! tp)\n                      return -1;\n                    tp++;\n                  }\n              }\n          }\n        if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, d1, kwset))\n          return tp - text;\n      big_advance:;\n      }\n  ep = text + size;\n  d = d1[U(tp[-1])];\n  while (d <= ep - tp)\n    {\n      d = d1[U((tp += d)[-1])];\n      if (d != 0)\n        continue;\n      if (bm_delta2_search (&tp, ep, sp, len, trans, gc1, gc2, NULL, kwset))\n        return tp - text;\n    }\n  return -1;\n}",
        "vulnerability": "Improper bounds checking",
        "reason": "The loop condition `while (d <= ep - tp)` combined with `d = d1[U((tp += d)[-1])];` might not adequately check that `tp` remains within valid memory. If `d1` or `tp` are miscalculated, this could allow attackers to exploit memory vulnerabilities by reading or writing out of bounds.",
        "file_name": "215921.sol"
    }
]