[
    {
        "function_name": "mobi_decode_infl",
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The check 'd + l > decoded + INDX_INFLBUF_SIZEMAX' intends to prevent buffer overflow, but it doesn't account for cases where 'd + l' wraps around, leading to a potential buffer overflow if 'l' is large enough.",
        "file_name": "277489.sol"
    },
    {
        "function_name": "mobi_decode_infl",
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "vulnerability": "Improper Buffer Manipulation",
        "reason": "The 'memmove' operation does not ensure that the source and destination do not overlap incorrectly, as the boundary checks are insufficient to prevent overlapping regions from causing corruption or unintended behavior.",
        "file_name": "277489.sol"
    },
    {
        "function_name": "mobi_decode_infl",
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "vulnerability": "Integer Underflow",
        "reason": "When 'pos' is greater than '*decoded_size', 'l' can become negative. Subsequent operations involving 'l' can lead to significant vulnerabilities, such as negative buffer lengths leading to unexpected behavior.",
        "file_name": "277489.sol"
    },
    {
        "function_name": "mobi_decode_infl",
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "vulnerability": "Buffer Overflow",
        "reason": "The check to prevent buffer overflow is incorrect and incomplete. The condition 'd + l > decoded + INDX_INFLBUF_SIZEMAX' should ensure that 's + l' and 'd + l' do not exceed 'decoded + INDX_INFLBUF_SIZEMAX'. Moreover, the use of pointer arithmetic without sufficient boundary checks can lead to writing beyond the allocated buffer, which might be exploited by an attacker to execute arbitrary code or corrupt data.",
        "file_name": "277489.sol"
    },
    {
        "function_name": "mobi_decode_infl",
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "vulnerability": "Improper Calculation of Buffer Size",
        "reason": "The length 'l' is calculated as '*decoded_size - pos', which can become negative. When cast to 'size_t' for 'memmove', it becomes a large positive number, causing a large memory region to be moved, potentially leading to memory corruption or illegal access. This can be exploited by an attacker to cause a denial of service or potentially execute arbitrary code.",
        "file_name": "277489.sol"
    },
    {
        "function_name": "mobi_decode_infl",
        "code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "vulnerability": "Use of Unchecked Input",
        "reason": "The position 'pos' is not validated before accessing 'decoded[pos]', which can result in an out-of-bounds read if 'pos' is negative. This unchecked access could be exploited by an attacker to read sensitive information beyond the intended buffer limits.",
        "file_name": "277489.sol"
    }
]