CWE_434_RULE = """
[CWE-434 Reference Guideline | Unrestricted Upload of File with Dangerous Type | Non-binding, Evidence-first]

Overview
- CWE-434 occurs when a product allows the upload or transfer of dangerous file types that are automatically processed within its environment. These files may contain malicious code or exploit vulnerabilities, potentially leading to unauthorized access, code execution, or data breaches.
- The vulnerability typically arises when the product fails to restrict or validate file types properly, allowing files that can execute code or trigger harmful operations to be uploaded.
- In partial snippets, missing file type validation or filtering evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “dangerous file types” (static analysis framing)
- Executable files:
  - `.exe`, `.bat`, `.sh`, `.cmd`, `.vbs`, `.pif`, etc., that can execute commands or scripts.
- Script-based files:
  - `.php`, `.asp`, `.js`, `.html`, `.pl`, `.py`, and others that can contain executable scripts.
- Archives and compressed files:
  - `.zip`, `.tar`, `.gz`, `.rar`, `.tar.gz`, `.7z`, which can contain executable files or scripts when extracted.
- Configuration files:
  - `.xml`, `.json`, `.ini`, `.conf` files that may be used to inject malicious settings or exploit vulnerabilities in system configurations.
- Files with unsafe mime types:
  - Files that are misidentified as non-executable types (e.g., `.jpg`, `.png`, but actually contain executable payloads).

Where unrestricted file uploads typically occur (sensitive sinks)
- Upload endpoints:
  - file upload handlers (e.g., forms for user profile pictures, document submission, media uploads)
- File transfer points:
  - API endpoints receiving files for processing (e.g., file import, attachment upload, email handling)
- File processing points:
  - automatic processing of uploaded files (e.g., thumbnail generation, file extraction, media previewing)

Common failure modes (reasoning hints, not assumptions)
- Missing file type validation:
  - allowing any file type to be uploaded without validating the file's MIME type, extension, or content
- Lack of sanitization for file contents:
  - files that are allowed through the upload process without validating their content (e.g., a `.jpg` file that is actually a PHP script or executable code)
- Insecure handling of file metadata:
  - allowing files to be named with potentially dangerous characters or extensions (e.g., a file named `image.php.jpg`)
- Unrestricted file execution:
  - processing/uploading files that are automatically executed or processed by the server without sufficient validation

What “proper file upload handling” looks like (context-specific)
- File type validation:
  - restrict file uploads to a whitelisted set of file types (based on MIME type, file extension, and content analysis).
  - reject files with invalid or unexpected types, especially those that are executable or could contain malicious content.
- File content validation:
  - parse the contents of files (e.g., for images, ensure they are valid image files, for text files, ensure they don't contain scripts).
  - check the file's actual content type (e.g., using libraries to verify image or document formats, not just extensions).
- Secure file handling:
  - store uploaded files in a non-executable directory and ensure they are not automatically executed by the server.
  - avoid saving files with user-controlled names that could lead to directory traversal or overwriting of existing files.
- Secure execution of uploaded files:
  - if files must be processed or executed, use a secure, sandboxed environment for execution.
  - never automatically execute or include uploaded files in server-side processes without thorough validation.

Common weak/insufficient defenses (signals of possible risk)
- Relying on file extension or MIME type alone:
  - trusting the file extension or MIME type without further checking the actual file content, which can be spoofed.
- Allowing execution of files:
  - storing uploaded files in web-accessible directories (e.g., `/uploads/`) where they can be executed by attackers.
- No file content inspection:
  - allowing file uploads without inspecting the file content to verify it matches the expected type (e.g., an image that is actually a PHP script).
- Insecure storage of uploaded files:
  - saving files with potentially dangerous or misleading names (e.g., `evil.php.jpg`) or to directories that allow execution (e.g., `/tmp/`).

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - validation logic that ensures only safe, expected file types are uploaded, based on both MIME type and content.
  - use of a secure directory for file uploads where files are not executable.
  - proper content validation (e.g., checking an image file's magic bytes to ensure it is a valid image, not just checking file extension).
  - rejection of files with dangerous or misleading extensions, or with file names that could be used for directory traversal or execution.
- Evidence suggesting vulnerability:
  - file type or extension is only checked using basic extension or MIME type checks (e.g., `.jpg` without validating the file format).
  - uploaded files are stored in directories where they can be executed by the server.
  - no content validation or checks are performed on uploaded files.
  - files are processed without validating their content or type.
  
How to use this guideline under incomplete context
- Identify where file uploads are processed and stored:
  - where are files uploaded to? Are they executed or processed automatically by the server?
- Identify the file validation checks in place:
  - Are the uploaded files validated by both extension and content type?
- Generate a small number of targeted hypotheses:
  - H1: File types are not validated or only weakly validated (e.g., relying on file extension alone).
  - H2: Uploaded files are stored in an executable directory or processed without content validation.
  - H3: File content is not checked for malicious payloads, and files may be incorrectly identified as safe.
  - H4: File uploads are handled outside the visible code (e.g., in libraries or framework handlers) and may not be securely configured.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (file upload endpoints, content validation, storage location),
  (b) evidence needed to confirm it (content validation logic, storage path security, security configuration),
  (c) counter-evidence that would refute it (strong file content validation, non-executable storage paths).

Quick red flags in partial code (weak → strong)
- Strong: uploaded files are stored in web-accessible directories or directories that allow file execution.
- Medium: file type is validated by extension or MIME type only, with no content inspection.
- Medium: uploaded files can be named arbitrarily and potentially lead to directory traversal or file overwriting.
- Weak: file upload handling may rely on insecure third-party libraries, or file validation may be handled outside of the shown code → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_434_RULE)
