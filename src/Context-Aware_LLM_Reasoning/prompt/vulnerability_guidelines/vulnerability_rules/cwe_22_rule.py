CWE_22_RULE = """
[CWE-22 Reference Guideline | Path Traversal | Non-binding, Evidence-first]

Overview
- CWE-22 (Path Traversal) occurs when an application constructs filesystem paths using untrusted input without sufficient restrictions, enabling access outside an intended base directory (e.g., via ../).
- In partial snippets, missing validation evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “path input” in Java (typical sources)
- HTTP-derived values: query params, path variables, headers, cookies, multipart form fields (e.g., filename, subpath).
- File-related metadata: uploaded filename, archive entry names (Zip/Tar), user-controlled “name/path” fields.
- Cross-component/user-influenced data: message payloads, DB fields, config values only if attacker-controllable.

Security-sensitive path usages (typical sinks)
- File read/write/delete: java.io.File, java.nio.file.Path/Paths/Files, FileInputStream/FileOutputStream, RandomAccessFile.
- Path resolution operations used before access: Path.resolve, normalize, toRealPath / getCanonicalFile.
- Archive extraction (“Zip Slip” family): writing archive entries to disk based on entry names.

Typical bypass primitives (reasoning hints, not assumptions)
- Relative traversal: ../, ..\\, repeated segments, mixed separators.
- Absolute paths: /etc/passwd, C:\\Windows\\..., UNC roots (\\\\server\\share\\...).
- Encoding/normalization tricks: URL-encoding (%2e%2e%2f), double-encoding, Unicode normalization.
- Platform quirks: trailing dots/spaces on Windows, separator differences.

What “proper restriction” looks like (context-specific)
- Prefer allow-list mapping to known-safe filenames/IDs over accepting arbitrary path fragments.
- Constrain input format to the minimum needed:
  - If only a filename is expected, reject any path separators and enforce strict regex/enum.
- Canonicalize/normalize before enforcing containment:
  - Build the candidate path from (baseDir, userPart) using Path.resolve (avoid raw string concatenation).
  - Normalize and/or canonicalize (toRealPath / getCanonicalFile) as appropriate for the check.
  - Enforce containment: resolved/canonical candidate must remain within canonical base directory.
- Explicitly reject dangerous path forms when relevant:
  - Absolute paths, drive letters, UNC roots, or unexpected prefixes.

Common weak/insufficient defenses (signals of possible risk)
- String-based filtering: replacing "../" once, removing "..", or blocking a small set of substrings (bypassable via encoding, separators, repetition).
- Raw prefix checks on strings: candidate.startsWith(baseDir) without canonicalization/normalization.
- Validating one representation but using another (e.g., validate raw, then decode/normalize later).
- Normalizing after the file operation (too late).

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - User input is converted to an allow-listed ID → mapped to a fixed safe path.
  - Candidate path is constructed via Path.resolve(base, userPart), then normalized/canonicalized, then checked for containment within base.
  - Input is constrained to filename-only semantics (no separators) before any path join.
- Evidence suggesting vulnerability:
  - Untrusted input directly concatenated or joined into a path used by file APIs with no visible containment/allow-list barrier in the same dataflow.
  - Only blacklist-style substring filtering or raw string prefix checks appear as “protection”.

How to use this guideline under incomplete context
- Use it to generate a small number of targeted hypotheses based on the observed sink and path construction pattern:
  - H1: Untrusted input can introduce traversal or absolute path forms.
  - H2: A containment check exists but is string-based and bypassable.
  - H3: A robust containment/allow-list validation exists upstream, but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (e.g., baseDir origin, canonicalization logic, allow-list mapping),
  (c) counter-evidence that would refute it (e.g., canonical containment check present in-flow).

Quick red flags in partial code (weak → strong)
- Strong: new File(base + userInput) / Paths.get(base, userInput) followed by file access, without normalize/canonicalize + containment.
- Medium: “sanitization” that only strips ../ or checks ".." without handling encoding/separators/repetition.
- Medium: startsWith(baseDir) checks on raw strings.
- Weak: validation likely occurs outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_22_RULE)
