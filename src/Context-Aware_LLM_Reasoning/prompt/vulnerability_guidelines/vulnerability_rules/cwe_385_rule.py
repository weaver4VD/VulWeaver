CWE_385_RULE = """
[CWE-385 Reference Guideline | Covert Timing Channel | Non-binding, Evidence-first]

Overview
- CWE-385 occurs when protected information can be inferred via a covert timing channel: the system modulates observable timing behavior (intentionally or unintentionally) in a way that an observer can correlate with secrets.
- In practice, this often appears as secret-dependent branching, secret-dependent early exits, secret-dependent resource access patterns, or other operations whose execution time varies with sensitive values.
- In partial snippets, timing variance risk is often hard to prove. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as a “covert timing channel” (static analysis framing)
- Covert timing channel:
  - A pathway where differences in elapsed time, latency, response timing, or throughput encode information.
- Protected information:
  - Secrets such as passwords, cryptographic keys, authentication tokens, existence of user accounts, authorization state, or sensitive record presence.
- Secret-dependent timing:
  - Program behavior (branches/loops/I/O) varies measurably based on secret values, enabling inference by repeated observations.

Where covert timing channels typically occur (sensitive sinks)
- Authentication and credential checks:
  - Username existence checks vs password checks; early-return string comparisons.
- Cryptographic operations:
  - Non-constant-time comparisons (MAC/signature/tag checks), secret-dependent branches in key handling.
- Access control and resource existence:
  - Different code paths for “authorized vs unauthorized”, “record exists vs not”, “valid vs invalid token”.
- Error handling and parsing:
  - Parsing that stops at first mismatch, producing timing differences correlated with secret structure.
- Rate limiting / throttling logic:
  - Differential delays that reveal internal state (e.g., per-user counters, lockout thresholds).

Common failure modes (reasoning hints, not assumptions)
- Early exit comparisons:
  - Equality checks that return on first mismatch (string/byte array compare) when comparing secrets.
- Secret-dependent branching:
  - `if (secretByte == ...)` branches that affect runtime; varying loop iterations based on secret.
- Different work for different secret states:
  - “User not found” returns quickly; “password wrong” does expensive hashing, creating a measurable gap.
- Conditional logging/exception paths that change execution time:
  - Extra formatting/stack building only on certain secret-dependent failures.
- Variable-time crypto primitives or naive implementations:
  - Custom verification routines that are not constant-time.

What “timing-resistant design” looks like (context-specific)
- Constant-time comparisons for secrets:
  - Use constant-time equality for MACs, tokens, digests, and other secret-bearing values.
- Uniform work regardless of secret state:
  - Make “user not found” and “wrong password” paths do comparable work (or at least comparable externally observable timing).
- Avoid secret-dependent control flow in hot paths:
  - Prefer table-driven or constant-time primitives for cryptographic checks.
- Normalize error responses:
  - Same status/response size and similar computational work where feasible, especially for auth/account existence.
- Rate limiting carefully:
  - Ensure delays do not encode secret state or fine-grained internal counters.

Common weak/insufficient defenses (signals of possible risk)
- “It’s probably too small to measure”:
  - Attackers can average over many requests; small differences can still leak.
- Partial constant-time:
  - Constant-time compare but secret-dependent parsing/lookup still varies.
- Relying on network noise:
  - Network jitter may reduce signal, but repeated measurements can recover it.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit use of constant-time compare utilities for secret comparisons.
  - Auth flows that avoid distinguishable early returns and do comparable work across failure cases.
  - Use of well-vetted crypto libraries rather than custom secret-dependent verification logic.
  - Uniform error handling paths for “exists vs not exists” and “valid vs invalid” where applicable.
- Evidence suggesting vulnerability:
  - Manual byte/string comparisons with early exit for secrets (loops breaking on first mismatch).
  - Different execution paths with clearly different cost based on secret state (DB hit vs no hit; hashing vs no hashing).
  - Branching/loop iteration counts derived from secret bytes.
  - Returning different responses quickly for secret-dependent conditions (especially in auth/account enumeration contexts).

How to use this guideline under incomplete context
- Identify the protected secret and observation point:
  - What sensitive property might be inferred? What timing can an attacker measure (response time, method latency)?
- Identify secret-dependent control flow:
  - Look for branches, loops, parsing, lookups, or early returns driven by secret-bearing values or secret-derived predicates.
- Generate a small number of targeted hypotheses:
  - H1: Secret comparisons are variable-time (early exit), enabling timing inference of secret values.
  - H2: Different failure/success paths do materially different work, leaking account existence or auth state.
  - H3: Secret-dependent resource access patterns (DB/cache/files) create measurable timing differences.
  - H4: Timing resistance is provided elsewhere (framework auth module, constant-time utilities) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., early break compare, distinct expensive calls in one branch),
  (b) evidence needed to confirm it (e.g., what values are secrets, whether attacker can measure timing repeatedly),
  (c) counter-evidence that would refute it (e.g., constant-time compare usage, normalized work across paths).

Quick red flags in partial code (weak → strong)
- Strong: Manual secret comparisons with early returns/breaks; visibly different computational workload across secret-dependent branches in auth/crypto checks.
- Medium: Secret-dependent lookups (DB/cache) where “hit vs miss” or “authorized vs unauthorized” causes different response timing.
- Medium: Different error messages/paths tied to secret state that likely have different processing cost.
- Weak: Timing behavior may be dominated by external factors or normalized in omitted middleware → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_385_RULE)