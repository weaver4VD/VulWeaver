CWE_470_RULE = """
[CWE-470 Reference Guideline | Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') | Non-binding, Evidence-first]

Overview
- CWE-470 occurs when a product uses external input with reflection to select which classes or code to invoke but fails to sufficiently restrict or validate the input, leading to the potential execution of improper or malicious classes or methods.
- This vulnerability arises when untrusted data is used to dynamically load classes or invoke methods, allowing attackers to control what code is executed. Malicious input could lead to unauthorized access, arbitrary code execution, or other forms of exploitation.
- In partial snippets, missing input validation or reflection safety measures are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "reflection" and "externally-controlled input" (static analysis framing)
- Reflection:
  - The process of inspecting or modifying classes, methods, fields, or objects dynamically at runtime using APIs such as `Class.forName()`, `Method.invoke()`, `Constructor.newInstance()`, or similar reflection-related methods.
- Externally-controlled input:
  - User input, environment variables, HTTP parameters, configuration files, or any external source that can influence the execution of code in an untrusted manner.
- Unsafe reflection usage:
  - Dynamically selecting a class or method to execute based on untrusted or insufficiently validated input, which could allow attackers to specify arbitrary classes or methods.

Where unsafe reflection issues commonly occur (sensitive sinks)
- Class loading or method invocation:
  - Using `Class.forName()` or `ClassLoader.loadClass()` to dynamically load classes based on user-controlled input.
  - Using reflection to call methods dynamically via `Method.invoke()`, `Constructor.newInstance()`, or similar.
- Configuration-based class selection:
  - Configurations or user inputs that specify class names or method signatures that are later invoked via reflection.

Common failure modes (reasoning hints, not assumptions)
- Lack of input validation or sanitization:
  - Using unsanitized user input directly in reflective calls to load classes or invoke methods, allowing an attacker to specify arbitrary class names or method signatures.
- Insufficient authorization checks:
  - Allowing external input to specify classes or methods without validating the requestor’s permissions or role.
- Misuse of reflection APIs:
  - Invoking methods via reflection without ensuring they are safe or authorized to execute.

What "safe reflection usage" looks like (context-specific)
- Restrict dynamic class loading:
  - Only allow the loading of a fixed, trusted set of classes or methods, ideally hardcoded or validated against a white list.
  - Avoid using user-controlled input directly in `Class.forName()`, `ClassLoader.loadClass()`, or similar methods.
- Validate user-controlled input:
  - Ensure that external input (e.g., from user queries, URL parameters, environment variables) is sanitized and validated before being passed to reflection methods.
  - Check that the requested classes or methods are from a trusted source and match expected patterns or lists of allowed classes/methods.
- Use a class whitelist:
  - Use a predefined list of acceptable classes that can be loaded or invoked, and only permit reflection-based actions on these classes.
- Restrict method invocation:
  - Ensure only safe methods are invoked via reflection, and always validate the method signatures against an expected set of allowable methods.

Common weak/insufficient defenses (signals of possible risk)
- Direct use of user input in reflection calls:
  - Passing user-controlled strings directly into `Class.forName()`, `Method.invoke()`, `newInstance()`, etc., without validating the input.
- Allowing arbitrary class loading:
  - Loading classes based on user input that might result in loading malicious or unintended classes.
- Lack of an access control model for reflection:
  - Reflective operations that do not perform any checks for whether the actor has appropriate permissions to invoke certain methods or load specific classes.
- Misconfigured class whitelisting:
  - Partial or poorly implemented whitelisting of allowed classes or methods, allowing bypass via unexpected input.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Input is validated before being used in reflective calls, ensuring only trusted classes or methods are invoked.
  - A whitelist of allowed classes and methods is enforced before any dynamic class loading or method invocation occurs.
  - Reflection is used sparingly, and only on known, trusted classes or methods with explicit checks.
- Evidence suggesting vulnerability:
  - External input is passed directly to reflection-based class or method selection (e.g., `Class.forName(userInput)`).
  - Classes or methods are loaded dynamically using user input without validation, allowing arbitrary classes to be invoked.
  - No evidence of a whitelist or strict access control for reflection-based operations.

How to use this guideline under incomplete context
- Identify reflective operations:
  - Look for `Class.forName()`, `ClassLoader.loadClass()`, `Method.invoke()`, `Constructor.newInstance()`, or other reflection-related APIs.
- Identify where user-controlled input is being passed to reflective methods:
  - Does the code accept external input (e.g., HTTP parameters, configuration files) and pass it to reflection methods without validation?
- Generate a small number of targeted hypotheses:
  - H1: External input is used in reflection calls without sufficient validation or sanitization.
  - H2: Class/method names are dynamically loaded from untrusted sources, potentially allowing arbitrary class loading.
  - H3: Reflection is properly secured with class whitelisting, input validation, and authorization checks, but the implementation is not fully visible in the snippet.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (use of reflection methods, dynamic class or method selection),
  (b) evidence needed to confirm it (validation logic, access control checks, class/method whitelisting),
  (c) counter-evidence that would refute it (explicit input validation, trusted class list, method security checks).

Quick red flags in partial code (weak → strong)
- Strong: user-controlled input passed directly into reflection methods, such as `Class.forName(userInput)` or `Method.invoke(userInput)`.
- Medium: dynamic loading of classes or method invocation without validation against a known whitelist of allowed classes or methods.
- Medium: reflection-based operations appear in some code paths but are not consistently checked for security across all routes.
- Weak: reflection-related functionality may be implemented in external libraries or helper functions not visible in the current snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_470_RULE)
