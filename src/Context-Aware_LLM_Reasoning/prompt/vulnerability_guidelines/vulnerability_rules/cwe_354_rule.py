CWE_354_RULE = """
[CWE-354 Reference Guideline | Improper Validation of Integrity Check Value | Non-binding, Evidence-first]

Overview
- CWE-354 occurs when a system relies on integrity check values (e.g., checksums, hashes, CRCs, digests) but does not validate them, validates them incorrectly, or validates them in a way that can be bypassed. As a result, modified or corrupted data may be accepted as if it were intact.
- In partial snippets, missing validation evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “integrity check values” (typical sources)
- Checksums/digests attached to data: CRC32, Adler32, MD5/SHA-1/SHA-256 digests, file hashes in manifests, ETag-like digests, message-level “checksum” fields.
- Protocol metadata: length+checksum fields in custom protocols, chunked transfer digests, multipart checksums.
- Package/update integrity: hash files, manifest digests, “expected hash” provided by a server/config, container/image digests.
- Storage/transmission integrity: hashes stored alongside blobs, object-store checksums, “content-md5” headers.

Security-sensitive usages (typical sinks)
- Loading/processing data as trusted: parsing configs, deserializing objects, executing scripts/plugins, applying updates, extracting archives.
- Persisting data as authoritative state: saving received content to disk/db, caching, using it for later security decisions.
- Cross-trust-boundary transfers: accepting data from network/remote storage/third parties where corruption or tampering is realistic.

What “proper validation” typically means (context-specific)
- Recompute the integrity check over the exact bytes actually received/used, then compare it to the expected integrity value.
- Ensure the expected integrity value is itself trustworthy:
  - If the expected hash/checksum is provided by an untrusted party or travels over the same untrusted channel without protection, it may be attacker-controlled.
  - In such cases, integrity validation may be meaningless unless the expected value is anchored in a trusted source.
- Validate at the correct time and on the correct representation:
  - Validate before parsing/executing/acting on the data.
  - Avoid validating a different representation than the one used (e.g., validate pre-decompression but use post-decompression, or validate decoded text but use raw bytes).
- Use the correct algorithm and parameters consistently:
  - Same algorithm (e.g., SHA-256 vs SHA-1), same encoding (hex/base64), same canonicalization rules.

Common weak/incorrect patterns (signals of possible risk)
- Missing recomputation: reading a checksum field but never recomputing from content.
- Comparing against an expected value that is attacker-controlled:
  - The “expected checksum” is sent alongside the message by the sender without any trusted anchoring.
- Validating the wrong bytes:
  - Checksum computed over transformed data (normalized/decoded/newlines changed) while the actual used bytes differ.
  - Validating only part of the payload (e.g., header-only), or validating before concatenation/assembly of chunks.
- Validation after use:
  - Data is parsed/executed/stored, then checksum is checked (too late to prevent effects).
- Incorrect comparison logic:
  - String comparison on differently formatted digests (case/whitespace), truncation, partial comparisons (prefix-only), or silent fallback on mismatch.
- Error handling that accepts bad data:
  - Catch-and-continue on mismatch, logging only, or treating failure as “best effort”.

Important nuance (integrity vs authenticity)
- A plain checksum/hash (CRC/MD5/SHA) detects accidental corruption only if the expected value is trusted.
- If an attacker can modify both data and checksum, a plain checksum does not prevent tampering.
- If the threat includes malicious modification, an authenticated integrity mechanism (e.g., HMAC or signature) is typically needed; however, CWE-354 focuses on incorrect/missing validation of the integrity check value itself.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Code recomputes checksum/digest from the actual bytes used and compares to a trusted expected value; mismatch triggers rejection/early return.
  - Validation happens before parsing/executing/extracting/applying updates.
  - Clear, consistent algorithm usage and correct decoding/encoding of digests.
- Evidence suggesting vulnerability:
  - Checksum field exists but is unused or not recomputed from payload bytes.
  - Comparison uses attacker-provided “expected checksum” with no trusted anchoring visible.
  - Validation is performed on a different representation than the data used, or only partially covers the data.
  - Failure paths still proceed with processing.

Typical attacker/corruption scenarios (reasoning hints, not assumptions)
- Network tampering or proxy modifies payload in transit; system fails to detect due to missing/incorrect validation.
- Truncation/partial delivery: receiver accepts incomplete data without verifying checksum over full content.
- Digest mismatch bypass: attacker exploits encoding/canonicalization differences to pass a superficial check.

How to use this guideline under incomplete context
- Generate a small set of targeted hypotheses based on observed data ingestion and use:
  - H1: Integrity value is present but never validated against recomputed bytes.
  - H2: Integrity check is performed, but on the wrong bytes/time/order (validate-after-use, partial coverage, pre/post transform mismatch).
  - H3: “Expected” integrity value is untrusted or comes from the same untrusted channel, making validation ineffective for tampering.
  - H4: Robust validation exists in helper/util layer or upstream component, but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (where checksum is computed, what bytes are used, source of expected value),
  (c) counter-evidence that would refute it (early rejection on mismatch, trusted anchoring of expected digest, validated representation matches used bytes).

Quick red flags in partial code (weak → strong)
- Strong: checksum/digest read or passed around, but content is consumed without recomputing+comparing.
- Medium: digest comparison exists but uses sender-provided expected value with no trusted source, or only compares a prefix/truncated digest.
- Medium: checksum computed on transformed/decoded text while actual bytes differ, or validation happens after parse/extract/apply.
- Weak: validation likely occurs outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_354_RULE)
