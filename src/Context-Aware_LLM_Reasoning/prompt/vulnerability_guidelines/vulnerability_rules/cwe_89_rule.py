CWE_89_RULE = """
[CWE-89 Reference Guideline | SQL Injection | Non-binding, Evidence-first]

Overview
- CWE-89 (SQL Injection) occurs when a product constructs all or part of an SQL command using externally-influenced input, and the input is not properly neutralized (or is neutralized incorrectly), allowing it to change the intended SQL semantics when executed by the database.
- The key distinction is whether user data is kept separate from SQL syntax (e.g., parameter binding) versus being interpolated into the SQL text.
- In partial snippets, missing neutralization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “externally-influenced input” (typical sources)
- HTTP-derived data: query params, form fields, path variables, headers, cookies, request bodies (JSON/form).
- Persisted user content: DB-stored fields used to build subsequent queries (second-order injection).
- Cross-component payloads: RPC/message fields only if attacker-controllable in context.
- Configuration/feature flags only if attacker-controllable through exposed interfaces.

SQL execution sinks (typical in Java)
- JDBC:
  - Statement.executeQuery/execute/executeUpdate with SQL strings
  - PreparedStatement with parameter placeholders (?)
- ORM / query builders:
  - JPA/Hibernate JPQL/HQL, Criteria API
  - MyBatis mapper queries
  - Spring JdbcTemplate / NamedParameterJdbcTemplate
  - “native query” features (raw SQL strings)
- Dynamic query construction utilities and repository helpers

Core risk mechanism (special elements in SQL)
- Injection happens when attacker-controlled input can introduce or modify SQL syntax:
  - quotes, comment markers, boolean operators, UNION/select fragments, stacked queries (DB-dependent), wildcards in LIKE, etc.
- The downstream interpreter is the SQL parser/executor; risk depends on whether input affects syntax positions (values vs identifiers vs clauses).

What “proper neutralization/restriction” looks like (context-specific)
- Prefer safe-by-construction APIs:
  - Use PreparedStatement (bind variables) or equivalent parameter binding mechanisms in frameworks (NamedParameterJdbcTemplate, MyBatis parameters, JPA Criteria).
  - Use ORM/query builders that separate structure from values.
- Treat identifiers (table/column/order-by) differently:
  - Parameter binding typically applies to values, not identifiers.
  - If user input influences identifiers, enforce strict allow-list mapping (enum/whitelist) rather than concatenating raw input.
- For LIKE queries:
  - Still use parameter binding, and handle wildcard escaping if the intended semantics require literal matching.
- Apply input constraints where feasible:
  - For IDs, enforce numeric/uuid patterns; for enums, enforce known sets. Constraints reduce attack surface but do not replace parameterization.

Common weak/insufficient defenses (signals of possible risk)
- String concatenation/interpolation in SQL text:
  - "SELECT ... WHERE x = " + userInput, building clauses dynamically using raw input.
- Blacklist filtering / ad-hoc escaping:
  - Replacing quotes or removing keywords is bypassable and dialect-dependent.
- Wrong-layer defenses:
  - HTML escaping or URL encoding does not protect SQL execution.
- Validate-then-transform pitfalls:
  - Validate raw input, then decode/normalize/replace later, reintroducing dangerous characters.
- Trusting “framework handles it” without evidence:
  - Some ORMs allow raw SQL; treat unknown helper methods as Unknown unless proven to bind parameters.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - PreparedStatement with “?” placeholders and setXxx bindings, or named parameters with binding.
  - Framework query APIs that clearly bind parameters (not string concatenation).
  - Strict allow-list mapping when user input influences identifiers (ORDER BY field, table name, column name).
  - Query structure built via Criteria/DSL, values passed separately.
- Evidence suggesting vulnerability:
  - Externally influenced input is concatenated into SQL strings executed via Statement (or equivalent “execute raw SQL” paths).
  - Dynamic query fragments derived from user input control WHERE/ORDER/GROUP/LIMIT clauses without allow-listing.
  - Use of “native query” or raw SQL strings with user input interpolation.

How to use this guideline under incomplete context
- Identify the SQL sink implied by imports and method calls:
  - Statement vs PreparedStatement vs framework helper vs ORM vs native SQL.
- Generate a small number of targeted hypotheses based on observed construction pattern:
  - H1: User input is interpolated into SQL text, affecting syntax.
  - H2: Parameterization exists but only for some parts; other parts (identifiers/clauses) are concatenated.
  - H3: Binding occurs inside helper methods not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (string concat, format, dynamic clause building),
  (b) evidence needed to confirm it (exact exec call, whether parameters are bound, helper method semantics),
  (c) counter-evidence that would refute it (bind variables, allow-list mapping for identifiers, Criteria/DSL usage).

Quick red flags in partial code (weak → strong)
- Strong: request-derived/persisted user data concatenated into an SQL string passed to Statement.execute* (or equivalent raw execution).
- Medium: user input influences ORDER BY / column / table / LIMIT as raw fragments without allow-list mapping.
- Medium: “escape/replace quotes” style sanitization with unclear completeness or dialect mismatch.
- Weak: parameter binding may occur in unshown layers (mappers/repositories) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_89_RULE)