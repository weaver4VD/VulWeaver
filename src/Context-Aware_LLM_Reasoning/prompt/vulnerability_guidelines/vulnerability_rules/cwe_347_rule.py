CWE_347_RULE = """
[CWE-347 Reference Guideline | Improper Verification of Cryptographic Signature | Non-binding, Evidence-first]

Overview
- CWE-347 occurs when the product does not verify, or incorrectly verifies, the cryptographic signature for data that is supposed to be integrity-protected and/or authenticated.
- Improper signature verification can allow attackers to tamper with signed data, forge identities/claims, bypass integrity checks, or inject malicious content (e.g., accepting modified updates/tokens/messages).
- In partial snippets, seeing “signature-related” code is not proof of correctness or vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “signature verification” (static analysis framing)
- Signed data:
  - Any payload accompanied by a signature intended to prove integrity and/or authenticity (e.g., JWT/JWS, SAML assertions, signed config, update packages, webhooks, license files, signed messages).
- Verification:
  - Checking the signature using the correct public key/certificate (or shared secret for MACs), the correct algorithm, and the correct signed bytes, and rejecting data if verification fails.
- Improper verification:
  - Skipping verification, accepting verification failures, verifying the wrong content, trusting attacker-controlled keys, or using insecure/incorrect algorithm handling.

Where CWE-347 typically occurs (sensitive sinks)
- Authentication/authorization based on signed tokens:
  - JWT/JWS claims (issuer/audience/subject), session tokens, signed cookies.
- Webhook/message validation:
  - Signature headers validating request bodies.
- Software update/package verification:
  - Signed updates, plugins, downloads, manifests.
- Document or configuration integrity:
  - Signed XML/JSON, signed policies/licenses, signed metadata.
- Inter-service integrity:
  - Signed messages between services or devices.

Common failure modes (reasoning hints, not assumptions)
- Missing verification step:
  - Data is parsed/used without any cryptographic verification.
- Fail-open behavior:
  - Catching verification exceptions and continuing, or returning “valid” on error.
- Algorithm confusion / weak algorithm acceptance:
  - Accepting attacker-chosen algorithms (e.g., “none” or unexpected algorithm), or not pinning expected algorithm.
- Key confusion / untrusted key source:
  - Using a key provided inside the message (e.g., embedded JWK) without trust anchoring; blindly trusting certificates/keys from untrusted sources.
- Verifying the wrong bytes:
  - Verifying a transformed payload (decoded/normalized) instead of the exact signed canonical bytes; verifying only part of the message.
- Incomplete semantic checks after signature:
  - Signature valid but claims not constrained (issuer/audience/expiry) — not strictly signature verification, but often co-occurs and changes exploitability.

What “correct signature verification” looks like (context-specific)
- Fail closed on any verification failure:
  - If signature verification fails, reject the data and stop processing.
- Pin expected algorithms:
  - Enforce a strict allowlist of acceptable algorithms for the context; do not accept algorithm from untrusted input without validation.
- Use trusted keys only:
  - Obtain verification keys from a trusted store/endpoint with integrity (pinned keys, trusted JWKS URL with TLS + caching rules), not from the untrusted payload itself.
- Verify the exact signed content:
  - Ensure the verifier is applied to the correct canonical bytes (e.g., raw request body for webhooks; JWS signing input for JWT).
- Tie verification to intended context:
  - Ensure the verified signature corresponds to the correct sender/issuer and correct key identity.

Common weak/insufficient defenses (signals of possible risk)
- “We checked a hash”:
  - Hashing without signature verification does not authenticate the sender.
- Partial validation:
  - Checking signature but allowing attacker to choose key/algorithm.
- Silent fallback:
  - Trying multiple verifiers until one passes without strict selection criteria.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit verification call that returns a boolean/status and is enforced (failure aborts).
  - Algorithm is fixed or strictly allowlisted; key material is sourced from a trusted store/config.
  - Verification is performed before using any claims/payload fields in security-sensitive decisions.
  - For webhooks/messages: verification uses the raw payload bytes and correct signature header parsing.
- Evidence suggesting vulnerability:
  - No verification call before using signed data.
  - Exceptions during verification are swallowed; code continues processing (“fail open”).
  - Algorithm is taken from the message and accepted broadly; “none”/unexpected algorithms not rejected.
  - Verification key is taken from the message (embedded key/cert) without trust anchoring.
  - Verification is applied to modified/partial content (e.g., pretty-printed JSON rather than raw bytes).

How to use this guideline under incomplete context
- Identify what data is “supposed to be signed”:
  - Token/message/update/config: what enforces integrity/authenticity?
- Identify verification boundary and sink usage:
  - Where is signature verification performed relative to parsing and security decisions?
- Generate a small number of targeted hypotheses:
  - H1: The code uses signed data without verifying the signature (missing verification).
  - H2: Verification failures are ignored or mishandled (fail-open).
  - H3: Algorithm/key selection is attacker-influenced (algorithm/key confusion).
  - H4: Verification is correct but performed in omitted helper/library code → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., use of token claims before verify; catch-and-continue),
  (b) evidence needed to confirm it (e.g., verifier configuration, key source, algorithm allowlist),
  (c) counter-evidence that would refute it (e.g., strict verify-before-use, trusted key retrieval).

Quick red flags in partial code (weak → strong)
- Strong: Processing token/message/update claims before verification, or continuing on verification failure.
- Medium: Accepting algorithm/key material from untrusted input; broad algorithm acceptance without pinning.
- Medium: Verifying non-raw/partial payload bytes (mismatched signed content).
- Weak: Verification may occur in omitted layers (auth middleware, message gateway, update framework) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_347_RULE)