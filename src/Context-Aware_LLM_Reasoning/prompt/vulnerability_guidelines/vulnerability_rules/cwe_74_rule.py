CWE_74_RULE = """
[CWE-74 Reference Guideline | Injection (Generic) | Non-binding, Evidence-first]

Overview
- CWE-74 (Improper Neutralization of Special Elements in Output Used by a Downstream Component) occurs when a product constructs all or part of a command, query, document, or structured record using externally-influenced input, but does not correctly neutralize special elements that affect how a downstream component parses or interprets it.
- CWE-74 is an umbrella concept: the downstream “interpreter” could be SQL, OS shell, LDAP, XML/HTML template engine, log/format string parser, expression language engine, JSONPath/XPath, serialization formats, etc.
- In partial snippets, missing sanitization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “externally-influenced input” (typical sources)
- HTTP-derived data: parameters, headers, cookies, path variables, request bodies (JSON/XML/form).
- Message/RPC payload fields from other services or clients.
- User-controlled DB fields or config values (only if attacker-controllable in the given system context).
- Files and uploaded content that later becomes part of a command/query/document.

Downstream components (typical sinks / interpreters)
- Database/query interpreters: JDBC execution APIs, ORM query builders, dynamic query languages.
- OS command interpreters: ProcessBuilder/Runtime.exec and wrappers.
- Directory/identity/query languages: LDAP filters, XPath/JSONPath queries.
- Template/expression interpreters: EL/SpEL/OGNL/MVEL, template engines, rule engines.
- Markup/document interpreters: HTML/XML generation, XML parsers with dynamic content, JSON builders consumed by strict parsers.
- Serialization/deserialization boundaries: constructing records for later parsing (CSV, log formats, custom protocols).

Core risk mechanism (what “special elements” means)
- Special elements are characters/tokens/structures that the downstream component treats as syntax, control operators, or delimiters.
- Injection happens when attacker-controlled input can introduce or modify these syntax elements, changing the downstream interpretation (e.g., altering query logic, executing a new command segment, breaking out of a quoted context, changing a template/expression).

What “proper neutralization” looks like (context-specific)
- Prefer safe-by-construction APIs over manual escaping:
  - Parameterized interfaces (e.g., prepared statements / bind variables).
  - Structured builders that separate data from syntax (e.g., JSON/XML DOM builders, templating with auto-escaping configured correctly).
  - Command execution with argument vectors (no shell), avoiding string-concatenated commands.
- Apply context-appropriate encoding/escaping only when safe APIs are unavailable:
  - Escaping must match the exact downstream grammar and the exact insertion context (string literal vs identifier vs regex vs path segment).
  - Ensure the escape/encode step happens after any decoding/normalization and immediately before sink usage.
- Constrain input when feasible:
  - Allow-list expected patterns/enums/IDs to reduce the chance that special syntax can be introduced.
  - Keep the “data” domain small (e.g., known commands/fields/columns) rather than accepting arbitrary free-form strings.

Common weak/insufficient defenses (signals of possible risk)
- String concatenation to build interpreter inputs:
  - Building SQL/commands/filters/expressions by concatenating user input into the syntax string.
- Blacklist filtering of “bad characters/tokens”:
  - Removing a few characters (quotes, semicolons, ${}, etc.) is often bypassable and context-incomplete.
- Escaping the wrong context or wrong layer:
  - HTML escaping used for SQL; SQL escaping used for shell; escaping for one dialect while downstream uses another.
- Validate-then-transform pitfalls:
  - Validate raw input, then decode/normalize/replace later, reintroducing special elements.
- Trusting upstream guarantees without evidence:
  - Assuming “already sanitized” when it is not visible in the snippet.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Use of parameterized APIs / bind variables / structured builders that keep data separate from syntax.
  - Command execution APIs that pass arguments as separate tokens (no shell parsing), with no concatenated command strings.
  - Clear, context-specific escaping/encoding at the exact boundary before the sink, matching the downstream grammar.
  - Allow-list constraints for inputs used in syntax-sensitive positions (e.g., field names, operators, templates).
- Evidence suggesting vulnerability:
  - Externally influenced input is interpolated into a command/query/expression/template/record string sent to a downstream interpreter, with no visible safe API usage or correct boundary escaping.
  - Sanitization is limited to blacklist-style replacements or generic “sanitize()” with unclear semantics.

How to use this guideline under incomplete context
- First identify the downstream component category implied by the sink and imports (SQL vs shell vs template/expression vs LDAP/XPath vs markup, etc.).
- Generate a small number of targeted hypotheses based on the observed construction pattern:
  - H1: User input can introduce syntax tokens that change downstream parsing.
  - H2: Escaping/sanitization exists but is context-mismatched or incomplete.
  - H3: A parameterized/builder-based safe interface exists upstream/downstream but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (string concatenation, interpolation, dynamic query/command building),
  (b) evidence needed to confirm it (exact sink call, whether parameterization is used, escaping method semantics),
  (c) counter-evidence that would refute it (bind parameters, safe builders, strict allow-listing).

Quick red flags in partial code (weak → strong)
- Strong: direct concatenation/interpolation of request-derived input into a query/command/expression string that is executed/evaluated by a downstream component.
- Medium: presence of “escape/replace/filter” that is blacklist-like or not clearly tied to the sink’s grammar.
- Medium: decoding/normalization happens after validation and before sink, enabling special elements to appear.
- Weak: sanitization/parameterization may occur outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_74_RULE)
