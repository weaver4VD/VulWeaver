CWE_345_RULE = """
[CWE-345 Reference Guideline | Insufficient Verification of Data Authenticity | Non-binding, Evidence-first]

Overview
- CWE-345 occurs when a system accepts data without sufficiently verifying its origin or authenticity, causing it to treat forged/tampered/unauthorized data as legitimate.
- In partial snippets, missing verification evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “authenticity-sensitive data” (typical sources)
- Network-received data: HTTP requests/responses, webhooks, callbacks, RPC messages, MQTT/AMQP/Kafka payloads.
- Tokens/credentials/claims: JWT/SAML/OAuth tokens, API keys, session-like tokens, signed URLs.
- Client-provided identifiers: userId/accountId/role/price/permissions/status fields coming from the client.
- Third-party integration data: payment provider events, CI/CD callbacks, SCM webhooks, cloud event notifications.
- Files and updates: downloaded artifacts, plugins, configs, license files, update packages, serialized objects.
- Inter-service messages: data from “trusted” internal services that is still forgeable if channel/service identity isn’t verified.

Security-sensitive usages (typical sinks)
- Authorization or privilege decisions: role checks, ACL decisions, “isAdmin” flags, access to protected resources.
- Financial / business logic: payment status, price/discount, order fulfillment states.
- Execution/installation: running scripts, loading plugins, applying updates, deserializing remote objects.
- Trust boundary crossings: persisting unverified data as authoritative state, triggering side effects (emails, resets, approvals).

What “verification of authenticity” typically means (context-specific)
- Verify who sent the data (origin) and that it was not modified (integrity), using mechanisms appropriate to the channel and threat model:
  - Cryptographic verification: HMAC signatures (shared secret), digital signatures (public key), certificate validation.
  - Token verification: validate signature, issuer, audience, expiration, and critical claims; reject “alg=none” or untrusted algorithms/keys.
  - Transport/channel authentication: TLS with proper certificate validation; optionally mTLS for service-to-service identity.
  - Replay protection where needed: timestamps, nonces, event IDs, idempotency keys.
  - Server-side re-derivation: treat client-provided “facts” (price/role/status) as untrusted; recompute or fetch from authoritative storage.

Common weak/insufficient patterns (signals of possible risk)
- Trusting client-controlled fields directly for security decisions (e.g., role/isAdmin/price/status from request body).
- Parsing tokens/claims but not verifying signatures or critical fields (issuer/audience/exp), or using a key sourced from attacker-controlled input.
- Accepting webhook/event payloads without verifying a shared-secret signature and replay constraints.
- Using “encryption” as authenticity (decrypting data ≠ verifying sender), or relying on obscurity/format checks alone.
- Performing verification but ignoring failures (catch-and-continue), or verifying after already acting on the data.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit signature/MAC verification using a fixed trusted secret or trusted public key; failure leads to rejection/early return.
  - Robust token verification: signature validated + issuer/audience/exp (and other relevant claims) checked before use.
  - Webhook validation: recompute signature over raw payload + compare in constant-time; validate timestamp/event ID if present.
  - Server-side authoritative lookup: sensitive fields are derived from server state rather than client input.
- Evidence suggesting vulnerability:
  - Security-sensitive decisions or side effects are based on external data with no visible authenticity checks in the same dataflow.
  - Token parsing without verification, or “verification” based only on decoding/format.
  - Verification exists but depends on attacker-controlled parameters (e.g., key/issuer from request), or errors are swallowed.

Typical attacker strategies (reasoning hints, not assumptions)
- Forge requests/events to look like trusted senders (fake webhook calls, spoofed internal-service payloads).
- Tamper with payload fields that drive authorization or business logic (roles, amounts, statuses).
- Bypass token checks via missing signature validation, weak algorithms, or mismatched issuer/audience.
- Replay previously valid messages if no replay protection exists where it matters.

How to use this guideline under incomplete context
- Generate a small number of targeted hypotheses based on observed sources and sinks:
  - H1: External data drives a sensitive decision without authenticity verification.
  - H2: Verification is present but incomplete (e.g., signature checked but issuer/audience/exp not checked, or replay risk).
  - H3: Verification exists upstream (filter/interceptor/gateway), but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (e.g., signature validation utility, token verifier config, trusted key source),
  (c) counter-evidence that would refute it (e.g., verified claims used only after successful checks, server-side re-derivation).

Quick red flags in partial code (weak → strong)
- Strong: client-provided role/permission/status/amount directly controls authorization or side effects, with no verification/lookup.
- Medium: JWT/token is decoded/parsed and claims are used, but signature/issuer/audience/exp checks are not visible.
- Medium: webhook handler processes payload without verifying signature/MAC tied to a server-held secret.
- Weak: verification likely occurs outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_345_RULE)
