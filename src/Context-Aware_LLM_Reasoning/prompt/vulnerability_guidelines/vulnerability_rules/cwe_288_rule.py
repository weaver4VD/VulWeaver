CWE_288_RULE = """
[CWE-288 Reference Guideline | Authentication Bypass Using an Alternate Path or Channel | Non-binding, Evidence-first]

Overview
- CWE-288 occurs when an application requires authentication for a protected capability, but also exposes an alternate path/channel that reaches the same (or equivalent) capability without enforcing authentication.
- In partial snippets, missing authentication evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “authentication required” (protected capability signals)
- Sensitive operations: account/profile access, privileged admin actions, configuration changes, data exports, payment actions, key management.
- Reading or modifying protected resources: user-specific data, tenant data, internal records, system state.
- Issuing tokens/credentials or establishing sessions.
- Actions guarded elsewhere by login/session checks, middleware, or annotations.

What counts as an “alternate path or channel” (typical variants)
- Alternate endpoints/handlers:
  - Another URL route, HTTP method variant (GET vs POST), legacy endpoint, debug/test endpoint, “internal” API exposed externally.
  - Same controller method reachable via different mappings, aliases, or forwarding.
- Alternate protocol/channel:
  - WebSocket handlers, gRPC/RPC services, message queue consumers, webhooks, file-based interfaces, CLI/admin ports.
- Alternate routing paths:
  - Reverse proxy / gateway misrouting, URL rewriting, path normalization differences, versioned routes (/v1 vs /v2), subdomain-based routing.
- Indirect invocation paths:
  - SSRF-like internal call paths, background jobs triggered externally, callback endpoints that perform privileged actions.

Core static-analysis viewpoint: “equivalent sink reached with different guard coverage”
- The key pattern is: the same sensitive sink (or equivalent capability) is reachable through multiple code paths, and at least one path lacks authentication enforcement.
- A “guard” can be explicit (if checks) or implicit (framework annotations/middleware); under incomplete snippets, treat implicit enforcement as Unknown unless evidenced.

Typical implementation-level guard mechanisms (may or may not appear in snippet)
- Framework annotations: controller-level or method-level auth annotations, security interceptors/filters, middleware chains.
- Session/cookie/token checks: retrieving principal, checking session validity, verifying JWT/bearer tokens.
- Custom guards: helper methods (requireLogin/ensureAuthenticated), role checks that imply auth presence.
- Gateway-level enforcement: but if not visible in code snippet, treat as Unknown.

Typical failure modes (reasoning hints, not assumptions)
- Route mismatch / partial coverage:
  - Some endpoints lack the same security annotations or filter chain, especially “legacy”, “health”, “debug”, “callback” routes.
- Method/verb confusion:
  - POST is protected but GET variant exposes same action; or one mapping bypasses the intended interceptor.
- Internal-only assumptions:
  - An internal API assumed behind a firewall becomes reachable externally; code lacks auth checks as a result.
- Alternate channel overlooked:
  - WebSocket/RPC handler performs privileged operations without reusing HTTP security middleware.
- Object-level authorization missing:
  - A request is “authenticated” but alternate path allows acting on arbitrary user resources without verifying identity/ownership (may overlap with authz issues; focus on missing auth requirement first).

What “proper enforcement” looks like (context-specific)
- Consistent guard coverage:
  - All routes/channels reaching the sensitive sink go through the same authentication enforcement mechanism (shared middleware/interceptor or explicit check).
- Single source of truth:
  - Centralize auth checks (filters/interceptors) or enforce at the business logic layer before sensitive operations.
- Parity across variants:
  - Ensure aliases, versioned routes, and alternate protocols enforce equivalent authentication requirements.

Common weak/insufficient defenses (signals of possible risk)
- Relying on “it’s internal” assumptions rather than explicit authentication checks on every entry point.
- Protecting only some HTTP methods or only some routes to a shared handler.
- Guarding UI pages but not backing APIs that perform the real action.
- Conditional auth checks controlled by parameters/headers (e.g., “skipAuth=true”), unless strictly unreachable to attackers.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit authentication checks (principal/session/token validation) occur before the sensitive operation.
  - Security annotations/middleware are clearly applied to the handler (and not conditional) and are consistent across equivalent handlers.
  - Sensitive business logic is behind a shared service method that enforces auth regardless of entry point.
- Evidence suggesting vulnerability:
  - A code path triggers a sensitive operation without any visible auth check, while other similar paths (or expected policy) imply it should be protected.
  - Multiple handlers lead to the same sink, but only some appear guarded (e.g., one annotated, one not; one behind filter chain, one not).
  - Alternate channel handler (WebSocket/RPC/queue consumer) performs privileged actions with no principal validation.

How to use this guideline under incomplete context
- Use it to generate a small number of targeted hypotheses based on observed entry points and sensitive sinks:
  - H1: This handler/path reaches a protected capability but lacks authentication enforcement in-flow.
  - H2: Authentication is enforced implicitly via framework config/filters/annotations not shown here.
  - H3: Another alternate route/channel exists that reaches the same sink with weaker/no guard coverage.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., missing principal checks, unguarded handler),
  (b) evidence needed to confirm it (e.g., route mappings, security config, annotations on class/method, filter chain),
  (c) counter-evidence that would refute it (e.g., mandatory interceptor, shared service-level auth).

Quick red flags in partial code (weak → strong)
- Strong: sensitive operation reachable in a handler with no principal/session/token validation and no visible security annotations/guards.
- Medium: two routes/handlers share the same underlying action, but only one shows auth enforcement.
- Medium: “internal/debug/callback” endpoints performing privileged actions without explicit auth checks.
- Weak: authentication likely handled outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_288_RULE)
