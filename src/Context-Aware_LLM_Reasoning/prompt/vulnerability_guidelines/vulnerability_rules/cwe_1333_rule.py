CWE_1333_RULE = """
[CWE-1333 Reference Guideline | Inefficient Regular Expression Complexity | Non-binding, Evidence-first]

Overview
- CWE-1333 occurs when the product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity, which consumes excessive CPU cycles.
- Inefficient regular expressions can lead to performance degradation, denial of service (DoS) attacks, or system crashes, as the excessive CPU cycles spent processing the expression can exhaust system resources.
- In partial snippets, inefficient regular expression usage is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "inefficient regular expression" and "exponential complexity" (static analysis framing)
- Inefficient Regular Expression:
  - A regular expression that is unnecessarily complex or inefficient in terms of execution time, especially in cases where the worst-case scenario can result in excessive computational complexity.
  - Common sources of inefficiency include regular expressions that involve nested quantifiers, backtracking, or patterns that can match a large set of inputs in a highly recursive or exponential fashion.
- Exponential Complexity:
  - A situation where the time taken to execute the regular expression grows exponentially with the size of the input. This typically occurs in patterns that involve nested quantifiers, such as `.*`, `.+`, or other greedy matching operators, without proper constraints.
  - Exponential complexity can lead to performance bottlenecks, especially with large input sizes, and in some cases, attackers can exploit this inefficiency by crafting malicious inputs.

Where inefficient regular expression issues typically occur (sensitive sinks)
- User input validation:
  - When a regular expression is used to validate user input, inefficient patterns may result in excessive backtracking or redundant evaluations, consuming CPU cycles and slowing down the application.
- Data parsing or processing:
  - Using complex regular expressions to process large amounts of data, where inefficiencies can lead to high computational overhead or delays, particularly when the expression has to scan large datasets or files.
- Security-critical areas:
  - Input parsing in authentication, authorization, or authorization contexts where an inefficient regular expression could lead to service disruptions or performance degradation.
  
Common failure modes (reasoning hints, not assumptions)
- Nested or complex quantifiers:
  - Using quantifiers like `*`, `+`, `{n,m}`, or other greedy operators in a nested manner (e.g., `.*.*`) can lead to inefficient regular expressions with exponential backtracking, especially if the expression can match many combinations.
- Lack of anchoring or constraints:
  - Failing to anchor the regular expression at the start (`^`) or end (`$`) of the string, leading to unnecessary evaluation of substrings.
- Repetitive or redundant patterns:
  - Repeating similar patterns in the regular expression without optimizing, leading to redundant evaluations and increased computation time.
- Non-deterministic matching:
  - Using patterns that are not deterministically matched, causing the engine to explore multiple possibilities before finding the correct match, which increases processing time.

What “efficient regular expression design” looks like (context-specific)
- Avoid unnecessary backtracking:
  - Use non-greedy quantifiers (`*?`, `+?`) or more efficient patterns to avoid unnecessary backtracking, especially in patterns that match large datasets.
- Use anchored patterns:
  - Always anchor regular expressions at the beginning (`^`) and/or end (`$`) of strings to limit the matching scope and prevent unnecessary exploration of the entire string.
- Optimize quantifiers:
  - Limit the scope of quantifiers (e.g., `.*`) and use more restrictive patterns where possible (e.g., `[^ ]*` or `[a-z]+`).
- Use more efficient matching algorithms:
  - Consider using non-regex algorithms or libraries for tasks that can be handled more efficiently without relying on regular expressions (e.g., simple string matching or state machine parsing).
- Test for performance bottlenecks:
  - Regularly profile regular expression performance, especially when processing large or untrusted inputs, to identify potential inefficiencies and optimize them.

Common weak/insufficient defenses (signals of possible risk)
- Use of greedy quantifiers:
  - Use of greedy quantifiers like `.*`, `.+`, or `.*?` in patterns where they can lead to unnecessary backtracking, making the regular expression inefficient.
- Missing anchors or constraints:
  - Using regular expressions without anchors or proper constraints, allowing the engine to evaluate unnecessary parts of the string.
- Non-optimized or repetitive regular expressions:
  - Regular expressions with redundant or inefficient patterns that perform multiple unnecessary checks, such as repeating similar groups or patterns.
- Heavy reliance on regular expressions for complex tasks:
  - Over-reliance on regular expressions for complex input validation or data processing, where a more optimized or algorithmic approach might be more efficient.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Regular expressions that use non-greedy quantifiers (`*?`, `+?`) to prevent excessive backtracking.
  - Anchored regular expressions that are clearly constrained to only match the start or end of strings, limiting the evaluation scope.
  - Efficient matching patterns with limited or no nested quantifiers or repeated patterns (e.g., `[^ ]*` instead of `.*`).
  - Profiling or performance measurements to confirm that the regular expression is optimized and does not result in excessive CPU consumption.
- Evidence suggesting vulnerability:
  - Regular expressions that contain nested quantifiers, such as `.*.*` or `.+.*`, leading to exponential backtracking and inefficient execution.
  - Lack of anchoring in regular expressions, allowing the engine to evaluate the entire string unnecessarily.
  - Use of regular expressions with redundant or repetitive patterns that lead to multiple redundant evaluations or overly complex matching logic.

How to use this guideline under incomplete context
- Identify regular expressions and their context:
  - Where are regular expressions being used in the code? Are they used for validating input, parsing data, or performing complex checks?
- Identify potential inefficiencies:
  - Are there nested quantifiers, excessive use of `.*`, or non-deterministic patterns that may result in backtracking or inefficiency?
- Generate a small number of targeted hypotheses:
  - H1: The regular expression has inefficient nested quantifiers or patterns, leading to exponential backtracking.
  - H2: Regular expressions lack anchors or constraints, causing unnecessary evaluation of the entire string.
  - H3: The regular expression is overly complex or redundant, making it inefficient in processing large datasets or inputs.
  - H4: Performance profiling has not been conducted, and the impact of inefficient regular expressions has not been identified.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., nested quantifiers, lack of anchoring),
  (b) evidence needed to confirm it (e.g., performance profiling, regex simplifications),
  (c) counter-evidence that would refute it (e.g., optimized regular expressions, non-repetitive patterns).

Quick red flags in partial code (weak → strong)
- Strong: Regular expressions that contain nested quantifiers, such as `.*.*`, which can lead to significant performance issues due to backtracking.
- Medium: Regular expressions that are overly complex or use redundant patterns (e.g., multiple similar groups or excessive `.*` usage).
- Medium: Lack of anchoring in regular expressions, leading to unnecessary evaluations of the entire string.
- Weak: Regular expressions may be handled by external libraries or frameworks not visible in the current snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_1333_RULE)