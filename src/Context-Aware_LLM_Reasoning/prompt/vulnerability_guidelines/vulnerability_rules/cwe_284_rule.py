CWE_284_RULE = """
[CWE-284 Reference Guideline | Improper Access Control | Non-binding, Evidence-first]

Overview
- CWE-284 occurs when a product does not restrict, or incorrectly restricts, an unauthorized actor’s access to a protected resource or operation.
- This includes missing authorization checks, incorrect policy enforcement, broken object-level access control, and inconsistent enforcement across code paths.
- In partial snippets, missing access-control evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

Actors, resources, and boundaries (static analysis framing)
- Actor (who requests the action):
  - unauthenticated users, authenticated users, service accounts, internal components acting on behalf of users
- Resource (what is accessed):
  - data objects (records, files, projects), administrative functions, configuration, secrets, execution capabilities
- Boundary (where enforcement should occur):
  - controllers/endpoints, RPC handlers, service-layer methods, repository access wrappers, file-serving endpoints

Common access control failure modes (reasoning hints, not assumptions)
- Missing authorization:
  - sensitive action performed without verifying the actor is permitted
- Broken object-level authorization (resource ID not bound to actor):
  - actor can access/modify arbitrary objects by changing an identifier (IDOR/BOLA-like patterns)
- Incorrect policy logic:
  - inverted conditions, default-allow behavior, wrong role checks, missing tenant/project scoping
- Inconsistent enforcement:
  - one endpoint checks permissions but alternate paths to the same resource do not
- Confused deputy:
  - privileged component performs sensitive action on behalf of untrusted requester without validating intent/authorization

Typical sensitive operations (“sinks”)
- Read access:
  - fetch by ID, list restricted data, download/export, view logs/artifacts
- Write access:
  - update/delete resources, modify state, upload/replace content
- Admin/privilege operations:
  - change roles/ACLs, manage tokens/keys, change configuration, enable features
- Execution capabilities:
  - run jobs/builds/deployments, execute scripts/commands, trigger workflows

Evidence cues to look for in code (static snippet oriented)
- Authentication context acquisition:
  - how current principal/user is obtained (security context/session/token)
- Authorization decision points:
  - explicit checks (canAccess/hasPermission/isOwner/isAdmin/isMember)
  - framework annotations (e.g., role-based guards) and whether they apply to this path
  - resource scoping: checks tie the specific resource ID/path to actor’s rights/tenant/project membership
- Enforcement placement:
  - checks should occur before the sensitive operation and on all reachable code paths

What “proper access control” looks like (context-specific)
- Explicit, deny-by-default authorization:
  - if access is not explicitly granted, deny
- Object-level binding:
  - validate access to the specific resource referenced by the request (ownership/tenant/project scoping)
- Consistent enforcement:
  - centralized guards (filters/interceptors/annotations/shared helpers) applied to all entry points
- Least privilege:
  - avoid performing user-triggered operations under broad system/admin privileges unless constrained and audited by policy logic

Common weak/insufficient defenses (signals of possible risk)
- Authentication-only checks:
  - requiring login but not checking whether the user is allowed to access this particular resource
- Client/UI-only restrictions:
  - hiding buttons or routes without server-side enforcement
- Role checks without scoping:
  - checking “isUser” or coarse roles without verifying ownership/tenant/project membership
- Trusting “internal” calls:
  - assuming internal endpoints are safe while they can be reached through chaining or user-controlled inputs
- Partial checks:
  - checks in some branches but not others; checks after the operation; checks on the wrong identifier

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - clear authorization checks tied to the specific resource and action occur before the sensitive operation
  - consistent policy enforcement across all access paths to the resource
  - access decisions rely on server-side trusted identity and verified relationships (owner/member/role/tenant)
- Evidence suggesting vulnerability:
  - externally influenced resource identifier used for read/write without visible object-level authorization in the same flow
  - privileged operations reachable without appropriate authorization checks
  - logic that defaults to allow when checks are missing/unknown

How to use this guideline under incomplete context
- Identify the sensitive operation and the target resource:
  - what is the sink (read/write/admin/execute), and what input selects the resource?
- Identify the actor context:
  - where does identity/role/tenant come from, and is it used to gate access?
- Generate a small number of targeted hypotheses:
  - H1: Authorization is missing for this sensitive operation.
  - H2: Authorization exists but is not object-level (resource not bound to actor).
  - H3: Authorization logic is incorrect/incomplete (default-allow, wrong role, missing tenant scoping).
  - H4: Authorization is enforced by global filters/interceptors/annotations not visible in the snippet.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (sink + lack/shape of checks),
  (b) evidence needed to confirm it (security configuration, helper semantics, scoping rules),
  (c) counter-evidence that would refute it (explicit canAccess checks, object-level scoping, deny-by-default enforcement).

Quick red flags in partial code (weak → strong)
- Strong: user-controlled object ID/path used to access/modify without object-level permission checks.
- Medium: checks verify only authentication or coarse role, not ownership/tenant/project membership.
- Medium: alternate code paths to the same operation lack checks.
- Weak: enforcement may occur outside the shown function (filters/interceptors/annotations) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_284_RULE)