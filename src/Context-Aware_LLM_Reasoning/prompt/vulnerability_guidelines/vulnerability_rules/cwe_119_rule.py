CWE_119_RULE = """
[CWE-119 Reference Guideline | Buffer Bounds (Out-of-bounds Read/Write) | Non-binding, Evidence-first]

Overview
- CWE-119 (Improper Restriction of Operations within the Bounds of a Memory Buffer) occurs when a program performs operations on a memory buffer but reads from or writes outside the buffer’s intended bounds.
- Consequences include memory corruption, crashes, information disclosure (out-of-bounds read), and potentially arbitrary code execution (out-of-bounds write).
- CWE-119 is common in C/C++-style memory management, but Java code can still exhibit analogous risks via unsafe/native layers (JNI), ByteBuffer misuse, array indexing, or third-party native bindings.
- In partial snippets, missing safety checks is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “buffer” and “index/length” sources (typical in static analysis)
- Buffers:
  - C/C++: raw pointers, arrays, heap allocations (malloc/new), stack buffers
  - Java/JVM: byte[], char[], direct/heap ByteBuffer, arrays, off-heap memory via JNI/Unsafe (if present)
- Index/length/size inputs (often attacker-influenced):
  - Parsed integers, lengths from network/file formats, user-controlled sizes, offsets in protocols, loop bounds
  - Values derived from external data streams (socket/file), message fields, or untrusted metadata

Security-sensitive operations (typical sinks / risky APIs)
- C/C++:
  - memcpy/memmove/memset/strcpy/strncpy/strcat/sprintf/snprintf, read/write calls using sizes, pointer arithmetic
  - Custom loops copying data, manual indexing, pointer increments
- Java/JVM:
  - Array indexing with externally influenced indices
  - ByteBuffer.get/put with computed offsets/lengths
  - JNI/native calls passing buffers and sizes
  - Any use of sun.misc.Unsafe / VarHandles for raw memory (if present)

Typical out-of-bounds patterns (reasoning hints, not assumptions)
- Off-by-one errors: using <= instead of <, miscomputing end index, inclusive bounds.
- Incorrect length/size propagation: trusting an external length field, mismatch between allocated size and used size.
- Integer overflow/underflow in size calculations: (len * elemSize), (offset + len), sign issues (negative values).
- Missing null terminator handling in C strings, or mixing signed/unsigned types.
- Confusion between units: bytes vs elements; characters vs bytes; absolute offsets vs relative offsets.

What “proper restriction within bounds” looks like (context-specific)
- Ensure indices and lengths are validated before buffer access:
  - 0 <= index < buffer_length
  - 0 <= offset, 0 <= len, and offset + len <= buffer_length (watch overflow)
- Use safe APIs or abstractions where possible:
  - Bounds-checked library functions, size-aware wrappers, container abstractions
  - In Java, prefer APIs that inherently check bounds, and avoid raw/unsafe memory access
- Maintain consistent invariants:
  - Track allocated size and enforce it at all access points
  - Validate external length/offset fields against actual buffer sizes
- Guard against arithmetic overflow:
  - Check multiplication/addition overflow in size computations before allocation or access
  - Treat negative values as invalid for indices/lengths

Common weak/insufficient defenses (signals of possible risk)
- Relying on assumed constraints from upstream parsing without visible enforcement.
- Checking only one bound:
  - e.g., checking index < len but not index >= 0; or checking len <= max but not offset+len.
- Performing bounds checks after access (too late) or in a different unit than the access uses.
- Using “clamp” logic that silently adjusts values instead of rejecting invalid inputs, potentially causing logic flaws.
- In Java, assuming “exceptions will prevent exploitation” while ignoring native/JNI paths that can bypass JVM safety.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Clear preconditions/guards for index/offset/len before each access.
  - Consistent use of buffer length variables that correspond to the actual allocated/available size.
  - Overflow-safe arithmetic checks on computed sizes.
  - Use of safe, bounds-checked abstractions without unsafe/native escapes.
- Evidence suggesting vulnerability:
  - Buffer access using externally influenced index/offset/len with no visible guards in the same dataflow.
  - Complex arithmetic used to compute offsets/lengths without overflow checks.
  - Loops copying data where termination condition can exceed buffer boundaries.
  - Calls to native/JNI functions with attacker-influenced size parameters and unclear validation.

How to use this guideline under incomplete context
- Identify the buffer, the access site, and the controlling values:
  - What is the buffer? What is its size? Where do index/offset/len come from?
- Generate a small number of targeted hypotheses based on the observed access pattern:
  - H1: An index/offset derived from external input can exceed buffer bounds.
  - H2: A size computation can overflow/underflow, invalidating bounds checks.
  - H3: Bounds checks exist in helpers/callers not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (access site + untrusted controlling value),
  (b) evidence needed to confirm it (buffer allocation size, full validation logic, type ranges),
  (c) counter-evidence that would refute it (in-flow guards, proven invariants, safe APIs).

Quick red flags in partial code (weak → strong)
- Strong: externally influenced index/offset/len used in buffer read/write with no visible bounds checks.
- Medium: bounds checks exist but ignore negatives, ignore offset+len, or risk overflow in computations.
- Medium: manual copy loops or pointer arithmetic with complex termination logic.
- Weak: safety checks may exist outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_119_RULE)
