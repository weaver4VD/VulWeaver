CWE_287_RULE = """
[CWE-287 Reference Guideline | Improper Authentication | Non-binding, Evidence-first]

Overview
- CWE-287 occurs when an actor claims an identity, but the product does not sufficiently prove or verify that the claim is correct, allowing unauthorized access as if the actor were authenticated.
- This concerns authentication (who you are), distinct from authorization (what you can do). Weak authentication often enables downstream authorization bypass.
- In partial snippets, missing authentication evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

Identity claims (typical upstream inputs)
- Session identifiers:
  - cookies/session IDs, bearer tokens, API keys, JWTs
- Credentials:
  - username/password, one-time codes, client certificates
- “Identity headers”:
  - X-User, X-Forwarded-User, X-Remote-User (often set by proxies) and similar custom headers
- Query/body identity fields:
  - userId/accountId fields supplied by the requester
- Signed assertions:
  - SSO/SAML/OIDC assertions, signed URLs, HMAC-based requests

Authentication boundaries and sinks (where verification should occur)
- Entry points:
  - web endpoints/controllers/servlets/filters/interceptors
  - RPC handlers/service endpoints
- Trust boundary crossings:
  - requests coming from outside the trust zone (internet, untrusted networks) into internal services
- Security context establishment:
  - code that sets “current user/principal” in thread-local/security context/session
  - middleware that populates authentication state

Common improper-authentication failure modes (reasoning hints, not assumptions)
- No verification:
  - accepting identity fields (userId, username) from the request without proving possession of credentials/token
- Trusting untrusted headers:
  - using request headers as identity without ensuring they are set by a trusted gateway and cannot be spoofed
- Weak token validation:
  - not verifying signature, expiry, audience/issuer, nonce, or binding to session/client as required
- Broken session handling:
  - predictable session IDs, missing session invalidation, not checking session is authenticated
- Missing replay protection where required:
  - accepting stale tokens/codes without appropriate freshness checks
- Confusing authentication with presence:
  - treating “parameter exists” or “non-empty token string” as authenticated without validating it

What “proper authentication” looks like (context-specific)
- Prove the identity claim:
  - verify credentials or validate tokens against a trusted authority (signature/secret, expiry, issuer/audience as appropriate)
- Establish trusted security context:
  - set current principal only after successful verification
- Protect trust boundaries:
  - only trust identity headers if they are injected by a trusted reverse proxy/gateway and cannot be supplied directly by the client
- Enforce freshness and integrity:
  - enforce expiration, nonce/replay protections when applicable, and reject tampered/unsigned tokens
- Fail closed:
  - unauthenticated requests should not proceed as authenticated; avoid defaulting to a user/role on errors

Common weak/insufficient defenses (signals of possible risk)
- “Authentication” based on user-supplied IDs:
  - taking userId from request and loading that user as the current principal without verifying credentials/token
- Accepting tokens without validation:
  - parsing JWT claims without verifying signature/expiry, or using “decode” APIs that do not validate
- Using remote-user headers directly:
  - relying on X-Forwarded-User/X-Remote-User from client-facing requests without gateway enforcement
- Error-handling bypass:
  - exceptions during verification lead to granting access, anonymous-to-authenticated fallback, or skipping checks
- Inconsistent enforcement:
  - some endpoints/paths enforce authentication, others do not

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - authentication is performed by a framework filter/interceptor or explicit verifier before any protected logic runs
  - token validation checks are visible (signature/secret validation, expiry checks, issuer/audience checks where relevant)
  - security context/principal is set only after successful verification
  - identity headers are only accepted when request is from a trusted internal channel/gateway (as evidenced in code/config)
- Evidence suggesting vulnerability:
  - setting principal/user context from request parameters/headers without verification
  - accepting bearer tokens/JWTs but only decoding/parsing without validation
  - bypass paths where missing/invalid credentials still allow access to protected operations
  - “if token != null” style checks without cryptographic/authoritative verification

How to use this guideline under incomplete context
- Identify where identity is claimed and where it is verified:
  - what field/header/token represents identity, and where is verification performed?
- Identify what “authenticated” means in this code path:
  - is there a security context, session object, or principal used to gate access?
- Generate a small number of targeted hypotheses:
  - H1: Identity is accepted from upstream input without proof (no real authentication).
  - H2: Token/session is used but validation is incomplete (signature/expiry/trust boundary).
  - H3: Authentication is enforced by global filters/interceptors/framework configuration not shown here.
  - H4: There is an error-handling path that fails open.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (where principal is derived, what checks are missing),
  (b) evidence needed to confirm it (security filter chain, token verifier config, trusted proxy assumptions),
  (c) counter-evidence that would refute it (explicit verification calls, framework-authenticated principal, fail-closed logic).

Quick red flags in partial code (weak → strong)
- Strong: principal/user identity set from request parameters or client-controlled headers without credential/token verification.
- Medium: JWT/bearer token parsed/decoded without signature/expiry validation.
- Medium: identity headers trusted on externally reachable endpoints without gateway enforcement evidence.
- Weak: authentication may be enforced outside the shown method (filters/interceptors) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_287_RULE)
