CWE_1018_RULE = """
[CWE-1018 Reference Guideline | CATEGORY: Manage User Sessions | Non-binding, Evidence-first]

Overview
- “Manage User Sessions” refers to weaknesses where a product mishandles the creation, binding, lifecycle, or invalidation of user sessions and session credentials.
- Session management flaws can enable unauthorized access via session hijacking, fixation, replay of stale credentials, cross-user session confusion, or privilege retention beyond intended lifetimes.
- In partial snippets, missing session controls are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “user session management” (static analysis framing)
- Session credential:
  - Any bearer artifact used to represent a logged-in session (session ID cookie, opaque token, signed token/JWT, remember-me token, refresh token used as session).
- Session lifecycle:
  - Creation (login), binding to identity, renewal/rotation, validation on each request, expiration (idle/absolute), logout invalidation, revocation on security events.
- Security goals:
  - Confidentiality of session credentials, correct binding to a principal, resistance to replay/fixation, and timely expiration/invalidation.

Where session management weaknesses typically occur (sensitive sinks)
- Login and session issuance:
  - Generating session IDs/tokens, setting cookies/headers, binding principal/roles/tenant.
- Request authentication middleware:
  - Extracting session credential and mapping to a principal (filters/interceptors).
- Logout and revocation paths:
  - Clearing cookies vs server-side invalidation; revocation lists/blacklists; session store deletions.
- Session rotation triggers:
  - After login, privilege changes, MFA completion, password change/reset, account disable.
- Cross-context usage:
  - Multiple subdomains/apps sharing cookies, multi-tenant apps, SSO bridges, gateway-to-service session propagation.

Common failure modes (reasoning hints, not assumptions)
- Weak session identifier handling:
  - Predictable IDs, reuse, insufficient randomness, or exposing IDs in URLs.
- Improper binding:
  - Session maps to wrong user/tenant; trusts caller-supplied userId to bind session.
- Session fixation:
  - Accepting a preexisting session ID after authentication without regenerating/rotating it.
- Insufficient expiration/invalidation:
  - Old session IDs remain valid after logout or beyond intended lifetime; no idle/absolute timeout enforcement.
- Missing renewal/rotation:
  - Long-lived tokens not rotated; remember-me tokens reusable without rotation/revocation.
- Over-broad session scope:
  - Cookie domain/path too broad; shared across apps unintentionally; inconsistent SameSite/secure handling where relevant.
- Inconsistent enforcement:
  - Some endpoints bypass session validation or perform partial checks.

What “robust session management” looks like (context-specific)
- Strong issuance and binding:
  - Generate unpredictable session IDs/tokens; bind to authenticated principal and tenant; avoid user-controlled binding inputs.
- Rotate on critical events:
  - Regenerate session IDs on login and privilege elevation; rotate/refresh tokens safely.
- Enforce expiration:
  - Idle + absolute timeouts checked on every request; fail closed when expired; remove from session store.
- Logout revocation:
  - Invalidate server-side session state (not only client cookie clearing); revoke persistent tokens.
- Consistent validation:
  - Centralized middleware enforces session validity and scope for all protected endpoints.

Common weak/insufficient defenses (signals of possible risk)
- Client-only controls:
  - Relying on cookie expiration alone without server-side TTL checks or revocation.
- UI-only logout:
  - Clearing browser state but leaving server-side session active.
- “Internal” endpoints exempted:
  - Assuming internal routes are safe; can be reachable via misrouting/SSRF or reused by gateways.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Secure session/token generation, explicit binding to authenticated principal, and no trust of caller-provided identity fields.
  - Session rotation/regeneration on login/privilege changes.
  - Middleware that checks expiry/revocation and enforces tenant/user scoping.
  - Logout invalidates server-side sessions and revokes persistent tokens.
  - Clear separation of short-lived access tokens and refresh tokens with strict validation.
- Evidence suggesting vulnerability:
  - Accepting/setting session IDs from request input or URLs; reusing session ID across auth transitions.
  - Missing expiry checks in session validation path; sessions remain valid indefinitely.
  - Logout only deletes cookie but does not revoke server-side session.
  - Inconsistent session checks across endpoints (some handlers bypass middleware).
  - Session scope confusion (cookie domain/path shared broadly; tenant scoping absent in lookups).

How to use this guideline under incomplete context
- Identify session credential type and flow:
  - Cookie session ID vs token; where is it issued, stored, and validated?
- Identify enforcement boundaries:
  - Which middleware or interceptors validate sessions? Are some paths exempt?
- Generate a small number of targeted hypotheses:
  - H1: Session lifecycle controls (expiration/invalidation/rotation) are missing or inconsistently enforced.
  - H2: Session binding/scoping is weak (user/tenant confusion, caller-supplied identity).
  - H3: Session fixation or replay is possible due to lack of regeneration or revocation.
  - H4: Session controls are provided elsewhere (framework security config, shared auth gateway) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., no rotate on login, no expiry checks, trusting userId param),
  (b) evidence needed to confirm it (e.g., middleware code, session store TTL config, cookie attributes),
  (c) counter-evidence that would refute it (e.g., enforced TTL checks, server-side revoke on logout, regeneration).

Quick red flags in partial code (weak → strong)
- Strong: Session IDs/tokens accepted or set from external input; no rotation on login; no expiry/revocation checks in validation path.
- Medium: Logout clears client state only; remember-me tokens reusable; inconsistent enforcement across endpoints.
- Medium: Tenant/user scoping missing when resolving session → cross-user session confusion risk.
- Weak: Session management may be handled by omitted framework/gateway configuration → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_1018_RULE)