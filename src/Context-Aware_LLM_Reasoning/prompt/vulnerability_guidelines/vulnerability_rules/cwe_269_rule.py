CWE_269_RULE = """
[CWE-269 Reference Guideline | Improper Privilege Management | Non-binding, Evidence-first]

Overview
- CWE-269 occurs when the product does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.
- Privilege management problems often surface as “who can do what” being broader than intended due to incorrect role assignment, missing privilege revocation, stale privilege state, or misuse of privileged execution paths.
- In partial snippets, absence of visible checks is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "privilege management" (static analysis framing)
- Privilege:
  - A capability/authority that allows an actor to access protected resources or perform protected operations (admin actions, elevated APIs, sensitive configuration, filesystem/network actions).
- Privilege management:
  - The lifecycle and enforcement of privilege state:
    - Assignment: granting roles/permissions/capabilities.
    - Modification: elevation/demotion, role changes, delegation.
    - Tracking: persistence and freshness of privilege state (sessions, caches, tokens).
    - Checking: verifying privilege at the point of the protected operation.
- Unintended sphere of control:
  - The actor gains the ability to control resources/actions beyond policy, even if partially (e.g., escalating to admin-like operations, cross-tenant control, privileged configuration changes).

Where improper privilege management typically occurs (sensitive sinks)
- Privileged operations / admin endpoints:
  - Create/delete users, modify roles, change security settings, run maintenance actions, access sensitive data.
- Authorization gates and privilege checks:
  - `isAdmin`, `hasRole`, `canAccess`, ACL evaluation, policy engine hooks.
- Session/token privilege binding:
  - Where privileges are embedded in session state, JWT claims, cached principal objects.
- Impersonation / delegation / “run-as” features:
  - Switching identities, acting on behalf of others, service-to-service credentials.
- Privileged execution context:
  - “system user” actions, root-level service accounts, scheduled jobs that can be triggered by unprivileged users.

Common failure modes (reasoning hints, not assumptions)
- Missing checks at the sink:
  - Sensitive operation executed without verifying privilege at the call site.
- Confused deputy / wrong principal:
  - Authorization performed against a different actor than the one performing/triggering the action (e.g., using caller-supplied userId).
- Privilege escalation via assignment path:
  - Role/permission update endpoints allow self-assignment or assignment without requiring higher privilege.
- Stale privilege state:
  - Privilege changes not reflected in active sessions/tokens/caches; revoked privileges still effective.
- Over-broad defaults:
  - New accounts get too many privileges; fallback role is too permissive.
- Improper privilege boundary in internal APIs:
  - Internal-only privileged methods callable from untrusted paths (e.g., public controller can invoke admin service method).

What “correct privilege management” looks like (context-specific)
- Enforce at the protected operation:
  - Privilege checks adjacent to the sensitive action (defense-in-depth), not only at entry points.
- Strong, explicit privilege transitions:
  - Privilege grant/revoke paths require appropriate authority and are auditable in code structure.
- Bind privilege to authenticated principal:
  - Use server-derived principal identity, not caller-provided identifiers, for authorization decisions.
- Freshness and revocation:
  - Ensure privilege changes propagate (invalidate sessions/tokens or re-fetch privileges at use points).
- Least privilege by default:
  - Conservative default roles; explicit elevation requires deliberate, authorized action.

Common weak/insufficient defenses (signals of possible risk)
- UI-only or client-only gating:
  - Hiding admin buttons without server-side enforcement.
- Single centralized check far from sink:
  - One check at routing layer, but internal calls can bypass it.
- Parameter-based “authorization”:
  - Trusting `role=admin` or `isAdmin=true` from request input.
- Over-trusting service accounts:
  - Running requests as a privileged service identity without strict request-level authorization.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit authorization checks for privileged operations, referencing the authenticated principal and required privilege.
  - Separate “admin” service interfaces guarded by policy checks; non-admin code cannot invoke them directly.
  - Role assignment/modification functions require higher privilege and prevent self-escalation.
  - Session/token invalidation or privilege refresh mechanisms after privilege changes.
- Evidence suggesting vulnerability:
  - Sensitive operations (role changes, config updates, admin actions) performed with no privilege check in the visible call chain.
  - Role/permission update endpoints that accept target role/permissions from request and apply them without verifying authority.
  - Authorization based on user-controlled parameters (e.g., `userId`, `role`, `isAdmin`) without binding to authenticated identity.
  - Use of cached/stored privilege state with no refresh/revalidation, especially after updates.

How to use this guideline under incomplete context
- Identify the privileged asset/action:
  - What operation changes security posture, controls resources, or accesses protected data?
- Identify the actor and privilege source:
  - Where does principal identity come from (session/auth context)? Is it server-derived or user-supplied?
- Generate a small number of targeted hypotheses:
  - H1: Privileged operation is reachable without an appropriate privilege check at the sink.
  - H2: Privilege assignment/modification path allows self-escalation or unauthorized privilege changes.
  - H3: Privilege state is stale (revocation not enforced) due to caching/session/token behavior.
  - H4: Privilege checks are enforced elsewhere (filters/interceptors/annotations/policy engine) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., missing `hasRole` before admin action, request-driven role updates),
  (b) evidence needed to confirm it (e.g., security middleware, policy configuration, service-layer guards),
  (c) counter-evidence that would refute it (e.g., explicit server-side privilege checks, revocation propagation).

Quick red flags in partial code (weak → strong)
- Strong: Role/permission changes applied based on request input without verifying caller privilege (self-assign/elevate).
- Medium: Sensitive operations executed in service layer without visible authorization checks; relies on upstream gating only.
- Medium: Authorization decisions use caller-supplied identifiers instead of authenticated principal binding.
- Weak: Enforcement may exist in omitted layers (security annotations, interceptors, centralized policy engine) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_269_RULE)
