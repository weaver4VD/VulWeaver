CWE_285_RULE = """
[CWE-285 Reference Guideline | Improper Authorization | Non-binding, Evidence-first]

Overview
- CWE-285 occurs when a product does not perform an authorization check, or performs it incorrectly, when an actor attempts to access a resource or perform an action.
- This focuses on the authorization decision itself (who is allowed to do what), distinct from authentication (who the actor is).
- In partial snippets, missing authorization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

Actors, resources, and actions (static analysis framing)
- Actor:
  - unauthenticated user, authenticated user, service account, internal component acting on behalf of a user
- Resource:
  - data objects (records/files/projects), administrative settings, secrets, execution capabilities
- Action:
  - read/view, create, update, delete, share/publish, grant roles/permissions, execute/run

Common improper-authorization failure modes (reasoning hints, not assumptions)
- Missing authorization gate:
  - code executes sensitive action without checking permissions/roles/ownership
- Checking the wrong thing:
  - checks authentication only (logged-in) but not authorization for the action/resource
  - checks a coarse role but ignores object-level scope (ownership/tenant/project membership)
  - validates the wrong identifier (e.g., checks access to one object but operates on another)
- Incorrect policy logic:
  - inverted condition, default-allow behavior, stale/cached permissions, bypass via alternate branch
- Inconsistent enforcement:
  - one entry point enforces authorization, another path to the same operation does not
- Confused deputy:
  - privileged component performs action on behalf of requester without verifying requester’s authorization

Typical sensitive operations (“sinks”)
- Reads of protected data:
  - fetch by ID, list private objects, download/export artifacts, view logs
- Writes and state changes:
  - update/delete resources, upload/replace content, modify configuration
- Privilege and policy changes:
  - grant roles, modify ACLs, issue tokens/keys, change ownership
- Execution capabilities:
  - trigger jobs/builds/deployments, execute scripts/commands, invoke admin-only actions

Evidence cues to look for in code (static snippet oriented)
- Where authorization should occur:
  - controllers/endpoints, RPC handlers, service methods, command handlers
- Authorization mechanisms (examples of signals):
  - explicit checks: canAccess/hasPermission/isOwner/isAdmin/isMember/authorize(...)
  - framework annotations: role-based or policy-based guards (and whether they apply here)
  - object-level scoping: the same resource identifier used in the sink is checked against the actor’s rights
- Placement and coverage:
  - checks appear before the sensitive operation and on all reachable paths

What “proper authorization” looks like (context-specific)
- Deny-by-default:
  - access/action is denied unless an explicit allow rule is satisfied
- Action + resource + actor binding:
  - authorization decision considers the specific action and the specific resource instance, not just “user is logged in”
- Consistency:
  - shared authorization helpers/interceptors/annotations ensure every path is guarded
- Least privilege:
  - avoid executing user-triggered operations with system/admin privilege unless policy is enforced and scoped

Common weak/insufficient defenses (signals of possible risk)
- UI/client-side checks only:
  - hiding buttons/menus without server-side authorization
- Authentication-only gating:
  - “if (user != null)” without checking permissions for the resource/action
- Coarse role checks without scope:
  - “isUser” / “isAdmin” used incorrectly; missing tenant/project/ownership checks where required
- Post-check:
  - checks performed after the operation or only in some branches
- Trusting “internal” callers:
  - assuming internal APIs won’t be abused when user-controlled flows can reach them

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - explicit authorization checks tied to the specific resource ID and specific action occur before the sink
  - object-level binding (ownership/tenant/project membership) is enforced for ID-based access
  - centralized policy enforcement is clearly in effect for this method/path
- Evidence suggesting vulnerability:
  - sensitive operation uses externally influenced resource identifiers or triggers privileged actions without visible authorization checks
  - authorization exists but is mismatched (wrong role, wrong object, missing scope)
  - alternate paths perform the same operation with weaker/no authorization

How to use this guideline under incomplete context
- Identify actor context, resource, and action:
  - where identity comes from, what resource is targeted, what action is performed
- Generate a small number of targeted hypotheses:
  - H1: Authorization is missing for this action/resource.
  - H2: Authorization is present but not object-level (resource not bound to actor).
  - H3: Authorization logic is incorrect/incomplete (default-allow, wrong role/scope, wrong object checked).
  - H4: Authorization is enforced by global filters/interceptors/annotations not visible in the snippet.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (sink + lack/shape of checks),
  (b) evidence needed to confirm it (security config, helper semantics, scoping rules, annotations applicability),
  (c) counter-evidence that would refute it (explicit authorize() checks on same resource/action, deny-by-default policy).

Quick red flags in partial code (weak → strong)
- Strong: user-controlled object ID/path used for read/write without object-level authorization.
- Medium: checks verify only “logged in” or coarse role, not ownership/tenant/project membership.
- Medium: privilege-changing operations reachable without clear authorization gates.
- Weak: enforcement may occur outside the shown function (filters/interceptors/annotations) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_285_RULE)