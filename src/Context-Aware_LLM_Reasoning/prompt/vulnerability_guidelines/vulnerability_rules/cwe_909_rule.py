CWE_909_RULE = """
[CWE-909 Reference Guideline | Missing Initialization of Resource | Non-binding, Evidence-first]

Overview
- CWE-909 occurs when the product does not initialize a critical resource that it relies on for correct and safe operation.
- “Critical resource” can include security-relevant state (permission/role context, crypto/TLS context, RNG seed), safety checks/guards, synchronization primitives, configuration controls, handles, or objects whose initialization establishes required invariants.
- Missing initialization can cause undefined behavior, insecure defaults, policy bypass, crashes, data corruption, or exposure of protected operations.
- In partial snippets, absence of an init call is not proof of CWE-909: initialization may occur elsewhere (constructors, framework lifecycle hooks, wrappers). Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “missing initialization” (static analysis framing)
- Missing initialization:
  - A required init step is never performed (or not performed before first use), such that:
    - The resource remains in an indeterminate/unconfigured state, or
    - The resource operates under unsafe default behavior because setup did not occur.
- “Critical resource” indicators:
  - Resource governs security boundaries or correctness:
    - Auth/authorization context, ACLs, session state, crypto keys, TLS verification settings, input validators, locks, resource limits, file permission settings, sandboxing controls.
- Difference from CWE-908 (use of uninitialized resource):
  - CWE-909 emphasizes that initialization is missing for a critical resource at all (or conceptually absent), not merely that a use occurs before initialization on some path. In practice, static inspection often overlaps; focus on “required init step not present/guaranteed”.

Where CWE-909 typically occurs (sensitive sinks)
- Security setup that must be configured:
  - TLS/certificate validation settings, secure RNG seeding, crypto context initialization, access control initialization, permission masks.
- Synchronization primitives:
  - Mutex/condvar init missing before lock/wait usage; lock objects used without init.
- Configuration gating:
  - Rate limits, quotas, sandbox policies, safe mode flags not initialized and default to permissive.
- Resource handles/contexts:
  - DB pool/client context not initialized; parser/decoder context not setup; session store not initialized.
- Framework lifecycle-dependent components:
  - Objects expected to be initialized in `init()`, `onStart()`, `@PostConstruct`, servlet filters, or DI container setup but missing wiring.

Common failure modes (reasoning hints, not assumptions)
- Relying on implicit defaults:
  - Assuming the resource starts “secure” but defaults are permissive or undefined.
- Skipping mandatory init due to refactor:
  - Init call removed/forgotten; constructor path changed; dependency injection not configured.
- Conditional init that never runs:
  - Init guarded by a condition that is false in some deployments, leaving resource uninitialized.
- Init API call present but ineffective:
  - Calling init with wrong parameters, or ignoring failure so resource remains uninitialized.
- Using the resource without establishing invariants:
  - Missing init that sets required fields, permissions, or validation rules.

What “correct initialization of critical resources” looks like (context-specific)
- Explicit initialization at creation time:
  - Constructors or factory functions fully initialize resources to safe defaults.
- Mandatory init verified before use:
  - Enforce init completion via state flags, invariants, or “must succeed” setup with fail-safe behavior.
- Secure-by-default configuration:
  - Defaults are restrictive; if init is missing, system fails closed rather than permissive.
- Centralized initialization path:
  - One authoritative setup routine; avoid scattered partial initialization.
- Detect and stop on init failure:
  - If a critical resource cannot be initialized, abort the operation safely (or refuse to start service) rather than continuing in degraded insecure mode.

Common weak/insufficient defenses (signals of possible risk)
- “Assume initialized elsewhere”:
  - No enforceable guarantee; initialization is implicit and easy to break.
- Soft-fail init:
  - Catching init exceptions and continuing with partially configured or default-permissive behavior.
- Checks based on non-null only:
  - Resource may exist but still not be configured (non-null ≠ initialized correctly).

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Constructors/factories that set all critical fields and configure secure defaults.
  - Explicit, unconditional init sequence (setup calls) executed before any use; failures handled by fail-closed logic.
  - Guarded access patterns: operations require `isInitialized == true` tied to real init completion.
  - Dependency injection wiring that ensures critical resource is created/configured before injection (visible in code/config).
- Evidence suggesting vulnerability:
  - Use of a critical resource without any visible init/setup/configuration in the creation path.
  - Security-critical settings left at defaults without explicit hardening (e.g., TLS verification not configured).
  - Init calls are conditional/optional, with paths where they do not execute, yet resource is used.
  - Init failure ignored; code proceeds with a “best effort” object.
  - Placeholder stubs or TODOs around initialization of security controls.

How to use this guideline under incomplete context
- Identify the “critical resource” and its required init contract:
  - What must be configured to make it safe/correct (keys, policies, validation rules, permissions, limits, state)?
- Locate creation and setup:
  - Constructors, factories, init hooks, dependency injection configuration, module wiring.
- Locate first use sites:
  - Where the resource influences security decisions or performs protected operations.
- Determine whether initialization is guaranteed:
  - Is there a single, unconditional init path that dominates all uses? Or is it assumed/implicit?
- Generate a small number of targeted hypotheses:
  - H1: A critical resource is never initialized/configured, leaving unsafe defaults or undefined behavior.
  - H2: Initialization is conditional or can fail, and the system continues in a degraded insecure state.
  - H3: Initialization is incomplete (missing required fields/policies), so the resource is effectively uninitialized for security purposes.
  - H4: Initialization is enforced elsewhere (framework lifecycle, constructors, configuration files) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., creation + immediate use, no setup calls),
  (b) evidence needed to confirm it (e.g., framework init hooks, config defaults, init API semantics),
  (c) counter-evidence that would refute it (e.g., explicit setup sequence, secure defaults, fail-closed behavior).

Quick red flags in partial code (weak → strong)
- Strong: Security-critical component used with no visible configuration/initialization and defaults appear permissive; init failures ignored.
- Medium: Init is optional/conditional; different constructors or deployment modes skip required setup; uses proceed anyway.
- Medium: Resource exists but essential fields/policies are never set; access guarded only by non-null checks.
- Weak: Initialization may occur in omitted framework wiring/config/constructors not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_909_RULE)
