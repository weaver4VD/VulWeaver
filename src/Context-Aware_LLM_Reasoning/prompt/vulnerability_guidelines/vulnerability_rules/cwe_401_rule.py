CWE_401_RULE = """
[CWE-401 Reference Guideline | Missing Release of Memory after Effective Lifetime | Non-binding, Evidence-first]

Overview
- CWE-401 occurs when a product fails to properly track and release allocated memory after it has been used, making the memory unavailable for reallocation or reuse.
- This leads to memory leaks, where memory that is no longer needed remains allocated, progressively consuming more system memory. This can cause crashes, slowdowns, or resource exhaustion over time.
- In partial snippets, missing memory release or tracking evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “memory allocation” and “effective lifetime” (static analysis framing)
- Memory allocation:
  - Any operation that reserves memory for use, such as `malloc()`, `new`, or `Buffer.alloc()` in languages with manual or semi-automatic memory management.
  - Memory allocation can also refer to dynamic structures like arrays, lists, or other data structures that are manually managed.
- Effective lifetime:
  - The time between the allocation of memory and its final use or disposal.
  - When the memory is no longer required or relevant (e.g., after processing), it should be released immediately.

Where missing memory release occurs (sensitive sinks)
- Manual memory management:
  - Allocating memory (e.g., `malloc`, `new`) without deallocating it when the object or memory block is no longer needed.
- Persistent resources:
  - Holding onto memory or data structures that are no longer required for the operation, but remain allocated due to missing release logic.
- Resource cleanup:
  - Failing to free or release memory resources after an operation finishes or when the resource goes out of scope.

Typical failure modes (reasoning hints, not assumptions)
- Failure to free memory after use:
  - Memory is allocated but never deallocated after the data is no longer needed.
- Memory references remain:
  - Objects or data structures that reference allocated memory continue to hold pointers, preventing garbage collection or memory deallocation.
- Lack of tracking or release:
  - Allocated memory is not tracked, leading to difficulty identifying and releasing resources.
- Poor cleanup on error or exit:
  - Memory leaks occur due to error paths, exceptions, or system shutdown scenarios where memory is not properly freed.
  
What “proper memory management” looks like (context-specific)
- Ensure every allocation is paired with a deallocation:
  - Memory is allocated with `malloc()`, `new`, or equivalent, and then freed with `free()` or `delete` when no longer needed.
  - Proper use of destructors or finalizers (in managed languages) to release resources when an object goes out of scope.
- Manage memory within scopes:
  - Limit the memory lifetime to the scope of its use; do not hold onto memory beyond its need.
- Use of smart pointers or memory management tools (in C++ or similar languages):
  - RAII (Resource Acquisition Is Initialization) in C++ or smart pointers like `std::unique_ptr`/`std::shared_ptr` for automatic memory release.
- Handle memory cleanup on errors:
  - In error paths or exceptions, ensure that allocated memory is properly freed (e.g., using `finally` blocks or equivalent in the code).

Common weak/insufficient defenses (signals of possible risk)
- Memory is allocated but not freed:
  - Using `malloc()` or `new` without `free()` or `delete`.
- Memory leaks in error handling:
  - Allocated memory is not released when an error occurs, or memory is lost due to exception handling paths.
- Not tracking allocated memory:
  - Not keeping track of memory allocation/release, causing memory blocks to be orphaned and inaccessible.
- Complex structures with no cleanup:
  - Data structures (e.g., lists, trees) are dynamically allocated but lack cleanup logic for individual elements or substructures.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Memory is explicitly freed/deallocated when it is no longer in use, using appropriate functions (`free()`, `delete`).
  - Clear ownership/management of memory through RAII principles, smart pointers, or automatic resource management frameworks.
  - Exception handling that ensures memory is released, such as `try-finally` blocks or using `defer`/`with` in managed languages.
- Evidence suggesting vulnerability:
  - Memory is allocated but no corresponding `free()`/`delete` calls are visible in the same code path.
  - Allocated memory is referenced by long-lived variables or data structures, preventing deallocation.
  - Complex data structures are created but there is no logic to traverse and release memory from substructures.
  - Error handling paths do not include memory release logic.

How to use this guideline under incomplete context
- Identify resource allocation and deallocation logic:
  - Where does memory get allocated (e.g., `malloc()`, `new`)? Where is it freed (e.g., `free()`, `delete`)?
- Track the scope of memory usage:
  - Does the allocated memory get released as soon as it’s no longer needed, or is it retained unnecessarily?
- Generate a small number of targeted hypotheses:
  - H1: Memory is allocated but never freed, leading to a potential memory leak.
  - H2: Memory allocation and deallocation are mismatched, leaving allocated blocks orphaned.
  - H3: Memory release is handled outside the visible code (in helpers, cleanup functions, or not shown in the snippet).
  - H4: Error paths and exceptions fail to release memory.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (allocation points, missing deallocation),
  (b) evidence needed to confirm it (ownership models, exception handling, resource cleanup helpers),
  (c) counter-evidence that would refute it (explicit memory management, resource release via smart pointers).

Quick red flags in partial code (weak → strong)
- Strong: allocated memory (`malloc`, `new`) with no corresponding release (`free`, `delete`) in visible code.
- Medium: memory allocated inside loops or functions but not freed in the same scope.
- Medium: references to allocated memory persist beyond the immediate scope of usage, preventing cleanup.
- Weak: memory management may be implemented outside of the shown code (e.g., helper functions or automatic cleanup) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_401_RULE)
