CWE_459_RULE = """
[CWE-459 Reference Guideline | Incomplete Cleanup | Non-binding, Evidence-first]

Overview
- CWE-459 occurs when a product fails to properly clean up and remove temporary or supporting resources after they have been used, leading to the accumulation of leftover resources (e.g., files, memory, network connections).
- These leftover resources can be accessed or exploited by unauthorized users or attackers, potentially leading to security vulnerabilities, data leakage, or system performance degradation.
- In partial snippets, missing cleanup logic is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “temporary or supporting resources” (static analysis framing)
- Temporary resources:
  - Files, logs, session data, and caches that are created for transient use and should be removed after use.
- Memory resources:
  - Dynamically allocated memory (e.g., heap allocations), objects, arrays, or buffers that are no longer needed.
- Network connections:
  - Open sockets, database connections, or other external connections (e.g., HTTP requests, FTP sessions) that should be closed after use.
- Cryptographic materials:
  - Keys, nonces, or other sensitive data used temporarily during operations but should be erased once their purpose is complete.

Where incomplete cleanup occurs (sensitive sinks)
- File handling:
  - Temporary files that are created but not deleted after use, or files with sensitive information that are left behind.
- Memory management:
  - Memory that is allocated but not freed or cleared after use, leading to memory leaks.
- Network resources:
  - Connections or sockets that are opened but never properly closed, potentially allowing for unauthorized access.
- Sensitive data:
  - Temporary storage of sensitive information (e.g., encryption keys) that is not securely erased after use.

Common failure modes (reasoning hints, not assumptions)
- Failing to release resources after use:
  - Memory allocated but never freed, file handles not closed, network connections left open.
- Leaking sensitive data:
  - Leaving sensitive data in memory or temporary files without proper cleanup, making it accessible to attackers.
- Failure in error paths:
  - Resources not released in error scenarios, such as during exceptions or failures in execution.
- Persistent resource references:
  - Objects or resources not dereferenced, preventing garbage collection or cleanup.
- Lack of cleanup on session termination:
  - Failure to clean up resources (e.g., temporary files, sessions) when the user logs out or when the process terminates.

What “proper cleanup” looks like (context-specific)
- Explicit release of resources after use:
  - Use of proper resource cleanup mechanisms (e.g., `free()`, `delete`, `close()`, `clear()`, `session.invalidate()`) to ensure resources are released when no longer needed.
- Memory management:
  - Ensure memory is freed after its use, and there are no lingering references that prevent garbage collection (e.g., in Java or managed languages).
- File handling:
  - Temporary files should be deleted after they are no longer needed, with secure file deletion methods (e.g., overwriting before deletion).
- Connection management:
  - Close all network connections, database connections, or sockets after their use, ensuring that no connections are left open unintentionally.
- Securely erase sensitive data:
  - Ensure sensitive data, such as cryptographic keys or session data, is erased securely from memory once it is no longer needed.

Common weak/insufficient defenses (signals of possible risk)
- Not cleaning up after resource allocation:
  - Failing to release memory after allocation, leaving allocated objects in memory without de-referencing them.
- File handling without deletion:
  - Leaving temporary files or logs on the filesystem without deleting them after their intended use.
- Open connections without closure:
  - Not closing database connections, sockets, or network connections after use, allowing potential unauthorized access.
- Lack of exception handling in cleanup:
  - Cleanup operations omitted or skipped in error-handling paths, leaving resources lingering unintentionally.
- Insufficient handling of sensitive data:
  - Leaving sensitive data (e.g., passwords, keys) in memory or on disk after they are no longer needed.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit resource cleanup (e.g., `free()`, `delete`, `close()`) immediately after use of resources.
  - Use of managed objects or smart pointers that ensure memory and resources are automatically cleaned up when no longer in scope (e.g., in C++ or Python).
  - Resources like files and network connections are explicitly closed and cleaned up in all execution paths, including error paths.
  - Sensitive data is erased securely (e.g., `memset()` for memory or secure deletion methods for files).
- Evidence suggesting vulnerability:
  - Memory allocated without proper deallocation, leading to potential memory leaks.
  - Temporary files or session data created without proper cleanup after use.
  - Connections opened (e.g., database, network) that are never closed after they are no longer needed.
  - Sensitive data left in memory or on disk without proper deletion.
  - Error-handling paths do not ensure resource cleanup or proper exception handling.

How to use this guideline under incomplete context
- Identify resource management patterns:
  - Are temporary files, memory, or connections allocated but never freed or closed?
- Identify cleanup mechanisms:
  - Are there explicit cleanup operations (e.g., `free()`, `close()`, `session.invalidate()`) after resources are used?
- Generate a small number of targeted hypotheses:
  - H1: Resources (memory, files, connections) are not released after use, leading to potential leaks.
  - H2: Sensitive data is not erased after use, exposing it to unauthorized access.
  - H3: Cleanup happens outside of the visible code (e.g., in global handlers or libraries not shown).
  - H4: Cleanup occurs, but error paths do not ensure proper resource release.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (resource allocation and release points, error handling),
  (b) evidence needed to confirm it (resource management policies, error handling code, cleanup configuration),
  (c) counter-evidence that would refute it (clear resource cleanup in all paths, smart pointers, automatic resource management).

Quick red flags in partial code (weak → strong)
- Strong: allocated memory or opened files/connections are not properly released, causing potential leaks.
- Medium: resource cleanup occurs, but not in all code paths (e.g., after exceptions).
- Medium: temporary files or sensitive data are not securely erased after use.
- Weak: resource management may occur in unshown helper methods or external libraries → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_459_RULE)
