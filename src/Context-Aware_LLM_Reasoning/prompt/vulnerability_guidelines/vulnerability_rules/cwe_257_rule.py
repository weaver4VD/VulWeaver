CWE_257_RULE = """
[CWE-257 Reference Guideline | Storing Passwords in a Recoverable Format | Non-binding, Evidence-first]

Overview
- CWE-257 occurs when a product stores user passwords in a recoverable form (plaintext, reversible encryption, or any representation that allows the original password to be recovered), enabling password reuse attacks by attackers or insiders.
- The core issue is recoverability: even “encrypted” passwords are unsafe if they can be decrypted or otherwise reversed to obtain the original password.
- In partial snippets, missing storage/crypto context is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “recoverable password storage”
- Plaintext storage:
  - Writing the raw password to a database, file, config, cache, or persistent log.
- Reversible encryption:
  - Encrypting the password with a key that the system can later use to decrypt it (symmetric encryption, key-based reversible schemes).
- Encodings mistaken for protection:
  - Base64, hex encoding, or any “obfuscation” that is reversible.
- “Password hints” or partial reversible transforms:
  - Storing enough information to reconstruct the password or to significantly reduce the search space.

Non-recoverable storage (desired direction, for contrast)
- One-way password hashing using dedicated password hashing functions with per-password salt and appropriate work factor:
  - e.g., bcrypt/scrypt/Argon2/PBKDF2 (conceptual; exact choice may vary by stack)
- Hashing should be done over the password, and verification should compare hashes, not decrypt secrets.

Where recoverable passwords typically appear in code (static snippet oriented cues)
- Persistence boundaries:
  - ORM entity fields mapped to DB columns, JDBC inserts/updates, repository save() calls
  - Writing to files/preferences/config stores
  - Caches or session stores that persist across restarts
- Serialization boundaries:
  - JSON/XML serialization of user objects that include password fields
- Migration/import/export code:
  - “sync credentials”, “export users”, “backup” utilities that persist passwords
- Credential management helpers:
  - methods named encryptPassword/decryptPassword, encodePassword/decodePassword, storePassword/retrievePassword

Typical risky patterns (reasoning hints, not assumptions)
- A decrypt/recover path exists:
  - any code path that “retrieves” a password for display/use implies recoverability.
- “Encrypt then store” for passwords:
  - use of symmetric ciphers (AES/DES/etc.) or custom reversible schemes on password fields.
- Reuse across systems:
  - storing recoverable passwords enables reuse on other accounts if leaked or accessed.

What “proper restriction” looks like (context-specific)
- Store only non-recoverable representations:
  - Replace reversible encryption with one-way password hashing suitable for passwords, using per-password salt and work factor.
- Ensure verification uses hash-compare:
  - Authentication should verify by hashing the provided password and comparing to stored hash (no decrypt step).
- Avoid password retrieval features:
  - Do not implement “show password” or “send original password”; use reset flows instead.
- Scope handling of passwords:
  - Keep passwords in memory only as needed; avoid persisting/transmitting them beyond authentication setup.

Common weak/insufficient defenses (signals of possible risk)
- Using “encryption” as justification for storing passwords:
  - Any reversible encryption that allows administrators/system to recover the original password.
- Using general-purpose hashing incorrectly:
  - Fast hashes (e.g., raw SHA-1/SHA-256/MD5) without salts/work factors are often insufficient for password storage (still not “recoverable” but often dangerously weak; treat as adjacent risk, not necessarily CWE-257).
- “Obfuscation”:
  - Base64/hex/rot/simple transforms provide no protection.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Password is transformed via a dedicated password hashing API and only the hash is stored.
  - No code path exists that decrypts or returns the original password.
  - Database fields and DTOs avoid carrying plaintext passwords after initial processing.
- Evidence suggesting vulnerability:
  - Plaintext password is persisted directly (DB/file/cache) or serialized into stored records.
  - Password is encrypted with a reversible cipher and stored, especially if decryptPassword/recoverPassword exists.
  - Code supports reading back and using/displaying the original password.

How to use this guideline under incomplete context
- Identify whether the snippet includes a persistence or retrieval boundary:
  - Is a password field being saved, updated, serialized, or later retrieved for reuse?
- Generate a small number of targeted hypotheses based on observed patterns:
  - H1: Password is stored in plaintext or reversible form.
  - H2: Password is “protected” via reversible encryption or reversible encoding.
  - H3: Actual storage uses secure hashing elsewhere (repository layer, entity hooks, authentication provider) not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (save/update, encrypt/decrypt calls, password fields),
  (b) evidence needed to confirm it (DB schema fields, crypto method semantics, presence of decrypt/recover usage),
  (c) counter-evidence that would refute it (one-way password hashing, no decrypt path, reset-not-recover design).

Quick red flags in partial code (weak → strong)
- Strong: plaintext password written to persistent storage or included in persisted serialized objects.
- Strong: reversible encryption used for password storage, especially with a decrypt/recover method present.
- Medium: “encode/decode” or Base64-like transforms used as “protection” for stored passwords.
- Weak: password hashing may be implemented in unshown layers (entity listeners, auth provider) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_257_RULE)