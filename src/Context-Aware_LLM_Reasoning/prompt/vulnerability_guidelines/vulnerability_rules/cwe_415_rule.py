CWE_415_RULE = """
[CWE-415 Reference Guideline | Double Free | Non-binding, Evidence-first]

Overview
- CWE-415 occurs when the product frees memory (or an equivalent resource) twice, i.e., attempts to release the same allocation more than once.
- Double free can lead to crashes, heap corruption, use-after-free style exploitation primitives, and potentially arbitrary code execution depending on allocator behavior and surrounding memory operations.
- In partial snippets, seeing two `free()` calls is not automatically proof of double free: they may refer to different ownership contexts or different pointers. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “double free” (static analysis framing)
- Double free:
  - The same allocation is released twice via `free/delete/delete[]` (or equivalent release API), without a valid re-allocation or ownership transfer that makes the second free correct.
- “Same allocation” evidence patterns:
  - Same pointer value (or alias) is freed more than once.
  - Pointer copied to another variable, then both are freed.
  - Cleanup code runs twice (e.g., error path + normal path) freeing the same resource.
- Related but distinct:
  - Freeing two different pointers that happen to point into the same allocation (invalid free) is different, but may appear similar. Focus on “same allocation freed twice”.

Where CWE-415 typically occurs (sensitive sinks)
- Error handling + shared cleanup:
  - `goto cleanup` plus additional free in caller; or freeing before returning error then cleanup frees again.
- Multiple owners / unclear ownership:
  - Shared pointers without reference counting; ambiguous “who frees”.
- Early return paths:
  - Free on one branch and later free in common epilogue.
- Retry/reinitialization logic:
  - Freeing old buffer, then failing to reset pointer, then freeing again on subsequent iteration.
- Callback/lifecycle mismatches:
  - Freeing in both destructor/finalizer and explicit close; or freeing in both completion callback and timeout/cancel path.

Common failure modes (reasoning hints, not assumptions)
- Pointer not nullified after free:
  - Stale pointer reused in later cleanup; second free triggered.
- Aliasing without ownership discipline:
  - Two variables refer to same allocation; both freed independently.
- Duplicate cleanup execution:
  - Cleanup function called twice; or both caller and callee free the same buffer (contract mismatch).
- Conditional frees with overlapping conditions:
  - Two `if (p) free(p);` blocks that can both execute on the same control path.
- Partial initialization:
  - Pointer set, freed on error, but control continues to cleanup section that also frees.

What “safe deallocation discipline” looks like (context-specific)
- Single clear owner:
  - Exactly one component is responsible for freeing; ownership transfers are explicit.
- Centralized cleanup:
  - Use one cleanup block that frees at most once, and avoid freeing the same pointer elsewhere.
- Null-out after free:
  - After `free(p)`, set `p = NULL` (or `nullptr`) to make repeated cleanup idempotent.
- Use RAII / smart pointers (C++):
  - `unique_ptr` for unique ownership; `shared_ptr` with correct semantics when shared ownership is needed.
- Guarded and structured lifecycle:
  - Ensure cancel/timeout/completion paths are mutually exclusive or synchronized.

Common weak/insufficient defenses (signals of possible risk)
- “if (p) free(p)” duplicated:
  - Without resetting `p`, multiple guarded frees can still double-free if both guards see `p` non-null.
- Ad-hoc ownership comments:
  - “caller frees” vs “callee frees” not enforced by API design.
- “Best effort cleanup” scattered:
  - Freeing in multiple layers “just in case”.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - After freeing, pointer is set to NULL and subsequent frees check NULL.
  - Only one cleanup site frees the resource; other paths transfer ownership by setting pointer to NULL or returning ownership explicitly.
  - In C++: `unique_ptr`/RAII and no raw deletes on the same object elsewhere.
  - Clear API contracts: either callee frees and caller doesn’t, or caller frees and callee never does.
- Evidence suggesting vulnerability:
  - Two frees reachable on the same execution path for the same pointer (or clear alias).
  - Free in a branch plus another free in a shared epilogue/cleanup label without nulling.
  - Pointer copied/assigned to another variable/field, both later freed.
  - Cleanup invoked from multiple paths (success + error + timeout) without mutual exclusion and without idempotent state updates.

How to use this guideline under incomplete context
- Identify allocations and pointer aliases:
  - Track where the pointer comes from (malloc/new/allocator function) and where it is copied/stored.
- Identify all free sites:
  - Enumerate every `free/delete` of that pointer or its aliases.
- Analyze control-flow overlap:
  - Determine whether two free sites can be executed on the same path, including error paths and callbacks.
- Generate a small number of targeted hypotheses:
  - H1: The same pointer can reach two deallocation sites on one control path (branch + cleanup).
  - H2: Ownership is shared/ambiguous, causing both caller and callee to free the same allocation.
  - H3: Concurrent/asynchronous paths (timeout/cancel vs completion) can both free without synchronization.
  - H4: State is actually made idempotent elsewhere (pointer nulled, refcounted, RAII wrapper) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., two frees, alias assignment, duplicate cleanup),
  (b) evidence needed to confirm it (e.g., missing parts of control flow, ownership contracts, callback ordering),
  (c) counter-evidence that would refute it (e.g., pointer set to NULL after first free, RAII ownership).

Quick red flags in partial code (weak → strong)
- Strong: Two `free/delete` calls on the same pointer (or a clear alias) can execute on the same path; pointer not nulled.
- Medium: Pointer freed in error branch and also freed in common cleanup; ownership contract unclear across functions.
- Medium: Cancel/timeout and completion paths both free the same resource without idempotent state or synchronization.
- Weak: Deallocation may be safely managed by omitted RAII wrappers/refcounting/ownership transfer code → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_415_RULE)
