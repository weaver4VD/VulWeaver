CWE_770_RULE = """
[CWE-770 Reference Guideline | Allocation of Resources Without Limits or Throttling | Non-binding, Evidence-first]

Overview
- CWE-770 occurs when a product allocates a reusable resource or a group of resources on behalf of an actor without imposing limits or throttling on the number or size of resources that can be allocated.
- This can lead to resource exhaustion, denial of service (DoS), or other performance and security issues, as an actor can consume an excessive amount of resources, overwhelming the system and causing instability or unavailability.
- In partial snippets, missing resource management controls or inadequate throttling mechanisms are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “resource allocation” and “limits or throttling” (static analysis framing)
- Resource Allocation:
  - The process of assigning or provisioning resources (e.g., memory, CPU, network bandwidth, file handles, or database connections) for use by a user, service, or process.
  - Resources can be allocated dynamically, such as during request handling, session creation, or API calls.
- Limits or Throttling:
  - Enforcing constraints on the amount of resources an actor can consume. This can include limiting the number of resource allocations, the amount of data processed, or the frequency at which resources are requested or used.
  - Throttling can be applied in terms of rate-limiting, quota enforcement, or maximum allowed resource usage.

Where resource allocation issues typically occur (sensitive sinks)
- File, memory, and network resource allocation:
  - Allocating file handles, memory buffers, or network connections without enforcing limits, leading to potential exhaustion of system resources.
- Database connections:
  - Allocating database connections or threads without limits, which could lead to database connection pool exhaustion or denial of service.
- API requests:
  - Allowing clients or users to request unlimited resources via API calls, which can lead to abuse, resource hogging, or service degradation.
- Session handling:
  - Allocating resources for sessions (e.g., user sessions, background jobs) without enforcing time or resource usage limits, potentially leading to session abuse.

Common failure modes (reasoning hints, not assumptions)
- Lack of rate-limiting:
  - Allowing users or services to make unlimited requests, leading to excessive resource consumption (e.g., handling a high number of requests per second).
- No limits on resource allocation:
  - Allocating resources without setting upper bounds on how much an actor can consume, leading to resource exhaustion.
- Overuse of shared resources:
  - Allowing one actor (e.g., a user or service) to monopolize resources (e.g., memory, CPU) and impact the availability or performance of the system for others.
- Absence of throttling mechanisms:
  - Not enforcing throttling or timeout rules, allowing services or users to continue requesting resources beyond reasonable limits.
- Inefficient or unsustainable resource allocation:
  - Allocating resources in an unsustainable manner, leading to performance bottlenecks, DoS, or system instability.

What “proper resource allocation limits” looks like (context-specific)
- Implement rate-limiting and quotas:
  - Enforce maximum request rates for API calls, maximum resource allocation per user, and time-based limits to prevent overconsumption of resources.
- Set resource limits and throttling:
  - Define maximum memory, CPU, or file handle allocations per actor or process, ensuring that no single actor can consume excessive resources.
- Apply the principle of least privilege:
  - Ensure that users or services can only allocate the resources they absolutely need and not more, limiting the impact of resource overuse.
- Monitor and enforce resource usage:
  - Regularly monitor resource usage and enforce limits when thresholds are reached, either by rejecting further requests or slowing down operations (e.g., through throttling).
- Design for scalability:
  - Implement dynamic resource allocation based on usage patterns and system load, allowing the system to handle surges in resource requests without crashing or slowing down.

Common weak/insufficient defenses (signals of possible risk)
- No resource usage limits:
  - Allowing actors to consume unlimited resources (e.g., memory, file handles, network bandwidth) without enforcing any form of restriction or throttling.
- No enforcement of quotas:
  - Failing to apply resource quotas for users or processes, leading to resource hogging or denial of service.
- Over-reliance on external or cloud resources without limits:
  - Using external or cloud-based resources without setting appropriate usage limits, leading to increased costs or resource exhaustion.
- Lack of monitoring and alerting:
  - Failing to monitor resource usage, which can allow resource overuse or abuse to go unnoticed and lead to degraded system performance or failure.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Resource allocation functions or API calls that enforce limits on memory, CPU, disk space, file handles, or other system resources.
  - Rate-limiting mechanisms that restrict the number of requests or operations a user or service can perform within a given time period (e.g., using API gateways, token buckets).
  - Throttling or queue management systems that prioritize resource allocation and slow down or reject excessive requests.
  - Quotas or limits defined for resource usage, ensuring that no single actor can monopolize system resources.
- Evidence suggesting vulnerability:
  - Resource allocation functions without any checks for usage limits, leading to potentially unlimited consumption of system resources.
  - Absence of rate-limiting or throttling mechanisms, allowing users to send an excessive number of requests or perform resource-intensive operations without restriction.
  - Over-permissive or undefined quotas, allowing users or services to consume more than necessary and exhaust critical system resources.
  - Lack of resource usage monitoring, making it difficult to detect or mitigate potential abuse of resources.

How to use this guideline under incomplete context
- Identify where resource allocation occurs:
  - Look for functions or methods that allocate resources (e.g., file handles, memory, database connections) or handle user requests for resources.
- Identify any limits or restrictions:
  - Are there clear constraints or throttling mechanisms in place to limit the number of resources allocated? Are there rate limits or quotas defined?
- Generate a small number of targeted hypotheses:
  - H1: Resource allocation occurs without limits, allowing users or services to consume excessive resources.
  - H2: No rate-limiting is implemented, allowing abuse of resources by users or services.
  - H3: Resource usage is monitored but not effectively limited or controlled, leading to system instability.
  - H4: Resource management is handled by external libraries or frameworks that are not visible in the current snippet.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., allocation functions, resource usage metrics),
  (b) evidence needed to confirm it (e.g., rate-limiting, quota enforcement, resource monitoring),
  (c) counter-evidence that would refute it (e.g., resource limits, effective throttling).

Quick red flags in partial code (weak → strong)
- Strong: No rate-limiting, throttling, or quotas are implemented for resource allocation, leading to potential exhaustion of resources.
- Medium: Resource allocation occurs, but the limits are too permissive or not consistently applied across all user or service requests.
- Medium: Throttling mechanisms are present but are too lenient or not configured to effectively prevent abuse.
- Weak: Resource allocation logic might be handled by external systems or libraries not visible in the snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_770_RULE)
