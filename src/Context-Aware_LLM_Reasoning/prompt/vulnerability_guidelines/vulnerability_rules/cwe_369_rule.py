CWE_369_RULE = """
[CWE-369 Reference Guideline | Divide By Zero | Non-binding, Evidence-first]

Overview
- CWE-369 occurs when the product performs a divide (or modulo) operation where the divisor can be zero.
- Divide-by-zero can cause crashes, undefined behavior, exceptions, or controllable abnormal termination (DoS). In some contexts it can also trigger logic bypass if error handling falls back to insecure defaults.
- In partial snippets, the absence of a zero-check near a division is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “divide by zero” (static analysis framing)
- Division operations:
  - Integer division (`/`) and modulo (`%`) where the divisor is an integer expression that can evaluate to 0.
  - Floating-point division where divisor can be 0.0 (behavior depends on language/runtime: may yield Inf/NaN or raise exceptions).
- “Divisor can be zero”:
  - The divisor is derived from external input, computed values, counters, sizes, or data-dependent branches, and there is no proven invariant that it is non-zero at the operation site.
- Security relevance:
  - Typically a reliability/DoS issue, but can become security-relevant if it can be triggered remotely or influences downstream sensitive logic via error handling.

Where CWE-369 typically occurs (sensitive sinks)
- Direct arithmetic:
  - `a / b`, `a % b`, `x /= y`, `x %= y`.
- Normalization/scaling logic:
  - `value / total`, `bytes / rate`, `score / count`, averages: `sum / n`.
- Indexing and bucketing:
  - `hash % buckets`, `i % chunkSize`, `offset / blockSize`.
- Time/ratio computations:
  - `delta / duration`, `requests / seconds`, `progress / totalWork`.
- Parsing/protocol computations:
  - Dividing by a field from input (e.g., “width”, “stride”, “blockSize”, “denominator”).

Common failure modes (reasoning hints, not assumptions)
- Missing guard:
  - No check that divisor is non-zero before division/modulo.
- Trusting external values:
  - Divisor originates from request/config/file data and is assumed non-zero.
- Underflow/overflow leading to zero:
  - Computation that can produce 0 unexpectedly (e.g., truncation, integer rounding, subtraction).
- Conditional paths:
  - A guard exists but is not dominant for all control paths reaching the division.
- Error-handling fallback:
  - Division fails/throws, and handler falls back to unsafe behavior (e.g., “if exception, disable limits”).

What “safe division” looks like (context-specific)
- Local non-zero validation:
  - Check `divisor != 0` (and for floats, consider `abs(divisor) > eps` if relevant) immediately before division.
- Enforced invariants:
  - Establish and preserve invariants: e.g., `count >= 1`, `bucketCount > 0`, `blockSize > 0`.
- Defensive defaults:
  - If divisor is 0, return error, clamp to safe value, or choose a safe branch (but ensure policy is correct).
- Type-aware handling:
  - Understand integer vs floating semantics (integer division by zero is typically fatal; float may produce Inf/NaN but still poison logic).

Common weak/insufficient defenses (signals of possible risk)
- Guard far away:
  - Divisor validated earlier but then modified before use; or guard not guaranteed on all paths.
- One-sided checks:
  - Checking `divisor >= 0` but not `!= 0`.
- Assuming “should never be zero”:
  - No enforcement for externally-influenced denominators.
- Ignoring exceptional values:
  - For float, accepting NaN/Inf results without validation in downstream logic.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Dominating guard: `if (d == 0) { ... return/error; }` immediately before `x / d` or `x % d`.
  - Proven non-zero invariant at the use site (e.g., `assert(d > 0)` or prior branch that guarantees `d > 0` and no intervening mutation).
  - Input validation that enforces `d` within `(min..max)` and is clearly connected to the value used at the sink.
  - For collections/buckets: logic that ensures `bucketCount` is set to at least 1.
- Evidence suggesting vulnerability:
  - Division/modulo using a divisor derived from external input or data-dependent computation with no visible guard.
  - Divisor computed via arithmetic that can yield 0 (truncation/rounding/subtraction) and then used in `/` or `%`.
  - Guards that don’t dominate all paths (e.g., check in one branch, division in another).
  - Catching divide-by-zero exceptions and continuing with unsafe defaults.

How to use this guideline under incomplete context
- Identify division/modulo sites:
  - Locate `/` and `%` operations and extract the divisor expression.
- Identify divisor provenance:
  - Is it user-controlled, file/network-controlled, config-controlled, or derived from potentially zero-producing arithmetic?
- Generate a small number of targeted hypotheses:
  - H1: Divisor is externally influenced and can be zero, and no dominating non-zero check exists.
  - H2: Divisor is computed in a way that can yield zero under edge cases (empty counts, truncation), leading to divide-by-zero.
  - H3: A guard exists but is incomplete (not dominant, wrong variable checked, or divisor later modified).
  - H4: Non-zero invariant is established elsewhere (validated parser, constructor, API contract) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., divisor from input; no `!= 0` check),
  (b) evidence needed to confirm it (e.g., upstream validation, type/range constraints),
  (c) counter-evidence that would refute it (e.g., dominating `d > 0` guard and immutability).

Quick red flags in partial code (weak → strong)
- Strong: `x / y` or `x % y` where `y` comes from input/config/data and there is no local non-zero guard.
- Medium: “Count/total/buckets” denominators that can be 0 in edge cases (empty list, zero-sized buffer), especially without checks.
- Medium: Guard exists but does not dominate the division, or checks the wrong expression.
- Weak: Divisor may be guaranteed non-zero by omitted contracts/initialization code → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_369_RULE)
