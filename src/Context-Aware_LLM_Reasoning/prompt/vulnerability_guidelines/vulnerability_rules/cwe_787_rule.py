CWE_787_RULE = """
[CWE-787 Reference Guideline | Out-of-bounds Write | Non-binding, Evidence-first]

Overview
- CWE-787 occurs when a product writes data past the end, or before the beginning, of the intended buffer.
- This can lead to data corruption, crashes, and potentially the execution of malicious code. An out-of-bounds write allows an attacker to overwrite critical memory areas, which could lead to severe vulnerabilities, including arbitrary code execution.
- In partial snippets, missing bounds checks or unsafe memory handling are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "out-of-bounds write" (static analysis framing)
- Out-of-bounds write:
  - A scenario in which data is written to memory outside the intended boundaries of a buffer, whether before the start or past the end of the allocated space.
  - It occurs when the application fails to properly check or enforce memory boundaries during write operations.
- Buffer:
  - A memory region (array, string, or other data structure) that is allocated to hold a certain amount of data, typically with a defined size.
  - Examples include arrays, dynamically allocated memory, file buffers, or other structures that hold input data.

Where out-of-bounds writes typically occur (sensitive sinks)
- Arrays and buffers:
  - Writing data into arrays or buffers without properly checking the bounds (e.g., using unsafe index manipulation or arithmetic).
- String handling:
  - Writing strings into buffers without ensuring that the string fits within the allocated space.
- Memory management functions:
  - Using memory allocation functions (e.g., `malloc()`, `calloc()`, `realloc()`, or `new`) without properly checking the bounds or sizes before writing to memory.
- External data handling:
  - Writing user-supplied or external data into buffers without validation, leading to potential overwrites of memory beyond the buffer’s allocated space.

Common failure modes (reasoning hints, not assumptions)
- Missing bounds checking:
  - Failing to check that the index or pointer used to write data does not exceed the buffer’s allocated size.
- Incorrect buffer size calculations:
  - Miscalculating the buffer size or memory allocation, allowing writes beyond the allocated memory space.
- Buffer overflows in unvalidated data handling:
  - Writing user-provided data (e.g., input fields, file contents) into a buffer without validating the size, leading to potential out-of-bounds writes.
- Use of unsafe memory handling techniques:
  - Using functions or methods that do not automatically check for bounds (e.g., `strcpy()`, `memcpy()`, `scanf()`) without manual validation.

What “proper bounds checking and memory management” looks like (context-specific)
- Validate data sizes before writing:
  - Ensure that all writes to buffers are validated to ensure that the data fits within the allocated space (e.g., using `strlen()` for strings or checking buffer size before writing).
- Use safe memory functions:
  - Prefer using memory functions that include bounds checking, such as `strncpy()` or `snprintf()`, which ensure data is written within the buffer size.
- Ensure memory allocation is sufficient:
  - Ensure that memory allocation for buffers is large enough to hold the data that will be written to it, including the null terminator for strings or any padding required for data structures.
- Use bounds-checked libraries or frameworks:
  - Use modern libraries or functions that automatically enforce bounds checking, especially for operations involving external or user-supplied data.
- Employ static analysis and runtime checks:
  - Use static analysis tools to detect potential out-of-bounds write vulnerabilities at compile-time and implement runtime checks to ensure that buffers are not accessed outside their allocated bounds.

Common weak/insufficient defenses (signals of possible risk)
- No bounds checks:
  - Writing to a buffer without verifying the size or checking that the index is within the bounds of the allocated space.
- Use of unsafe functions:
  - Using functions that do not automatically enforce bounds checks (e.g., `strcpy()`, `sprintf()`, `gets()`).
- Insufficient input validation:
  - Writing user-provided data into buffers without validating or sanitizing the input size or content.
- Miscalculated buffer sizes:
  - Allocating buffers that are too small to hold the expected data, leading to overwrites when the buffer is written to.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Bounds checks are explicitly performed before writing data to buffers (e.g., checking if the index is within the valid range or verifying data length against buffer size).
  - Use of safe memory functions (e.g., `strncpy()`, `snprintf()`) that prevent writing beyond buffer limits.
  - Memory allocation is sufficient and validated, ensuring that the buffer is large enough to hold the data.
  - Use of dynamic memory management that checks for allocation failures or reallocation issues (e.g., checking the result of `malloc()` or `realloc()`).
- Evidence suggesting vulnerability:
  - Data is written to a buffer or array without bounds checking (e.g., `memcpy(destination, source, size)` without verifying `size` against the buffer size).
  - Unsafe functions are used without bounds checks (e.g., `strcpy()`, `sprintf()`, `scanf()`).
  - Buffer allocation is incorrect or does not account for all required data, leading to writes beyond the allocated space.
  - Input data is written directly into buffers without validation of size or format, leading to potential buffer overflows.

How to use this guideline under incomplete context
- Identify buffer-related operations:
  - Where are arrays, strings, or buffers being written to in the code? Are bounds or sizes checked before the write operation?
- Identify the data being written:
  - Is the data being written user-provided or dynamically allocated? Are the sizes or lengths of these inputs validated before writing to buffers?
- Generate a small number of targeted hypotheses:
  - H1: Data is written to buffers without sufficient bounds checking, leading to potential out-of-bounds writes.
  - H2: Unsafe memory functions are used without proper checks, making the system vulnerable to buffer overflows.
  - H3: Memory allocation is insufficient or incorrectly calculated, allowing writes past the buffer’s allocated space.
  - H4: Input validation is missing or insufficient, allowing user data to overwrite memory beyond buffer boundaries.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., buffer writes without checks, unsafe functions used),
  (b) evidence needed to confirm it (e.g., bounds-checking logic, memory management functions),
  (c) counter-evidence that would refute it (e.g., secure memory functions, proper bounds checking).

Quick red flags in partial code (weak → strong)
- Strong: Buffer writes are not checked against the allocated size, or unsafe functions are used that allow writing past the buffer’s limits.
- Medium: Bounds checking exists but is incomplete or not consistently applied across all data writes.
- Medium: Buffer size or memory allocation is not validated before writing, leading to potential overflows.
- Weak: Memory management may be handled outside of the visible code (e.g., in helper functions or external libraries) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_787_RULE)
