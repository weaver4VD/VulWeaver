CWE_23_RULE = """
[CWE-23 Reference Guideline | Relative Path Traversal | Non-binding, Evidence-first]

Overview
- CWE-23 (Relative Path Traversal) occurs when a product uses external input to construct a pathname that is intended to stay within a restricted base directory, but it fails to properly neutralize traversal sequences such as ".." that can escape that directory.
- Compared with broader path traversal, CWE-23 emphasizes relative-path manipulation (e.g., ".." segments) that changes the resolved location.
- In partial snippets, missing validation evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “relative path input” in Java (typical sources)
- HTTP-derived values: query params, path variables, multipart fields (e.g., "file", "path", "name", "dir", "subpath").
- File/packaging metadata: uploaded filenames, archive entry names (Zip/Tar) that are treated as relative paths on extraction.
- User-influenced fields from other components: message payload fields or DB records that can be controlled or influenced by an attacker.

Security-sensitive path usages (typical sinks)
- File read/write/delete APIs: java.io.File, java.nio.file.Path/Paths/Files, FileInputStream/FileOutputStream, RandomAccessFile.
- Directory-based operations: listing directories, copying/moving files, creating directories under a base directory.
- Archive extraction: writing archive entries to disk using entry names as relative paths.

Typical bypass primitives (reasoning hints, not assumptions)
- Traversal segments: "..", "../", "..\\", repeated segments, mixed separators.
- Encoded traversal: %2e%2e%2f, double-encoding, Unicode normalization that produces "." or separator-like characters.
- Separator confusion: forward/backward slashes, platform-specific parsing quirks.
- “Looks relative but escapes”: paths that begin relative yet resolve outside base after normalization/canonicalization.

What “proper restriction” looks like (context-specific)
- Prefer allow-list mapping:
  - Use stable identifiers (IDs/keys) mapped to fixed filenames/paths rather than accepting arbitrary relative paths.
- Constrain input to the minimum required semantics:
  - If only a filename is needed, reject any separators and enforce strict regex/enum constraints.
- Normalize/canonicalize before enforcing containment:
  - Construct candidate path via Path.resolve(base, userPart) (avoid raw string concatenation).
  - Normalize to eliminate "." and ".." segments, and/or canonicalize (toRealPath / getCanonicalFile) depending on your verification model.
  - Enforce containment: resolved/canonical candidate must remain within the resolved/canonical base directory.
- Treat “neutralization” as semantic, not textual:
  - Avoid relying on substring removal of ".."; ensure the final resolved path cannot escape the base.

Common weak/insufficient defenses (signals of possible risk)
- Textual filtering for ".." only:
  - Removing ".." or "../" without considering encodings, separators, repetition, or path normalization.
- Raw string prefix checks:
  - candidate.startsWith(baseDir) on non-canonicalized strings.
- Validating one representation but using another:
  - Validate raw input but decode/normalize later, reintroducing traversal.
- Partial normalization:
  - Normalize but fail to enforce containment against a canonical base, leaving escape cases possible.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Input is transformed into an allow-listed ID and mapped to fixed safe files.
  - In-flow containment enforcement after normalization/canonicalization:
    - basePathNormalized = base.toRealPath()/canonical
    - candidate = base.resolve(userPart).normalize()/toRealPath
    - verify candidate starts with basePathNormalized (Path-based containment).
  - Explicit constraints that reject separators / prohibit ".." with correct handling of encoding/normalization stages.
- Evidence suggesting vulnerability:
  - External input contributes to a relative path used in file operations, and no robust “resolve→normalize/canonicalize→containment” barrier appears in the same dataflow.
  - Protection relies primarily on substring filtering of ".." or similar patterns.

How to use this guideline under incomplete context
- Generate a small number of targeted hypotheses based on observed sink + path construction pattern:
  - H1: The user-controlled relative path can include ".." to escape the restricted directory.
  - H2: The code “filters” ".." textually but can be bypassed by encoding or separator variations.
  - H3: A robust containment check exists upstream (filter/interceptor/helper), but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (e.g., baseDir definition, decoding stage, canonicalization logic, allow-list mapping),
  (c) counter-evidence that would refute it (e.g., in-flow canonical containment check).

Quick red flags in partial code (weak → strong)
- Strong: baseDir + userInput (or resolve without containment) followed by file access, with no normalize/canonicalize + containment.
- Medium: only checks for ".." or "../" textually, or replace/remove patterns.
- Medium: string startsWith(baseDir) checks without canonicalization.
- Weak: key validation likely happens outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_23_RULE)
