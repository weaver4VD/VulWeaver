CWE_91_RULE = """
[CWE-91 Reference Guideline | XML Injection / XPath Injection | Non-binding, Evidence-first]

Overview
- CWE-91 (XML Injection) occurs when a product incorporates externally-influenced input into XML markup or XML-related expressions (e.g., XPath) without correct neutralization, allowing attackers to modify XML structure, content, or query semantics before it is processed by an XML/XPath-consuming component.
- CWE-91 can manifest as:
  - XML markup injection: attacker input breaks out of text/attribute context and injects new tags/attributes/entities.
  - XPath injection (including blind variants): attacker input alters XPath query predicates/operators to change selected nodes or exfiltrate data via side effects.
- In partial snippets, missing neutralization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “externally-influenced input” (typical sources)
- HTTP-derived data: query params, form fields, path variables, headers/cookies, request bodies (JSON/form/XML).
- Persisted user content: DB-stored fields later embedded into XML documents or XPath queries.
- Cross-component payloads: message/RPC fields only if attacker-controllable in context.
- File content/metadata: uploaded XML fragments, filenames/fields inserted into XML/XPath.

Downstream XML/XPath sinks (typical in Java)
- XML construction and serialization paths:
  - String-based XML building (StringBuilder/format/templating) that produces XML text consumed later.
  - Transformer/Serializer outputs (when fed attacker-influenced DOM/text).
- XML parsing/processing:
  - DocumentBuilderFactory / DocumentBuilder, SAXParserFactory, XMLInputFactory (StAX)
  - JAXB unmarshalling when given XML text that includes attacker-controlled fragments
- XPath evaluation:
  - javax.xml.xpath.XPath / XPathExpression.evaluate(...)
  - Third-party XPath engines or XML query utilities
- XML-centric protocols:
  - SOAP message construction, SAML assertions, custom XML-based messaging

Special elements that enable XML/XPath injection (reasoning hints, not assumptions)
- XML markup/control characters:
  - '<', '>', '&', quotes in attributes, CDATA boundaries, comment delimiters, processing instruction markers
- XPath control tokens:
  - quotes, brackets, operators (or/and), functions, axis selectors, node tests, union '|', wildcard '*'
- Encoding/normalization tricks:
  - entity encoding/decoding mismatches, double-encoding, Unicode normalization affecting delimiters

What “proper neutralization/restriction” looks like (context-specific)
- Prefer safe-by-construction XML building:
  - Use DOM/StAX/JAXB builders that treat data as text nodes/attribute values rather than concatenating raw strings into markup.
  - Ensure special characters in text/attributes are escaped by the library at serialization boundaries.
- Avoid string-concatenated XPath:
  - Prefer compiling XPath with fixed structure and binding values via safe patterns (e.g., strict allow-listing) because standard XPath APIs typically do not support parameter binding like SQL.
  - If user input must influence XPath, constrain it to safe subsets:
    - allow-list node names/attributes/IDs, enforce strict regex, or map input to pre-defined query variants.
- Context-aware escaping when unavoidable:
  - If building XML as text, escape according to XML context (text vs attribute) exactly.
  - If embedding in XPath string literals, handle quoting safely (e.g., enforce single-quote-only patterns or construct literals with safe concatenation rules), but treat ad-hoc escaping as fragile.

Common weak/insufficient defenses (signals of possible risk)
- Building XML or XPath via string concatenation/interpolation:
  - "<tag>" + userInput + "</tag>" or "//user[name='" + userInput + "']"
- Blacklist filtering:
  - Removing "<" or ">" only, or stripping quotes without a complete, context-specific strategy.
- Wrong-context encoding:
  - HTML escaping or URL encoding used where XML/XPath escaping is required.
- Validate-then-transform pitfalls:
  - Validate raw input, then decode/normalize/entity-expand later, reintroducing special elements.
- Assuming parser safety covers injection:
  - Parser hardening (e.g., XXE controls) is distinct from injection; do not treat it as solving CWE-91.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - XML is constructed via DOM/JAXB/StAX APIs where untrusted input is inserted as text nodes/attribute values (not markup fragments).
  - Explicit XML escaping applied at the output boundary for the correct context (text vs attribute) when strings are used.
  - XPath queries are not built from raw user input; user influence is via allow-listed mapping (IDs/enums) or predefined query templates.
  - Strict constraints on any input that influences XPath grammar positions (e.g., node/attribute names).
- Evidence suggesting vulnerability:
  - Externally influenced input is embedded into XML markup strings or XPath expressions without clear escaping/constraints.
  - XPath predicates or structure are dynamically assembled using user input (quotes/brackets/operators potentially injectable).
  - “Sanitization” appears as partial character stripping or generic sanitize() with unclear semantics.

How to use this guideline under incomplete context
- Identify which downstream interpreter is present:
  - Is the snippet constructing XML text, or building XPath expressions, or both?
- Generate a small number of targeted hypotheses based on observed construction patterns:
  - H1: User input can break XML text/attribute context and inject additional markup.
  - H2: User input can alter XPath query semantics by injecting operators/quotes.
  - H3: Safe XML building or strict allow-listing exists in unshown layers, but is not visible here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (string building, dynamic XPath, interpolation),
  (b) evidence needed to confirm it (exact parser/evaluate call sites, whether DOM/builder APIs are used, escaping helper semantics),
  (c) counter-evidence that would refute it (DOM text-node insertion, correct XML escaping, allow-list mapping for XPath inputs).

Quick red flags in partial code (weak → strong)
- Strong: request-derived/persisted user data concatenated into XML markup strings that are parsed/processed downstream.
- Strong: user data concatenated into XPath strings used in XPath.evaluate(...) or equivalent.
- Medium: generic filtering/escaping with unclear XML/XPath context correctness.
- Medium: decoding/entity normalization occurs after validation.
- Weak: escaping or query construction may be handled in helpers not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_91_RULE)
