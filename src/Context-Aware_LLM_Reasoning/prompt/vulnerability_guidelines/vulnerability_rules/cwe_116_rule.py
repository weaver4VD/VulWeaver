CWE_116_RULE = """
[CWE-116 Reference Guideline | Improper Encoding or Escaping of Output | Non-binding, Evidence-first]

Overview
- CWE-116 occurs when a product prepares a structured message (text, markup, command, query, or record) for a downstream component, but required encoding/escaping is missing or incorrect, so the message structure is not preserved as intended.
- CWE-116 is cross-cutting: it often underlies injections (SQL/XSS/command/XML) but can also cause generic structural corruption when data is embedded into structured formats.
- The key is *context-appropriate* encoding/escaping at the boundary where data is inserted into a specific grammar (HTML, URL, JSON, XML, SQL, shell, CSV, etc.).
- In partial snippets, missing encoding evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “externally-influenced data” (typical sources)
- HTTP-derived data: parameters, headers, cookies, path variables, request bodies.
- Persisted user content: DB-stored fields later embedded into structured outputs.
- Cross-component payloads: message/RPC fields only if attacker-controllable in context.
- Files/metadata: uploaded names/content later embedded into documents/records.

Structured message outputs & downstream interpreters (typical sinks)
- Web/markup outputs:
  - HTML generation, template rendering, attribute/URL/JS/CSS embedding
- Data serialization formats:
  - JSON, XML, YAML, CSV, custom delimited protocols
- Query/command-like outputs:
  - SQL queries, LDAP filters, XPath expressions, OS commands, template/expression strings
- HTTP-level structured values:
  - URLs, query strings, headers, cookies, redirects

Core risk mechanism (structure-breaking special elements)
- Each downstream format has special delimiters/tokens that define structure:
  - HTML/XML: <, >, &, quotes, attribute delimiters
  - JSON: quotes, backslashes, control chars
  - CSV: separators, quotes, newlines
  - URLs: reserved characters, encoding boundaries
  - Shell/commands: separators/operators/quoting
  - SQL/XPath/LDAP: quotes/operators/comments
- CWE-116 arises when inserted data is not correctly encoded/escaped for that exact grammar/context, so attackers can inject structural tokens or the message becomes misinterpreted.

What “proper encoding/escaping” looks like (context-specific)
- Prefer safe-by-construction APIs:
  - Use builders/serializers that separate data from syntax (JSON libraries, XML DOM/StAX, prepared statements, argv-based ProcessBuilder, template engines with correct auto-escaping).
- Apply encoding/escaping that matches the precise insertion context:
  - “Correct” escaping is not universal: HTML body vs attribute vs JS string differ; URL path vs query differ; JSON string vs HTML differs.
  - Ensure encoding happens after any decoding/normalization and immediately before the message is handed to the downstream interpreter.
- Constrain inputs when possible:
  - Allow-list expected patterns/enums/IDs to reduce exposure to structure-breaking tokens.
  - For fields that must be free-form, rely on correct serializers rather than hand-crafted escaping.

Common weak/insufficient defenses (signals of possible risk)
- Generic “escape” used everywhere:
  - Applying one escaping function across multiple contexts (e.g., HTML escaping for SQL, URL encoding for HTML) is often incorrect.
- Blacklist filtering:
  - Removing a few “bad characters” is typically incomplete and bypassable.
- Escaping at the wrong time:
  - Escaping before decoding/normalization; or escaping early then later concatenating/transforming, reintroducing special elements.
- Manual string concatenation of structured outputs:
  - Building JSON/XML/HTML/queries/commands by concatenating user input into raw strings.
- Confusing validation with encoding:
  - Input validation reduces risk but does not substitute for correct output encoding when a structured grammar is involved.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Use of dedicated serializers/builders (JSON libraries, XML DOM/StAX, CSV writers) rather than string concatenation.
  - Use of parameter binding (SQL), argument vectors (commands), and framework auto-escaping (templates) in the correct contexts.
  - Encoding/escaping functions that clearly match the target context and are applied at the boundary before sink usage.
- Evidence suggesting vulnerability:
  - Externally influenced input inserted into structured outputs via concatenation/interpolation with no visible context-appropriate encoding.
  - Encoding is applied but appears mismatched to the output context or used inconsistently.
  - The code “sanitizes” by stripping characters rather than preserving structure through proper escaping/serialization.

How to use this guideline under incomplete context
- First identify the downstream format and insertion context implied by sinks/imports:
  - HTML vs attribute vs JS; JSON vs embedded-in-HTML; XML vs XPath; SQL vs ORM; shell vs argv; CSV vs custom protocol.
- Generate a small number of targeted hypotheses based on observed construction patterns:
  - H1: Missing encoding/escaping for the identified output context allows structure-breaking tokens.
  - H2: Encoding exists but is wrong-context or applied at the wrong stage.
  - H3: Proper encoding/serialization is handled in helpers/framework defaults not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (string building, sink call, context indicators),
  (b) evidence needed to confirm it (actual sink type, serializer usage, template auto-escape settings),
  (c) counter-evidence that would refute it (serializer/binding/builder usage, correct context-specific encoding).

Quick red flags in partial code (weak → strong)
- Strong: request-derived/persisted user data concatenated into a structured message (HTML/JSON/XML/SQL/command/CSV) handed to a downstream parser/interpreter.
- Medium: a single “escape” function used across multiple contexts with unclear target grammar.
- Medium: encoding/escaping happens before decoding/normalization, or transformations occur after escaping.
- Weak: encoding may be automatically applied by frameworks/serializers not visible → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_116_RULE)
