CWE_704_RULE = """
[CWE-704 Reference Guideline | Incorrect Type Conversion or Cast | Non-binding, Evidence-first]

Overview
- CWE-704 occurs when the product does not correctly convert an object, resource, or structure from one type to a different type, leading to incorrect interpretation of data.
- Incorrect conversions/casts can cause logic flaws, memory corruption, type confusion, out-of-bounds access, truncation/sign issues, or security checks being bypassed due to misinterpreted values.
- In partial snippets, seeing a cast is not proof of CWE-704: the cast may be safe under invariants or API contracts. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “incorrect type conversion/cast” (static analysis framing)
- Type conversion:
  - Implicit or explicit conversion between types (numeric, pointer/object, enum, struct, union, byte buffers ↔ structured data).
- Incorrect conversion:
  - The conversion changes meaning in an unintended way, e.g.:
    - Numeric truncation/overflow (widening/narrowing mismatch).
    - Signedness confusion (signed ↔ unsigned).
    - Pointer casts that violate actual object type/layout.
    - Reinterpreting raw bytes as a struct with incorrect alignment/packing/endian assumptions.
    - Downcasting to wrong derived type.
- Security relevance:
  - Conversions that affect bounds, lengths, indices, permissions, authentication/authorization decisions, or memory access patterns are higher risk.

Where CWE-704 typically occurs (sensitive sinks)
- Numeric size/length handling:
  - Converting from `size_t`/`uint64_t` to `int`/`uint32_t`, especially for buffer sizes, loop bounds, allocation sizes.
- Signed/unsigned comparisons:
  - Casting negative values to unsigned, or comparing across signedness leading to unexpected large values.
- Pointer/object casts:
  - `void*` to typed pointer, base ↔ derived conversions, `reinterpret_cast`, C-style casts.
- Serialization/deserialization and parsing:
  - Interpreting network/file bytes as structs; parsing numeric strings into smaller types.
- Bit manipulation and shifts:
  - Shifting with incorrectly typed operands; sign extension issues.
- ABI/layout assumptions:
  - Casting between structs with different packing/alignment; assuming field offsets.

Common failure modes (reasoning hints, not assumptions)
- Truncation on narrowing cast:
  - Large value becomes smaller (wrap/truncate) and used as size/index/offset.
- Signedness bugs:
  - Negative becomes huge after unsigned conversion; checks like `if (len < MAX)` pass unexpectedly.
- Wrong downcast/type confusion:
  - Casting to a subtype that the object is not actually an instance of.
- Misaligned/packed struct reinterpretation:
  - Casting a byte pointer to a struct pointer without ensuring alignment/packing/endian.
- Using cast to silence compiler:
  - Cast hides a real mismatch instead of validating the underlying type.
- Type-based security check mismatch:
  - Checks done in one type, then value cast to another type before sensitive use.

What “safe conversion/casting” looks like (context-specific)
- Preserve semantics with explicit bounds checks:
  - Before narrowing casts, verify value is within target type range.
- Signedness discipline:
  - Avoid mixing signed/unsigned for lengths and indices; normalize types early.
- Use safe downcasting:
  - In C++ prefer `dynamic_cast` where appropriate, or explicit tag/type checks before `static_cast`.
- Avoid reinterpretation unless guaranteed:
  - Prefer parsing/decoding into fields rather than casting raw bytes to structs; handle endianness/alignment explicitly.
- Keep checks and uses in the same type domain:
  - Perform validation in the type actually used by the sink (or prove equivalence).

Common weak/insufficient defenses (signals of possible risk)
- “It works on my platform”:
  - Layout/endianness/alignment assumptions may break on other targets or under crafted inputs.
- Checks before cast only:
  - Validating in wider type but using narrowed/truncated value later.
- Casting away warnings:
  - Large casts introduced just to silence compiler diagnostics.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit range checks prior to narrowing conversions (min/max bounds).
  - Consistent type usage for sizes/offsets (`size_t`/`uint64_t`) with no unsafe downcasts.
  - Verified object type before downcast (type tags, RTTI checks).
  - Explicit decoding/parsing routines for byte streams; no raw struct pointer casts without alignment/size checks.
  - Assertions/invariants that are actually enforced by input validation (not just comments).
- Evidence suggesting vulnerability:
  - Narrowing cast of attacker-influenced size/index/offset without bounds checks.
  - Casting negative-capable values to unsigned, then using them for allocation/loop bounds.
  - Reinterpret casts of buffers to structs without verifying length/alignment/endian.
  - Downcasting pointers/objects without type validation.
  - Validation performed on pre-cast value but sensitive operation uses post-cast value (mismatch window).

How to use this guideline under incomplete context
- Identify conversions/casts:
  - Look for explicit casts, implicit assignments, API boundaries with different type widths/signedness.
- Trace value provenance:
  - Does the value come from external input, parsing, or untrusted sources?
- Check usage at sensitive sinks:
  - Is the converted value used as a length, index, pointer, allocation size, permission flag, or other security-relevant parameter?
- Generate a small number of targeted hypotheses:
  - H1: Narrowing conversion can truncate attacker-influenced values, leading to wrong bounds/allocations.
  - H2: Signedness conversion can turn negative into huge, bypassing checks or causing OOB/resource issues.
  - H3: Pointer/object cast violates actual type/layout, enabling type confusion or memory corruption.
  - H4: Safety is guaranteed elsewhere (validated ranges, strict parsing, enforced invariants) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., `(int)len`, `(size_t)neg`, `reinterpret_cast<T*>(buf)`),
  (b) evidence needed to confirm it (e.g., input constraints, platform assumptions, object type guarantees),
  (c) counter-evidence that would refute it (e.g., explicit range checks, proven type tags, safe parsing).

Quick red flags in partial code (weak → strong)
- Strong: Attacker-influenced length/index cast from wider to narrower type without bounds checks, then used for allocation/memcpy/indexing.
- Medium: Signed-to-unsigned conversion feeding size/loop/index logic; checks performed in a different type than the sink uses.
- Medium: Reinterpreting raw bytes as structs/pointers without validating size/alignment/endian; unchecked downcast.
- Weak: Type safety may be enforced by omitted validation layers or strict ABI constraints not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_704_RULE)
