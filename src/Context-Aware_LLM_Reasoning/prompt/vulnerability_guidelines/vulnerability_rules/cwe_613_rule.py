CWE_613_RULE = """
[CWE-613 Reference Guideline | Insufficient Session Expiration | Non-binding, Evidence-first]

Overview
- CWE-613 occurs when a system permits reuse of old session credentials (e.g., session IDs/tokens/cookies) for authorization because sessions do not expire properly or are not invalidated when they should be.
- This can enable attackers to replay stolen/old session identifiers, maintain access after logout, or continue using sessions beyond intended lifetimes.
- In partial snippets, not seeing explicit expiration logic is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “insufficient session expiration” (static analysis framing)
- Session credential:
  - Any bearer artifact used for session authorization (session ID cookie, session token, remember-me token, refresh token used as session, server-side session handle).
- Expiration:
  - Rules that limit session validity over time or events (absolute timeout, idle timeout, logout invalidation, rotation on privilege change).
- Insufficient expiration:
  - Session remains valid longer than policy, is renewable indefinitely without controls, or is not invalidated upon security-relevant events.

Where CWE-613 typically occurs (sensitive sinks)
- Session creation and lifecycle:
  - Login handlers, session issuance, token minting, session store insertion.
- Logout and session invalidation:
  - Logout endpoints, token revocation lists, session store deletion.
- Session validation middleware:
  - Filters/interceptors that accept session IDs/tokens and resolve principals.
- Remember-me / persistent login mechanisms:
  - Long-lived cookies/tokens without rotation, revocation, or binding constraints.
- Privilege changes and credential events:
  - Password change, account disable, role change, MFA enablement—events that should invalidate sessions.

Common failure modes (reasoning hints, not assumptions)
- Missing server-side invalidation on logout:
  - Logout clears cookie client-side but session remains valid server-side.
- No idle/absolute timeout enforcement:
  - Sessions live indefinitely unless manually cleared.
- Token not checked for expiration:
  - Expiry field exists but validation ignores it or uses wrong time source/units.
- Persistent tokens without rotation:
  - “Remember me” tokens can be replayed indefinitely; no one-time use or rotation on use.
- Session fixation-ish persistence:
  - Old session IDs remain usable after re-authentication or privilege change (no rotation).
- Revocation not propagated:
  - Distributed caches/session stores accept stale sessions after account disable or password change.

What “robust session expiration” looks like (context-specific)
- Enforce time-based expiration:
  - Absolute lifetime and idle timeout checked on every session use.
- Fail closed on expiration:
  - Expired sessions are rejected and removed from session store/revocation state.
- Invalidate on security events:
  - Logout, password reset/change, account disable, privilege changes trigger session invalidation.
- Token/session rotation:
  - Regenerate session ID on login and privilege elevation; rotate persistent tokens on use.
- Centralized validation:
  - Session validation middleware consistently checks expiration and revocation.

Common weak/insufficient defenses (signals of possible risk)
- Client-only expiration:
  - Relying only on cookie expiration without server-side checks (cookies can be replayed if copied).
- Long-lived tokens treated as sessions:
  - Using refresh/remember-me tokens as direct authorization tokens without proper constraints.
- Best-effort cleanup:
  - Background cleanup without strict per-request expiration checks.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Session/token carries expiry metadata and validation enforces it on every request.
  - Server-side session store tracks `createdAt/lastAccessed` and enforces absolute + idle timeouts.
  - Logout path invalidates server-side session (delete/revoke) and rotates tokens.
  - Session ID is regenerated on login and on privilege changes.
  - Revocation checks tied to account state changes (disabled users cannot reuse old sessions).
- Evidence suggesting vulnerability:
  - Authorization accepts session IDs/tokens with no visible expiry checks or last-access updates.
  - Logout only clears cookies but does not revoke/delete server-side session state.
  - Persistent “remember me” tokens are long-lived and reusable without rotation/revocation.
  - Session validation ignores expiry fields, or uses inconsistent time units/clock sources.
  - Sessions remain valid across password change/account disable (no invalidation hooks).

How to use this guideline under incomplete context
- Identify the session credential type:
  - Cookie-based session ID? JWT? custom token? remember-me token?
- Identify where validity is enforced:
  - Middleware/interceptor that loads session/principal; where are expiry and revocation checked?
- Generate a small number of targeted hypotheses:
  - H1: Sessions/tokens are accepted without enforcing expiration (no absolute/idle timeout).
  - H2: Logout does not invalidate server-side session credentials (replayable old session IDs).
  - H3: Persistent tokens are reusable without rotation or revocation, enabling long-term replay.
  - H4: Expiration/revocation is enforced elsewhere (framework security module, session store config) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., missing expiry checks, logout only clears cookie),
  (b) evidence needed to confirm it (e.g., session store settings, middleware code, token validation code),
  (c) counter-evidence that would refute it (e.g., enforced TTL checks, server-side revoke on logout).

Quick red flags in partial code (weak → strong)
- Strong: Authorization relies on session ID/token with no expiry/revocation checks; logout does not revoke server-side sessions.
- Medium: “Remember me” or long-lived tokens used for authorization without rotation/revocation and without binding constraints.
- Medium: Expiry exists but is inconsistently checked or can be bypassed (wrong units, ignored exceptions).
- Weak: Session expiration may be configured in omitted framework/session-store settings → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_613_RULE)