CWE_191_RULE = """
[CWE-191 Reference Guideline | Integer Underflow (Wrap or Wraparound) | Non-binding, Evidence-first]

Overview
- CWE-191 occurs when the product subtracts one value from another such that the result is less than the minimum allowable integer value, producing an incorrect wrapped result.
- Underflow can turn a small value into a very large value (commonly in unsigned arithmetic) or otherwise distort control flow, bounds checks, sizes, and offsets, leading to out-of-bounds access, mis-sized allocations, logic bypass, or denial of service.
- In partial snippets, the absence of visible underflow guards is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "integer underflow/wraparound" (static analysis framing)
- Integer underflow / wraparound:
  - A subtraction (or decrement/negation) produces a result below the representable minimum of the integer type.
  - Typical triggers: `a - b`, `x--`, `x -= k`, `-x` when `x` is the minimum value, and conversions between signed/unsigned or wider/narrower types around subtraction.
- Security-relevant underflow pattern:
  - Code assumes `a - b <= a` and remains non-negative (or within range), but wraparound violates this assumption.

Where integer underflow issues typically occur (sensitive sinks)
- Length/remaining calculations:
  - `remaining = total - consumed`, `payloadLen = len - headerSize`, `n = size - 1`.
- Indexing and pointer/offset arithmetic:
  - `buf[pos - 1]`, `start = end - len`, `ptr - offset`, window calculations.
- Bounds checks and range enforcement:
  - Using `if (remaining > 0)` or `if (len - header >= 0)` style checks that can be broken by unsigned wrap.
- Loop bounds and counters:
  - Decrementing counters that can wrap and cause very long loops or incorrect termination.
- Resource allocation decisions:
  - `alloc = requested - overhead` underflows to huge value, causing oversized allocations or failures.

Common failure modes (reasoning hints, not assumptions)
- Subtraction before validation:
  - Compute `x = a - b` then check `x` instead of validating `a >= b` first.
- Unsigned wrap to huge:
  - `size_t remaining = len - header;` when `len < header` yields a very large `remaining`.
- Off-by-one at zero boundary:
  - `i--` or `len - 1` when `len == 0`.
- Mixed signed/unsigned comparisons:
  - Negative results converted to unsigned, or comparisons that never behave as intended.
- Truncation around subtraction:
  - Perform subtraction in wider type then cast down, or cast inputs before subtracting, losing sign/range info.

What “underflow-safe arithmetic” looks like (context-specific)
- Validate preconditions before subtracting:
  - Ensure `a >= b` (or `a > 0` before `a - 1`) at the point of use.
- Keep consistent signedness:
  - Avoid unsigned subtraction for values that can legitimately go below zero; use signed types where negative is meaningful, but still guard min bounds.
- Use checked arithmetic helpers:
  - Use APIs/utilities that detect underflow or return failure on invalid subtraction.
- Re-check at sinks:
  - For cursor/remaining logic, enforce `consumed <= total` and `remaining = total - consumed` only after that check.
- Explicit invariants:
  - Maintain clear invariants like “len is non-negative and >= headerSize” and preserve them across transformations.

Common weak/insufficient defenses (signals of possible risk)
- Checking the result after unsigned subtraction:
  - `if (len - header > 0)` is unsafe if `len < header` underflows.
- Assuming values can’t be smaller:
  - “len is always >= header” without enforcement at boundaries (parsing, error paths).
- One-sided checks:
  - Checking `len <= MAX` but not `len >= MIN` (e.g., header size), or checking only `idx < size` but later doing `idx - 1`.
- Hidden conversions:
  - Implicit casting to unsigned (`size_t`) before subtraction.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit guards like `if (a < b) reject/error` before `a - b`.
  - Guards like `if (len == 0) ...` before `len - 1`, or `if (i == 0) ...` before `i--`-driven indexing.
  - Use of checked-subtraction helpers that return a boolean/status on underflow.
  - Clear, adjacent invariants around parsing and cursor movement (e.g., `if (consumed > total) fail`).
- Evidence suggesting vulnerability:
  - Subtractions on externally influenced lengths/offsets without visible `a >= b`/`a > 0` checks.
  - Unsigned types used for “remaining”/“available” with `len - header` patterns and no guard.
  - Indexing patterns like `buf[i-1]` without ensuring `i > 0`.
  - Decrement loops/counters that can wrap (e.g., `for (size_t i = n; i >= 0; i--)` style).

How to use this guideline under incomplete context
- Identify subtract sites and their operands’ provenance:
  - Are `a`/`b` derived from input, file/network lengths, headers, counters, or arithmetic that can reach zero?
- Identify how results are used:
  - Do underflowed results feed allocation, indexing, bounds checks, loop conditions, or security decisions?
- Generate a small number of targeted hypotheses:
  - H1: `len - headerSize` (or similar) can underflow, producing huge length/remaining and enabling OOB or large allocation.
  - H2: `idx - 1` or cursor backtracking can underflow at zero, causing OOB read/write.
  - H3: Decrementing unsigned loop counters can wrap, causing excessive iteration or incorrect memory access.
  - H4: Underflow is prevented elsewhere (validated parsing / checked arithmetic utilities) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unguarded subtraction, unsigned types),
  (b) evidence needed to confirm it (e.g., precondition checks, checked-sub APIs),
  (c) counter-evidence that would refute it (e.g., explicit `a >= b` guards adjacent to subtraction).

Quick red flags in partial code (weak → strong)
- Strong: Unsigned subtraction of externally influenced values (`len - header`, `remaining - consumed`) with no `a >= b` checks and used for sizing/indexing.
- Medium: Subtractions feeding bounds checks written in a way that can be bypassed by wraparound (`if (len - header > 0)`).
- Medium: Indexing with `-1` adjustments (`i-1`, `pos-1`) without explicit `> 0` guards.
- Weak: Underflow guards may exist in omitted helpers/parsers/framework layers → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_191_RULE)
