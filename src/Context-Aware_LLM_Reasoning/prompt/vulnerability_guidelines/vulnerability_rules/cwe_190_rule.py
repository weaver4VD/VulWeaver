CWE_190_RULE = """
[CWE-190 Reference Guideline | Integer Overflow or Wraparound | Non-binding, Evidence-first]

Overview
- CWE-190 occurs when the product performs integer calculations that can overflow or wrap around, while the logic assumes the resulting value is “safe” or monotonically larger than the original value.
- When an integer exceeds the maximum representable value of its type, it may wrap to a small or negative value (depending on signedness and language/runtime), leading to incorrect control flow, bypassed checks, mis-sized allocations, out-of-bounds access, or other security-relevant failures.
- In partial snippets, the absence of visible overflow guards is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "integer overflow/wraparound" (static analysis framing)
- Integer overflow / wraparound:
  - A computation produces a result outside the representable range of the integer type.
  - Typical triggers: addition/subtraction/multiplication, increment/decrement, shifting, negation of minimum value, and conversions between wider/narrower integer types.
- Security-relevant overflow pattern:
  - The code assumes `x + k >= x` always holds, or that a computed size/offset/count is valid, but overflow breaks this assumption.

Where integer overflow issues typically occur (sensitive sinks)
- Size and allocation computations:
  - `bytes = count * elemSize`, `total = header + payloadLen`, `newLen = oldLen + delta`.
- Indexing and pointer/offset arithmetic:
  - `buf[offset + i]`, `ptr + offset`, slicing ranges computed from untrusted lengths.
- Loop bounds and counters:
  - `for (i = start; i <= end; i++)` where `i++` can wrap; termination conditions become incorrect.
- Validation and access control logic:
  - Range checks, quota/limit enforcement, pagination/offset calculations.
- Parsing and protocol handling:
  - Using untrusted length fields (from input) in arithmetic before verifying constraints.

Common failure modes (reasoning hints, not assumptions)
- Overflow before bounds check:
  - Compute `n = a + b` (or `a * b`) then validate `n`, but the overflowed `n` passes checks.
- Monotonicity assumptions:
  - Logic relies on “increment always increases” (e.g., `if (x + 1 > x)` used implicitly), but wraparound violates it.
- Signed/unsigned mismatch:
  - Negative values converted to unsigned become huge; unsigned overflow wraps silently in many contexts.
- Narrowing conversion/truncation:
  - Casting from `long` to `int` after arithmetic discards high bits and can reintroduce wrap behavior.
- Off-by-one with max values:
  - `len + 1` for terminator, `end = start + length`, where `length` near MAX triggers wrap.

What “overflow-safe arithmetic” looks like (context-specific)
- Use checked arithmetic:
  - Use APIs/helpers that detect overflow (or explicit precondition checks) for add/mul/sub.
- Validate inputs before arithmetic:
  - Constrain `count`, `elemSize`, `len`, `offset` to safe ranges first.
- Keep computations in wider types:
  - Promote to wider type (e.g., 64-bit) before multiply/add, then validate before narrowing back.
- Validate derived values at the sink:
  - Re-check `offset + needed <= bufLen` using overflow-safe logic right before reads/writes/allocations.
- Consistent signedness:
  - Avoid mixing signed/unsigned; define clear invariants (non-negative, <= MAX).

Common weak/insufficient defenses (signals of possible risk)
- Checking only the final value without guarding overflow:
  - `if (a + b < MAX)` where `a + b` can overflow before comparison.
- Using `int` for sizes/lengths:
  - Especially when values come from external input or can be large.
- Relying on language defaults:
  - Assuming overflow “won’t happen” or is “safe”; behavior differs across languages and build modes.
- Partial range checks:
  - Checking `len <= MAX` but not ensuring `offset + len` is safe, or not checking for negative values.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit overflow guards (e.g., `if (a > MAX - b) reject`, `if (count > MAX / elemSize) reject`).
  - Use of checked math helpers (exact/checked add/mul) and error handling when overflow would occur.
  - Computations performed in wider types with subsequent validated narrowing.
  - Clear invariants and adjacent checks at sinks (allocation/indexing) that are overflow-safe.
- Evidence suggesting vulnerability:
  - Externally influenced `len/count/offset` used in `+`/`*`/`++` to compute sizes or indices without overflow guards.
  - Conditions that compare overflowed results (e.g., `if (a + b > a)` as safety).
  - Multiplication-based size calculations without `MAX / elemSize` style checks.
  - Casting after arithmetic (e.g., `(int)(longVal + delta)`) with no validation.

How to use this guideline under incomplete context
- Identify candidate overflow variables:
  - Lengths, counts, offsets, capacities, indices, loop counters, especially derived from untrusted sources.
- Identify arithmetic sites and sinks:
  - Where do `+`, `*`, `-`, `<<`, `++` feed into allocation, indexing, bounds checks, or security decisions?
- Generate a small number of targeted hypotheses:
  - H1: `count * elemSize` or similar can overflow, causing undersized allocation and downstream OOB.
  - H2: `offset + len` can overflow, bypassing bounds checks and enabling OOB read/write.
  - H3: Loop counter increment can wrap, breaking termination and enabling DoS or logic bugs.
  - H4: Overflow is prevented elsewhere (validated parsing / checked math utilities) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unguarded arithmetic, narrowing casts),
  (b) evidence needed to confirm it (e.g., input constraints, checked arithmetic helpers),
  (c) counter-evidence that would refute it (e.g., `MAX - b` / `MAX / elemSize` guards near sink).

Quick red flags in partial code (weak → strong)
- Strong: Untrusted lengths/counts drive `+`/`*` size computations used for allocation/indexing with no overflow checks.
- Medium: Bounds checks exist but use overflow-prone expressions (`a + b` in the condition) or rely on monotonicity.
- Medium: Mixed signed/unsigned arithmetic or narrowing casts after arithmetic without validation.
- Weak: Overflow guards may be implemented in omitted helpers/parsers or in different layers → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_190_RULE)
