CWE_212_RULE = """
[CWE-212 Reference Guideline | Improper Removal of Sensitive Information Before Storage or Transfer | Non-binding, Evidence-first]

Overview
- CWE-212 occurs when a product stores, transfers, or shares a resource that contains sensitive information, but fails to properly remove or redact that information before making the resource accessible to unauthorized actors.
- In partial snippets, missing sanitization/redaction evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “sensitive information” (typical categories)
- Credentials & secrets: passwords, API keys, tokens, session IDs, private keys, shared secrets, OAuth codes.
- Personal data: names, emails, phone numbers, addresses, IDs, health/financial records (depending on context).
- Security internals: stack traces with secrets, internal hostnames/paths, system configuration containing secrets, debug dumps.
- Authentication/authorization artifacts: cookies, JWTs, refresh tokens, CSRF tokens, password reset links.
- Proprietary data: business-sensitive records, internal documents, source code, confidential metadata.

What counts as “resource” being stored/transferred/shared (typical carriers)
- Persistent storage: database rows/columns, files, object storage, caches (Redis), search indices, analytics stores.
- Transfers: HTTP responses, downloads, API payloads, RPC messages, webhooks, emails/notifications, logs-as-data pipelines.
- Shared artifacts: generated reports, exports (CSV/JSON/XML), archives, backups, serialized objects, attachments.
- Observability artifacts treated as data: crash reports, telemetry payloads, tracing spans, debug snapshots (if exposed to others).

Key code-level operations where CWE-212 manifests (static snippet oriented)
- Serialization/marshalling: JSON/XML/YAML serialization, object mappers, template rendering, DTO/view-model mapping.
- Export/report generation: building CSV/Excel/PDF/HTML exports, zips of data, “download my data” endpoints.
- Storage writes: inserting/updating DB objects, writing files, caching objects, snapshotting objects for later retrieval.
- Data forwarding: proxying/relaying responses, webhook payload construction, message publishing to queues/topics.

Typical failure modes (reasoning hints, not assumptions)
- Over-sharing / over-serialization:
  - Returning full domain objects that include secrets (e.g., passwordHash, token, internalNotes) instead of a minimal DTO.
  - Using generic serializers that include all fields by default (reflection-based).
- Partial redaction:
  - Masking only some sensitive fields while leaving equivalent or derived sensitive data intact (e.g., token also appears in URL, headers, nested objects).
  - Redacting at the wrong layer (redact displayed string but store raw object; redact after serialization too late).
- Incorrect authorization boundary:
  - Sanitization depends on “who is allowed,” but response/export is accessible to broader audiences (e.g., sharing links, multi-tenant leakage).
- Copy/clone issues:
  - Creating a “safe” view but accidentally reusing the original object/reference or including nested sensitive sub-objects.

What “proper removal/redaction” looks like (context-specific)
- Data minimization by construction:
  - Use explicit DTOs/view models containing only allowed fields; avoid returning/storing whole domain entities.
  - Use allow-list field selection during serialization (explicit inclusion), not implicit “serialize everything.”
- Redaction before exposure:
  - Remove or transform sensitive fields prior to storage/transfer/sharing boundaries (before write/serialize/send).
  - Ensure nested structures and alternate representations are also handled (headers/URLs/metadata/attachments).
- Deterministic rules:
  - Define sensitive-field taxonomy and consistent redaction rules (masking, hashing, truncation, omission) aligned with use case.
  - Avoid reversible “masking” when true removal is required (depending on threat model).

Common weak/insufficient defenses (signals of possible risk)
- Blacklist-based “remove a few fields” approaches when the object shape can evolve (new sensitive fields silently added later).
- Redacting only string representations (e.g., log message or toString) while exporting raw structured objects elsewhere.
- Post-hoc redaction after the data already left the trust boundary (after send/write/serialize).
- “Debug mode” paths that bypass redaction and are reachable in production contexts.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Response/export is built from an allow-listed DTO (explicit field mapping) rather than serializing a full domain object.
  - Explicit omission/redaction of sensitive fields occurs before persistence/serialization/transfer.
  - Serializer configuration restricts fields by annotation/visibility/allow-list and is applied on this code path.
- Evidence suggesting vulnerability:
  - Returning or exporting a rich object that likely contains sensitive fields, with no visible filtering/mapping step.
  - Copying request/session/security context into objects that are stored or sent externally.
  - Generic “serialize object” or “dump all properties” patterns in an exposure path.

How to use this guideline under incomplete context
- Use it to generate a small number of targeted hypotheses based on the observed storage/transfer/sharing sink:
  - H1: Sensitive fields are included in the resource due to over-serialization or returning domain objects.
  - H2: Redaction exists but is incomplete (nested/alternate representations) or occurs too late.
  - H3: A safe DTO/redaction is applied upstream, but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (e.g., object schema, serializer config, DTO mappings, call chain),
  (c) counter-evidence that would refute it (e.g., explicit allow-list mapping, annotations excluding secrets).

Quick red flags in partial code (weak → strong)
- Strong: “return/serialize/store whole object” where that object plausibly contains secrets/PII, with no explicit field selection/redaction.
- Medium: Ad-hoc removal of a few known fields (blacklist) in a codebase where objects may evolve.
- Medium: Redaction after serialization or after writing/sending.
- Weak: Sanitization likely occurs outside shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_212_RULE)
