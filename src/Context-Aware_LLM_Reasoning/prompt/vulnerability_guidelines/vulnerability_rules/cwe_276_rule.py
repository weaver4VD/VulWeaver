CWE_276_RULE = """
[CWE-276 Reference Guideline | Incorrect Default Permissions | Non-binding, Evidence-first]

Overview
- CWE-276 occurs when default permissions are set too permissively, such that installed files (or similar resources) can be modified by unintended actors (e.g., “anyone can write/modify”).
- Incorrect default permissions are especially risky for executables, configuration files, scripts, libraries, or other security-critical resources, because unauthorized modification can enable code execution, privilege escalation, or persistent compromise.
- In partial snippets, not seeing permission-setting code is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “incorrect default permissions” (static analysis framing)
- Default permissions:
  - The access mode/ACL applied automatically during installation, initialization, deployment, or first-run setup when files/directories are created or packaged.
- Incorrect (too permissive):
  - Write/modify permissions granted to broad principals (e.g., world-writable files, overly broad group write, permissive ACL entries) beyond the intended administrative owners.
- Installation context:
  - Installer scripts, packaging specs, build/deploy pipelines, container images, init routines, or code that creates files with explicit modes.

Where incorrect default permissions typically occur (sensitive sinks)
- File creation and installation routines:
  - Creating config files, scripts, executables, keystores, PID files, logs, temp dirs, or plugin folders.
- Packaging/install scripts:
  - Post-install hooks, Docker image layers, deployment templates, init containers, service install steps.
- Permission/ACL APIs:
  - Setting file modes/permissions explicitly (e.g., chmod-like operations, POSIX file attribute setting, Windows ACL changes).
- Directory permissions impacting files:
  - World-writable directories that allow attackers to replace/modify installed files (TOCTOU, symlink attacks).
- “Extract/unpack” operations:
  - Unzipping/tarring installed artifacts with permissive modes or preserving unsafe modes from archive entries.

Common failure modes (reasoning hints, not assumptions)
- World-writable files or directories:
  - Installed files created with modes like `0666`, directories like `0777`, or equivalent ACL granting write to “Everyone/Users”.
- Overly permissive group permissions:
  - Group write enabled when group membership is broad or untrusted.
- Missing umask / insecure defaults:
  - Relying on environment defaults (umask/ACL inheritance) that may be permissive.
- Permission set incorrectly after creation:
  - Create file with permissive mode and forget to tighten, or fail on error path.
- Applying permissions to wrong path:
  - Intended secure path differs from actual path (symlink/relative path), resulting in permissions not applied to the real installed file.

What “secure default permissioning” looks like (context-specific)
- Least privilege defaults:
  - Files: owner-readable/writable only where appropriate (e.g., `0600` for secrets, `0644` for non-sensitive read-only).
  - Executables: no write for non-owners; controlled write access.
  - Directories: restrict write/modify to owners/admins (e.g., `0700` or `0755` depending on needs).
- Explicit permission setting:
  - Set restrictive permissions at creation time and verify the result.
- Defensive handling of directories:
  - Avoid world-writable install locations; ensure directories that contain security-critical files are not writable by untrusted actors.
- Clear separation of writable vs non-writable areas:
  - Only designated data dirs are writable; install dirs remain read-only to non-admins.

Common weak/insufficient defenses (signals of possible risk)
- “It’s only during install”:
  - Default permissions persist after installation; attackers can modify files later.
- Relying on inherited permissions:
  - Assuming umask/ACL inheritance will be safe across environments.
- Broad ACL entries:
  - Granting write to broad principals for convenience (“Everyone can edit configs”) without strict need.

Evidence to look for in code/config (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit restrictive modes/ACLs for installed files and directories (especially configs/executables).
  - Clear separation of install path vs runtime data path, with only the latter writable.
  - Verification steps after creating files (checking permissions/ownership).
  - Secure archive extraction that enforces safe modes rather than trusting archived permissions.
- Evidence suggesting vulnerability:
  - Explicit creation/installation with permissive modes/ACLs (world-writable or broadly writable).
  - Use of temp/shared directories for installed components without tightening permissions.
  - Unpacking archives preserving permissive modes into install directories.
  - Missing permission hardening for sensitive files (configs/keys/scripts) in install/init routines.

How to use this guideline under incomplete context
- Identify what is being installed/created:
  - Configs, scripts, binaries, plugin dirs, or other files that affect execution/security posture.
- Identify permission-setting sites:
  - Where are file modes/ACLs set (creation flags, chmod-like calls, file attribute setters, packaging metadata)?
- Generate a small number of targeted hypotheses:
  - H1: Installed files/directories are created with world-writable or overly broad write permissions.
  - H2: Install directory is writable by untrusted actors, enabling modification/replacement of critical files.
  - H3: Permissions rely on environment defaults (umask/ACL inheritance) and may be unsafe.
  - H4: Permission hardening is enforced elsewhere (packaging spec, installer framework) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., `0777`/`0666`-like modes, broad ACL grants),
  (b) evidence needed to confirm it (e.g., packaging/install scripts, actual default modes, install paths),
  (c) counter-evidence that would refute it (e.g., explicit restrictive modes, verified ownership/ACLs).

Quick red flags in partial code (weak → strong)
- Strong: Explicitly setting “anyone writable” permissions on installed files or install directories containing executables/config.
- Medium: Creating install artifacts in shared/writable locations without subsequent tightening.
- Medium: Archive extraction/installer preserves or applies permissive modes by default.
- Weak: Permission controls may be specified in omitted packaging/installer layers → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_276_RULE)
