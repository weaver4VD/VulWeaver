CWE_476_RULE = """
[CWE-476 Reference Guideline | NULL Pointer Dereference | Non-binding, Evidence-first]

Overview
- CWE-476 occurs when the product dereferences a pointer that it expects to be valid but is actually NULL.
- NULL dereference typically causes crashes or abnormal termination (DoS). In some contexts it can be security-relevant if attackers can reliably trigger it remotely or if it leads to unsafe fallback logic.
- In partial snippets, the absence of a NULL check is not proof of vulnerability: the pointer may be guaranteed non-NULL by API contracts, earlier checks, or invariant enforcement elsewhere. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “NULL pointer dereference” (static analysis framing)
- Dereference:
  - Any operation that reads/writes through a pointer assumed non-NULL, e.g.:
    - `*p`, `p->field`, `p[i]`, calling a function pointer from `p`, `memcpy(p, ...)` when `p` must be valid.
  - In C++, dereferencing references or calling methods on a null object pointer also qualifies (though references are supposed to be non-null).
- NULL origin:
  - Pointer is NULL due to failed allocation, failed lookup, optional return, error path, partial initialization, or user-controlled index/key producing a missing entry.

Where CWE-476 typically occurs (sensitive sinks)
- Post-allocation usage:
  - `malloc/new` results used without checking for failure (esp. in C where malloc can return NULL).
- Lookup/get APIs:
  - Map/dict lookups, container `find`, `getenv`, `fopen`, `dlsym`, `GetProcAddress`, `strchr`, parsing functions returning NULL on failure.
- Pointer chains:
  - `a->b->c` where any intermediate can be NULL.
- Virtual dispatch / function pointers:
  - Calling through pointers obtained from dynamic loading, vtables, callbacks.
- Error-handling boundaries:
  - A pointer is set in one branch but used unconditionally later.

Common failure modes (reasoning hints, not assumptions)
- Missing check after failure-prone API:
  - Using pointer immediately after allocation/lookup/open without validating it.
- Non-dominating checks:
  - Pointer checked in one branch, but dereferenced on another path not covered by the check.
- Intermediate NULL in chained accesses:
  - Checking `a` but not `a->b` before dereferencing `a->b->c`.
- Incorrect assumptions about inputs:
  - User-controlled indices/keys select missing entries, returning NULL.
- Partial initialization:
  - Struct fields not set under some conditions; later dereference assumes initialized.

What “robust NULL safety” looks like (context-specific)
- Dominating NULL checks:
  - Check pointer (and relevant intermediates) on all paths before dereference.
- Fail-closed handling:
  - If pointer is NULL, return error / propagate failure rather than continuing.
- Strong API contracts / invariants:
  - Use APIs that guarantee non-NULL (and verify that guarantee is valid for your build/runtime).
- Defensive coding for optional returns:
  - Treat lookups as optional; handle missing values explicitly.
- Avoid ambiguous ownership/initialization:
  - Ensure initialization is complete before use; keep pointers in well-defined states.

Common weak/insufficient defenses (signals of possible risk)
- Checking too late:
  - Dereference occurs before check (including hidden dereference in helper macros/functions).
- Checking only outer pointer:
  - Chain dereference where only the first pointer is checked.
- “Should never be NULL” comments:
  - Assumptions not enforced by code, especially under attacker-controlled inputs.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Immediate checks after failure-prone calls: `p = malloc(...); if (!p) return ...;`
  - Checks that dominate dereference sites (control-flow proves non-NULL).
  - Explicit handling of lookup failure: `node = find(...); if (!node) ...;`
  - For pointer chains: guarding intermediates (or using safe access patterns).
  - Assertions/invariants that are credible in context (e.g., validated constructor guarantees non-NULL fields).
- Evidence suggesting vulnerability:
  - Dereferencing a pointer that comes from allocation/lookup/open without any visible NULL check.
  - Dereference in code paths that can execute when pointer remains NULL (e.g., pointer assigned only in some branches).
  - Chained dereference where intermediate pointers are not validated.
  - Error codes ignored (e.g., API returns status but pointer still used).

How to use this guideline under incomplete context
- Identify dereference sites:
  - `->`, `*`, array indexing, function pointer calls, library functions requiring valid pointer arguments.
- Trace pointer provenance:
  - Allocation, lookup, parse result, optional return, struct field initialization.
- Check control-flow dominance:
  - Is there a NULL check that must execute before dereference on every path?
- Generate a small number of targeted hypotheses:
  - H1: Pointer can be NULL (allocation/lookup failure) and is dereferenced without a dominating check.
  - H2: An intermediate in a pointer chain can be NULL and is dereferenced without guarding.
  - H3: Initialization is conditional; pointer/field may remain NULL on some paths but used unconditionally later.
  - H4: Non-NULL guarantee exists elsewhere (API contract, earlier validation, constructor invariants) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., failure-prone API + no checks + dereference),
  (b) evidence needed to confirm it (e.g., API guarantees, caller validation, allocation failure handling),
  (c) counter-evidence that would refute it (e.g., dominating checks, proven invariants).

Quick red flags in partial code (weak → strong)
- Strong: Dereference immediately after a call that can return NULL (malloc/lookup/open) with no guard.
- Medium: Pointer checked in some branch, but dereference occurs outside/afterward without ensuring the check dominates.
- Medium: Multi-level dereference (`a->b->c`) where only `a` is checked.
- Weak: Non-NULL invariants may be established outside the snippet (validated inputs, guaranteed container semantics) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_476_RULE)
