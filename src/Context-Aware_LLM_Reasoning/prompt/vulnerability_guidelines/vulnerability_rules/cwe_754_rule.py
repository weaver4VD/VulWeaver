CWE_754_RULE = """
[CWE-754 Reference Guideline | Improper Check for Unusual or Exceptional Conditions | Non-binding, Evidence-first]

Overview
- CWE-754 occurs when the product does not check, or incorrectly checks, for unusual or exceptional conditions that are not expected to occur frequently during normal operation.
- These conditions are “edge cases” or “rare failures” (e.g., partial I/O, empty/oversized inputs, timeouts, resource exhaustion, unexpected state transitions) that can be triggered intentionally by attackers to cause crashes, inconsistent state, security bypass, or denial of service.
- In partial snippets, missing an edge-case check is not automatically CWE-754: checks may exist elsewhere or conditions may be impossible under enforced invariants. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “unusual/exceptional conditions” (static analysis framing)
- Unusual condition:
  - A non-happy-path situation that is uncommon but possible, including:
    - API failure signals (NULL, negative return, error code, exceptions).
    - Partial reads/writes, interrupted syscalls, short writes, truncation.
    - Empty inputs, missing fields, out-of-range values, malformed encodings.
    - Overflow/underflow, divide-by-zero preconditions.
    - Resource exhaustion (OOM, fd limits), quota breaches.
    - Concurrency anomalies (timeouts, cancellations, races exposing stale state).
- Improper check:
  - Not checking at all, checking the wrong condition/variable, checking but not dominating the sensitive use, or checking but continuing unsafely.

Where CWE-754 typically occurs (sensitive sinks)
- Input parsing and validation:
  - Handling malformed/degenerate inputs, extreme sizes, unexpected characters/encodings.
- Boundary operations:
  - Indexing, buffer operations, arithmetic preconditions, pointer dereferences.
- I/O and networking:
  - Handling partial reads/writes, timeouts, EOF, connection resets, retries.
- Resource acquisition:
  - Allocation/open/lock acquisition failures, pool depletion.
- State machines / protocol handlers:
  - Unexpected message order, missing required steps, replays, partial handshakes.
- Security-sensitive operations:
  - Authorization/authentication and policy decisions that must fail closed when conditions are uncertain.

Common failure modes (reasoning hints, not assumptions)
- Happy-path assumptions:
  - Code assumes “this won’t fail” and omits checks for rare but valid failure returns.
- Wrong or incomplete guard:
  - Checking `ret < 0` but not `ret == 0` where zero is failure; checking `p` but not `p->field`.
- Non-dominating checks:
  - A check exists but can be bypassed via alternative control paths.
- Silent continuation after anomaly:
  - Detecting an unusual condition but continuing with uninitialized/partial state.
- Inconsistent validation:
  - Some fields validated, others not; rare combinations slip through.
- Retry without reset:
  - Retrying after partial failure without clearing state, compounding inconsistencies.

What “robust unusual-condition checking” looks like (context-specific)
- Enumerate and validate failure modes of called APIs:
  - Treat documented “rare” failure signals as real; handle them explicitly.
- Validate edge cases close to the sink:
  - Check preconditions immediately before sensitive operations (bounds, non-NULL, non-zero divisors).
- Fail safely:
  - Reject malformed/unexpected inputs; abort the current operation (not the whole process) if recovery is unsafe.
- Preserve invariants:
  - Ensure state remains consistent when an unusual condition occurs (rollback/cleanup).
- Prefer deterministic handling:
  - Avoid “best effort guessing” on ambiguous protocol/message framing.

Common weak/insufficient defenses (signals of possible risk)
- Logging-only handling:
  - Detecting an anomaly but proceeding anyway.
- Catch-all without correction:
  - Swallowing exceptions and continuing with partial state.
- Validating one representation but using another:
  - E.g., checking parsed sizes but using raw lengths later.
- Over-trusting environment:
  - Assuming filesystem/network always behaves ideally; assuming inputs are well-formed.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit checks for documented rare outcomes (e.g., partial I/O loops, NULL returns, boundary checks).
  - Checks that dominate sensitive operations (no alternative path reaches the sink without validation).
  - Defensive handling of empty/oversized/malformed input with error returns.
  - Cleanup/rollback logic ensuring consistent state after failures.
  - Correct handling of “zero/empty” semantics where relevant (EOF, empty list, missing key).
- Evidence suggesting vulnerability:
  - Failure-prone calls with unchecked/incorrectly checked return values.
  - Handling that assumes full reads/writes or valid parse results without verifying.
  - Boundary-sensitive operations without checks under attacker-influenced inputs.
  - Detecting abnormal condition but continuing with uninitialized buffers, stale pointers, or inconsistent state.
  - Validation checks that are present but not aligned with the actual failure semantics (wrong condition).

How to use this guideline under incomplete context
- Identify operations with rare but important failure modes:
  - I/O, parsing, allocation, arithmetic, protocol/state transitions, security checks.
- Determine the expected “failure signals”:
  - Return codes, NULL, exceptions, partial counts, sentinel values.
- Verify correctness and dominance of checks:
  - Are checks present, correct, and guaranteed to run before sensitive use?
- Generate a small number of targeted hypotheses:
  - H1: A rare/edge failure mode is not checked, leading to unsafe use of partial/invalid state.
  - H2: The check exists but is incorrect (wrong predicate/variable), allowing unusual conditions to slip through.
  - H3: Unusual condition is detected but handling is unsafe (continues, inconsistent state, fail-open).
  - H4: Checks/handling occur elsewhere (wrappers, frameworks, centralized validators) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unchecked return, partial I/O assumed),
  (b) evidence needed to confirm it (e.g., API semantics, upstream validation, wrapper behavior),
  (c) counter-evidence that would refute it (e.g., dominating guards, safe failure returns, rollback).

Quick red flags in partial code (weak → strong)
- Strong: Boundary-sensitive operation (buffer/index/division/pointer deref) fed by untrusted input with no guarding for rare/edge values.
- Medium: Failure-prone API called and its result assumed valid; partial I/O not handled; wrong/insufficient checks.
- Medium: Unusual condition detected but execution continues into sensitive logic or leaves state inconsistent.
- Weak: Edge-case handling may be implemented in omitted layers; API semantics not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_754_RULE)
