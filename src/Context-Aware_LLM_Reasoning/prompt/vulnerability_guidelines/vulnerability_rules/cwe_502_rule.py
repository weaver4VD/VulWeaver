CWE_502_RULE = """
[CWE-502 Reference Guideline | Deserialization of Untrusted Data | Non-binding, Evidence-first]

Overview
- CWE-502 occurs when a product deserializes untrusted data without sufficiently ensuring that the resulting data is valid, secure, and safe to process.
- This can lead to vulnerabilities such as arbitrary code execution, denial of service (DoS), or data corruption, as untrusted data may contain malicious objects, unexpected structures, or exploit flaws in the deserialization process.
- In partial snippets, missing deserialization validation or improper checks are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “deserialization” and “untrusted data” (static analysis framing)
- Deserialization:
  - The process of converting data from a serialized format (e.g., JSON, XML, or binary formats) back into objects or data structures that the application can process. This is done using methods like `deserialize()`, `readObject()`, or equivalent.
- Untrusted data:
  - Data that originates from an untrusted or unverified source, such as user input, external APIs, files, or network traffic.
  - Data that could be manipulated or crafted by an attacker to exploit weaknesses in the deserialization process.

Where deserialization issues typically arise (sensitive sinks)
- Deserialization calls:
  - `ObjectInputStream.readObject()`, `deserialize()`, `json.deserialize()`, or equivalent deserialization functions.
- File parsing or network data processing:
  - Data received from external systems or saved to files that are later deserialized without validation or filtering.
- Dynamic class loading via deserialization:
  - Deserializing data that includes class references or types that could lead to class loading vulnerabilities.

Common failure modes (reasoning hints, not assumptions)
- Deserialization without input validation:
  - Accepting untrusted data directly for deserialization without ensuring its integrity or validating the data type and structure.
- Executing or invoking methods through deserialized objects:
  - Malicious data could contain references to executable code (e.g., objects with `readObject()` or `finalize()` methods) that could be invoked during the deserialization process.
- Unchecked type information or data structure manipulation:
  - Deserialization that blindly casts or processes data structures from the serialized input without verifying its expected type.
- Lack of proper deserialization security settings:
  - Not using secure deserialization libraries or mechanisms that prevent arbitrary code execution or data corruption during deserialization.

What “safe deserialization” looks like (context-specific)
- Validate untrusted data before deserialization:
  - Ensure that the data is well-formed, properly encoded, and matches the expected structure before deserialization.
- Use safe, vetted deserialization libraries:
  - Use deserialization libraries that offer built-in protections against malicious inputs, such as those that limit the types of objects that can be deserialized or those that use whitelisting techniques.
- Prevent object execution during deserialization:
  - Disable features that allow objects to execute code during deserialization (e.g., Java’s `ObjectInputStream` can be restricted using `ObjectInputStream.setObjectInputFilter()`).
- Implement strong input validation and sanitization:
  - Ensure that any data received from external sources is sanitized, checked for consistency, and validated for correctness before deserialization.

Common weak/insufficient defenses (signals of possible risk)
- No validation or sanitization of deserialized data:
  - Accepting and deserializing arbitrary, untrusted data without validating or filtering it.
- Blind deserialization of untrusted objects:
  - Deserializing data into objects without checking for type safety or security constraints, allowing attackers to craft objects that exploit weaknesses in the deserialization logic.
- Lack of protection against malicious object manipulation:
  - Failing to prevent dangerous or malicious objects from being created through deserialization, potentially leading to code execution or system manipulation.
- Missing access control during deserialization:
  - Deserialized data can cause the application to execute unauthorized actions if the deserialized objects reference sensitive code or system functionality.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Input validation before deserialization (e.g., checking data against a predefined schema or using regular expressions).
  - Use of secure deserialization libraries or features like object input filters (`setObjectInputFilter()`, `JSON.parseSecure()`).
  - Restricting or sanitizing the classes or types that can be deserialized, using white-listing techniques.
  - Deserialization of data that is explicitly validated for expected structure and data types before being processed.
- Evidence suggesting vulnerability:
  - Data deserialized from untrusted sources with no evidence of validation or sanitization.
  - Use of deserialization methods like `readObject()` or `deserialize()` without input filtering or checks.
  - Deserialization occurring with the potential for dangerous or malicious objects (e.g., objects with overridden `readObject()` or `finalize()` methods).
  - Object casting or type handling that is done unsafely based on untrusted data.

How to use this guideline under incomplete context
- Identify the deserialization method used:
  - What deserialization function or library is being called? Is the deserialized data properly validated before it is processed?
- Identify the source and trust level of the data:
  - Where does the data come from? Is it externally controlled (e.g., user input, network, external files)?
- Generate a small number of targeted hypotheses:
  - H1: Data is deserialized from an untrusted source without proper validation or input sanitization.
  - H2: Deserialized objects include executable code or methods that can be triggered during deserialization.
  - H3: Deserialization is handled by a secure library or includes appropriate validation mechanisms, but they are not visible in this snippet.
  - H4: Malicious objects or data structures are processed without type checks, leading to potential exploits.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (use of reflection, deserialization functions, object casting),
  (b) evidence needed to confirm it (validation logic, deserialization filters, secure handling of types),
  (c) counter-evidence that would refute it (explicit deserialization security features, clear input validation).

Quick red flags in partial code (weak → strong)
- Strong: user-controlled input is deserialized without validation or filtering, potentially executing malicious code.
- Medium: deserialization functions are used without clear input validation or whitelisting of allowed classes/methods.
- Medium: deserialization occurs, but the resulting objects are not sanitized or type-checked.
- Weak: deserialization logic may be handled by an external library or framework not shown in the snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_502_RULE)