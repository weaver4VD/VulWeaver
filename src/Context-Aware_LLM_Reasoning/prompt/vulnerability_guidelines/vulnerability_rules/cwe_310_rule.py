CWE_310_RULE = """
[CWE-310 Reference Guideline | Cryptographic Issues (Generic) | Non-binding, Evidence-first]

Overview
- CWE-310 is a broad category covering vulnerabilities caused by improper implementation or usage of cryptographic algorithms, protocols, randomness, or key management.
- Typical impacts include loss of confidentiality (data exposure), loss of integrity (tampering), authentication failures, and broader compromise of sensitive information.
- In partial snippets, missing crypto context is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “cryptographic usage” in code (static analysis framing)
- Confidentiality:
  - encrypting/decrypting sensitive data at rest or in transit
- Integrity/authenticity:
  - MAC/HMAC, signatures, token signing/verification
- Key derivation and password handling:
  - KDFs, password hashing, token generation
- Randomness and nonces:
  - IVs, nonces, salts, session tokens, reset tokens

Typical crypto “sinks” (Java-oriented cues)
- JCA/JCE primitives:
  - Cipher, Mac, Signature, MessageDigest, KeyPairGenerator, KeyGenerator
  - SecretKeySpec, IvParameterSpec, GCMParameterSpec, PBEKeySpec
- TLS/SSL usage:
  - SSLContext, TrustManager, HostnameVerifier, certificate validation hooks
- Randomness:
  - SecureRandom (and alternatives)
- Third-party crypto utilities:
  - framework/helper methods that wrap encryption, signing, hashing

Common cryptographic issue families (reasoning hints, not assumptions)
- Weak or deprecated algorithms:
  - broken/obsolete primitives, too-short keys, weak digests for security goals
- Insecure modes/parameters:
  - encryption without authentication (malleability), misuse of modes, missing or fixed IV/nonce
- Key management problems:
  - hard-coded keys, keys stored alongside ciphertext, shared keys across tenants/users
  - missing rotation, inappropriate key reuse across purposes
- Poor entropy:
  - predictable randomness, time-based seeds, non-cryptographic PRNG for secrets
- Improper verification:
  - signature/MAC verification skipped or implemented incorrectly
  - TLS certificate validation disabled or overly permissive
- Incorrect composition:
  - hashing when encryption is needed; encryption when integrity is needed; “homegrown” schemes

What “proper cryptographic usage” looks like (context-specific)
- Match primitive to security goal:
  - confidentiality + integrity → authenticated encryption or encrypt-then-MAC (conceptually)
  - integrity/authenticity → MAC/signature with correct verification
- Use strong, modern primitives with correct parameters:
  - adequate key sizes, correct IV/nonce handling (unique/unpredictable as required)
- Use secure randomness for secrets:
  - cryptographic-strength RNG for keys/tokens/nonces/salts
- Manage keys safely:
  - keys not hard-coded; sourced from secure key management/config
  - separate keys for different purposes; minimal exposure; rotation strategy when applicable
- Verify correctly and fail closed:
  - verification failures deny access; no “accept on exception” behavior
  - TLS validation should not be bypassed

Common weak/insufficient defenses (signals of possible risk)
- “Encryption” or “hashing” used as a label without evidence of correct construction/parameters.
- Hard-coded secrets:
  - literal keys, static IVs, embedded passwords, default credentials
- Reusing IV/nonce or using fixed IV:
  - deterministic IVs, constant IV arrays, IV derived from predictable inputs
- Non-crypto RNG for secrets:
  - java.util.Random or predictable seeds used for tokens/keys
- Disabling TLS checks:
  - permissive TrustManager/HostnameVerifier patterns that accept all certificates/hosts
- Rolling custom crypto:
  - bespoke XOR/obfuscation schemes, ad-hoc “encrypt” functions without standard primitives

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - explicit use of established crypto APIs with clear intent and correct separation of roles (encryption vs MAC/signature)
  - SecureRandom used for key/nonce/salt generation
  - IV/nonce is generated per encryption and carried/stored appropriately
  - keys are obtained from secure configuration/keystore/KMS-like sources (not literals), and are scoped by purpose
  - signature/MAC verification is performed and enforced (fail closed)
  - TLS validation is standard (no “trust all” behavior)
- Evidence suggesting vulnerability:
  - hard-coded keys/IVs/salts or keys derived from predictable values
  - insecure randomness for secrets (Random, time-seeded PRNG)
  - encryption used without integrity where integrity is needed (malleable ciphertext scenarios)
  - digest misuse (e.g., using fast hashes as password storage) or incorrect verification logic
  - certificate/hostname validation disabled
  - “encrypt/decrypt” helpers with unclear semantics and no visible secure parameter handling

How to use this guideline under incomplete context
- First identify the crypto goal and boundary:
  - is it protecting data at rest, generating tokens, verifying identity, protecting transport?
- Identify the primitive usage pattern:
  - which APIs are called; where do keys/IVs/nonces come from; how are outputs stored/transmitted?
- Generate a small number of targeted hypotheses:
  - H1: Weak primitives/parameters (mode, key size, IV/nonce handling) undermine confidentiality/integrity.
  - H2: Key management is unsafe (hard-coded, reused, wrong scope).
  - H3: Randomness is predictable for secrets.
  - H4: Verification is missing/incorrect or fails open.
  - H5: Correct crypto handling exists in helpers/config not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (API usage, literals, fixed arrays, disabled checks),
  (b) evidence needed to confirm it (algorithm/mode strings, key sources, IV lifecycle, config),
  (c) counter-evidence that would refute it (proper key/nonce generation, standard verification, secure config sources).

Quick red flags in partial code (weak → strong)
- Strong: hard-coded keys or fixed IV/nonce/salt used in cryptographic operations.
- Medium: non-cryptographic RNG used for tokens/keys, or predictable seeding.
- Medium: “trust all certs” / disable hostname verification patterns in TLS code.
- Medium: crypto helper methods with no visible parameter/key/nonce discipline.
- Weak: crypto correctness may depend on unshown configuration or helper implementations → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_310_RULE)
