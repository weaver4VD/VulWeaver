CWE_824_RULE = """
[CWE-824 Reference Guideline | Access of Uninitialized Pointer | Non-binding, Evidence-first]

Overview
- CWE-824 occurs when the product accesses or uses a pointer that has not been initialized.
- Using an uninitialized pointer can lead to crashes, undefined behavior, information disclosure (reading arbitrary memory), memory corruption, or exploitable control-flow effects depending on how the pointer is used.
- In partial snippets, seeing a pointer declaration without initialization is not automatically CWE-824: it may be initialized on all paths before use. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “access of uninitialized pointer” (static analysis framing)
- Uninitialized pointer:
  - A pointer variable whose value has not been set to a known valid state (e.g., NULL or a valid address) before it is used.
- “Use” includes:
  - Dereference: `*p`, `p->field`, `p[i]`.
  - Passing to APIs expecting a valid pointer: `memcpy(p, ...)`, `free(p)` (if p must be allocator-returned), `strlen(p)` (if p points to string).
  - Control-flow or code pointers: calling a function pointer or virtual dispatch through an uninitialized object pointer.
  - Comparison or arithmetic that influences security decisions: `if (p == something)` where p is uninitialized and affects a branch.
- Path sensitivity:
  - The key question is whether there exists any feasible path where the pointer remains uninitialized at the use site.

Where CWE-824 typically occurs (sensitive sinks)
- Conditional initialization:
  - Pointer assigned only in some branches; later used unconditionally.
- Error handling paths:
  - Early error branches skip initialization but still reach cleanup/use code.
- Complex control flow:
  - Multiple returns/gotos; loops where initialization depends on first iteration; switch statements missing cases.
- Out-parameters:
  - Functions expected to initialize pointer via output argument, but caller uses pointer even when function fails.
- Struct/heap objects:
  - Struct fields (pointer members) not initialized in all constructors/initialization routines.
- Stack variables in C:
  - Local pointers declared without initialization, then used due to logic oversight.

Common failure modes (reasoning hints, not assumptions)
- Missing default initialization:
  - Pointer not set to NULL on declaration; later checked or used.
- Incorrect error checking:
  - Caller ignores return code that indicates output pointer was not set.
- Partial initialization of aggregates:
  - Some struct fields set, others left indeterminate; later used.
- Loop-dependent initialization:
  - Pointer set inside loop body, but loop may not execute (zero iterations).
- Cleanup code uses pointer:
  - `free(p)`/`close(p)` in cleanup even if p was never initialized to a safe sentinel value.

What “safe initialization” looks like (context-specific)
- Initialize pointers to a known sentinel:
  - Set to `NULL`/`nullptr` at declaration or immediately after allocation of owning struct.
- Ensure initialization dominates use:
  - Prove that on every path reaching the use, the pointer has been assigned a valid value (or remains NULL and is handled safely).
- Respect API contracts for out-parameters:
  - Only use output pointers when the API indicates success; set outputs to NULL on failure.
- Use constructors/zeroing:
  - In C: `memset(&obj, 0, sizeof(obj))` when appropriate; in C++: constructors that initialize all members.
- Guard cleanup:
  - Cleanup should only act on pointers that are known-initialized and valid for that cleanup action.

Common weak/insufficient defenses (signals of possible risk)
- “It will be set later”:
  - Delayed initialization easily becomes path-dependent under error/edge cases.
- Checking an uninitialized pointer:
  - `if (p) ...` is unsafe if p is uninitialized; it does not reliably indicate validity.
- Relying on debug behavior:
  - Some environments fill stack memory with patterns; this masks bugs rather than proving safety.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Pointer is initialized at declaration (`T* p = NULL;`) or via constructor initialization.
  - Initialization occurs in all branches before any use; or use is guarded by success checks that guarantee initialization.
  - Out-parameter APIs: caller checks return status before using the output pointer; callee sets output to NULL on failure.
  - Cleanup guarded by `if (p != NULL)` where p is known-initialized to NULL initially.
- Evidence suggesting vulnerability:
  - Pointer declared without initialization and used (dereferenced/passed/free) along a path where assignment is not guaranteed.
  - Pointer assigned only in some conditional branches; later used outside the conditional without an else/default initialization.
  - Caller uses output pointer despite API failure; ignores return codes.
  - Struct pointer fields left uninitialized in some constructor/init function; later accessed.

How to use this guideline under incomplete context
- Identify pointer variables and fields:
  - Track local pointers, struct members, and outputs.
- Identify initialization sites:
  - Assignments, allocations, constructor init lists, zeroing routines.
- Identify use sites:
  - Dereferences, frees/closes, API calls requiring valid pointers, branch conditions influenced by pointer value.
- Analyze control-flow coverage:
  - Is there any feasible path from entry to use where initialization does not occur?
- Generate a small number of targeted hypotheses:
  - H1: Pointer is conditionally initialized, and there exists a path where it is used uninitialized.
  - H2: Out-parameter is used even when the callee indicates failure, leaving pointer uninitialized.
  - H3: Struct/aggregate member pointer is not initialized in all initialization routines/constructors.
  - H4: Pointer is initialized elsewhere (wrapper, constructor, guaranteed API contract) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., declaration + missing init + unconditional use),
  (b) evidence needed to confirm it (e.g., missing branches, callee guarantees, loop bounds),
  (c) counter-evidence that would refute it (e.g., default init to NULL, dominating assignment, checked return codes).

Quick red flags in partial code (weak → strong)
- Strong: Local pointer declared without initialization and later dereferenced/free/passed as valid without a dominating assignment.
- Medium: Pointer assigned only under a condition; later used outside; loops where initialization occurs inside but loop may not run.
- Medium: Using pointer truthiness checks (`if (p)`) where p could be uninitialized; ignoring out-parameter failure status.
- Weak: Initialization may be ensured by omitted constructors/wrappers or global invariants not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_824_RULE)
