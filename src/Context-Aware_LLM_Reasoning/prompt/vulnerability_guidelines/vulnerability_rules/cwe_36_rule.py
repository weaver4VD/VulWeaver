CWE_36_RULE = """
[CWE-36 Reference Guideline | Absolute Path Traversal | Non-binding, Evidence-first]

Overview
- CWE-36 occurs when a product uses external input to construct a pathname that is intended to stay within a restricted base directory, but it fails to properly neutralize absolute path sequences (e.g., "/abs/path"), allowing the resolved path to point outside the restricted directory.
- Unlike relative traversal-focused cases (e.g., ".."), CWE-36 emphasizes absolute-path forms that bypass base-directory joins.
- In partial snippets, missing validation evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “pathname input” in Java (typical sources)
- HTTP-derived values: query params, path variables, headers/cookies, multipart form fields (e.g., "file", "path", "name", "dir", "subpath").
- File/packaging metadata: uploaded filenames or archive entry names if treated as filesystem paths.
- Cross-component/user-influenced data: message payload fields, DB-stored “path/name” fields, config values only if attacker-controllable.

Security-sensitive path usages (typical sinks)
- File read/write/delete APIs: java.io.File, java.nio.file.Path/Paths/Files, FileInputStream/FileOutputStream, RandomAccessFile.
- Directory-based operations: listing directories, copying/moving files, creating directories under a base directory.
- “Serve/download” helpers that map user-controlled path to disk reads.

Typical bypass primitives (reasoning hints, not assumptions)
- Unix absolute paths: "/etc/passwd", "/var/...", leading "/" that causes Path.resolve to ignore the base.
- Windows absolute forms (if relevant to environment):
  - Drive-letter paths: "C:\\Windows\\...", "C:/Windows/..."
  - UNC paths: "\\\\server\\share\\..."
  - Rooted paths with separator quirks.
- Encoding/normalization tricks:
  - Encoded leading separators (e.g., "%2f"), double-encoding, Unicode normalization to produce separators.
- Confusion between URL path vs filesystem path where leading "/" is accepted.

What “proper neutralization/restriction” looks like (context-specific)
- Prefer allow-list mapping:
  - Accept an identifier (ID/key) and map to a fixed safe file/path within base; avoid user-supplied full paths.
- Constrain input format to disallow absolute forms:
  - Reject any input that is absolute or has absolute-path signatures (leading "/" or platform absolute indicators).
  - If only a filename is needed, reject separators entirely and enforce strict regex/enum constraints.
- Normalize/canonicalize before enforcing containment:
  - Construct candidate path via Path.resolve(base, userPart) and then normalize/canonicalize.
  - Enforce containment: resolved/canonical candidate must remain within resolved/canonical base directory.
- Explicitly handle platform-specific absolute-path forms:
  - If the product runs on multiple OSes, ensure checks cover both POSIX and Windows absolute path patterns.

Common weak/insufficient defenses (signals of possible risk)
- Assuming baseDir + userInput is safe:
  - Path.resolve(base, userInput) can drop the base when userInput is absolute.
- Only filtering traversal segments ("..") but not rejecting absolute paths:
  - Neutralizing ".." does not stop "/abs/path".
- Raw string prefix checks without canonicalization:
  - candidate.startsWith(baseDir) on raw strings is bypassable (encodings, separators, normalization).
- Validating one representation but using another:
  - Validate raw input, then decode/normalize later, introducing absolute separators.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Input is an allow-listed ID mapped to a fixed internal path.
  - Explicit rejection of absolute paths (e.g., checks equivalent to “isAbsolute” / leading separator / drive letter / UNC) before path join or file access.
  - In-flow containment enforcement after normalization/canonicalization:
    - baseCanonical = base.toRealPath()/canonical
    - candidate = base.resolve(userPart).normalize()/toRealPath
    - verify candidate starts with baseCanonical (Path-based containment)
- Evidence suggesting vulnerability:
  - External input is used as a path argument to file APIs directly (or joined to base without absolute-path checks), and no robust containment/allow-list barrier appears in the same dataflow.
  - Protection focuses on ".." or substring filtering but does not address absolute-path forms.

How to use this guideline under incomplete context
- Generate a small number of targeted hypotheses based on observed sink + path construction pattern:
  - H1: The user-controlled input can be absolute (leading "/" or platform equivalent), bypassing the restricted directory.
  - H2: The code performs base join but fails to detect absolute paths, so the base is ignored by resolution.
  - H3: A robust absolute-path rejection and containment check exists upstream (filter/interceptor/helper), but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (e.g., baseDir origin, decoding stage, whether isAbsolute checks exist, canonicalization logic),
  (c) counter-evidence that would refute it (e.g., in-flow absolute-path rejection + canonical containment check).

Quick red flags in partial code (weak → strong)
- Strong: userInput passed as a path/file argument (or resolved against base) followed by file access, with no absolute-path rejection and no normalize/canonicalize + containment.
- Medium: defenses only mention ".." or "../" but do not address leading "/" or platform absolute forms.
- Medium: string startsWith(baseDir) checks without canonicalization/normalization.
- Weak: key validation likely occurs outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_36_RULE)