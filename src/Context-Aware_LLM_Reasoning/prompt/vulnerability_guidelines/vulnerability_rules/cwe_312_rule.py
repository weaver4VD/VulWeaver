CWE_312_RULE = """
[CWE-312 Reference Guideline | Cleartext Storage of Sensitive Information | Non-binding, Evidence-first]

Overview
- CWE-312 occurs when the product stores sensitive information in cleartext within a resource that might be accessible to another control sphere (i.e., a broader or less-trusted set of actors/systems than intended).
- Cleartext storage increases the blast radius of a compromise: if the storage medium is read (by an attacker, a misconfigured permission, an insider, or another service), the sensitive values are immediately usable.
- In partial snippets, seeing a “save/write” is not proof of cleartext storage. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “cleartext storage” (static analysis framing)
- Sensitive information:
  - Credentials/passwords, API keys, tokens/session identifiers, private keys, secrets, recovery codes, PII, financial identifiers, or other data requiring confidentiality.
- Cleartext:
  - Stored without cryptographic protection appropriate for the threat model (no encryption at rest, no hashing where required, no key protection), or stored in trivially reversible form (e.g., base64 encoding is not protection).
- Resource accessible to another control sphere:
  - DB tables, files, caches, shared storage, configuration files, crash dumps, temp files, backups, analytics logs, or any medium that could be read by unauthorized actors due to access controls, misconfiguration, or lateral movement.

Where cleartext storage typically occurs (sensitive sinks)
- Databases and ORM persistence:
  - Saving entities/fields that contain secrets/PII directly.
- Configuration and property files:
  - Storing credentials/keys in plaintext config files, environment dumps, or checked-in defaults.
- Caches and session stores:
  - Persisting tokens or credentials directly in cache entries accessible across services.
- Files and exports:
  - Writing secrets/PII to local files, temp files, backups, reports, or attachments.
- Client-side persistence:
  - Persisting secrets in local storage, cookies (if not appropriately protected), or downloadable artifacts.

Common failure modes (reasoning hints, not assumptions)
- Storing raw secrets:
  - Writing password/token/API key directly to a DB/file with no protection.
- Confusing encoding with encryption:
  - Base64/URL encoding/hex encoding used and treated as “secured”.
- Using reversible “encryption” without key protection:
  - Hard-coded keys, keys stored alongside ciphertext, or insecure key derivation.
- Wrong protection primitive:
  - Encrypting passwords instead of hashing (for authentication secrets), or hashing when reversible retrieval is required.
- Over-broad storage scope:
  - Storing secrets in places not needed for function (e.g., caching full auth objects).

What “appropriate protection” looks like (context-specific)
- For passwords:
  - Store only strong one-way password hashes with a per-password salt (never cleartext or reversible encryption).
- For tokens/keys/PII requiring retrieval:
  - Use encryption at rest with proper key management (keys not hard-coded; access-controlled; rotation considerations).
- Data minimization:
  - Store only what’s necessary; avoid persisting secrets in multiple redundant stores.
- Separation of duties:
  - Store encrypted values in DB; store keys in a dedicated secret manager/HSM/KMS or equivalent trusted store.
- Access boundary awareness:
  - Assume storage may be read in breach scenarios; protect sensitive fields even if DB is “internal”.

Common weak/insufficient defenses (signals of possible risk)
- “DB is private” assumption:
  - Internal DB access can still be compromised; cleartext amplifies impact.
- Masking at display time only:
  - Hiding secrets in UI does not protect at rest.
- Hard-coded secrets or keys:
  - “Encrypting” with a constant key in code can collapse security.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Passwords passed through strong hashing function before persistence; raw password never stored.
  - Encryption applied to sensitive fields before writing, with clear separation of key retrieval (not inline hard-coded).
  - DTO mapping that excludes secrets from persisted artifacts where not needed.
  - Clear “secret handling” utilities that wrap storage operations for sensitive fields.
- Evidence suggesting vulnerability:
  - Direct persistence of sensitive fields (e.g., `entity.setPassword(raw)` then `save(entity)`).
  - Writing tokens/keys/PII to files/caches/DB without any encryption/hashing step.
  - Use of base64/encoding as if it were protection.
  - Storing secrets in broadly accessible resources (shared cache, temp files) with no protection.

How to use this guideline under incomplete context
- Identify candidate sensitive values:
  - Variables/fields that look like credentials/tokens/keys/PII; sources from auth flows, config, request headers, secret stores.
- Identify storage sinks:
  - DB writes, file writes, cache puts, serialization to persistent artifacts.
- Generate a small number of targeted hypotheses:
  - H1: Sensitive data is stored directly (cleartext) in DB/files/caches.
  - H2: Data is “obfuscated” (encoded) but still effectively cleartext.
  - H3: Encryption is attempted but key handling is insecure (hard-coded or co-located), weakening protection.
  - H4: Protection is enforced elsewhere (ORM converters, encryption interceptors, secret manager integration) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., raw secret passed to `save`/`write`),
  (b) evidence needed to confirm it (e.g., field-level converters, encryption wrappers, key source),
  (c) counter-evidence that would refute it (e.g., hashing/encryption performed before sink with trusted key handling).

Quick red flags in partial code (weak → strong)
- Strong: Raw credentials/tokens/keys written to DB/file/cache with no protective transform.
- Medium: Base64/hex encoding used as “security”; reversible transforms treated as encryption.
- Medium: “Encryption” with hard-coded key or key stored alongside ciphertext.
- Weak: Field-level encryption/hashing may be implemented in omitted layers (ORM annotations/converters/interceptors) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_312_RULE)
