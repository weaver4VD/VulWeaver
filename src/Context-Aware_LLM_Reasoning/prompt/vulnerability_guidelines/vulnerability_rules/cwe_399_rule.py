CWE_399_RULE = """
[CWE-399 Reference Guideline | Resource Management Errors (Category) | Non-binding, Evidence-first]

Overview
- CWE-399 is a category covering weaknesses related to improper management of system resources (e.g., memory, file descriptors, sockets, threads, locks, database connections, temporary files, GPU handles).
- Resource management errors can lead to denial of service (resource exhaustion), degraded availability/performance, deadlocks, data corruption, or security boundary breaks when privileged resources are mismanaged.
- In partial snippets, seeing an allocation/open/acquire call is not proof of a CWE-399 issue. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “resource management error” (static analysis framing)
- Resource:
  - A finite object provided/managed by the OS/runtime/library that requires correct lifecycle handling:
    - Acquire/allocate/open → use → release/close/free.
- Management error:
  - Missing release, double release, releasing wrong resource, failing to handle exceptional paths, leaking across iterations/requests, failing to bound the number/size of resources, or incorrect concurrency control around resources.
- Category nature:
  - CWE-399 is broad; specific findings typically map to more specific CWEs (e.g., CWE-401 leak, CWE-772 missing release, CWE-770 lack of limits, CWE-833 deadlock). Use this guideline to guide static inspection rather than force a single label.

Where resource management errors typically occur (sensitive sinks)
- Acquisition APIs:
  - `malloc/new`, `fopen/open`, socket/connect, DB connection checkout, lock acquire, thread creation, handle creation, temp file/dir creation.
- Release APIs:
  - `free/delete`, `fclose/close`, socket close, DB connection return, unlock, join/detach semantics, handle disposal.
- Error handling boundaries:
  - Early returns, exception paths, `goto` cleanup blocks, callbacks, asynchronous continuations.
- Loop/request boundaries:
  - Per-iteration/per-request acquisitions without guaranteed release; unbounded caches/queues.
- Ownership transfers:
  - Passing resources across layers without clear ownership; reference counting mismanagement.

Common failure modes (reasoning hints, not assumptions)
- Missing release on some paths:
  - Early return, error branch, exception/callback path forgets to close/free/unlock.
- Double release / use-after-release patterns:
  - Two owners both close/free; or resource freed then reused.
- Wrong resource released:
  - Closing wrong fd/handle; freeing pointer not returned by allocator.
- Unbounded resource growth:
  - Creating threads/objects/handles per input/request without limits; unbounded queue/cache.
- Mis-scoped locks:
  - Lock acquired but not released on all paths; lock ordering issues that lead to deadlocks.
- Leaking across retries:
  - Reconnect/retry loops that allocate new resources without cleaning old ones.

What “robust resource management” looks like (context-specific)
- Clear ownership and lifecycle:
  - One owner responsible for release; ownership transfer is explicit.
- Structured cleanup:
  - RAII/smart pointers (C++), `defer`-like patterns, or centralized cleanup blocks (`goto cleanup`) in C.
- Fail-closed and cleanup on error:
  - On any failure, ensure all acquired resources up to that point are released.
- Bounds and quotas:
  - Enforce maximum counts/sizes for caches, thread pools, connection pools, and per-request allocations.
- Idempotent / safe release patterns:
  - Nulling pointers after free, setting fds to invalid, guarding against double close.

Common weak/insufficient defenses (signals of possible risk)
- Cleanup only on “happy path”:
  - Release calls at end of function but missing in intermediate error returns.
- Ad-hoc ownership:
  - Multiple layers “sometimes” close; unclear contract.
- Relying on process exit:
  - Assuming OS cleanup at exit is acceptable for long-running servers.
- Superficial bounds:
  - Checking one dimension (count) but not size/time; or bounds not enforced under concurrency.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - For each acquire/open/lock, a guaranteed corresponding release/close/unlock on all control paths.
  - Centralized cleanup label (`cleanup:`) in C, or RAII in C++ (`unique_ptr`, `shared_ptr`, lock guards).
  - Pooling constructs (thread pools, connection pools) with bounded capacity and correct return semantics.
  - Explicit limits on resource creation based on input (max file size, max connections, max tasks queued).
- Evidence suggesting vulnerability:
  - Acquire without visible release in reachable paths (especially in loops or request handlers).
  - Multiple potential owners calling release; lack of clear ownership transfer.
  - Resource allocated per user-controlled input without caps (e.g., spawn thread per request).
  - Locks acquired with multiple returns/throws without guard/unlock.
  - Retry/loop logic that allocates new resource each iteration without releasing prior ones.

How to use this guideline under incomplete context
- Inventory resources in the snippet:
  - Identify each acquire/open/lock/create and its corresponding release/close/unlock.
- Map control-flow paths:
  - Consider early returns, error codes, exceptions, callbacks, and loop iterations.
- Generate a small number of targeted hypotheses:
  - H1: A resource is acquired but not released on some error/early-return path (leak).
  - H2: Resource growth is unbounded with input/request/loop iterations (exhaustion risk).
  - H3: Ownership is unclear, enabling double release or use-after-release in some paths.
  - H4: Cleanup/limits are enforced elsewhere (wrappers, RAII classes, pool managers) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., acquire + missing cleanup on branch),
  (b) evidence needed to confirm it (e.g., caller lifecycle, wrapper semantics, loop bounds),
  (c) counter-evidence that would refute it (e.g., RAII wrapper, centralized cleanup block, pool with strict caps).

Quick red flags in partial code (weak → strong)
- Strong: Acquire/open/lock inside a loop or request path with no visible guaranteed release; or spawning resources per input with no cap.
- Medium: Multiple returns/throws after acquire with no guard; unclear ownership transfer across layers.
- Medium: Unbounded queues/caches/collections storing per-request resources without eviction/limits.
- Weak: Resource lifecycle may be handled by omitted wrappers/RAII/pools not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_399_RULE)
