CWE_755_RULE = """
[CWE-755 Reference Guideline | Improper Handling of Exceptional Conditions | Non-binding, Evidence-first]

Overview
- CWE-755 occurs when the product does not handle, or incorrectly handles, an exceptional condition (errors, failures, unexpected situations).
- Poor handling can cause crashes, inconsistent state, resource leaks, security bypass (fail-open), or other unintended behavior—especially when attackers can intentionally trigger exceptional paths.
- In partial snippets, missing a check is not automatically CWE-755: handling may occur in wrappers, callers, or framework layers. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “exceptional conditions” (static analysis framing)
- Exceptional condition:
  - Any deviation from the expected happy path, including:
    - API failures: NULL returns, negative/error codes, status objects indicating failure.
    - Exceptions (language/runtime/library), `throw`/`catch`, `panic`/`abort`-like conditions.
    - I/O anomalies: partial reads/writes, timeouts, EOF, connection resets.
    - Resource exhaustion: OOM, fd limits, pool depletion, quota breaches.
    - Invalid/malformed inputs: parse failures, unexpected formats/encodings.
    - Unexpected states: state machine violations, missing prerequisites, concurrency cancellations.
- Improper handling:
  - Not checking, checking wrong condition, swallowing exceptions, proceeding with partial/invalid state, unsafe defaults, missing cleanup/rollback, or inconsistent handling across call sites.

Where CWE-755 typically occurs (sensitive sinks)
- Return-value boundaries:
  - Calls where failure is signaled via return codes/NULL/errno/status.
- Exception boundaries:
  - Try/catch blocks, callbacks, destructors/finalizers, thread entry points.
- Security-critical decision points:
  - AuthN/AuthZ, input validation, deserialization/parsing, policy enforcement, request routing.
- Multi-step updates:
  - Sequences requiring atomicity (update A then B); failures in the middle require rollback/compensation.
- Resource lifecycle:
  - Allocation/open/lock acquisition and cleanup on all early exits.
- Network/protocol handlers:
  - Handling malformed messages and desync conditions.

Common failure modes (reasoning hints, not assumptions)
- Unchecked failures:
  - Ignoring return codes or assuming non-NULL results.
- Swallowed exceptions:
  - `catch (...) {}` or broad catch that continues as if success occurred.
- Fail-open fallbacks:
  - On error, defaulting to “allow”, “skip validation”, “use default credential”, “disable checks”.
- Partial state continuation:
  - Proceeding after an error with partially initialized objects or incomplete data.
- Missing cleanup/rollback:
  - Resources leaked or locks held on exceptional exits; inconsistent state persists.
- Inconsistent handling:
  - Some paths handle errors correctly, others don’t; rare path becomes exploitable.

What “robust exceptional-condition handling” looks like (context-specific)
- Check and enforce error signals:
  - Validate return values/status; stop or safely recover on failure.
- Fail closed for security:
  - When uncertain due to errors, deny/reject rather than allow.
- Preserve invariants:
  - Use rollback/compensation or transactional patterns for multi-step operations.
- Structured cleanup:
  - Ensure cleanup runs on all exits (RAII, finally blocks, centralized cleanup labels).
- Explicitly handle partial I/O:
  - Loop until completion or hard failure; validate lengths and boundaries.

Common weak/insufficient defenses (signals of possible risk)
- Logging-only handling:
  - Detecting error but proceeding with unsafe state.
- “Best effort” parsing:
  - Accepting malformed inputs and trying to guess intent.
- Catch-all with permissive continuation:
  - Broad catch that returns success or continues into sensitive operations.
- Error masking:
  - Converting errors to default values that pass checks (e.g., parse fail → 0).

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Return codes/NULL/status checked immediately, with safe early return or controlled recovery.
  - Exceptions caught narrowly and handled safely; critical exceptions propagate or trigger safe failure.
  - Cleanup/rollback logic covers all branches/throws (RAII/finally/cleanup blocks).
  - Security checks are fail-closed on error (deny access when auth/validation fails or is indeterminate).
  - Defensive handling of partial reads/writes and malformed input.
- Evidence suggesting vulnerability:
  - Failure-prone calls used without checking results; dereferences after potential failure.
  - Broad catch blocks that swallow exceptions and continue or return “success”.
  - Sensitive operations executed even after errors; error flags ignored.
  - Multi-step operations without rollback on intermediate failures.
  - Missing cleanup on early returns/exceptions leading to leaks/locks held.

How to use this guideline under incomplete context
- Identify exceptional-condition sources:
  - APIs that can fail, parsing operations, I/O, allocations, concurrency primitives, external dependencies.
- Determine failure signaling:
  - Return values, status objects, exceptions, sentinel values.
- Check whether handling dominates sensitive uses:
  - Ensure checks are correct and cover all control-flow paths to sinks.
- Generate a small number of targeted hypotheses:
  - H1: Exceptional condition is not checked/handled, causing unsafe continuation (crash/state corruption).
  - H2: Error handling is fail-open, enabling security bypass under attacker-triggered failures.
  - H3: Partial failure leaves inconsistent state due to missing rollback/cleanup.
  - H4: Handling is centralized elsewhere (wrappers/framework interceptors) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unchecked return, swallowed exception, unsafe default),
  (b) evidence needed to confirm it (e.g., API semantics, wrapper behavior, upstream guarantees),
  (c) counter-evidence that would refute it (e.g., dominating guards, fail-closed logic, rollback/cleanup).

Quick red flags in partial code (weak → strong)
- Strong: Unchecked failures or swallowed exceptions followed by sensitive operations; defaulting to permissive behavior on error.
- Medium: Cleanup/rollback missing on exceptional exits; error flags set but ignored; partial I/O treated as complete.
- Medium: Broad catch blocks that hide failures and continue with partially initialized or attacker-influenced state.
- Weak: Exceptional handling may be enforced by omitted wrappers/framework layers; API failure semantics not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_755_RULE)
