CWE_281_RULE = """
[CWE-281 Reference Guideline | Improper Preservation of Permissions | Non-binding, Evidence-first]

Overview
- CWE-281 occurs when a product copies, restores, clones, or shares an object/resource but fails to preserve the intended permissions (or preserves them incorrectly), resulting in permissions that are less restrictive than required.
- This often appears in workflows that duplicate resources (files, records, projects), restore from backups/snapshots, export/import, or “share with others”, where ACLs/ownership/labels are not carried over or are reset to permissive defaults.
- In partial snippets, missing permission-preservation evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “objects” and “permissions” (static analysis framing)
- Objects/resources:
  - filesystem objects (files/directories), blobs, artifacts, attachments
  - application objects (documents, projects, dashboards, reports, tickets, datasets)
  - configuration objects (settings, policies, secrets containers)
- Permissions/metadata that may need preservation:
  - filesystem mode bits, ACLs, ownership/group, security labels
  - application ACLs: owners, editors/viewers, role bindings, tenant/project scoping, sharing links
  - inheritance flags: whether child objects inherit parent permissions

Operations where preservation matters (typical sinks / workflows)
- Copy/clone/duplicate:
  - copy file/dir, duplicate record, fork project, clone template
- Restore/recover:
  - restore from backup, import/export, rollback versions, unpack archives
- Share/publish:
  - generate share links, publish artifacts, move resources into shared/public areas
- Migration/synchronization:
  - sync resources between systems, move across tenants/projects, replication jobs

Typical failure modes (reasoning hints, not assumptions)
- Default-permissive on copy/restore:
  - new object created with “public”/world-readable permissions, or overly broad ACLs
- Dropped ACL/ownership:
  - content copied but ACLs/ownership not copied; ownership resets to system/admin
- Broken inheritance:
  - child objects fail to inherit restrictive parent permissions, becoming accessible
- Confused scope:
  - object moved across tenants/projects without updating ACLs consistently
- Partial preservation:
  - read permission preserved but write/admin permissions misapplied; share links created without respecting original restrictions

What “proper preservation” looks like (context-specific)
- Preserve or correctly re-derive permissions:
  - Carry over ACL/ownership/labels from source to destination when semantics require it.
  - If destination context differs (new tenant/project), map permissions conservatively (deny-by-default) and require explicit re-grant.
- Preserve restrictive invariants:
  - Ensure copied/restored object is not more accessible than the source unless explicitly intended.
- Atomicity and ordering:
  - Create the object in a non-public/locked-down state, then apply correct ACLs before exposing it via listing/sharing/download.
- Consistent inheritance logic:
  - If the model uses inherited permissions, ensure new objects are attached to the right parent scope and inheritance flags are preserved.

Common weak/insufficient defenses (signals of possible risk)
- Relying on system defaults for permissions on new objects:
  - creating copies without explicitly setting ACLs/ownership can lead to permissive defaults
- “Copy content only” implementations:
  - copying bytes/data fields but not copying associated ACL/metadata
- Applying permissions after exposure:
  - object becomes accessible briefly before ACL is applied (TOCTOU-style window)
- Using caller’s privileges incorrectly:
  - copy/restore performed by privileged service account that assigns broad access unintentionally

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit permission/ACL copy or conservative permission assignment during copy/restore/share workflows.
  - Source permission retrieval and destination permission application are clearly linked.
  - Destination visibility is gated until permissions are set (no premature publish/share).
  - Unit/metadata copy includes ownership/tenant scope and inheritance configuration.
- Evidence suggesting vulnerability:
  - Copy/restore creates destination object without any explicit ACL/ownership handling.
  - Code sets destination permissions to permissive defaults (e.g., public/read-all) without clear justification.
  - Share/publish logic bypasses original object’s access restrictions.
  - Metadata copy omits ACL fields or resets them.

How to use this guideline under incomplete context
- Identify the operation type and exposure boundary:
  - Is the code copying/restoring/sharing, and when does the new object become accessible?
- Identify the permission model:
  - filesystem permissions vs application ACLs vs role/tenant scoping; what should be preserved?
- Generate a small number of targeted hypotheses:
  - H1: Permissions/ACLs are not copied, so the new object uses permissive defaults.
  - H2: Permissions are copied but mapped incorrectly (wrong owner/tenant/scope/inheritance).
  - H3: Permissions are applied after the object becomes externally accessible.
  - H4: Permission preservation is implemented in helper layers not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (object creation/copy + missing ACL handling),
  (b) evidence needed to confirm it (ACL schema, default permission settings, exposure points),
  (c) counter-evidence that would refute it (explicit ACL transfer/conservative assignment before exposure).

Quick red flags in partial code (weak → strong)
- Strong: copy/restore/share creates new resource and exposes it without explicit permission preservation or conservative ACL assignment.
- Medium: ACL fields/ownership/tenant scope are omitted during duplication or reset to broad access.
- Medium: publish/share-link generation ignores source object’s restrictions.
- Weak: permission handling may be centralized in helpers/interceptors not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_281_RULE)
