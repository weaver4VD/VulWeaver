CWE_193_RULE = """
[CWE-193 Reference Guideline | Off-by-one Error | Non-binding, Evidence-first]

Overview
- CWE-193 occurs when a product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.
- Off-by-one errors often surface at boundaries (0, last index, length, capacity) and can lead to out-of-bounds read/write, incorrect authorization/validation decisions, logic bypass, or crashes.
- In partial snippets, missing boundary checks are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as an "off-by-one error" (static analysis framing)
- Off-by-one error:
  - A boundary condition mistake where code includes/excludes one extra element, byte, iteration, or unit.
  - Common forms:
    - Using `<=` instead of `<` (or vice versa) for upper bounds.
    - Using `>=` instead of `>` (or vice versa) for lower bounds.
    - Miscomputing lengths for terminators (e.g., NUL) or separators.
    - Misaligned inclusive/exclusive range conventions (start/end indices).
- Security-relevant pattern:
  - The “+1/-1” mistake reaches a sink: indexing, copying, allocation, slicing, loop bounds, or policy checks.

Where off-by-one issues typically occur (sensitive sinks)
- Buffer and array indexing:
  - Accessing `buf[len]` instead of `buf[len-1]`, or allowing `idx == size`.
- Copying and concatenation:
  - Copying `n+1` bytes into `n`-sized buffer, or forgetting space for terminator.
- Loop bounds:
  - Iterating `i <= n` when valid indices are `[0, n-1]`, or iterating one too few (skipping validation).
- Range checks and validation:
  - Accepting `value == maxAllowed+1` or rejecting `value == minAllowed` incorrectly.
- Parsing and slicing:
  - `end = start + len` used as inclusive when it should be exclusive (or vice versa).

Common failure modes (reasoning hints, not assumptions)
- Confusing length vs last index:
  - Treating `len` as the last valid index (it’s usually one past the last index).
- Inclusive/exclusive mismatch:
  - One function interprets `end` as inclusive, another as exclusive.
- Terminator accounting:
  - Forgetting `+1` for string terminator, or adding it twice.
- Fencepost errors in loops:
  - Incorrect initialization or termination conditions (`i = 1` vs `0`, `i < n` vs `i <= n-1`).
- Boundary checks on derived values:
  - Checking `idx <= size` then using `buf[idx]`.

What “correct boundary discipline” looks like (context-specific)
- Clear conventions:
  - Use consistent range semantics: `[start, end)` (end exclusive) is common and reduces ambiguity.
- Validate at the use site:
  - Bounds checks adjacent to indexing/copying: `0 <= idx && idx < size`.
- Explicit handling of terminators:
  - When copying strings, allocate/copy with space for terminator exactly once.
- Prefer safer APIs:
  - Use APIs that take buffer sizes and return required sizes; avoid manual `+1/-1` arithmetic when possible.
- Keep units consistent:
  - Ensure comparisons use the same unit (bytes vs elements, chars vs bytes).

Common weak/insufficient defenses (signals of possible risk)
- “Looks right” checks:
  - `if (idx <= size)` without realizing `idx == size` is invalid for indexing.
- Scattered checks:
  - Checking `idx` in one place, then adjusting it (`idx+1`, `idx-1`) before use without re-checking.
- Mixed signedness:
  - Negative indices plus `-1/+1` adjustments with implicit conversions.
- Reliance on sentinel presence:
  - Looping until delimiter without capping at length can interact with off-by-one at boundary.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Consistent use of `< size` for upper bound and `>= 0` for lower bound at read/write sites.
  - Clear `[start, end)` slicing with explicit `end <= size`.
  - Correct terminator handling (allocate `len+1`, write terminator once, copy at most `len` payload bytes).
  - Tests or assertions that enforce boundary invariants (e.g., `assert(idx < size)` before access).
- Evidence suggesting vulnerability:
  - Comparisons using `<=` where indexing/copying requires `<`.
  - Access patterns `buf[len]`, `arr[count]`, `memcpy(dst, src, len+1)` into `len`-sized region.
  - Loop conditions `i <= len` used with `buf[i]`.
  - Range checks performed on one variable but a different derived variable is used (`end = start + len`, then use `end` as inclusive).

How to use this guideline under incomplete context
- Identify boundary variables:
  - `len`, `size`, `capacity`, `count`, `end`, `max`, `min`, `idx`, `offset`.
- Identify the sink:
  - Does the boundary feed into indexing, copy size, allocation, loop bound, or validation decision?
- Generate a small number of targeted hypotheses:
  - H1: Upper-bound check is inclusive (`<=`) but used for indexing/copying that requires exclusive (`<`).
  - H2: Length/terminator accounting is wrong by 1, causing overwrite or missing terminator.
  - H3: Slice/range end semantics are mixed (inclusive vs exclusive), enabling OOB or skipped checks.
  - H4: Boundary correctness is enforced elsewhere (helper validators / safe APIs) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., `<=`, `len+1`, `buf[len]`),
  (b) evidence needed to confirm it (e.g., actual buffer sizes, invariants, helper implementations),
  (c) counter-evidence that would refute it (e.g., consistent `[start,end)` usage, adjacent `idx < size` checks).

Quick red flags in partial code (weak → strong)
- Strong: Using `<= size` then indexing with that value, or copying `len+1` bytes into a `len`-sized buffer.
- Medium: Mixed inclusive/exclusive range usage across functions (end sometimes inclusive).
- Medium: Adjusting indices (`+1/-1`) after checks without re-validating.
- Weak: Boundaries may be validated in omitted code or via safe wrappers not visible → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_193_RULE)
