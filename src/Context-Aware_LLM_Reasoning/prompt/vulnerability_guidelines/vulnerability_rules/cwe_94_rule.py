CWE_94_RULE = """
[CWE-94 Reference Guideline | Code Injection | Non-binding, Evidence-first]

Overview
- CWE-94 (Code Injection) occurs when a product constructs all or part of executable code using externally-influenced input, and fails to correctly neutralize elements that can alter code syntax/semantics, leading to unintended execution of attacker-controlled code.
- The downstream “interpreter” can be a script engine, expression evaluator, template engine with executable directives, dynamic compilation, runtime bytecode generation/loading, or any subsystem that executes constructed code.
- In partial snippets, missing neutralization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “externally-influenced input” (typical sources)
- HTTP-derived data: parameters, headers, cookies, path variables, request bodies.
- Persisted user content: DB-stored fields later used to build/evaluate code or expressions.
- Cross-component payloads: message/RPC fields only if attacker-controllable in context.
- File-based sources: uploaded scripts/templates/configs that are later executed or loaded.

Downstream code execution sinks (typical in Java)
- Script engines / eval-like APIs:
  - javax.script.ScriptEngine#eval(...)
  - Nashorn/GraalJS/Rhino integrations (if present)
- Expression language evaluators (often used in frameworks):
  - Spring Expression Language (SpEL), OGNL, MVEL, JEXL, JXPath, GroovyShell, etc. (depending on imports)
- Template engines that can execute logic:
  - Freemarker/Velocity/Thymeleaf (when configured for unescaped or executable directives)
- Dynamic compilation / class loading:
  - JavaCompiler API (javax.tools), Groovy compilation, Janino
  - ClassLoader#defineClass, URLClassLoader loading attacker-influenced locations, bytecode frameworks
- Reflection-based dispatch that evaluates user-controlled method/field names is usually a separate concern, but can become CWE-94 if it enables executing attacker-chosen code paths with attacker-crafted code-like payloads.

Core risk mechanism (what “special elements” means here)
- Special elements are tokens/constructs that the downstream executor interprets as code syntax:
  - quotes, parentheses, operators, delimiters, keywords, interpolation markers, method calls, property accessors, import/include directives, etc.
- Injection occurs when attacker input is placed into a code context (not just a data string) such that it can:
  - break out of a literal/context boundary, or
  - introduce new expressions/statements, or
  - redirect evaluation to attacker-chosen functions/objects.

What “proper neutralization/restriction” looks like (context-specific)
- Prefer eliminating dynamic code generation:
  - Avoid building executable code from untrusted strings; use fixed logic with safe parameters.
- Use safe-by-construction alternatives:
  - If a rule/expression must be user-defined, restrict to a non-Turing-complete DSL with strict parsing and allow-list semantics.
  - Use interpreters that support safe bindings (data variables passed separately) rather than concatenating into code strings.
- Constrain and isolate user input:
  - Treat user input as data-only values, never as code fragments.
  - Enforce strict allow-lists for any input that selects operations (e.g., enum of allowed functions/operators).
- If templating/expression evaluation is required:
  - Ensure user input is only inserted into data slots that are escaped/encoded appropriately for that engine, and do not allow executable directives/macros from user input.

Common weak/insufficient defenses (signals of possible risk)
- String concatenation/interpolation to form code:
  - "return " + userInput, "eval(" + userInput + ")", dynamic script templates.
- Blacklist filtering:
  - Removing a few keywords or characters is bypassable in most languages/engines.
- Wrong-context escaping:
  - HTML escaping does not prevent code injection into a script/expression engine.
- Validate-then-transform pitfalls:
  - Validate raw input, then decode/normalize/replace later, producing executable tokens.
- Trusting “safe mode” without evidence:
  - Assuming the engine sandbox is enabled or restrictive without visible configuration in snippet.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - No dynamic eval/compile; execution is via fixed code paths with data parameters.
  - User input is parsed by a strict grammar/DSL with allow-list constructs and is never concatenated into executable source.
  - Expression evaluation uses variable bindings (data passed separately) and restricts accessible methods/classes.
  - Clear allow-list mapping for any user-controlled selector of operations/functions.
- Evidence suggesting vulnerability:
  - Externally influenced input flows into eval/execute/compile APIs (ScriptEngine.eval, GroovyShell.evaluate, JavaCompiler, Janino, etc.).
  - User input is concatenated into script/expression/template directives that are executed.
  - The system loads/defines classes or bytecode from attacker-influenced sources without strict constraints.

How to use this guideline under incomplete context
- Identify the downstream executor category implied by imports and APIs:
  - script engine, expression language, template engine, dynamic compilation, class loading.
- Generate a small number of targeted hypotheses based on observed construction pattern:
  - H1: User input can be interpreted as code by an eval/engine/templating subsystem.
  - H2: “Sanitization” exists but is blacklist-like or context-mismatched for the target language/engine.
  - H3: Strong sandboxing/allow-list binding exists elsewhere but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (string building + eval/compile calls),
  (b) evidence needed to confirm it (engine type, accessible objects/classes, sandbox config, whether bindings are used),
  (c) counter-evidence that would refute it (no eval/compile, strict DSL parser, allow-list bindings, restricted engine config).

Quick red flags in partial code (weak → strong)
- Strong: request-derived/persisted user data concatenated into strings passed to eval/execute/compile APIs.
- Medium: presence of “sanitize/strip keywords” style filtering around code strings.
- Medium: decoding/normalization occurs after validation and before evaluation/compilation.
- Weak: safety controls may exist in helpers/config not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_94_RULE)
