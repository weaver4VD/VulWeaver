CWE_122_RULE = """
[CWE-122 Reference Guideline | Heap-based Buffer Overflow | Non-binding, Evidence-first]

Overview
- CWE-122 occurs when a buffer overflow condition allows a buffer allocated in the heap portion of memory to be overwritten. This typically happens when the buffer is allocated dynamically, using routines such as `malloc()` or `calloc()`.
- A heap-based buffer overflow can lead to data corruption, crashes, or arbitrary code execution, as attackers can exploit the overflow to overwrite critical data structures or control flow areas on the heap.
- In partial snippets, missing or incorrect heap buffer handling is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "heap-based buffer overflow" (static analysis framing)
- Heap-based Buffer Overflow:
  - A buffer overflow condition in which data is written past the allocated boundary of a buffer in the heap memory area, potentially allowing for the modification of adjacent memory, such as control data or other critical structures.
  - Typically caused by failing to validate the size of the input data before copying it into a dynamically allocated buffer, resulting in memory corruption or vulnerability to code execution.
- Heap Memory:
  - Memory that is dynamically allocated using functions such as `malloc()`, `calloc()`, `realloc()`, or through `new` in languages like C and C++.
  - Unlike stack memory, which is managed automatically, heap memory is explicitly allocated and freed by the program, and overflow conditions can lead to more serious vulnerabilities due to the nature of memory management in the heap.

Where heap buffer overflow issues typically occur (sensitive sinks)
- Memory allocation:
  - Buffers are allocated dynamically in heap memory using functions like `malloc()` or `calloc()` without properly validating that the allocated buffer size is sufficient for the data to be written.
- Buffer copying and string handling:
  - Using unsafe memory functions like `strcpy()`, `memcpy()`, or `sprintf()` to copy data into heap buffers without checking the size of the data being copied.
- Input handling:
  - Taking input from untrusted sources (e.g., user input, network data) and copying it into dynamically allocated heap buffers without ensuring the data fits within the allocated space.
- Data processing:
  - Processing large datasets in memory without validating that the amount of data matches the allocated buffer size, leading to overflows.

Common failure modes (reasoning hints, not assumptions)
- Missing bounds checks:
  - The product copies data into a heap-allocated buffer without verifying that the data fits within the allocated memory, resulting in a buffer overflow.
- Unsafe use of memory functions:
  - Functions like `strcpy()`, `memcpy()`, `sprintf()` are used to copy data into heap buffers without checking the size, allowing overflows to occur.
- Insufficient input validation:
  - User input, external data, or untrusted sources are copied directly into heap-allocated buffers without validating the size or range of the input data.
- Overwritten heap data structures:
  - The heap buffer overflow condition is exploited to overwrite adjacent memory areas, leading to corruption of critical heap structures or arbitrary code execution.

What “safe heap buffer handling” looks like (context-specific)
- Verify buffer sizes before copying data:
  - Ensure that the size of the buffer is checked before copying data into dynamically allocated heap memory to prevent buffer overflows (e.g., using `strlen()` to check the length of strings or validating the input data size).
- Use safe memory functions:
  - Prefer using safer memory functions that check buffer sizes, such as `strncpy()`, `memcpy_s()`, `snprintf()`, or equivalent, which ensure that data is copied within the bounds of the allocated memory.
- Input validation and sanitization:
  - Always validate or sanitize untrusted input before copying it into a heap-allocated buffer, ensuring that the input size fits within the allocated memory.
- Allocate sufficient buffer space:
  - Allocate buffers large enough to hold the data being processed, considering worst-case scenarios, and use dynamic allocation techniques that can handle large or variable-size data safely.
- Use of memory-safe data structures:
  - Where applicable, use higher-level data structures that automatically handle memory allocation and resizing, such as vectors or lists in C++ or similar constructs in other languages.

Common weak/insufficient defenses (signals of possible risk)
- No bounds checking before copying data:
  - Directly copying data into heap buffers without verifying that the buffer can hold the data, resulting in buffer overflows.
- Use of unsafe memory functions:
  - Functions like `strcpy()`, `memcpy()`, `sprintf()` being used to copy data into heap buffers without validating the size of the data.
- Lack of input size validation:
  - Failing to check or sanitize input data before copying it into dynamically allocated buffers, leading to overflow conditions.
- Misconfigured buffer allocation:
  - Allocating insufficient memory for buffers or failing to handle dynamically sized data, which leads to buffer overflows when large or unexpected data is processed.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Bounds checks or size validation are explicitly performed before copying data into heap buffers (e.g., `if (input_size < buffer_size)`).
  - Safe memory functions like `strncpy()`, `memcpy_s()`, `snprintf()` are used, which ensure that the data copied into the buffer does not exceed its allocated size.
  - Input size is validated before being processed, ensuring that data fits within the allocated buffer space.
  - Proper memory allocation techniques are used, such as `malloc()` with checks to ensure sufficient memory is allocated for the data.
- Evidence suggesting vulnerability:
  - Unsafe functions like `strcpy()`, `memcpy()`, or `sprintf()` are used to copy data into heap buffers without validating the size of the input data or the buffer.
  - Missing or inadequate bounds checks before copying data into heap buffers, allowing potential buffer overflows.
  - Insufficient input validation, where user-supplied or external data is copied into the heap buffer without size checks.
  - Heap buffers are allocated without considering the full size of the data being processed, leading to possible overflows when large or unexpected data is used.

How to use this guideline under incomplete context
- Identify where memory is allocated dynamically:
  - Where in the code are heap buffers being allocated (e.g., using `malloc()`, `calloc()`, or `new`)? Are the sizes of these buffers properly validated before data is copied into them?
- Identify where data is copied into buffers:
  - Are functions like `strcpy()`, `memcpy()`, `sprintf()` being used? If so, are bounds checks in place to ensure that the data fits within the allocated buffer?
- Generate a small number of targeted hypotheses:
  - H1: The buffer is allocated dynamically without validating that the input data fits within the buffer, leading to a buffer overflow.
  - H2: Unsafe memory functions are used to copy data into heap buffers without proper bounds checking or size validation.
  - H3: Input validation is missing or insufficient, allowing untrusted input to overflow the heap buffer.
  - H4: Buffer allocation sizes are miscalculated or insufficient, leading to overflows when large or unexpected data is copied.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unsafe copying functions, lack of size checks),
  (b) evidence needed to confirm it (e.g., explicit buffer size validation, safe memory functions),
  (c) counter-evidence that would refute it (e.g., proper input validation, use of bounds-checked memory functions).

Quick red flags in partial code (weak → strong)
- Strong: Unsafe copying functions (e.g., `strcpy()`, `memcpy()`) are used to copy data into heap buffers without bounds checking or size validation.
- Medium: Buffer sizes are not checked before data is copied into heap memory, potentially allowing overflow.
- Medium: Fixed-size buffers are allocated dynamically but without validating that input data will fit into the buffer, leading to potential overflow conditions.
- Weak: Buffer handling might be managed by external systems or libraries not visible in the snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_122_RULE)
