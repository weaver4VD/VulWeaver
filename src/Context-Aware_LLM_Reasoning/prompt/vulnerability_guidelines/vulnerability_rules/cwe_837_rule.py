CWE_837_RULE = """
[CWE-837 Reference Guideline | Improper Enforcement of a Single, Unique Action | Non-binding, Evidence-first]

Overview
- CWE-837 occurs when a product requires that an actor should only be able to perform an action once (or only have one unique action/state), but the product does not enforce or improperly enforces this restriction.
- This can enable replay, duplication, double-spend/double-submit, repeated privilege-affecting operations, or inconsistent state (e.g., redeeming a coupon multiple times, submitting the same transaction twice).
- In partial snippets, the absence of visible “once-only” enforcement is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “single, unique action enforcement” (static analysis framing)
- Single/unique action requirement:
  - A business/security invariant that an operation must be performed at most once per actor, per token, per resource, per request-id, or per time window.
  - Examples: one-time tokens, nonce usage, one-time password reset link, single redemption, single registration for event, single vote, idempotent payment.
- Improper enforcement:
  - Missing uniqueness checks, non-atomic checks, race-prone enforcement, or relying on client-side “disable button” style gating.

Where CWE-837 typically occurs (sensitive sinks)
- One-time token flows:
  - Password reset, email verification, invite links, magic links, CSRF nonces, signed one-time URLs.
- Financial/transaction operations:
  - Payments, refunds, withdrawals, order submission, inventory reservation.
- State transitions meant to be one-way:
  - Account activation, privilege elevation approvals, consent grants, coupon redemption.
- “Idempotency” surfaces:
  - Request identifiers, deduplication keys, message queue consumers, webhook handlers.
- Concurrency-prone write paths:
  - Multi-threaded services, distributed systems, retries, at-least-once delivery.

Common failure modes (reasoning hints, not assumptions)
- No deduplication key / nonce tracking:
  - Accepting repeated identical requests without checking whether they were already processed.
- Check-then-act without atomicity:
  - `if (!used) { markUsed; performAction }` without transactional guarantees → race allows double execution.
- Client-side enforcement only:
  - UI disables action, but server accepts duplicates.
- Token not invalidated after use:
  - One-time token continues to validate after success.
- Weak uniqueness scope:
  - Uniqueness enforced per-process/memory only (lost on restart) rather than persistent/global.
- Retry/replay handling missing:
  - Network retries or message re-delivery can trigger repeated processing.

What “correct single-action enforcement” looks like (context-specific)
- Persistent uniqueness tracking:
  - Store a “used” marker or processed request-id in durable storage with appropriate scope.
- Atomic enforcement:
  - Enforce uniqueness with database constraints/transactions/compare-and-set (CAS) or idempotency keys.
- Fail-closed on duplicates:
  - If an action is detected as already performed, reject or return the prior result safely.
- Token lifecycle discipline:
  - One-time tokens are invalidated/rotated immediately upon successful use; enforce expiry + one-time use.
- Replay-aware handlers:
  - Use idempotency keys for endpoints that can be retried; ensure message consumers deduplicate.

Common weak/insufficient defenses (signals of possible risk)
- “We check a flag” without atomicity:
  - A boolean “used” check that is not protected by a transaction/lock/unique constraint.
- In-memory dedup caches only:
  - Works only within a single instance; fails under multi-instance scaling or restarts.
- Time-window heuristics:
  - Rejecting repeats within N seconds but still allowing later replay.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Database unique constraints on action keys (token ID, request ID, redemption key) and handling of constraint violations.
  - Transactional update patterns that atomically transition state (e.g., update-if-unused returns affected row count).
  - Explicit idempotency key support and storing processed keys/results.
  - Token invalidation after use and validation that includes “unused” state.
- Evidence suggesting vulnerability:
  - No persistent “used/processed” tracking for one-time actions.
  - Non-atomic check-then-act patterns around “used” flags.
  - Relying on client-side markers to prevent repeat submissions.
  - Token validation that checks signature/expiry but not one-time use state.
  - Handlers that perform irreversible operations without deduplication in retry-prone contexts (webhooks, MQ consumers).

How to use this guideline under incomplete context
- Identify the “must be unique” invariant:
  - What action should be one-time? What is the uniqueness key (token, actor+resource, request-id)?
- Identify enforcement points:
  - Where is the check performed, and where is the state updated to prevent repeats?
- Generate a small number of targeted hypotheses:
  - H1: The endpoint lacks deduplication/nonce tracking, allowing replay or duplicate execution.
  - H2: Uniqueness is checked but not enforced atomically, enabling race-condition duplicates.
  - H3: One-time token is not invalidated after use, enabling reuse.
  - H4: Enforcement exists elsewhere (DB constraints, middleware idempotency layer) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., no token “used” update, check-then-act),
  (b) evidence needed to confirm it (e.g., DB schema constraints, transaction boundaries, distributed lock usage),
  (c) counter-evidence that would refute it (e.g., atomic update, unique constraint handling, stored processed request-ids).

Quick red flags in partial code (weak → strong)
- Strong: Check-then-act pattern for “already processed/used” without transaction/unique constraint; irreversible action performed without deduplication.
- Medium: One-time tokens validated without marking used; duplicates possible via retries/concurrency.
- Medium: Deduplication implemented only in memory in a multi-instance or retry-prone setting.
- Weak: Uniqueness may be enforced by omitted DB constraints or upstream idempotency middleware → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_837_RULE)