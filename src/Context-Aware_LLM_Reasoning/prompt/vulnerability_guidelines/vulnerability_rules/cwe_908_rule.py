CWE_908_RULE = """
[CWE-908 Reference Guideline | Use of Uninitialized Resource | Non-binding, Evidence-first]

Overview
- CWE-908 occurs when the product uses or accesses a resource that has not been initialized.
- “Resource” is broader than a pointer: it can include objects/structs, buffers, file/socket handles, locks, cryptographic contexts, parser/decoder states, configuration objects, or any stateful component that must be initialized before use.
- Using an uninitialized resource can cause undefined behavior, crashes, data corruption, information exposure, logic bypass, or security policy violations depending on the resource type.
- In partial snippets, seeing a resource variable is not proof of CWE-908: initialization might occur on all paths or be guaranteed by API contracts. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “uninitialized resource” (static analysis framing)
- Resource types commonly impacted:
  - Memory-backed objects: structs/classes, buffers, arrays, union fields.
  - Handles/descriptors: file descriptors, sockets, OS handles, DB connections.
  - Synchronization primitives: mutexes, condition variables, semaphores.
  - Crypto/auth contexts: cipher contexts, RNG state, TLS contexts, key objects.
  - Parser/codec contexts: decompression/serialization state machines.
  - Configuration/state objects: objects expected to be “setup” before use.
- Uninitialized:
  - Not created/constructed, not configured, not “init()”-ed, not zeroed, or partially initialized such that some required fields/state remain indeterminate.
- “Use” includes:
  - Dereference/calls on the object, passing it to APIs that assume initialized state, performing operations guarded by flags that are themselves uninitialized, or invoking methods that rely on initialized internal invariants.
- Path sensitivity:
  - Key question: does there exist any feasible path where the resource is used before initialization completes?

Where CWE-908 typically occurs (sensitive sinks)
- Conditional/partial initialization:
  - Resource is initialized only in certain branches; later used unconditionally.
- Error paths and early returns:
  - Initialization fails midway, but code continues or cleanup/use assumes success.
- Out-parameter and “init by callee” APIs:
  - Caller uses resource even when callee indicates failure or does not guarantee initialization.
- Object construction / factory patterns:
  - Constructors or init routines that leave fields unset; multiple constructors with inconsistent initialization.
- State machines:
  - Using a context in the wrong state (e.g., “update/finalize” before “init”).
- Concurrency and publication:
  - Resource published to other threads before fully initialized (safe-publication failure).

Common failure modes (reasoning hints, not assumptions)
- Missing default initialization:
  - Not setting safe defaults (zero/null/invalid handle) at declaration.
- Incorrect success checks:
  - Proceeding despite init returning failure; not checking return codes.
- Partially initialized aggregates:
  - Some members set, others left indeterminate; later logic assumes all are valid.
- Uninitialized read used for control flow:
  - Branching on an uninitialized flag/length/state that gates sensitive behavior.
- Using invalid handle values:
  - File/socket handle variables not set to a known invalid sentinel, then used in close/read/write.

What “robust initialization discipline” looks like (context-specific)
- Establish safe defaults:
  - Initialize resource to a known safe sentinel (NULL/zeroed/invalid handle) before any conditional init.
- Ensure init dominates use:
  - On every path reaching a use site, resource must be fully initialized and in the correct state.
- Validate init success:
  - Check return values; on failure, abort the operation safely (and avoid using the resource).
- Centralize initialization:
  - Single init routine that sets all required fields; avoid duplicated partial init logic.
- Safe publication:
  - Do not expose the resource to other threads/components until initialization is complete and visibility is ensured.

Common weak/insufficient defenses (signals of possible risk)
- “It should have been initialized” assumptions:
  - Relying on informal conventions instead of enforceable checks.
- Null/zero checks that don’t prove initialized state:
  - Resource might be non-null but still partially configured.
- Logging-only on init failure:
  - Detecting failure but continuing anyway.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Resource is initialized at declaration or via constructor/zeroing; required fields set unconditionally.
  - Explicit `init()`/`setup()` calls with checked success before any use.
  - Dominating state checks (e.g., `if (!initialized) return error;`) that are tied to actual init completion.
  - For handles: initialized to invalid sentinel and checked before use; set only upon successful open.
  - For stateful contexts: clear state machine enforcement (init → use → finalize) with guards.
- Evidence suggesting vulnerability:
  - Resource used before any visible initialization or configuration.
  - Initialization only happens on some branches; use happens outside without proving init occurred.
  - Ignored init failures or unchecked return values.
  - Reading fields/flags/lengths from a struct/object that has not been zeroed/constructed.
  - Publishing resource (storing globally/returning pointer) before initialization completes.

How to use this guideline under incomplete context
- Identify the resource and its required init steps:
  - Constructor, `init()` function, configuration setters, open/connect, lock init, etc.
- Enumerate uses:
  - Method calls, API invocations, dereferences, read/write, finalize/close operations.
- Analyze control-flow ordering:
  - Is init guaranteed to occur before each use on all paths? Consider early returns, loops, exceptions, callbacks.
- Consider partial vs full initialization:
  - Are all required fields/state set before use, or only some?
- Generate a small number of targeted hypotheses:
  - H1: Resource can be used before initialization on a feasible path (missing dominating init).
  - H2: Initialization can fail/short-circuit, but code still proceeds to use the resource.
  - H3: Resource is partially initialized (some members/state indeterminate) and later used as if fully initialized.
  - H4: Initialization is guaranteed elsewhere (wrapper, constructor contract, framework lifecycle) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., use before init, unchecked init return),
  (b) evidence needed to confirm it (e.g., init contract, missing branches, state machine rules),
  (c) counter-evidence that would refute it (e.g., default init, dominating guards, enforced state transitions).

Quick red flags in partial code (weak → strong)
- Strong: Calling methods/using fields of a context/handle/object before any visible successful initialization.
- Medium: Init is conditional or can fail; return code ignored; use occurs regardless.
- Medium: Struct/object fields read without prior zeroing/constructor; state machine operations out of order.
- Weak: Initialization may be enforced by omitted constructors/wrappers/framework lifecycle not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_908_RULE)
