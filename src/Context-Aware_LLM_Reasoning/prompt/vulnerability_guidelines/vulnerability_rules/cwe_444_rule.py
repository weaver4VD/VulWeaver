CWE_444_RULE = """
[CWE-444 Reference Guideline | Inconsistent Interpretation of HTTP Requests (Request/Response Smuggling) | Non-binding, Evidence-first]

Overview
- CWE-444 occurs when an intermediary HTTP agent (proxy, gateway, load balancer, firewall, WAF-like filter, middleware) parses or normalizes malformed/ambiguous HTTP requests or responses differently from the ultimate destination (upstream/downstream server or client).
- This inconsistency can allow an attacker to “smuggle” a hidden request/response through the intermediary, potentially bypassing security controls, poisoning caches, hijacking sessions, or desynchronizing request routing.
- In partial snippets, seeing HTTP parsing code is not proof of CWE-444. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “inconsistent interpretation” (static analysis framing)
- Inconsistent interpretation:
  - Two HTTP entities in the chain disagree on request/response boundaries, header semantics, or message framing.
- Typical precondition:
  - The intermediary re-parses, rewrites, filters, or forwards HTTP messages, especially when it handles hop-by-hop details like transfer encodings, content lengths, connection reuse, or header normalization.
- Smuggling effect:
  - A crafted payload is interpreted as:
    - One request by the intermediary, but two requests by the backend (request smuggling), or
    - One response by one side and a different boundary by the other (response smuggling / desync).

Where CWE-444 typically occurs (sensitive sinks)
- Custom HTTP parsers and message framing code:
  - Manual parsing of start line/headers, handling of `Content-Length`, `Transfer-Encoding`, chunked decoding, and connection reuse.
- HTTP normalization/rewriting layers:
  - Proxies that rewrite headers, combine/duplicate headers, or normalize whitespace/casing.
- Security middleboxes:
  - Firewalls/WAF-like filters that parse and validate, then forward raw bytes or reconstructed requests.
- Upstream/downstream bridging:
  - HTTP/1.1 ↔ HTTP/2 translation, or proxying to different stacks with different strictness.
- Connection pooling / keep-alive management:
  - Reusing connections to backend where mis-framed requests desynchronize the stream.

Common failure modes (reasoning hints, not assumptions)
- Conflicting message length signals:
  - Accepting requests with both `Transfer-Encoding` and `Content-Length` without strict rejection or canonicalization.
- Multiple or ambiguous `Content-Length`:
  - Multiple `Content-Length` headers with different values, or comma-separated values, handled inconsistently.
- Non-standard whitespace and header folding:
  - Obsolete line folding, unusual whitespace around `:` or in header values, differing tolerance across stacks.
- Chunked parsing differences:
  - Accepting invalid chunk sizes, chunk extensions, or premature termination differently than backend.
- Request line / header normalization differences:
  - Tolerating invalid characters, mixed encodings, or unusual line endings.
- Forwarding “raw” vs “reconstructed” data mismatch:
  - Intermediary validates a reconstructed/normalized request but forwards original raw bytes (or vice versa).

What “robust intermediary parsing/forwarding” looks like (context-specific)
- Strict framing rules and fail-closed behavior:
  - Reject ambiguous/malformed requests rather than trying to “guess” intent.
- Canonicalize once, forward consistently:
  - If parsing and rewriting, ensure the forwarded bytes match the interpretation used for security decisions.
- Enforce clear precedence rules:
  - When both `Transfer-Encoding` and `Content-Length` appear, follow a strict policy (often reject or ensure consistent canonical framing).
- Normalize or drop problematic constructs:
  - Remove hop-by-hop headers appropriately; avoid passing through conflicting framing headers.
- Connection safety:
  - If framing is uncertain, do not reuse backend connections; isolate or close to avoid desync propagation.

Common weak/insufficient defenses (signals of possible risk)
- “Best effort” parsing:
  - Attempting to accept and forward malformed requests for compatibility.
- Partial validation:
  - Checking header presence but not validating structure, duplicates, or conflicts.
- Security decision on one representation, forwarding another:
  - Filtering the parsed form but forwarding raw bytes that include hidden payload.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit detection and rejection of ambiguous framing:
    - Conflicts between `Transfer-Encoding` and `Content-Length`.
    - Multiple `Content-Length` headers or invalid forms.
  - Clear, deterministic parsing logic for request boundaries and chunked decoding with strict error handling.
  - Forwarding uses the same canonical representation that the intermediary validated (no “validate parsed, forward raw” mismatch).
  - Conservative handling of malformed headers/line endings; normalization applied consistently.
  - Defensive connection handling (close/disable keep-alive) on parse anomalies.
- Evidence suggesting vulnerability:
  - Custom parser that tolerates multiple/invalid `Content-Length` or accepts both `TE` and `CL` without strict resolution.
  - Header normalization that merges/splits headers in ways that can change semantics between intermediary and backend.
  - Use of different parsing logic for security checks vs forwarding (double-parse with different rules).
  - Forwarding raw bytes after higher-level validation (or reconstructing outbound requests in a way that differs from inbound interpretation).
  - Incomplete chunked decoding implementation (accepting invalid chunk sizes/terminators).

How to use this guideline under incomplete context
- Identify whether the code is an intermediary:
  - Look for proxying, filtering, forwarding, gateway behavior, or request/response rewriting between client and server.
- Identify message framing logic:
  - Parsing of headers, handling of `Content-Length`, `Transfer-Encoding`, chunked decoding, connection reuse.
- Generate a small number of targeted hypotheses:
  - H1: The intermediary can accept ambiguous framing (TE+CL, multiple CL) and forward in a way that backend interprets differently.
  - H2: The intermediary validates one representation (normalized/parsed) but forwards another (raw/re-serialized), enabling smuggling.
  - H3: Chunked decoding or header parsing is permissive/partial, creating boundary disagreements across stacks.
  - H4: Robust parsing and canonical forwarding are enforced elsewhere (library proxy core, strict config) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., permissive CL/TE handling, raw forwarding),
  (b) evidence needed to confirm it (e.g., full parser behavior, backend protocol, connection reuse policy),
  (c) counter-evidence that would refute it (e.g., explicit reject rules, canonicalization + consistent forwarding).

Quick red flags in partial code (weak → strong)
- Strong: Accepting requests with both `Transfer-Encoding` and `Content-Length`, or multiple conflicting `Content-Length`, without strict rejection; and using keep-alive to backend.
- Medium: Security filtering/normalization uses parsed headers, but forwarding uses raw bytes or a differently serialized form.
- Medium: Custom chunked decoding/parsing that is tolerant of invalid syntax or unusual whitespace/line endings.
- Weak: Parsing/forwarding may be delegated to a well-tested HTTP library with strict defaults not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_444_RULE)
