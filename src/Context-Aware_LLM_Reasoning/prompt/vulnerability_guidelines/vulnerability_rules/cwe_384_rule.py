CWE_384_RULE = """
[CWE-384 Reference Guideline | Session Fixation | Non-binding, Evidence-first]

Overview
- CWE-384 occurs when a system authenticates a user or establishes a new session without invalidating any existing session identifiers. This enables attackers to set or hijack a valid session identifier, potentially impersonating an authenticated user.
- The vulnerability arises when the session identifier (typically stored in a cookie or URL) is not regenerated or invalidated after login or session creation, allowing attackers to trick the system into using a session they control.
- In partial snippets, missing session invalidation or regeneration evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “session identifier” (static analysis framing)
- Session ID:
  - unique identifier used to track a user session, often stored in a cookie (`JSESSIONID`, `PHPSESSID`), URL parameter, or request header
- Session tokens:
  - JWTs, signed cookies, OAuth tokens, or similar mechanisms used to represent and authenticate a session

Where session fixation issues arise (sensitive sinks)
- Session creation or authentication:
  - login mechanisms, user registration, session regeneration points (e.g., after successful login)
- Session management mechanisms:
  - renewing session IDs, creating new session tokens, switching between authenticated roles (admin/user)

Common failure modes (reasoning hints, not assumptions)
- Session ID is not regenerated:
  - When a user logs in or when the session is established, the system does not generate a new session ID but continues using the old one.
- Session ID is not invalidated:
  - Old session IDs are left valid after login, and the attacker can set or use an existing session ID to impersonate the user.
- Token reuse across different users:
  - Same session ID being reused after login by the attacker.
- Missing proper session termination:
  - When logging out, the system does not invalidate or destroy the session identifier, leaving it usable by the attacker.

What “proper session management” looks like (context-specific)
- Regenerate session identifiers on login:
  - After user authentication, generate a new session identifier and discard any pre-existing session identifiers.
- Invalidate old session IDs:
  - Ensure that any previous session identifiers are invalidated immediately upon successful login or session creation.
- Session termination on logout:
  - Properly destroy and invalidate the session token on logout or after session expiry.
- Use secure session management practices:
  - Ensure that session identifiers are transmitted securely (via `Secure` and `HttpOnly` flags in cookies, and using `SameSite` where appropriate).
  - Implement secure session handling mechanisms to prevent session fixation attacks.

Common weak/insufficient defenses (signals of possible risk)
- Using the same session identifier after authentication:
  - If the session ID is not regenerated or invalidated during login, attackers can potentially hijack it.
- Not invalidating sessions on logout:
  - Leaving session IDs active after logout can lead to session fixation if the attacker intercepts or guesses the session ID.
- Allowing session IDs to be passed via insecure channels:
  - Transmitting session IDs over non-HTTPS channels makes them vulnerable to interception and fixation.
- Session hijacking via URL or cookie:
  - Session IDs in URLs or unprotected cookies are more vulnerable to interception or fixation attacks.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit session ID regeneration after user authentication/login (`session.regenerate()` or similar).
  - Invalidating or destroying session identifiers upon logout (`session.invalidate()` or equivalent).
  - Secure session ID storage in cookies with `HttpOnly`, `Secure`, and `SameSite` attributes.
  - Use of secure session handling libraries or frameworks with built-in protections against session fixation.
- Evidence suggesting vulnerability:
  - Session ID is not regenerated after login and remains the same, potentially accessible through cookies or URL parameters.
  - No evidence of invalidation for previous sessions after authentication or on logout.
  - Session identifiers are passed over insecure channels (non-HTTPS) or stored without proper flags.
  - Custom session management logic with no evidence of session regeneration.

How to use this guideline under incomplete context
- Identify session creation and authentication patterns:
  - Does the code regenerate or invalidate session identifiers after login? Is the session ID reused after authentication?
- Generate a small number of targeted hypotheses:
  - H1: Session identifier is not regenerated after login, leaving the session vulnerable to fixation.
  - H2: Previous session IDs are not invalidated, allowing attackers to hijack sessions.
  - H3: Session ID management is handled outside of the visible code (e.g., handled by a framework or external service).
  - H4: Session ID is passed in insecure ways (e.g., URL, unsecured cookie).
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (session creation points, token regeneration, logout logic),
  (b) evidence needed to confirm it (session management configuration, secure cookie headers, external session handling logic),
  (c) counter-evidence that would refute it (explicit session regeneration, secure token management, proper invalidation on logout).

Quick red flags in partial code (weak → strong)
- Strong: session ID remains the same across login/authentication and is passed via URL or unsecured cookies.
- Medium: session regeneration logic appears in some endpoints but is missing from others.
- Medium: session ID is passed insecurely without appropriate flags (`Secure`, `HttpOnly`, `SameSite`).
- Weak: session management may be handled by frameworks or external components not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_384_RULE)
