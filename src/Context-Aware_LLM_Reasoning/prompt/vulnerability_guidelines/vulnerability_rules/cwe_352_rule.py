CWE_352_RULE = """
[CWE-352 Reference Guideline | Cross-Site Request Forgery (CSRF) | Non-binding, Evidence-first]

Overview
- CWE-352 (CSRF) occurs when a web application performs a state-changing action based solely on the user’s authenticated browser session (e.g., cookies) without ensuring the request was intentionally initiated by that user.
- The attacker does not need to read the response; they exploit the browser’s ability to automatically attach credentials (cookies, sometimes client certs) to cross-site requests.
- In partial snippets, missing anti-CSRF evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

Preconditions and key concepts (static analysis framing)
- Authentication via “ambient authority”:
  - session cookies (most common), possibly other automatically sent credentials
- A state-changing endpoint:
  - actions that modify server state: create/update/delete, change settings, perform transactions, trigger jobs
- Missing or incorrect request origin intent validation:
  - server accepts cross-site requests as if they were user-intended

Typical CSRF-relevant sinks (server-side actions)
- State changes:
  - update profile/email/password, change permissions/roles, create/delete resources, perform purchases/transfers, trigger builds/jobs
- Sensitive operations even if “idempotent-looking”:
  - endpoints that cause side effects (e.g., “/refresh”, “/reindex”, “/run”, “/approve”)
- Any endpoint that relies on session authentication and does not require an additional per-request proof of user intent

Common CSRF protections (what to look for in code)
- Per-request anti-CSRF token verification:
  - token bound to user session and validated on state-changing requests
  - token passed via form field or custom header, and compared server-side
- SameSite cookie strategy (partial mitigation, browser-dependent and context-dependent):
  - cookie attributes that reduce cross-site sending, but not always sufficient alone
- Origin/Referer validation (defense-in-depth, can be brittle):
  - checking Origin/Referer headers against expected site origin, typically for unsafe methods
- Double-submit cookie patterns:
  - matching a cookie value with a request parameter/header value (with correct scoping)

Important distinctions (avoid false positives in partial snippets)
- Method matters but is not sufficient:
  - Using POST does not prevent CSRF by itself.
  - GET endpoints that change state are especially suspicious, but POST/PUT/DELETE can still be CSRF-vulnerable without defenses.
- Content-Type and CORS are not CSRF defenses by default:
  - CORS controls reading responses, not sending requests; CSRF often works without reading.
- Authentication type matters:
  - If endpoint is authenticated purely via Authorization header with bearer tokens stored outside cookies and not automatically attached, CSRF risk may be reduced, but this is often Unknown from a snippet.

Common failure modes (reasoning hints, not assumptions)
- No CSRF check on state-changing endpoints that rely on cookies/session.
- CSRF token exists but is not validated on all relevant endpoints (inconsistent enforcement).
- Token is predictable, not bound to session, or not tied to request context.
- Relying solely on “Origin/Referer” in ways that can be absent/unreliable, or not enforced for all unsafe methods.
- Misconfigured framework protection (disabled CSRF filter, endpoints excluded broadly).

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - explicit CSRF token validation in request handler or in a clearly active framework filter/interceptor
  - framework annotations/config that enforce CSRF checks for unsafe methods (when visible)
  - token is tied to session/user and compared against request-supplied token
  - consistent enforcement: all state-changing endpoints appear guarded
- Evidence suggesting vulnerability:
  - state-changing logic in an authenticated session context with no token/origin validation visible in the same flow
  - endpoints accept requests with only cookie/session authentication and no additional proof of user intent
  - handler performs sensitive actions without checking CSRF-related headers/parameters/tokens

How to use this guideline under incomplete context
- Identify whether the endpoint is state-changing and how it authenticates:
  - does it modify server state? is it likely cookie-session based?
- Identify the presence/absence of CSRF defenses:
  - is there token verification, origin checking, or framework-level CSRF filter evidence?
- Generate a small number of targeted hypotheses:
  - H1: Endpoint relies on session cookies and lacks CSRF token/origin validation (CSRF possible).
  - H2: CSRF protection exists at framework/filter level not shown here.
  - H3: Endpoint uses non-cookie authentication (e.g., bearer header) so CSRF risk may be reduced (Unknown unless evidenced).
  - H4: CSRF checks exist but are inconsistently applied or bypassable.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (state change + auth context + missing checks),
  (b) evidence needed to confirm it (security filter config, CSRF token generation/validation, cookie attributes, endpoint method),
  (c) counter-evidence that would refute it (explicit token/origin validation, framework CSRF enforcement clearly enabled).

Quick red flags in partial code (weak → strong)
- Strong: state-changing servlet/controller method uses session/project/user context and performs sensitive updates with no CSRF token/origin validation visible.
- Medium: CSRF validation appears only in some endpoints; this endpoint lacks it.
- Medium: GET endpoint triggers state changes without CSRF defenses.
- Weak: CSRF defenses may be implemented in global filters/interceptors/config not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_352_RULE)