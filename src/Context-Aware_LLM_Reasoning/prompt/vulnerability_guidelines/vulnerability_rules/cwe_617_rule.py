CWE_617_RULE = """
[CWE-617 Reference Guideline | Reachable Assertion | Non-binding, Evidence-first]

Overview
- CWE-617 occurs when the product contains an `assert()` (or similar “must be true” statement) that can be triggered by an attacker, causing the program to exit, abort, crash, or otherwise fail in a way that is more severe than necessary.
- This is often a denial-of-service vector when attacker-controlled inputs can violate the asserted condition in production builds where assertions are enabled (or when assertion-like checks terminate the process).
- In partial snippets, seeing an assert does not prove CWE-617: the condition may be unreachable to attackers, or asserts may be compiled out. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “reachable assertion” (static analysis framing)
- Assertion-like constructs:
  - `assert(expr)`, `ASSERT(expr)`, `DCHECK`, `CHECK`, `BUG_ON`, `panic`, `fatalIf`, or custom macros that abort/terminate on failure.
  - Also includes invariants enforced via `abort()`, `exit()`, `std::terminate()`, or `__builtin_trap()` when used as “this should never happen”.
- Reachable by an attacker:
  - The asserted predicate can be influenced by external input (network, file, IPC, user request) along at least one feasible path.
- More severe than necessary:
  - Instead of returning an error, rejecting input, or handling gracefully, the program terminates or enters a fatal state.

Where CWE-617 typically occurs (sensitive sinks)
- Input parsing and validation:
  - Asserting parse invariants directly on untrusted input (protocol fields, JSON/XML parsing, file formats).
- Request handlers / public APIs:
  - Assertions inside endpoints reachable via remote requests or public interfaces.
- State machines:
  - Assertions on state transitions that can be forced into unexpected states by crafted sequences.
- Bounds and resource checks:
  - Asserting size limits or index bounds instead of validating and returning an error.
- “Should never happen” assumptions in edge cases:
  - Assertions that fire on rare/invalid inputs (empty, malformed, extreme values).

Common failure modes (reasoning hints, not assumptions)
- Using assert as input validation:
  - `assert(len < MAX)` rather than checking and rejecting invalid input.
- Asserting on attacker-influenced arithmetic:
  - Overflows, underflows, division preconditions asserted instead of enforced.
- Assertion compiled-in unexpectedly:
  - Some projects keep `CHECK`-style fatal checks in release builds; or asserts are not stripped in certain configurations.
- Inadequate gating:
  - Assertion sits behind a condition that seems safe but is attacker-controllable.
- Untrusted state desynchronization:
  - Attacker causes inconsistent internal state that violates an asserted invariant.

What “safe handling” looks like (context-specific)
- Replace asserts with recoverable validation on untrusted inputs:
  - Use explicit checks that return error codes / exceptions / structured error responses.
- Keep asserts for internal invariants only:
  - Assertions should enforce developer assumptions not reachable from external inputs, or only in debug builds.
- Fail gracefully:
  - On invalid input, reject and continue serving other requests; avoid process-wide abort.
- Harden state transitions:
  - Validate sequences and handle unexpected transitions without fatal termination.

Common weak/insufficient defenses (signals of possible risk)
- “It’s just an assert”:
  - Some “assert-like” macros abort in production, making them exploitable DoS points.
- Checking only in debug:
  - If runtime still crashes on invalid input in release, debug-only checks don’t help.
- Relying on upstream validation:
  - Assuming earlier layers sanitize input without evidence; missing local defensive checks.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Assertions only on internal invariants where inputs are already proven trusted or derived from validated state.
  - Attacker-controlled inputs are validated with normal error handling, not assertions.
  - Build configuration indicates assertions are disabled in production (but treat as Unknown unless evidenced).
  - Defensive error returns around conditions that could otherwise be asserted.
- Evidence suggesting vulnerability:
  - Assertions whose predicate depends on external input or request-derived values (lengths, indices, states).
  - Assertion in code path reachable from network/file parsing or request handling.
  - Assertion-like macros that abort unconditionally (e.g., `CHECK`) used as validation.
  - No fallback/error handling when predicate fails (fatal termination is the only behavior).

How to use this guideline under incomplete context
- Identify assertion-like statements:
  - Locate `assert`, `CHECK`, `panic`, `abort` patterns and determine their failure behavior.
- Trace predicate influence:
  - Does the asserted condition depend on variables that can be influenced by external input?
- Determine reachability:
  - Is the code in a public-facing path (parser, endpoint, message handler) or internal-only tooling?
- Generate a small number of targeted hypotheses:
  - H1: Assert predicate is attacker-influenced along a feasible public path → reachable assertion DoS risk.
  - H2: Assertion is intended for internal invariants but can be violated by malformed input sequences (state machine desync).
  - H3: Assertion is effectively debug-only / compiled out in production → risk depends on build (Unknown without evidence).
  - H4: The path is gated by strong validation elsewhere (protocol layer, schema validation) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., assert uses request field length),
  (b) evidence needed to confirm it (e.g., build flags, macro semantics, caller exposure),
  (c) counter-evidence that would refute it (e.g., explicit validation + error handling before assert).

Quick red flags in partial code (weak → strong)
- Strong: `assert(...)`/`CHECK(...)` directly on attacker-controlled input within a request handler or parser, leading to abort/exit.
- Medium: Assertion in a state machine transition reachable via external sequences; or assertion-like macro known to be enabled in release.
- Medium: Assertion depends on indices/lengths derived from input with no prior validation shown.
- Weak: Assertion may be unreachable to attackers or compiled out in production; macro semantics/build config not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_617_RULE)
