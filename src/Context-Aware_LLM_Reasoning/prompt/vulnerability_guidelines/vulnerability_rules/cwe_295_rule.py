CWE_295_RULE = """
[CWE-295 Reference Guideline | Improper Certificate Validation | Non-binding, Evidence-first]

Overview
- CWE-295 occurs when the product does not validate, or incorrectly validates, a certificate used to establish trust in a secure communication channel (typically TLS/SSL).
- Improper certificate validation can enable man-in-the-middle attacks, endpoint impersonation, data interception, or unauthorized access by allowing connections to untrusted endpoints that present invalid or attacker-controlled certificates.
- In partial snippets, not seeing certificate checks is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “certificate validation” (static analysis framing)
- Certificate validation:
  - Verifying that a presented certificate is trustworthy for the intended connection, typically including:
    - Chain of trust validation (issuer/CA chain).
    - Validity period checks (notBefore/notAfter).
    - Subject identity checks (hostname/SAN matches the target).
    - Revocation considerations (CRL/OCSP) where applicable.
- Improper validation:
  - Skipping validation, accepting all certificates, disabling hostname verification, or using a trust store/validator in a way that defeats the security model.

Where improper certificate validation typically occurs (sensitive sinks)
- TLS client configuration:
  - HTTP clients, REST clients, gRPC clients, WebSocket clients, SMTP/IMAP clients over TLS, database drivers with TLS.
- Custom trust managers / verifiers:
  - Custom `TrustManager`, `X509TrustManager`, `HostnameVerifier`, certificate pinning logic.
- “Insecure mode” toggles:
  - Flags or settings like “trustAll”, “insecureSkipVerify”, “disableHostnameVerification”.
- Embedded trust stores:
  - Loading custom trust stores or self-signed certs without tight scoping, or falling back to permissive behavior on errors.

Common failure modes (reasoning hints, not assumptions)
- Trust-all certificate acceptance:
  - Custom trust manager that accepts any certificate or returns success without checks.
- Hostname verification disabled:
  - Accepting certificates that do not match the target host (common via permissive hostname verifiers).
- Fallback-to-insecure on error:
  - If validation fails, code retries with relaxed validation instead of failing closed.
- Incorrect pinning:
  - Pinning logic compares wrong fields, accepts empty pins, or does not enforce pin mismatch failure.
- Using wrong trust store:
  - Trusting broad/unintended CAs, or loading a trust store from an attacker-influenced path.

What “correct certificate validation” looks like (context-specific)
- Fail-closed validation:
  - Validation failures abort the connection; no insecure fallback.
- Default platform validation:
  - Prefer standard TLS stacks that validate chain + hostname by default, unless there is a strong reason to customize.
- Hostname identity enforcement:
  - Ensure hostname/SAN verification is enabled and consistent with the actual target.
- Scoped customization:
  - If custom trust is needed (private CA, self-signed, pinning), scope it narrowly to intended endpoints and enforce strict checks.

Common weak/insufficient defenses (signals of possible risk)
- “It’s encrypted anyway”:
  - TLS without proper certificate validation does not ensure endpoint authenticity.
- Partial checks only:
  - Checking validity dates but not chain, or chain but not hostname identity.
- Debug-only insecure settings leaking into production:
  - Insecure flags or verifiers left enabled.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Using default HTTPS/TLS client configurations that keep certificate validation and hostname verification enabled.
  - Explicit hostname verification enabled (or not overridden) and explicit trust store loading with strict scope.
  - Certificate pinning with strict mismatch failure and clear pin source (not user-controlled).
  - No “trust all” verifiers, and no insecure fallback paths.
- Evidence suggesting vulnerability:
  - Custom trust managers/hostname verifiers that accept all certificates or always return true.
  - Explicit disabling of hostname verification or trust checks.
  - Configuration flags that skip certificate validation (especially if derived from external config/input) without tight controls.
  - Catching certificate validation exceptions and proceeding with the connection anyway.

How to use this guideline under incomplete context
- Identify TLS client usage:
  - Where are HTTPS/TLS connections created/configured? Which client library is in use?
- Identify customization points:
  - Are `TrustManager`/`HostnameVerifier`/SSL context builders overridden?
- Generate a small number of targeted hypotheses:
  - H1: The code disables certificate or hostname validation (trust-all / always-true verifier).
  - H2: Validation failures are ignored or trigger insecure fallback.
  - H3: Custom trust store/pinning is misapplied or attacker-influenced, weakening trust.
  - H4: Proper validation is handled by default client configuration or centralized TLS setup elsewhere → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., “trust all” verifiers, disabled hostname checks),
  (b) evidence needed to confirm it (e.g., full SSL context setup, config sources),
  (c) counter-evidence that would refute it (e.g., default validation retained, strict pinning).

Quick red flags in partial code (weak → strong)
- Strong: Trust manager/hostname verifier that unconditionally accepts certificates/hosts; explicit “disable verification” settings.
- Medium: Validation exceptions caught and ignored; fallback to insecure SSL context.
- Medium: Trust store path or pins derived from external input/config without strict control.
- Weak: TLS setup may be centralized elsewhere with correct defaults, and this snippet only shows high-level calls → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_295_RULE)
