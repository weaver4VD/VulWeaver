CWE_78_RULE = """
[CWE-78 Reference Guideline | OS Command Injection | Non-binding, Evidence-first]

Overview
- CWE-78 occurs when the product constructs all or part of an OS command using externally-influenced input, but it does not neutralize (or incorrectly neutralizes) special elements that can change the command’s meaning when executed by the OS or a command interpreter.
- If attacker-controlled input reaches a command execution sink, it can enable unauthorized command execution, data compromise, or broader system compromise, depending on privileges and environment.
- In partial snippets, seeing string concatenation near a command call is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “OS command injection” (static analysis framing)
- OS command construction:
  - Building a command line, command string, or argument list that is executed by the operating system (directly or via a shell).
- Special elements:
  - Shell metacharacters, quoting/escaping rules, argument separators, variable/command substitution constructs, redirections, pipes, or control operators that may be interpreted by a shell/command parser.
- Injection condition (high-level):
  - External input influences the executed command structure (not just data), e.g., by breaking out of intended arguments or adding new operators.

Where OS command injection typically occurs (sensitive sinks)
- Command execution APIs (language-agnostic patterns):
  - APIs that spawn processes or invoke shell commands (e.g., `exec`, `system`, `popen`, `Runtime.exec`, `ProcessBuilder`, `os.system`, etc.).
- “Shell=true” or interpreter-based execution:
  - Explicitly invoking `/bin/sh -c`, `cmd.exe /c`, or equivalent.
  - Libraries/wrappers that default to shell interpretation.
- Indirect sinks:
  - Passing constructed command strings into helper utilities, scripts, or wrappers that later execute them.

Common failure modes (reasoning hints, not assumptions)
- String concatenation to form a command:
  - `cmd = "tool " + userArg` then execute `cmd` (especially if a shell is involved).
- Shell invocation with untrusted input:
  - Using `sh -c <string>` or `cmd.exe /c <string>` where `<string>` is influenced by external input.
- Unsafe quoting/escaping:
  - Attempting to escape a subset of metacharacters or using ad-hoc replacements that can be bypassed.
- Argument boundary confusion:
  - Treating an entire command line as a single string when the API expects structured arguments (or vice versa).
- Over-trusting “allowed characters”:
  - Allowing broad sets that still enable separators, expansion, or path tricks.

What “robust command execution safety” looks like (context-specific)
- Prefer structured argument APIs:
  - Use exec APIs that take an argument array/list (no shell), so input cannot introduce new operators.
- Avoid shell interpretation:
  - Do not invoke a shell unless absolutely necessary; if needed, use strict allowlists and minimal templates.
- Strict allowlisting and canonicalization:
  - Validate external input against a narrow, context-appropriate allowlist (e.g., fixed enum options, safe filenames).
- Separate data from command structure:
  - Keep the command template constant; external input only fills validated argument slots.
- Least privilege execution:
  - Run command execution with minimal OS privileges (mitigation, not a substitute for validation).

Common weak/insufficient defenses (signals of possible risk)
- Blacklisting metacharacters:
  - Trying to remove `;|&$()` etc. is fragile across shells/platforms/encodings.
- Escaping without understanding target shell semantics:
  - “Escaping” can be wrong if the actual interpreter differs (POSIX sh vs bash vs cmd.exe vs PowerShell).
- Relying on URL encoding / HTML escaping:
  - Output encodings do not neutralize shell parsing.
- “It’s internal input” assumptions:
  - Upstream components can still be attacker-influenced (headers, params, config, DB fields).

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Command executed via structured args (no shell) with external input occupying a single argument position after validation.
  - External input constrained to safe enums/whitelists (e.g., mapping user choices to known-safe command options).
  - No use of `sh -c`/`cmd.exe /c` with untrusted strings; no “shell=true” patterns.
  - Explicit rejection of unexpected characters/lengths plus canonicalization where relevant (e.g., paths).
- Evidence suggesting vulnerability:
  - External input concatenated into a command string passed to a shell or shell-like API.
  - Use of `sh -c`, `cmd.exe /c`, or “shell execution” with any attacker-influenced content.
  - Wrapper functions that accept a single command string and forward to shell execution.
  - Partial/naive escaping or blacklisting around command strings.

How to use this guideline under incomplete context
- Identify sources and trust boundaries:
  - Which variables are influenced by requests, files, env, DB, IPC, or user-controlled config?
- Identify command construction and execution sinks:
  - Where is the command string/args assembled, and which API actually executes it?
- Generate a small number of targeted hypotheses:
  - H1: Untrusted input reaches an OS command execution sink as part of the command string (especially via shell).
  - H2: Input validation/escaping is insufficient or mismatched to the actual interpreter semantics.
  - H3: The code uses structured args, but an attacker can still control the executable path or option set (argument injection via program-specific parsing).
  - H4: Validation is enforced elsewhere (centralized sanitizers, wrappers, policy layer) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., concatenation into `sh -c`, `Runtime.exec(cmd)` with string),
  (b) evidence needed to confirm it (e.g., how the exec API interprets inputs, wrapper implementation, input source),
  (c) counter-evidence that would refute it (e.g., strict allowlist mapping, argument-array execution without shell).

Quick red flags in partial code (weak → strong)
- Strong: `sh -c` / `cmd.exe /c` with attacker-influenced command string; “shell execution” with untrusted content.
- Medium: Building command strings via concatenation and passing to an exec API that parses a single string.
- Medium: Ad-hoc escaping/blacklisting of metacharacters with no clear guarantee of interpreter semantics.
- Weak: Command execution may be encapsulated by a safe wrapper not shown (structured args + strict allowlists) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_78_RULE)