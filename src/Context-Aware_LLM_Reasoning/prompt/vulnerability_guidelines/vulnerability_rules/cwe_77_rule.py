CWE_77_RULE = """
[CWE-77 Reference Guideline | Command Injection | Non-binding, Evidence-first]

Overview
- CWE-77 (Command Injection) occurs when a product constructs all or part of an OS command using externally-influenced input, but fails to properly neutralize characters/tokens that the command interpreter treats as syntax (e.g., separators, operators, quoting), allowing attackers to alter the intended command.
- The key factor is whether the downstream execution path performs shell-style parsing or otherwise interprets special elements as control syntax.
- In partial snippets, missing neutralization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “externally-influenced input” (typical sources)
- HTTP-derived data: parameters, headers, cookies, path variables, request bodies (JSON/form).
- Message/RPC payload fields, user-controlled DB fields (only if attacker-controllable in context).
- Uploaded file metadata (filenames) or file content that is later inserted into commands.
- Environment/config values if attacker-controlled through the product’s interfaces.

Command execution sinks (typical in Java)
- Direct execution:
  - Runtime.getRuntime().exec(...)
  - new ProcessBuilder(...).start()
- Wrapper utilities:
  - org.apache.commons.exec (CommandLine, DefaultExecutor, etc.)
  - Framework-specific “run command” helpers that eventually invoke OS processes
- Indirect execution:
  - Passing command strings to scripts/interpreters (sh, bash, cmd.exe, powershell, python, perl) which then parse/execute.

Special elements that enable injection (reasoning hints, not assumptions)
- Shell metacharacters / separators / operators (varies by shell and OS):
  - POSIX shells: ;, &&, ||, |, `...`, $(...), >, <, &, newline
  - Windows cmd: &, |, &&, ||, ^, %, newline
  - PowerShell: ;, |, &, $(...), backtick escapes
- Quoting/context breaks:
  - Unbalanced quotes, escaping differences, whitespace tokenization
- Path and argument confusion:
  - user input influences executable name vs argument, or introduces extra arguments

What “proper neutralization/restriction” looks like (context-specific)
- Prefer safe-by-construction command invocation:
  - Use ProcessBuilder with an argument list (each arg as a separate token), not a single concatenated command string.
  - Avoid invoking a shell (e.g., "sh -c", "cmd /c", "powershell -Command") unless strictly necessary; shells increase injection risk.
- Constrain and separate untrusted data:
  - For fixed operations, allow-list the command and options; treat user input as data-only arguments.
  - Validate input with strict allow-lists (regex/enum) when only limited characters/values are legitimate.
- If escaping is unavoidable:
  - Escaping must match the exact shell/interpreter grammar and the exact insertion context; generic “replace bad chars” is fragile.
  - Ensure escaping happens after decoding/normalization and right before execution.

Common weak/insufficient defenses (signals of possible risk)
- String concatenation/interpolation to build commands:
  - "cmd " + userInput, format strings, template-based command construction.
- Blacklist filtering:
  - Removing a few metacharacters (e.g., ';', '&') is bypassable (alternate tokens, encoding, whitespace/newlines).
- Using ProcessBuilder but still passing a single string that is shell-parsed:
  - e.g., ProcessBuilder("sh", "-c", userControlledString) or cmd.exe /c with user input.
- Validate-then-transform pitfalls:
  - Validate raw input, then decode/normalize/expand later, enabling special characters to appear.
- Ambiguous “sanitize()” or “escape()” helpers:
  - Semantics unclear; may be context-mismatched.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - ProcessBuilder with explicit argument array/list where user input occupies a single argument position and cannot introduce new tokens.
  - No shell invocation; executable and options are fixed/allow-listed.
  - Strict allow-list validation for user-provided argument values (e.g., IDs, filenames restricted to safe patterns).
- Evidence suggesting vulnerability:
  - Externally influenced input is concatenated into a command string executed via Runtime.exec or via a shell ("sh -c", "cmd /c", "powershell -Command").
  - The only visible “defense” is character stripping/blacklist replacement.
  - User input influences the executable name or introduces additional arguments/operators.

How to use this guideline under incomplete context
- Identify the execution mode implied by the sink:
  - Is a shell involved (sh -c / cmd /c / powershell)? Or is it direct exec with argv?
- Generate a small number of targeted hypotheses based on the observed construction pattern:
  - H1: User input can introduce command separators/operators that change execution.
  - H2: The command is executed through a shell, making parsing/injection more likely.
  - H3: A strict allow-list or argv-based separation exists upstream, but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (concatenation, shell flags, dynamic command strings),
  (b) evidence needed to confirm it (exact exec call signature, whether argv separation is used, sanitization semantics),
  (c) counter-evidence that would refute it (argv-only ProcessBuilder usage, no shell, allow-list constraints).

Quick red flags in partial code (weak → strong)
- Strong: request-derived input concatenated into a command executed by Runtime.exec or by shell-based execution (sh -c / cmd /c / powershell -Command).
- Medium: presence of “replace/remove special chars” style sanitization with unclear completeness.
- Medium: decoding/normalization occurs after validation and before execution.
- Weak: sanitization/argv separation may occur outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_77_RULE)
