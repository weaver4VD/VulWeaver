CWE_772_RULE = """
[CWE-772 Reference Guideline | Missing Release of Resource after Effective Lifetime | Non-binding, Evidence-first]

Overview
- CWE-772 occurs when the product does not release a resource after its effective lifetime has ended (i.e., after it is no longer needed).
- Leaked resources can accumulate and cause denial of service (memory/FD/socket/thread exhaustion), degrade performance, or create secondary failures (deadlocks, stuck handles, inability to accept connections).
- In partial snippets, seeing an acquire/open without a visible release is not automatically CWE-772: release may occur in other functions, destructors/RAII, deferred cleanup, or higher-level lifecycle hooks. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “missing release after lifetime” (static analysis framing)
- Resource:
  - Anything requiring explicit release/close/free/unlock/dispose after use, such as:
    - Memory allocations, file descriptors/FILE*, sockets, database connections, locks, threads, handles, mappings, temporary files, GPU resources.
- Effective lifetime ended:
  - The program has finished using the resource for its intended purpose, but retains it without releasing, or loses track of it so it cannot be released.
- Missing release:
  - No reachable release on some control paths, or release never happens for long-lived processes (per-request/per-loop leaks).

Where CWE-772 typically occurs (sensitive sinks)
- Acquire/open/lock APIs:
  - `malloc/new`, `fopen/open`, `socket/connect`, `accept`, `db.connect/checkout`, `mutex_lock`, `Create*Handle`.
- Error handling and early returns:
  - Failures after partial acquisition that bypass cleanup.
- Loops and request handlers:
  - Per-iteration/per-request acquisition without guaranteed release (high amplification).
- Ownership transfer boundaries:
  - Returning resources without clear ownership; storing in globals/caches without eviction; callbacks that “take ownership” ambiguously.
- Exceptional control flow:
  - Exceptions/longjmp/cancellation paths that skip cleanup.

Common failure modes (reasoning hints, not assumptions)
- Happy-path-only cleanup:
  - Release happens only at the end of the “success” path; error paths leak.
- Forgotten close/free in loops:
  - Each iteration allocates/opens; release missing or only happens under rare conditions.
- Lost handle/pointer:
  - Overwriting a handle without releasing previous one; dropping references so cleanup is impossible.
- Conditional acquisition mismatch:
  - Acquire under certain conditions, but release not conditioned consistently.
- Resource stored but never removed:
  - Adding to caches/collections without removal/eviction, effectively leaking.

What “robust resource lifetime management” looks like (context-specific)
- One-to-one acquire/release discipline:
  - Every successful acquire/open/lock has a corresponding release/close/unlock on all paths.
- Structured cleanup:
  - Central cleanup blocks (`goto cleanup` in C), RAII/smart pointers in C++, or scoped guards.
- Clear ownership contracts:
  - If ownership is transferred, it is explicit and the original owner stops releasing (and stops using).
- Loop-safe patterns:
  - Ensure per-iteration resources are released each iteration, even on errors.
- Bounded retention:
  - For caches/pools, enforce maximum sizes and proper return-to-pool semantics.

Common weak/insufficient defenses (signals of possible risk)
- Relying on process termination:
  - OS will reclaim resources at exit, but long-running services leak over time.
- Cleanup in “somewhere else” without evidence:
  - Assuming a caller/callee will clean up, but contract not clear.
- “Best effort” cleanup without coverage:
  - Cleanup exists but does not dominate all early returns/exceptions.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Cleanup dominates all exits:
    - Single `cleanup:` label that releases all acquired resources.
    - RAII guards that ensure release on scope exit.
  - Explicit `close/free/unlock` paired with acquisition, including in error branches.
  - In loops/request handlers, release occurs within the loop body or guaranteed via scope guards.
  - Ownership transfer is explicit (e.g., setting pointer to NULL after handing off, or documented contract enforced by code).
- Evidence suggesting vulnerability:
  - Acquire/open/lock with no corresponding release on reachable paths.
  - Early returns after acquiring resources without cleanup.
  - Per-request/per-iteration acquisition without release.
  - Overwriting resource variables without releasing the old value.
  - Storing resources in collections/globals without any removal strategy visible.

How to use this guideline under incomplete context
- Inventory resources acquired:
  - Identify each acquisition and the variable/handle storing it.
- Enumerate all exits and exceptional paths:
  - Returns, breaks, gotos, exceptions, error branches, callbacks.
- Search for corresponding release calls:
  - `free/delete`, `close/fclose`, `unlock`, `release/dispose`, `shutdown/close socket`, “return-to-pool”.
- Generate a small number of targeted hypotheses:
  - H1: A resource is acquired but not released on some early-return/error path (leak).
  - H2: Resource is acquired repeatedly (loop/request) without per-iteration release, enabling exhaustion.
  - H3: Ownership is unclear across layers (caller vs callee), causing a missing release after handoff.
  - H4: Release is handled by omitted RAII/wrappers/framework lifecycle hooks → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., acquire + return before cleanup),
  (b) evidence needed to confirm it (e.g., wrapper semantics, object destructor behavior, higher-level lifecycle),
  (c) counter-evidence that would refute it (e.g., scope guards, centralized cleanup, explicit close elsewhere).

Quick red flags in partial code (weak → strong)
- Strong: Resource acquisition in a loop or request handler with no visible close/free/unlock before iteration ends or function returns.
- Medium: Multiple early returns after acquisition; cleanup exists but is bypassable; overwritten handles without releasing old ones.
- Medium: Resources stored globally/in containers with no eviction/removal path visible.
- Weak: Cleanup may be performed by omitted RAII wrappers or managed by outer framework lifecycle not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_772_RULE)
