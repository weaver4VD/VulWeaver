CWE_416_RULE = """
[CWE-416 Reference Guideline | Use After Free | Non-binding, Evidence-first]

Overview
- CWE-416 occurs when the product reuses or references memory after it has been freed.
- After free, the allocator may reassign the same memory region to a different allocation; the original pointer (dangling pointer) may still point into that region. Subsequent reads/writes/calls through the dangling pointer can cause crashes, data corruption, or exploitable behavior.
- In partial snippets, seeing a `free()` and later a pointer use is not automatically proof of UAF: the pointer might be reassigned, ownership might transfer, or the free might be conditional on paths not taken. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “use-after-free” (static analysis framing)
- Use-after-free (UAF):
  - A pointer/reference to an allocation is used (dereferenced, indexed, passed to APIs expecting valid memory, used as object pointer / vtable dispatch, etc.) after the allocation has been freed.
- “Use” includes:
  - Read: `*p`, `p[i]`, `memcpy(dst, p, ...)`, `strcmp(p, ...)`.
  - Write: `*p = ...`, `memset(p, ...)`, `p->field = ...`.
  - Call: calling function pointers / virtual methods via freed object pointer.
  - Free again: UAF can lead into double free; but UAF is the invalid access, not only the second free.
- Aliasing dimension:
  - UAF can occur through an alias of the freed pointer (copy, struct field, global cache entry, container element).

Where CWE-416 typically occurs (sensitive sinks)
- Lifecycle mismatches:
  - Object freed in one path, still referenced by another component (callback, global cache, container).
- Error handling and cleanup:
  - Cleanup frees memory, but code continues to use pointer afterward (or uses it in later cleanup logic).
- Asynchronous/concurrent callbacks:
  - Timeout/cancel/completion handlers use a pointer that may have been freed by another thread or handler.
- Ownership transfer bugs:
  - Callee frees memory but caller continues to use it; or caller frees but callee keeps an internal reference.
- Container and iterator invalidation:
  - Elements freed/removed while another iterator or pointer to the element remains in use.

Common failure modes (reasoning hints, not assumptions)
- Dangling pointer not cleared:
  - After `free(p)`, `p` and its aliases remain non-null and later used.
- Hidden aliases:
  - Pointer stored in a struct, global, or container; freeing one view doesn’t remove/clear all other references.
- Reallocation reuse:
  - After free, new allocation reuses same region; stale pointer now points into a different object’s memory.
- Partial teardown:
  - Freeing sub-objects but leaving parent object referencing them.
- Race conditions:
  - One thread frees, another thread uses concurrently (often paired with CWE-362).

What “safe lifetime management” looks like (context-specific)
- Clear ownership and lifetime:
  - Single owner frees; others hold non-owning references only while guaranteed valid (scoped).
- Invalidate references after free:
  - Set freed pointers to NULL and clear them from structs/containers; update state so callbacks cannot use them.
- RAII / smart pointers (C++):
  - Use `unique_ptr` for unique ownership; `shared_ptr/weak_ptr` for shared ownership with explicit lifetime semantics.
- Reference counting / hazard pointers (C):
  - If shared access is required, use refcounting (with thread-safety) or safe reclamation strategies.
- Synchronize free vs use:
  - Ensure no concurrent access during free; cancel callbacks safely; use locks/atomics/RCU-like patterns as appropriate.

Common weak/insufficient defenses (signals of possible risk)
- Only nulling the local variable:
  - Setting `p = NULL` is insufficient if aliases exist elsewhere (struct fields, globals).
- “Free in destructor + manual free” mix:
  - Complex ownership increases the chance of dangling references.
- Assuming callback order:
  - Relying on “completion happens before timeout” without enforcement.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - After freeing, all known references/aliases are cleared or made unreachable (remove from containers, set struct fields to NULL).
  - Strict ownership transfer: functions that free also set caller-visible pointer to NULL or return ownership explicitly.
  - Use sites guarded by lifetime checks that are actually tied to ownership (e.g., refcount increments, `weak_ptr.lock()` success).
  - Synchronization ensuring no concurrent use during free (lock held, refcount drop to zero, join/cancel barriers).
- Evidence suggesting vulnerability:
  - A pointer (or alias) is dereferenced after a free on a reachable path, without reassignment to a new valid allocation.
  - Free occurs in one branch, but pointer is later used in common epilogue or later logic.
  - Pointer stored globally/in a container, freed elsewhere, but entry not removed/invalidated before later use.
  - Asynchronous handler uses pointer while another path can free it (no mutual exclusion / no refcount).

How to use this guideline under incomplete context
- Identify allocation, ownership, and aliases:
  - Track where the pointer is created, where it’s stored/copied, and who is responsible for freeing it.
- Identify free sites and use sites:
  - Enumerate all frees and all dereferences/uses; consider all control-flow paths and callbacks.
- Determine temporal ordering:
  - Can a use occur after a free on the same path, or via another concurrently executing path?
- Generate a small number of targeted hypotheses:
  - H1: A dangling pointer is used after it is freed on some control-flow path (branch + later use).
  - H2: An alias (struct/global/container) remains after free and is later used (hidden alias UAF).
  - H3: Concurrent/asynchronous path can free while another path uses (race-driven UAF).
  - H4: Lifetime is actually protected elsewhere (RAII, refcounting, synchronized teardown) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., `free(p)` then `p->field` later; pointer stored globally),
  (b) evidence needed to confirm it (e.g., missing paths, callback ordering, alias clearing),
  (c) counter-evidence that would refute it (e.g., pointer reassigned, refcount/RAII, removal from containers, lock discipline).

Quick red flags in partial code (weak → strong)
- Strong: `free(p)` followed by any dereference/call/indexing through `p` or a clear alias on a reachable path; no reassignment.
- Medium: Pointer freed in one function while aliases remain stored elsewhere; later code retrieves and uses it.
- Medium: Asynchronous callbacks or multithreading where one path frees and another uses without refcount/synchronization.
- Weak: Lifetime may be guaranteed by omitted ownership protocols (smart pointers, refcount, confinement) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_416_RULE)
