CWE_200_RULE = """
[CWE-200 Reference Guideline | Exposure of Sensitive Information to an Unauthorized Actor | Non-binding, Evidence-first]

Overview
- CWE-200 occurs when the product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.
- “Exposure” includes returning data in responses, rendering it in views, embedding it in client-side artifacts, or sending it across components where the receiver should not see it.
- In partial snippets, seeing a “sensitive-looking” value is not proof of a leak. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "sensitive information exposure" (static analysis framing)
- Sensitive information:
  - Data that can enable account takeover, privilege escalation, privacy violations, or compromise of confidentiality.
  - Examples (non-exhaustive): credentials/secrets, tokens/session IDs, API keys, private keys, reset links/codes, PII, internal identifiers tied to user identity, internal network/infra details, security configurations.
- Unauthorized actor:
  - Any principal (user/client/service) that lacks explicit permission to access the data.
  - Often arises from missing/incorrect authorization, incorrect scoping/tenant checks, or unintended data propagation.
- Exposure:
  - The data crosses a trust boundary: server → client, service → service, privileged context → unprivileged context, internal → external.

Where sensitive information exposure typically occurs (sensitive sinks)
- HTTP responses / RPC responses:
  - JSON fields, headers, cookies, error responses, redirects that include sensitive data.
- View rendering / templating:
  - Server-side templates (JSP/Thymeleaf/etc.) that include sensitive fields.
- Client-side artifacts:
  - Embedding secrets into HTML/JS, data attributes, page source, or downloadable files.
- Serialization:
  - Auto-serializing objects that include sensitive fields (DTO/entity leakage).
- Cross-tenant / cross-user access paths:
  - Queries or lookups that return objects not scoped to the current principal.

Common failure modes (reasoning hints, not assumptions)
- Returning overly broad objects:
  - Using generic serialization (e.g., entity objects) where sensitive fields are included by default.
- Missing or incorrect access control:
  - No authorization check before returning data; or check exists but doesn’t enforce ownership/tenant scope.
- Confused identity source:
  - Trusting user-supplied identifiers (userId/accountId) to fetch data without verifying it matches the authenticated principal.
- Incomplete redaction/masking:
  - Redacting some fields but forgetting derived/duplicate fields, nested objects, or metadata.
- Using debug/admin paths in normal flows:
  - “Diagnostics” responses accidentally exposed to normal users.

What “safe disclosure control” looks like (context-specific)
- Least disclosure:
  - Return only the minimal fields required for the operation; use explicit DTOs/response schemas.
- Strong authorization + scoping:
  - Verify access for the specific resource instance (ownership/tenant/role) before fetching/returning.
- Explicit sensitive-field handling:
  - Ensure sensitive fields are never serialized by default; require explicit opt-in for exposure.
- Clear trust boundary discipline:
  - Treat all outbound channels as potentially observable by unauthorized parties unless proven otherwise.
- Consistent redaction:
  - Apply a centralized redaction/mapping layer rather than ad-hoc field removal.

Common weak/insufficient defenses (signals of possible risk)
- “We don’t display it in UI”:
  - Data may still be present in JSON/HTML source or client logs if included in responses.
- Partial masking:
  - Masking only in some endpoints or only top-level fields.
- Assuming internal endpoints are safe:
  - Internal RPC endpoints can be reachable via SSRF/misrouting, or reused by external gateways.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit DTO mapping that excludes sensitive fields (e.g., `UserPublicView` vs `UserEntity`).
  - Resource-level authorization checks tied to the authenticated principal before returning data.
  - Explicit selection of safe columns/fields in queries rather than `SELECT *`.
  - Redaction/masking utilities applied consistently at the response boundary.
- Evidence suggesting vulnerability:
  - Returning or rendering objects that likely contain secrets/PII without explicit filtering.
  - Using user-controlled identifiers to fetch and return data without ownership/tenant verification.
  - Serializing internal exceptions/structures that include sensitive data (stack traces, config objects, request objects).
  - Sending sensitive fields to downstream components that don’t require them (over-sharing across service boundaries).

How to use this guideline under incomplete context
- Identify potential sensitive sources:
  - Credentials/tokens/keys/PII/config values present in variables/objects, or retrieved from storage/services.
- Identify outbound sinks (disclosure points):
  - Response bodies, templates, serialization calls, redirects, headers, or inter-service messages.
- Generate a small number of targeted hypotheses:
  - H1: The code returns/renders sensitive fields to a caller without resource-level authorization/scoping.
  - H2: Auto-serialization leaks sensitive nested fields because DTO filtering is absent.
  - H3: Data fetched by user-supplied identifiers is not constrained to the authenticated principal (IDOR-style exposure).
  - H4: Disclosure is actually prevented elsewhere (global filters/DTO mappers/annotations) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., returning entity directly, missing ownership checks),
  (b) evidence needed to confirm it (e.g., DTO definitions, security middleware, auth principal usage),
  (c) counter-evidence that would refute it (e.g., explicit field whitelisting, verified scoping checks).

Quick red flags in partial code (weak → strong)
- Strong: Returning full internal objects/entities (with likely sensitive fields) directly to untrusted callers.
- Medium: Fetching by user-controlled `id` then returning the result without verifying ownership/tenant scope.
- Medium: Rendering sensitive values into templates/HTML/JS without explicit minimization.
- Weak: Disclosure control may be implemented in omitted layers (serialization annotations, response mappers, interceptors) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_200_RULE)
