CWE_134_RULE = """
[CWE-134 Reference Guideline | Use of Externally-Controlled Format String | Non-binding, Evidence-first]

Overview
- CWE-134 occurs when the product uses a function that accepts a format string as an argument, but the format string originates from an external (potentially attacker-controlled) source.
- If an attacker can control the format string, they may trigger unintended reads/writes, memory corruption, crashes, or information disclosure, depending on language/runtime and the specific formatting API.
- In partial snippets, the absence of visible sanitization is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "externally-controlled format string" (static analysis framing)
- Format string:
  - A string interpreted by a formatting function to decide how to print/compose output (e.g., `%s`, `%d`, `%x`, width/precision modifiers, positional arguments).
- Externally-controlled:
  - The format string is derived from untrusted input (network, request params, files, environment variables, IPC, user-controlled configuration).
- Vulnerability pattern:
  - Untrusted data is used as the *format* argument rather than as a *data* argument (i.e., `printf(user)` instead of `printf("%s", user)`).

Where format-string issues typically occur (sensitive sinks)
- C/C++-style formatting APIs:
  - `printf`, `fprintf`, `sprintf`, `snprintf`, `syslog`, `vprintf`, `vsprintf`, `vsnprintf`, and variants/macros wrapping them.
- Logging wrappers and tracing utilities:
  - Custom logging functions that forward a format string to `printf`-like sinks.
- Language/runtime bridges:
  - JNI/FFI boundaries where a Java/Rust/etc. string is forwarded into native `printf`-style formatting.
- Template-like “format” calls that interpret placeholders:
  - If the API interprets directives from the string (not just concatenation), treat it as format-like.

Common failure modes (reasoning hints, not assumptions)
- Direct pass-through:
  - Using an untrusted string as the format parameter (e.g., `printf(input)`).
- Indirect pass-through via wrapper:
  - `log(input)` where `log` internally calls `vfprintf(fmt, ...)`.
- Building format strings from pieces:
  - Concatenating user input into a format string (e.g., `"ERR: " + userFmt`) and passing as format.
- Misplaced escaping:
  - Escaping output for display but still treating user input as the format directive source.

What “safe formatting usage” looks like (context-specific)
- Constant format strings + untrusted data as arguments:
  - Prefer `printf("%s", userInput)` or `fprintf(fd, "%s", msg)`.
- Strictly constrain format templates:
  - If dynamic formatting is required, only allow a predefined set of format tokens (whitelist) and reject everything else.
- Use safer formatting APIs:
  - Prefer APIs that separate template from data and/or enforce type safety where available.
- Clear trust boundaries:
  - Ensure only developer-controlled templates reach format sinks; treat all external strings as data.

Common weak/insufficient defenses (signals of possible risk)
- Blacklisting format tokens:
  - Trying to remove `%n` or `%` by ad-hoc replacements is fragile.
- Partial neutralization:
  - Escaping some characters but leaving others that still form directives.
- Assuming “it’s just logging”:
  - Logging can still be a format sink if it forwards to `printf`-like APIs.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Format argument is a constant literal or comes from a trusted constant set.
  - Untrusted input is only ever used as a data parameter (`"%s"`, `"{}"`, etc.) not as the format/template.
  - Validation that the format string is chosen from a whitelist (enum/table) and never directly from external input.
  - Wrapper functions that enforce `format` to be compile-time constant or validated token set.
- Evidence suggesting vulnerability:
  - External input reaches a `printf`/`sprintf`/`syslog`-like sink as the first format parameter.
  - Wrapper logger takes a single string and forwards it as format (e.g., `log(msg)` → `vfprintf(msg, ...)`).
  - User input is concatenated into a format template that is then interpreted by a formatter.

How to use this guideline under incomplete context
- Identify format sinks:
  - Look for printf-like calls (including wrappers) where the first argument is a string used as a format.
- Identify provenance of the format argument:
  - Is it a string literal/constant? Or derived from request/file/env/config/user?
- Generate a small number of targeted hypotheses:
  - H1: Untrusted input is used directly as the format argument to a printf-like sink.
  - H2: A logging/utility wrapper forwards untrusted strings as format internally.
  - H3: The format string is built using untrusted pieces, enabling directive injection.
  - H4: Format selection is actually constrained elsewhere (factory/enum/config loader) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., `printf(userStr)` or wrapper usage),
  (b) evidence needed to confirm it (e.g., wrapper implementation, input source visibility),
  (c) counter-evidence that would refute it (e.g., constant format string, whitelist enforcement).

Quick red flags in partial code (weak → strong)
- Strong: `printf(userInput)` / `sprintf(buf, userInput, ...)` / `syslog(userInput)` patterns (or equivalent wrappers).
- Medium: Dynamic format strings assembled from untrusted pieces, even if prefixed/suffixed by constants.
- Medium: Wrapper APIs that accept a single message string but are implemented as printf-like format sinks.
- Weak: Formatting may be delegated to a safe API or validated template chooser outside the snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_134_RULE)
