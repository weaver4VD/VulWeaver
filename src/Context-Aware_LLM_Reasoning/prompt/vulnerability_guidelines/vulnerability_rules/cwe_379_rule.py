CWE_379_RULE = """
[CWE-379 Reference Guideline | Creation of Temporary File in Directory with Insecure Permissions | Non-binding, Evidence-first]

Overview
- CWE-379 occurs when a product creates a temporary file in a directory with insecure permissions, allowing unintended or unauthorized actors to access or manipulate that file.
- This can expose sensitive data, allow unauthorized modifications or deletions, and lead to potential security breaches, such as information leakage or data corruption.
- In partial snippets, missing permission checks or insecure directory context is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “temporary files” and “insecure directory permissions” (static analysis framing)
- Temporary files:
  - Files created by the system or application that are intended to store data temporarily (e.g., logs, session data, cache files, uploads).
  - These files may be used by the application for transient purposes and should not be accessible outside the application or by unauthorized users.
- Insecure directory permissions:
  - Permissions that allow unauthorized users or processes to read, write, or execute files within a directory.
  - Common issues include overly permissive read/write/execute permissions (e.g., world-readable, world-writable, or executable directories) or lacking access control altogether.

Where insecure directory permissions often arise (static analysis cues)
- Temporary file creation logic:
  - Any code that handles file creation (e.g., `tmpfile()`, `File.createTempFile()`, `Path.createTempFile()` in Java, or filesystem-based temporary directories).
  - Directories like `/tmp`, `/var/tmp`, or system temporary paths where permissions are not carefully controlled.
- File handling without permission checks:
  - Accessing or manipulating temporary files without confirming that the directory permissions are restrictive enough to prevent unauthorized access.
- Insecure file access configuration:
  - Incorrect use of `chmod`, `umask`, or insufficient restrictions on temporary directories/files, allowing broad access.
  
Typical failure modes (reasoning hints, not assumptions)
- Insecure directory configuration:
  - Temporary files are placed in directories with read/write/execute permissions for everyone (`777` permissions on directories).
- Lack of permission setting after file creation:
  - Temporary files created with default or overly permissive permissions, which are not properly sanitized after creation (i.e., no `chmod` or `umask` set to restrict access).
- Untrusted access to shared directories:
  - Directories used by multiple users or processes that do not properly isolate temporary files (e.g., `/tmp` or `C:\temp`).
- Predictable file names:
  - Use of predictable or guessable filenames for temporary files, allowing attackers to potentially overwrite or access the contents.

What “secure temporary file handling” looks like (context-specific)
- Use of appropriate temporary directories with secure permissions:
  - Temporary files should be created in directories that are restricted to the application’s user or process, with limited access (e.g., `0700` for directory and file permissions).
  - System-wide temporary directories like `/tmp` should be configured with restrictive permissions (e.g., `1777` with sticky bit) to prevent unauthorized access by other users.
- Control over file permissions:
  - Set restrictive file permissions after file creation to prevent unauthorized access or modifications (e.g., `chmod 600` for files).
- Temporary file names should be unpredictable:
  - Use random or non-guessable file names for temporary files to avoid unauthorized access or manipulation.

Common weak/insufficient defenses (signals of possible risk)
- Allowing world-readable or world-writable temporary files:
  - Using default temporary directories or files with excessive permissions (e.g., `/tmp` with `777` permissions or similar).
- Failure to restrict directory access for sensitive files:
  - Creating sensitive temporary files (such as logs, session data, or cryptographic keys) in insecure directories with weak access control.
- Lack of permission sanitization:
  - Temporary files created with default file permissions (e.g., world-readable files) without adjusting their permissions afterward.
- Predictable naming of temporary files:
  - Using predictable filenames or patterns for temporary files that could be exploited by attackers to overwrite or access them.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Use of secure temporary directories with controlled access (e.g., directories with `0700` permissions).
  - Explicit file permission setting after file creation (`chmod 600`, `umask 0777`).
  - Use of unpredictable filenames for temporary files to prevent access or overwriting by unauthorized users.
  - Secure configuration of system-wide temporary directories (e.g., `/tmp` with proper access control settings).
- Evidence suggesting vulnerability:
  - Temporary files are created in directories with insecure or overly permissive permissions (e.g., `777` or `775`).
  - Temporary files created with default permissions that allow unauthorized access (`644`, `755`, etc.).
  - Predictable filenames used for temporary files, making them vulnerable to unauthorized access or overwriting.
  - No explicit permission settings applied after file creation, leaving temporary files accessible to other users.

How to use this guideline under incomplete context
- Identify the temporary file creation pattern and context:
  - What directory is the file created in, and what permissions does it have?
- Identify how the permissions are handled after file creation:
  - Are explicit permissions set after temporary file creation? Is the `umask` or `chmod` used to restrict access?
- Generate a small number of targeted hypotheses:
  - H1: Temporary files are created in insecure directories with permissive access settings.
  - H2: Temporary files are created with default, overly permissive file permissions.
  - H3: File names are predictable, and attackers can guess or overwrite them.
  - H4: Secure permission handling occurs outside the shown snippet (e.g., helper functions not visible here).
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (directory permissions, file permissions, filename generation),
  (b) evidence needed to confirm it (file creation logic, permission settings, directory configuration),
  (c) counter-evidence that would refute it (use of secure temp directories, unpredictable filenames, permission sanitization after file creation).

Quick red flags in partial code (weak → strong)
- Strong: temporary files created in directories with insecure permissions (`777` or overly broad `755`).
- Medium: lack of explicit permission settings after file creation, leaving files with default or weak permissions.
- Medium: predictable file names used for temporary files, making them prone to overwriting or unauthorized access.
- Weak: permission handling may occur in global helper functions not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_379_RULE)
