CWE_24_RULE = """
[CWE-24 Reference Guideline | Path Traversal: '../' Sequences | Non-binding, Evidence-first]

Overview
- CWE-24 occurs when a product uses external input to construct a pathname that is intended to stay within a restricted base directory, but it fails to properly neutralize "../" (and equivalent) traversal sequences, allowing the resolved path to escape the restricted directory.
- In partial snippets, missing validation evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “pathname input” in Java (typical sources)
- HTTP-derived values: query params, path variables, headers/cookies, multipart form fields (e.g., "file", "path", "name", "dir", "subpath").
- File/packaging metadata: uploaded filenames, archive entry names (Zip/Tar) used as relative paths during extraction.
- Cross-component/user-influenced data: message payload fields, DB-stored “path/name” fields, config values only if attacker-controllable.

Security-sensitive path usages (typical sinks)
- File read/write/delete APIs: java.io.File, java.nio.file.Path/Paths/Files, FileInputStream/FileOutputStream, RandomAccessFile.
- Directory-based operations: listing directories, copying/moving files, creating directories under a base directory.
- Archive extraction: writing extracted entries to disk using attacker-influenced entry names.

Typical bypass primitives (reasoning hints, not assumptions)
- Traversal segments: "../", "..\\", repeated traversal, mixed separators, nested traversal (e.g., "a/../../b").
- Encoded traversal: URL-encoding (%2e%2e%2f), double-encoding, Unicode normalization that yields "." or separators.
- Platform differences: separator rules, Windows path quirks (e.g., drive letters) when inputs are not expected to be absolute.

What “proper neutralization/restriction” looks like (context-specific)
- Prefer allow-list mapping:
  - Use stable identifiers (IDs/keys) mapped to fixed safe paths; avoid accepting arbitrary path fragments.
- Constrain input format to the minimum required:
  - If only a filename is needed, reject any separators and enforce strict regex/enum constraints.
- Normalize/canonicalize before enforcing containment:
  - Construct candidate path via Path.resolve(base, userPart) (avoid raw string concatenation).
  - Normalize to eliminate "." and ".." semantics and/or canonicalize (toRealPath / getCanonicalFile) depending on the verification model.
  - Enforce containment: resolved/canonical candidate must remain within the resolved/canonical base directory.
- Treat neutralization as semantic:
  - Do not rely solely on removing "../" substrings; ensure the final resolved path cannot escape base.

Common weak/insufficient defenses (signals of possible risk)
- Textual filtering for "../" only:
  - replace("../","") / forbid "../" without accounting for encodings, separators, repetition, or later decoding/normalization steps.
- Raw string prefix checks:
  - candidate.startsWith(baseDir) on non-canonicalized strings.
- Validating one representation but using another:
  - Validate raw input, then decode/normalize later, reintroducing traversal.
- Partial normalization without containment:
  - normalize() used but no subsequent containment check against canonical base.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Allow-listed ID → mapped to a fixed safe file/path within base directory.
  - In-flow containment enforcement after normalization/canonicalization:
    - baseCanonical = base.toRealPath()/canonical
    - candidate = base.resolve(userPart).normalize()/toRealPath
    - verify candidate starts with baseCanonical (Path-based containment)
  - Input constraints that reliably exclude separators/traversal after all decoding/normalization stages.
- Evidence suggesting vulnerability:
  - External input contributes to a constructed path used in file operations, with no robust “resolve→normalize/canonicalize→containment” barrier in the same dataflow.
  - The only “defense” is textual replacement/blacklist checks around "../".

How to use this guideline under incomplete context
- Generate a small number of targeted hypotheses based on observed sink + path construction pattern:
  - H1: The user-controlled input can include "../" (or equivalents) to escape the restricted directory.
  - H2: The code filters "../" textually but can be bypassed (encoding/separators/repetition or decode-after-validate).
  - H3: A robust containment/allow-list check exists upstream (filter/interceptor/helper), but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it,
  (b) evidence needed to confirm it (e.g., baseDir origin, decoding stage, canonicalization logic, allow-list mapping),
  (c) counter-evidence that would refute it (e.g., in-flow canonical containment check).

Quick red flags in partial code (weak → strong)
- Strong: baseDir + userInput (or resolve without containment) followed by file access, with no normalize/canonicalize + containment.
- Medium: only checks/strips "../" as a substring or blocks a small set of patterns.
- Medium: string startsWith(baseDir) checks without canonicalization.
- Weak: key validation likely occurs outside the shown function → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_24_RULE)