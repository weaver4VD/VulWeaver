CWE_120_RULE = """
[CWE-120 Reference Guideline | Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') | Non-binding, Evidence-first]

Overview
- CWE-120 occurs when the product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer.
- This can lead to a buffer overflow, where data is written beyond the bounds of the output buffer, resulting in potential data corruption, crashes, or arbitrary code execution. Buffer overflows can compromise system stability and security, allowing attackers to overwrite critical memory areas.
- In partial snippets, missing or incorrect buffer size checks are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "buffer copy" and "buffer overflow" (static analysis framing)
- Buffer Copy:
  - The process of copying data from one memory location (the input buffer) to another (the output buffer), typically using functions like `memcpy()`, `strcpy()`, or similar.
  - The copy operation can be risky if the size of the input buffer is not properly validated against the size of the output buffer, leading to potential overflows.
- Buffer Overflow:
  - A condition where more data is copied into a buffer than it can hold, causing the excess data to overwrite adjacent memory, potentially leading to crashes, data corruption, or arbitrary code execution.
  - Buffer overflows often result from poor input validation or the failure to check that the size of the input data does not exceed the allocated size of the output buffer.

Where buffer overflow issues typically occur (sensitive sinks)
- Unsafe string and memory manipulation:
  - Using unsafe functions like `strcpy()`, `memcpy()`, `sprintf()`, or similar that do not automatically check for buffer sizes before copying data.
- Data copying without bounds checks:
  - Copying user-supplied or external data into fixed-size buffers without verifying that the data fits within the allocated memory.
- Input buffer handling:
  - Accepting user input or data from untrusted sources and copying it directly to memory buffers without checking the input size, leading to potential overflows.
- Insecure file handling:
  - Reading files or network data into memory buffers without validating that the input size fits within the allocated buffer space.

Common failure modes (reasoning hints, not assumptions)
- Missing size checks:
  - The product does not verify that the input buffer size is smaller than the output buffer size before copying the data, allowing for buffer overflows.
- Use of unsafe copying functions:
  - Functions like `strcpy()`, `memcpy()`, or `sprintf()` are used without bounds checking or size validation, allowing excessive data to be written into the buffer.
- Insufficient input validation:
  - The product fails to validate the size of input data or does not ensure that it fits within the allocated buffer before performing the copy operation.
- Overly permissive buffer sizes:
  - The output buffer is allocated too large, or the input data is assumed to be smaller than it is, leading to buffer overflows during data copying.

What “proper buffer handling” looks like (context-specific)
- Ensure proper bounds checking:
  - Always verify that the input buffer size is smaller than the output buffer size before copying data, and use functions that perform such checks automatically.
- Use safer memory functions:
  - Use functions like `strncpy()`, `memcpy_s()`, `snprintf()` or equivalent that take the size of the destination buffer into account when copying data.
- Input validation:
  - Validate that input data fits within the bounds of the output buffer before copying it. For example, check that the size of the input string does not exceed the available space in the buffer.
- Buffer size constraints:
  - Limit the size of buffers and ensure that their size is consistent with the expected data they need to hold, preventing overflow situations from occurring.
- Static and dynamic analysis:
  - Use static code analysis tools to identify unsafe buffer copying operations and employ runtime protections such as stack canaries or bounds-checking.

Common weak/insufficient defenses (signals of possible risk)
- No size validation before buffer copy:
  - Data is copied into an output buffer without first checking if the input data will fit, leading to potential overflows.
- Use of unsafe string manipulation functions:
  - Functions like `strcpy()`, `memcpy()`, and `sprintf()` are used without bounds checking or ensuring that the destination buffer has enough space.
- Lack of input sanitization:
  - User input or external data is directly copied into a buffer without validation, allowing attackers to exploit the overflow.
- Miscalculation of buffer sizes:
  - Output buffers are not correctly sized to accommodate the input data, leaving the system vulnerable to overflow when copying data.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Size checks or validations are explicitly performed before copying data into buffers (e.g., `if (input_size < buffer_size)`).
  - Safe memory functions that limit the number of bytes copied based on the size of the destination buffer (e.g., `strncpy()`, `memcpy_s()`).
  - The use of bounds-checked or secure functions, such as `snprintf()` or `strlcpy()`, which ensure data does not overflow the buffer.
  - Input validation that ensures the size of user-supplied data fits within the allocated memory for the buffer.
- Evidence suggesting vulnerability:
  - Direct usage of functions like `strcpy()`, `memcpy()`, or `sprintf()` without validating the size of the input data or the output buffer, allowing for buffer overflows.
  - No checks on the size of the input data before copying it into the buffer, leading to the potential for excessive data being written beyond the buffer’s allocated space.
  - Fixed-size buffers being used without ensuring that input data will fit, leading to the risk of overflow.

How to use this guideline under incomplete context
- Identify the use of buffer copying:
  - Where in the code are buffers being copied or manipulated? Are there checks in place to verify the size of the input data compared to the output buffer?
- Identify the memory functions being used:
  - Are unsafe functions like `strcpy()`, `memcpy()`, or `sprintf()` being used, which do not automatically validate the buffer sizes?
- Generate a small number of targeted hypotheses:
  - H1: The product copies data into buffers without verifying the size of the input data compared to the buffer size, leading to a potential overflow.
  - H2: Unsafe memory functions are used, leaving the system vulnerable to buffer overflows.
  - H3: Input validation is not applied before copying data into the buffer, allowing attackers to exploit the overflow.
  - H4: Buffer sizes are miscalculated or fixed in a way that makes them vulnerable to overflow when larger-than-expected data is copied into them.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unsafe copying functions, lack of bounds checks),
  (b) evidence needed to confirm it (e.g., explicit buffer size checks, safe copying functions),
  (c) counter-evidence that would refute it (e.g., proper buffer size validation, safe memory handling).

Quick red flags in partial code (weak → strong)
- Strong: Unsafe copying functions (e.g., `strcpy()`, `memcpy()`) are used without bounds checking, allowing data to overflow the buffer.
- Medium: Buffer size validation is missing, and the input data is copied directly to the output buffer, potentially exceeding the buffer size.
- Medium: Fixed-size buffers are used without ensuring that the input data will fit, making the system vulnerable to overflow.
- Weak: Buffer handling might be managed by external systems or libraries not visible in the current snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_120_RULE)
