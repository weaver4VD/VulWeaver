CWE_522_RULE = """
[CWE-522 Reference Guideline | Insufficiently Protected Credentials | Non-binding, Evidence-first]

Overview
- CWE-522 occurs when the product transmits or stores authentication credentials using an insecure method that is susceptible to unauthorized interception and/or retrieval.
- “Credentials” includes passwords, API keys, access tokens, session secrets, private keys, refresh tokens, and any authentication material that enables impersonation.
- In partial snippets, seeing a credential variable is not proof of CWE-522. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “insufficiently protected credentials” (static analysis framing)
- Credential material:
  - Passwords/passphrases, shared secrets, API keys, bearer tokens, OAuth client secrets, session signing keys, private keys, device secrets.
- Storage exposure:
  - Persisting credentials in recoverable form (plaintext or trivially reversible encoding), or storing them in an overly accessible location.
- Transmission exposure:
  - Sending credentials over channels that do not provide confidentiality/integrity (e.g., plain HTTP) or embedding them where they can be captured (URLs, headers that leak, client-side artifacts).
- “Insecure method”:
  - Design/implementation choices that allow an unauthorized actor to intercept or retrieve credentials.

Where CWE-522 typically occurs (sensitive sinks)
- Storage sinks:
  - Writing to files/configs, environment files, DB records, caches, client storage, serialized snapshots, backups, artifacts.
- Transmission sinks:
  - HTTP requests/responses, redirects, WebSocket messages, RPC calls, email-like notifications, inter-service messages.
- Credential handling surfaces:
  - Authentication flows, token issuance/refresh, password reset/change, login endpoints, service-to-service auth headers.
- “Convenience” interfaces:
  - CLI flags, debug endpoints, health/status pages that expose config.

Common failure modes (reasoning hints, not assumptions)
- Storing credentials in plaintext or reversible form:
  - Plain strings in config/db; base64/hex encoding mistaken for protection; reversible encryption with hardcoded key.
- Weak or missing channel protection:
  - Sending credentials over HTTP without TLS, or disabling certificate validation in HTTPS clients.
- Credential leakage via placement:
  - Putting credentials in URLs/query strings, referrers, or places likely to be recorded by intermediaries.
- Over-sharing credentials internally:
  - Passing raw credentials to components that do not need them; storing them longer than necessary.
- Hardcoded credentials:
  - Embedding secrets in source code or binaries.
- Insecure key/secret management:
  - Storing encryption keys alongside encrypted credentials, or using fixed keys.

What “proper credential protection” looks like (context-specific)
- Store non-recoverable representations when possible:
  - For passwords: store salted, slow hashes (not reversible).
- Protect secrets at rest:
  - Use secure secret stores / OS keychains / protected configuration mechanisms; restrict file permissions; avoid persisting raw secrets unless necessary.
- Protect secrets in transit:
  - Use TLS with proper certificate validation; avoid plaintext channels for credential-bearing traffic.
- Minimize exposure surface:
  - Do not put credentials in URLs; prefer secure headers/body; avoid returning credentials in responses.
- Reduce lifetime:
  - Avoid logging or persisting; keep credentials in memory only as long as needed; zero sensitive buffers when applicable.

Common weak/insufficient defenses (signals of possible risk)
- Encoding ≠ protection:
  - Base64/URL encoding is not encryption.
- “Encrypted but key is nearby”:
  - Reversible encryption with hardcoded or co-located key offers little real protection.
- TLS but insecure validation:
  - TLS usage with disabled certificate/hostname validation undermines transport protection.
- Masking only on UI:
  - Hiding secrets in UI does not fix insecure storage/transmission.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Password handling uses non-reversible hashing with salt and appropriate work factor.
  - Secrets loaded from secure secret management interfaces (not hardcoded), and not written back to persistent stores.
  - Network transmission uses HTTPS/TLS with strict certificate and hostname validation enabled.
  - Credentials sent in request bodies/secure headers (not URLs), and responses do not echo secrets.
  - Explicit access controls and restrictive permissions for any credential-containing files.
- Evidence suggesting vulnerability:
  - Persisting raw credentials to disk/DB/config/caches, or “encrypting” via base64/hex.
  - Using reversible crypto with hardcoded keys/IVs or weak/constant secrets.
  - Sending credentials over HTTP, or HTTPS clients with certificate validation disabled.
  - Putting credentials in URLs/query parameters or redirect targets.
  - Hardcoded credentials in code paths.

How to use this guideline under incomplete context
- Identify credential sources:
  - Variables/fields named password/token/key/secret, auth headers, login payloads, config secrets.
- Identify storage/transmission sinks:
  - Writes to files/DB/cache; outbound HTTP/RPC calls; redirects; serialization.
- Determine protection mechanisms visible:
  - Hashing vs encryption vs encoding; TLS usage and certificate validation; permission settings.
- Generate a small number of targeted hypotheses:
  - H1: Credentials are stored in recoverable form (plaintext/reversible) or in an overly accessible location.
  - H2: Credentials are transmitted over an insecure channel (no TLS or broken TLS validation).
  - H3: Credentials are placed in leak-prone locations (URL/query/redirect) or are unnecessarily propagated internally.
  - H4: Protection is enforced elsewhere (secret manager, centralized TLS wrapper, secure storage layer) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., `save(password)`, `http://`, base64 “encryption”),
  (b) evidence needed to confirm it (e.g., actual storage schema, channel guarantees, client TLS config),
  (c) counter-evidence that would refute it (e.g., strong hashing, strict TLS validation, secret-store usage).

Quick red flags in partial code (weak → strong)
- Strong: Storing/transmitting raw passwords/tokens; base64-encoding secrets and persisting; hardcoded credentials.
- Medium: HTTPS used but certificate/hostname validation disabled; reversible encryption with hardcoded key.
- Medium: Credentials included in URLs/query parameters or redirect locations.
- Weak: Secure handling may be delegated to omitted frameworks/secret stores/wrappers not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_522_RULE)
