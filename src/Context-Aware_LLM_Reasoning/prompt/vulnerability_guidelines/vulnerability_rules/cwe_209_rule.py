CWE_209_RULE = """
[CWE-209 Reference Guideline | Error Message Contains Sensitive Information | Non-binding, Evidence-first]

Overview
- CWE-209 occurs when a product generates an error message that includes sensitive information about its environment, users, or associated data, and exposes it to an unintended recipient (often an external client).
- The core risk is information disclosure through error handling paths: exceptions, debug outputs, and failure responses can leak secrets or internal details that aid further attacks.
- In partial snippets, missing redaction/exception-mapping evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “sensitive information” in error messages (examples; context-dependent)
- Secrets: passwords, API keys, tokens, cryptographic keys, authorization headers, connection strings with credentials.
- User data: email/phone/address, account identifiers, session IDs, personal records included in exception text.
- Internal environment details:
  - filesystem paths, internal hostnames/IPs, service URLs, topology details
  - database schema/table names, queries with parameters, ORM-generated SQL
  - library/framework versions, stack traces revealing class/method names and code structure
- Derived sensitive content:
  - raw request payloads, headers, cookies, or serialized objects embedded in error output

Where error messages are exposed (typical sinks / channels in Java web apps)
- HTTP responses:
  - response body (JSON/XML/HTML), error pages, exception mappers
  - response headers that include error details
- Application-level responses:
  - API error objects (message/detail/stackTrace fields), debug endpoints
- Indirect exposure:
  - returning exception.toString() / getMessage() to clients
  - templated error views that embed exception details

Typical root causes (reasoning hints, not assumptions)
- Directly returning exception messages/stack traces:
  - e.getMessage(), e.toString(), stack traces included in API response
- Overly verbose error payloads:
  - including request parameters, headers, or internal objects in error responses
- Debug mode leakage:
  - framework debug pages enabled in production-like paths (configuration not shown in snippet)
- Sensitive data embedded in exception text:
  - errors that echo input values (including secrets) or include connection details

What “proper handling” looks like (context-specific)
- Separate internal diagnostics from external error messages:
  - External recipients receive generic messages with non-sensitive error codes.
  - Detailed context is kept internal (not exposed to untrusted recipients).
- Control exception-to-response mapping:
  - Use centralized error handlers that sanitize messages and omit stack traces.
- Avoid echoing sensitive values:
  - Do not include tokens/credentials or full personal data in error strings returned to clients.
- Consider the recipient boundary:
  - Even authenticated users should not receive environment secrets or other users’ data via error messages.

Common weak/insufficient defenses (signals of possible risk)
- Returning raw exception messages to clients:
  - “return e.getMessage()” / “message: ex.toString()” in API error objects
- Including stack traces or class/method names in responses by default
- Building error messages using untrusted data without considering sensitivity:
  - “Invalid token: {token}” or “DB error for user {email}” returned externally
- Assuming “errors are rare”:
  - attackers can trigger errors intentionally to harvest details

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Client-facing errors use generic messages/codes and avoid including exception text/stack traces.
  - Error handling explicitly strips sensitive fields from error payloads.
  - Exceptions are mapped to safe response schemas (no raw environment/user data included).
- Evidence suggesting vulnerability:
  - Error response includes exception.getMessage()/toString() or stack trace content.
  - Error payload includes request headers/cookies/body fragments, connection strings, file paths, or internal identifiers.
  - Error views/templates render exception details directly.

How to use this guideline under incomplete context
- Identify whether the error message reaches an external boundary:
  - Is the message returned in HTTP response bodies/headers/views, or only used internally?
- Generate a small number of targeted hypotheses based on observed error-handling pattern:
  - H1: The code returns raw exception messages/stack traces to clients.
  - H2: The error message interpolates sensitive values (tokens/credentials/user PII).
  - H3: Sanitization is performed by global exception handlers not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (response building, exception mapping, rendered error fields),
  (b) evidence needed to confirm it (global handler config, debug mode, response schemas),
  (c) counter-evidence that would refute it (generic error messages, explicit sanitization, no external exposure).

Quick red flags in partial code (weak → strong)
- Strong: exception.getMessage()/toString() or stack traces are included in HTTP responses or client-facing error objects.
- Medium: error message includes internal paths/hostnames/queries or echoes sensitive request fields.
- Medium: templates/views render exception details directly.
- Weak: sanitization may occur in global handlers not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_209_RULE)