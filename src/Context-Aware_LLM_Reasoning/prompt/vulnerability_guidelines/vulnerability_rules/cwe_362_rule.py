CWE_362_RULE = """
[CWE-362 Reference Guideline | Race Condition (Improper Synchronization on Shared Resource) | Non-binding, Evidence-first]

Overview
- CWE-362 occurs when concurrent code sequences require temporary, exclusive access to a shared resource, but a timing window exists where the shared resource can be modified by another concurrently executing sequence.
- Race conditions can cause lost updates, invariant violations, use-after-free patterns, privilege/authorization bypass (time-of-check to time-of-use), inconsistent reads, crashes, or corruption—depending on what the shared resource represents.
- In partial snippets, seeing “threaded/asynchronous” code is not proof of a race. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “race condition” (static analysis framing)
- Shared resource:
  - Any state accessed by multiple concurrent execution contexts: memory objects, global/static variables, shared heap structures, caches, files, directories, sockets, DB rows, singleton services, maps/collections, session objects.
- Concurrent execution context:
  - Multiple threads, async tasks, thread pools, callbacks, interrupts, signal handlers, event loops, request handlers (server), or multi-process interactions.
- Improper synchronization:
  - Missing/incorrect locking, atomicity, memory visibility, or ordering guarantees needed to preserve invariants across a critical section.
- Timing window:
  - A TOCTOU-like gap between check and use, or between multiple dependent operations on shared state.

Where CWE-362 typically occurs (sensitive sinks)
- Check-then-act sequences on shared state:
  - `if (exists(x)) { use(x); }` without atomicity; “read-modify-write” without locks/atomics.
- Shared collections and caches:
  - Concurrent updates to maps/lists/sets, LRU caches, session stores, singleton registries.
- Lazy initialization / singletons:
  - Double-checked locking done incorrectly; non-atomic publication of objects.
- Resource lifecycle management:
  - Reference counts, freeing/reallocating shared buffers, closing handles while others use them.
- File-system / OS resources:
  - File existence checks followed by open/write/delete; temp file creation patterns; symlink race windows.
- Cross-thread signaling:
  - Flags/booleans used for coordination without atomics/volatile/fences; condition variables used incorrectly.

Common failure modes (reasoning hints, not assumptions)
- Missing critical section:
  - Multiple operations that must be atomic are split without a lock (or lock covers only part).
- Wrong lock object / inconsistent locking:
  - Different code paths protect the same resource with different locks, or sometimes without lock.
- Non-atomic read-modify-write:
  - Increment/decrement or update based on current value without atomic primitives.
- Visibility/order bugs:
  - One thread writes state, another reads without proper memory barriers, leading to stale/partial reads.
- Iteration + mutation races:
  - Iterating a collection while another thread mutates it without synchronization.
- Lock-free misuse:
  - Attempting lock-free patterns without correct atomics, ordering, and invariants.
- TOCTOU across layers:
  - Check performed in one method, use in another, with intervening scheduling points.

What “proper synchronization” looks like (context-specific)
- Define the invariant and the critical section:
  - Identify which operations must be atomic together to preserve correctness/security.
- Use a consistent synchronization strategy:
  - Same lock protects the same resource everywhere; lock acquisition order is consistent to avoid deadlocks.
- Use atomic types/operations where appropriate:
  - For counters/flags, use atomic increments/compare-and-swap rather than plain reads/writes.
- Ensure safe publication:
  - Proper initialization ordering and memory visibility for shared objects (e.g., volatile/atomic publish + fully constructed object).
- Prefer thread-safe structures:
  - Use concurrency-safe collections and still reason about compound operations (thread-safe does not make multi-step logic atomic).

Common weak/insufficient defenses (signals of possible risk)
- “It’s probably single-threaded” assumptions:
  - Server handlers, callbacks, and executors often introduce concurrency even if not obvious.
- Thread-safe container ≠ atomic compound logic:
  - `ConcurrentMap` can still race on check-then-put semantics unless using atomic APIs (e.g., compute/putIfAbsent).
- Overly coarse or partial locking:
  - Locking only around writes but not reads; locking one of multiple related fields.
- Using sleep/timing to “avoid races”:
  - Timing-based mitigation is not synchronization.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - A clearly defined lock/critical section covering the full check+use sequence or full read-modify-write.
  - Consistent use of the same mutex/monitor/lock for all accesses to the shared resource.
  - Atomic APIs used for compound actions (CAS loops, `putIfAbsent/compute`, atomic increment, etc.).
  - Correct condition variable usage (predicate loops, lock held during checks and state transitions).
  - For file races: using atomic OS primitives (e.g., open-with-flags / create-new semantics) instead of check-then-open.
- Evidence suggesting vulnerability:
  - Shared mutable state accessed from multiple threads/tasks without any visible synchronization.
  - Check-then-act patterns on shared state without atomic operations or a lock spanning both steps.
  - Inconsistent locking (different locks, sometimes locked, sometimes not) for the same resource.
  - Publication of shared objects without safe publication (e.g., writing a pointer/reference then later initializing fields).
  - Use of non-atomic flags/counters for coordination across threads.

How to use this guideline under incomplete context
- Identify concurrency sources:
  - Thread creation, executors, async callbacks, event handlers, request handlers, background workers.
- Identify shared resources:
  - Globals/statics, shared singletons, shared maps, shared file paths, shared caches, shared handles.
- Identify compound operations that must be atomic:
  - Check-then-use, read-modify-write, lifecycle transitions (init/use/free), multi-field invariants.
- Generate a small number of targeted hypotheses:
  - H1: Shared mutable state is accessed concurrently without synchronization, enabling inconsistent reads/writes.
  - H2: A check-then-act window exists (TOCTOU) where another thread can change the resource between check and use.
  - H3: Synchronization exists but is inconsistent/incorrect (wrong lock, partial coverage, visibility bug).
  - H4: Concurrency is actually prevented by higher-level guarantees (single-threaded executor, confinement, immutable data) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., shared var + multiple threads + no lock),
  (b) evidence needed to confirm it (e.g., caller threading model, other access sites),
  (c) counter-evidence that would refute it (e.g., confinement, immutable snapshot, consistent lock everywhere).

Quick red flags in partial code (weak → strong)
- Strong: Shared mutable state touched in code reachable by multiple threads, with no lock/atomics, especially in check-then-act or read-modify-write sequences.
- Medium: Lock exists but does not span the full critical sequence, or different paths use different locks for the same resource.
- Medium: Non-atomic flags/counters used for coordination; object published before fully initialized.
- Weak: Thread confinement or serialization might exist outside the snippet (single-threaded event loop, actor model, synchronized wrapper) → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_362_RULE)
