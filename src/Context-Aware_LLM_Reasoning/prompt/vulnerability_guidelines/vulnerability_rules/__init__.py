"""
Lazy loader for `CWE_<id>_RULE` constants.

The original implementation imported every CWE rule module at import time,
which is slow and unnecessary for most runs (a single execution typically
needs only a small subset of CWE rules).
"""

from __future__ import annotations

import importlib
import re
from functools import lru_cache
from typing import Optional

_CWE_RULE_CONST_RE = re.compile(r"^CWE_(\d+)_RULE$")


def _constant_to_module(name: str) -> Optional[str]:
    m = _CWE_RULE_CONST_RE.match(name)
    if not m:
        return None
    num = str(int(m.group(1)))
    return f"cwe_{num}_rule"


@lru_cache(maxsize=1024)
def _load_constant(name: str) -> Optional[str]:
    mod_name = _constant_to_module(name)
    if not mod_name:
        return None
    mod = importlib.import_module(f"{__name__}.{mod_name}")
    return getattr(mod, name, None)


def get_rule(cwe: str) -> Optional[str]:
    """
    Load and return the rule text for a CWE, e.g. "CWE-22" -> CWE_22_RULE.
    """
    if not isinstance(cwe, str):
        return None
    m = re.match(r"^CWE-(\d+)$", cwe.strip(), flags=re.IGNORECASE)
    if not m:
        return None
    const_name = f"CWE_{int(m.group(1))}_RULE"
    return _load_constant(const_name)


def __getattr__(name: str) -> str:
    """
    Backward-compatible access: `vulnerability_rules.CWE_22_RULE`.
    """
    value = _load_constant(name)
    if value is None:
        raise AttributeError(name)
    return value


__all__ = ["get_rule"]
