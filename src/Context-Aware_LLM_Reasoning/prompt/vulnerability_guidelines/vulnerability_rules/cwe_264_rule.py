CWE_264_RULE = """
[CWE-264 Reference Guideline | Permissions / Privileges / Access Controls | Non-binding, Evidence-first]

Overview
- CWE-264 is a broad category covering security issues caused by improper management of permissions, privileges, and access control mechanisms.
- Typical consequences include unauthorized access to resources, privilege escalation, and data exposure due to missing/weak authorization checks, overly broad privileges, or misconfigured access control policies.
- In partial snippets, missing authorization evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “resources” and “actors” (static analysis framing)
- Actors (who initiates the action):
  - unauthenticated users, authenticated users, service accounts, background jobs, administrators
  - upstream components calling APIs (microservices), internal plugins/modules
- Resources (what is being accessed/modified):
  - data objects (projects, accounts, files, records), administrative settings, secrets, system configs
  - operations (create/delete/update, permission changes), execution capabilities (run job, deploy, execute command)
- Access control boundary:
  - any transition from an actor context to a protected resource/action (API endpoints, service methods, controllers, RPC handlers)

Common access control failure modes (reasoning hints, not assumptions)
- Missing authorization:
  - operation performed without checking that the current actor is allowed to do it
- Broken object-level authorization (BOLA/IDOR-style patterns):
  - access control checks exist, but do not bind the resource ID to the requesting actor’s privileges/ownership
- Excessive privilege:
  - performing an operation with admin/system privileges when least privilege is sufficient
  - overly broad roles granted by default
- Confused deputy:
  - trusted component performs sensitive action on behalf of untrusted requester without adequate validation
- Policy mismatch:
  - checks occur at UI/client side only, or checks are inconsistent across endpoints/paths

Typical access-control “sinks” (sensitive operations)
- Reads of protected data:
  - fetching objects by ID, exporting data, downloading files, listing restricted resources
- Writes of protected data:
  - updating records, deleting resources, changing ownership, modifying permissions/roles
- Privilege/role management:
  - granting roles, changing ACLs, issuing tokens, enabling admin features
- Execution capabilities:
  - triggering jobs/builds/deployments, executing scripts/commands, invoking privileged APIs

Evidence cues in code (what to look for around sensitive operations)
- Authentication context:
  - how current user/principal is obtained (session, token, security context)
- Authorization decision points:
  - explicit permission checks (e.g., hasPermission/canAccess/isAdmin/isOwner)
  - framework annotations (e.g., @PreAuthorize, @RolesAllowed) and whether they apply to this path
  - resource-level checks (ownership/tenant/project membership) tied to the specific resource ID used
- Enforcement placement:
  - checks should appear before the sensitive operation (read/write/execute) in the same control flow
  - beware of checks in unrelated branches or after the operation

What “proper access control” looks like (context-specific)
- Explicit, consistent authorization on sensitive operations:
  - verify actor identity (if required) and verify permission for the specific action and specific resource
- Object-level binding:
  - ensure the resource being accessed (by ID/path) is authorized for the current actor (ownership, tenant scoping, membership)
- Least privilege:
  - operations execute with minimal necessary privileges; avoid privileged service accounts unless required and constrained
- Centralized enforcement:
  - prefer shared authorization helpers/interceptors/annotations to avoid missing checks in alternate paths
- Deny-by-default:
  - absence of explicit allow should result in denial, not implicit access

Common weak/insufficient defenses (signals of possible risk)
- UI/client-side checks without server-side enforcement (cannot be trusted).
- Checking only authentication but not authorization:
  - user must be logged in, but any logged-in user can access any resource ID.
- Role checks without resource checks:
  - “isUser” gate but no ownership/tenant binding; “isAdmin” check missing where needed.
- Inconsistent enforcement:
  - one endpoint checks permissions but another path to the same operation does not.
- Over-trusting “internal” calls:
  - assuming internal endpoints/services are safe while they accept attacker-controlled input via chaining.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - clear authorization checks tied to the specific resource/action occur before sensitive operations
  - annotations/interceptors that are evidently active for this method and enforce roles/permissions
  - resource scoping logic (tenant/project/user ownership) is enforced consistently
- Evidence suggesting vulnerability:
  - sensitive operation executed with no visible authorization gate in the same flow
  - resource accessed by externally supplied ID/path without binding to actor’s permissions/ownership
  - privilege-changing operations exposed with weak/no checks
  - use of privileged execution context for user-triggered operations without constraints

How to use this guideline under incomplete context
- Identify the sensitive operation and the resource:
  - what is being read/modified/executed, and what input selects the target resource?
- Identify the actor context:
  - where does the current principal come from? is it required but missing?
- Generate a small number of targeted hypotheses:
  - H1: Authorization is missing for this sensitive operation.
  - H2: Authorization exists but is not object-level (resource ID not bound to actor).
  - H3: Authorization is enforced by framework/interceptors not visible in the snippet.
  - H4: Operation runs with excessive privilege relative to the requester.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (sensitive sink + lack/shape of checks),
  (b) evidence needed to confirm it (security annotations, interceptor config, helper method semantics, ownership checks),
  (c) counter-evidence that would refute it (explicit canAccess checks, resource scoping, deny-by-default logic).

Quick red flags in partial code (weak → strong)
- Strong: externally influenced resource identifier used to read/update/delete without visible object-level authorization.
- Medium: checks verify only “logged in” or only coarse role, but not ownership/tenant/project binding.
- Medium: privilege/role/ACL changes performed with weak/no authorization checks.
- Weak: enforcement may occur in global filters/interceptors/annotations not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_264_RULE)
