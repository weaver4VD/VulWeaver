CWE_400_RULE = """
[CWE-400 Reference Guideline | Uncontrolled Resource Consumption | Non-binding, Evidence-first]

Overview
- CWE-400 occurs when a product fails to properly control the allocation and maintenance of a limited resource, such as memory, CPU, bandwidth, or file handles. This failure can lead to resource exhaustion, resulting in system crashes, degraded performance, or unavailability to legitimate users.
- Uncontrolled resource consumption often stems from improper handling of resources that are finite or can grow uncontrollably (e.g., memory leaks, excessive threading, file handle leaks).
- In partial snippets, missing resource management checks are not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “limited resources” (static analysis framing)
- Memory:
  - heap memory (dynamic allocations), stack space, buffer management, object creation
- CPU:
  - excessive or unregulated computation (CPU-bound processes, infinite loops)
- Bandwidth:
  - network I/O, excessive HTTP requests, large file uploads/downloads
- File handles:
  - file descriptors, open files, database connections
- Other system resources:
  - threads, database connections, GPU resources, cache entries

Where uncontrolled resource consumption occurs (sensitive sinks)
- Network operations:
  - processing large requests, large file uploads, unregulated API calls, denial-of-service-like patterns
- Thread management:
  - spawning threads without limits or checks, excessive concurrent threads without throttling
- Memory management:
  - unbounded memory allocation (e.g., appending to a list, allocating large objects) without proper resource limits
- File management:
  - opening files without closing them, handling file streams poorly, failing to release file handles
- Computational processes:
  - recursive computations, unbounded loops, excessive processing of data without break conditions

Typical failure modes (reasoning hints, not assumptions)
- Resource exhaustion through unbounded growth:
  - creating an unbounded number of objects or threads in a loop or recursive call without limiting or capping
- Resource leakage:
  - not releasing allocated resources (e.g., not closing files, not freeing memory) leading to gradual consumption of available resources
- Inefficient resource usage:
  - consuming too much bandwidth, CPU, or memory in an inefficient manner that degrades system performance
- Unchecked limits:
  - not enforcing limits on input size, data processing, or system calls that could potentially use too many resources
- Poor handling of resource failure conditions:
  - no fallback mechanism when resource allocation fails (e.g., out of memory, thread pool exhaustion)

What “proper resource management” looks like (context-specific)
- Enforce resource limits:
  - set practical limits on memory usage, bandwidth, and file handles; avoid unbounded allocation (e.g., limit the number of concurrent connections or threads)
- Implement resource cleanup:
  - release resources explicitly when they are no longer needed (e.g., close files, free memory, close database connections)
- Use resource pools with throttling:
  - use thread pools, connection pools, and memory buffers to limit the number of resources allocated at a time
- Fail gracefully:
  - handle failures in resource allocation (e.g., memory exhaustion, thread exhaustion) gracefully without crashing the system
- Monitor and log resource consumption:
  - track and log resource usage over time, especially in production systems, to detect abnormal consumption patterns early

Common weak/insufficient defenses (signals of possible risk)
- Unbounded loops or recursion:
  - creating infinite loops or recursive calls that consume increasing resources without limits
- Resource allocation without limit:
  - spawning an unbounded number of threads, processes, or database connections without throttling
- Memory leaks:
  - failing to release memory after use, such as not de-referencing objects or closing files
- Inefficient resource handling:
  - unnecessarily large data buffers, excessive file I/O operations, or inefficient algorithms that consume too much memory/CPU
- No resource monitoring:
  - no system in place to track and control resource consumption dynamically (e.g., no thread limit, no memory usage cap)

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - explicit checks to limit the number of resources allocated (e.g., thread pools, connection pools, limited buffer sizes)
  - resource cleanup logic implemented consistently (e.g., using `finally` blocks for closing resources, closing streams/files immediately after use)
  - system configuration that limits memory usage, database connections, or request handling
  - graceful failure or error handling when resources cannot be allocated (e.g., `OutOfMemoryError`, `ResourceUnavailableException`)
- Evidence suggesting vulnerability:
  - creation of unbounded resources (e.g., unbounded thread creation, indefinite memory allocation)
  - failure to release resources, leading to a resource leak (e.g., unclosed file handles, unfreed memory)
  - resource exhaustion is not handled gracefully, leading to crashes or system freezes
  - lack of limits on input size, processing time, or resource-intensive operations

How to use this guideline under incomplete context
- Identify the resource in question:
  - Is memory, CPU, bandwidth, or file handles being consumed or allocated? What is the resource that needs to be managed?
- Identify where resources are allocated and released:
  - Are there proper mechanisms for releasing resources after use (e.g., `close()`, `free()`)? Are memory and CPU limits being respected?
- Generate a small number of targeted hypotheses:
  - H1: The application allocates unbounded resources (e.g., unlimited threads, memory buffers) without restrictions.
  - H2: Resources are allocated but not cleaned up, leading to leakage and eventual resource exhaustion.
  - H3: Resource limits are checked, but the failure cases are not handled gracefully (e.g., system crash on out-of-memory).
  - H4: Resource management is handled outside the visible code (in global config or helpers).
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (resource creation, memory/thread allocation, file handling),
  (b) evidence needed to confirm it (system configuration, resource limit settings, error-handling logic),
  (c) counter-evidence that would refute it (explicit resource management strategies, system monitoring in place).

Quick red flags in partial code (weak → strong)
- Strong: unbounded resource allocation without limits or cleanup (e.g., infinite threads, memory, or file handles).
- Medium: resource allocation occurs without checks or limits, or cleanup only occurs inconsistently.
- Medium: resource exhaustion (e.g., out-of-memory errors) is not handled gracefully, leading to potential system crashes.
- Weak: resource management may occur in external helper methods, libraries, or configurations not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_400_RULE)
