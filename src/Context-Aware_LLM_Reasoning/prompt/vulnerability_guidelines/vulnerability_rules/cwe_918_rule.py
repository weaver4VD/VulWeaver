CWE_918_RULE = """
[CWE-918 Reference Guideline | Server-Side Request Forgery (SSRF) | Non-binding, Evidence-first]

Overview
- CWE-918 occurs when a web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but does not sufficiently ensure that the request is being sent to the expected destination.
- This can allow attackers to manipulate the server to send requests to internal systems or unauthorized destinations, potentially leading to data breaches, system compromise, or denial of service (DoS).
- In partial snippets, missing or inadequate request validation is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "Server-Side Request Forgery" (static analysis framing)
- SSRF (Server-Side Request Forgery):
  - A type of attack in which an attacker tricks the server into making requests to arbitrary locations (e.g., internal systems, metadata services, or unauthorized external systems) that it is not supposed to access.
  - SSRF vulnerabilities occur when a web server, which processes a URL or request provided by the user, sends requests to resources that it should not, such as internal services or unauthorized destinations.
- Improper validation:
  - When a server fails to properly validate or restrict where it sends requests, allowing attackers to send requests to internal systems or services that would otherwise be inaccessible from outside the network.

Where SSRF issues typically occur (sensitive sinks)
- URL processing:
  - The server processes URLs provided by users or other components (e.g., via HTTP requests, form submissions, or API calls) without properly verifying the URL destination.
- File retrieval mechanisms:
  - The server retrieves files or resources from a URL provided by the user without checking if the URL points to an authorized or safe destination.
- Internal service communication:
  - SSRF vulnerabilities can lead to an attacker forcing the server to interact with internal services or systems (e.g., internal databases, cloud metadata services).
- Proxy or redirect-based requests:
  - If the server uses a proxy or handles redirects based on user input, attackers may manipulate the request to redirect the server to an unauthorized internal service.

Common failure modes (reasoning hints, not assumptions)
- Lack of request validation:
  - The server accepts user-supplied URLs and retrieves them without validating that the URL is within an expected range of destinations (e.g., only allowing requests to external services and disallowing internal services).
- Inadequate destination filtering:
  - The server does not properly filter or restrict requests based on the URL domain, IP address, or other characteristics that would prevent access to internal or unauthorized resources.
- Blind acceptance of user input:
  - Accepting any URL, especially those containing potentially dangerous schemes (e.g., `file://`, `http://localhost`, `http://127.0.0.1`), and blindly fetching data without any context-aware checks.
- Insufficient access controls:
  - Missing or inadequate access controls on internal services or resources that could be accessed via SSRF exploitation, making them vulnerable to external abuse.

What “secure server-side request handling” looks like (context-specific)
- URL validation:
  - Always validate and sanitize the URL before making requests. Only allow known, trusted external URLs and block internal or sensitive destinations (e.g., internal IPs, `localhost`, `127.0.0.1`, cloud metadata services).
- Destination filtering:
  - Implement destination filtering by validating that the requested URL or domain is from a predefined safe list. Block requests to internal or restricted services.
- Use of proper access controls:
  - Ensure that services or resources that should not be accessed externally are protected by access control mechanisms, such as firewalls, authentication, or network segmentation.
- Avoiding direct URL-based resource fetching:
  - Avoid blindly accepting URLs from untrusted sources or making HTTP requests to arbitrary user-defined URLs. Instead, enforce a strict whitelist for allowed URLs or IPs.
- Rate limiting and access logging:
  - Implement rate limiting to mitigate the impact of SSRF attacks and log access to internal resources, monitoring for abnormal or unauthorized access patterns.

Common weak/insufficient defenses (signals of possible risk)
- No URL or destination validation:
  - Allowing URLs to be passed through directly without validation or checks, allowing attackers to manipulate the server into making requests to internal services.
- Insufficient filtering or domain whitelisting:
  - Failing to restrict URLs to a known set of safe external domains or IP addresses, allowing users to request arbitrary internal resources or services.
- Accepting dangerous URL schemes:
  - Allowing dangerous URL schemes (e.g., `file://`, `ftp://`, `localhost`, or `127.0.0.1`) to be processed without restriction, making the server vulnerable to SSRF.
- Lack of internal resource access control:
  - Internal services or systems are exposed to external requests due to insufficient access control, allowing exploitation via SSRF.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Input validation that filters or rejects URLs based on allowed patterns (e.g., only allowing external HTTP/HTTPS requests and blocking internal IP ranges or localhost).
  - Explicit checks for allowed domains or IPs before making requests (e.g., using a whitelist of trusted external services).
  - Proper sanitization or escaping of user-supplied URLs before they are processed or used by the server.
  - Enforced network segmentation or access controls that prevent access to internal services from external requests.
- Evidence suggesting vulnerability:
  - URLs are processed or requested directly from user input without validation, allowing requests to arbitrary locations.
  - No checks for unsafe URL schemes or IP ranges, allowing attackers to send requests to internal resources (e.g., `localhost`, `127.0.0.1`).
  - Missing access control to internal services, making it possible to access internal resources or systems via SSRF.

How to use this guideline under incomplete context
- Identify where URLs are processed:
  - Where in the code are URLs or external requests being handled? Are there checks to ensure these requests go to trusted, external destinations?
- Identify filtering or validation mechanisms:
  - Does the application validate and sanitize user-supplied URLs to ensure they point to safe destinations? Are internal IP addresses or restricted services blocked?
- Generate a small number of targeted hypotheses:
  - H1: User-supplied URLs are being processed without validation, allowing SSRF.
  - H2: URLs to internal resources or restricted services are not properly blocked, allowing attackers to access internal systems.
  - H3: The application accepts unsafe URL schemes, such as `file://` or `http://localhost`, without restriction.
  - H4: Network or access control mechanisms are not in place to prevent external systems from reaching internal resources.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., direct URL fetching without validation, lack of checks for internal addresses),
  (b) evidence needed to confirm it (e.g., URL validation logic, network segmentation),
  (c) counter-evidence that would refute it (e.g., URL whitelisting, use of secure external request libraries).

Quick red flags in partial code (weak → strong)
- Strong: User-controlled URLs are processed directly without any validation or filtering, leading to potential SSRF vulnerabilities.
- Medium: URLs are validated but the scope is too broad, allowing access to restricted or internal destinations.
- Medium: Internal services or systems are exposed to external requests due to lack of proper access controls.
- Weak: URL processing or validation logic might be handled by external libraries or frameworks not visible in the current snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_918_RULE)
