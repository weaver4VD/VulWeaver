CWE_665_RULE = """
[CWE-665 Reference Guideline | Improper Initialization | Non-binding, Evidence-first]

Overview
- CWE-665 occurs when a product does not initialize or incorrectly initializes a resource, leaving it in an unexpected state when it is accessed or used.
- This can lead to undefined behavior, data corruption, or system instability, as the resource may not be in the expected state when interacted with. Improper initialization can occur in various contexts, such as uninitialized variables, memory allocations, or system resources like file handles or network connections.
- In partial snippets, missing or incomplete initialization logic is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “initialization” and “incorrect initialization” (static analysis framing)
- Initialization:
  - The process of preparing a resource, variable, or object to be used in the program, typically by assigning an initial value or setting it to a known, safe state.
  - Examples include initializing variables, allocating memory, opening file handles, or configuring system resources.
- Incorrect initialization:
  - The resource is initialized incorrectly, left uninitialized, or initialized to an unexpected value, which could lead to undefined or unintended behavior.
  - Examples include using default or random values, failing to allocate memory, or initializing with null or invalid states.

Where improper initialization issues typically occur (sensitive sinks)
- Uninitialized variables:
  - Variables that are declared but not given an initial value before being used.
- Memory allocation:
  - Memory allocated but not properly initialized, leading to potentially corrupted or invalid data.
- System resources:
  - Files, network connections, or other system resources that are not initialized or configured properly before use (e.g., file handles not opened correctly, sockets not bound).
- Object initialization:
  - Objects or classes that are instantiated but not initialized to a valid or expected state.

Common failure modes (reasoning hints, not assumptions)
- Failing to initialize variables or resources:
  - A variable is declared but not initialized with a proper value before being used, leading to undefined behavior or memory corruption.
- Incorrect initialization of complex data structures:
  - Data structures like arrays, lists, or objects are initialized but not fully populated or set to default values, causing incomplete data or incorrect results.
- Memory management issues:
  - Memory is allocated but not initialized, leading to access to uninitialized or garbage data.
- Initialization races or ordering issues:
  - A resource is initialized in the wrong order or without proper synchronization, leading to inconsistencies or errors during access.

What “proper initialization” looks like (context-specific)
- Explicit initialization of resources:
  - Always assign a valid, defined value to variables, memory, or system resources before use (e.g., setting default values, allocating and initializing memory, or configuring system resources).
- Ensure proper state for complex data structures:
  - Initialize complex data structures fully and set all elements to a known, valid state before accessing or modifying them.
- Memory initialization:
  - Ensure that memory allocated (e.g., with `malloc()` or `new`) is properly initialized before use (e.g., using `calloc()`, or setting memory to zero with `memset()`).
- System resource initialization:
  - Ensure that resources like file handles, database connections, and network sockets are properly opened, configured, and initialized before use.
- Order of initialization:
  - Ensure that initialization is done in the correct order, especially when resources depend on each other.

Common weak/insufficient defenses (signals of possible risk)
- Uninitialized or randomly initialized variables:
  - Variables that are declared but not explicitly initialized before being used, leading to undefined behavior.
- Memory that is allocated but not initialized:
  - Memory allocated using `malloc()` or `new` but not initialized to a known or safe state.
- System resources not initialized properly:
  - File handles, network connections, or database connections opened but not properly configured, leading to errors or instability.
- Incorrect initialization logic:
  - Objects or data structures initialized to invalid or incomplete states, leading to incorrect functionality or program crashes.
- Race conditions or incorrect initialization order:
  - Resources initialized in the wrong order, leading to dependencies being used before they are set up.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Variables and resources are explicitly initialized to defined, valid values before use (e.g., `int x = 0`, `new MyClass()`).
  - Memory is initialized before it is accessed or used (e.g., using `calloc()` or `memset()`).
  - System resources like file handles and network sockets are properly opened and configured before being used.
- Evidence suggesting vulnerability:
  - Variables declared but not initialized before being used, leading to potential undefined behavior (e.g., `int x;` followed by `x = x + 1;`).
  - Memory allocated but not initialized, leading to garbage values (e.g., `malloc(sizeof(int));` without setting the memory to a known value).
  - System resources accessed or used before being initialized (e.g., accessing a file handle before opening the file, using a network socket before binding it).
  - Objects or data structures initialized to invalid or incomplete states, leading to incorrect results or errors.

How to use this guideline under incomplete context
- Identify where initialization occurs:
  - Where are variables, memory, and system resources initialized in the code? Are they set to valid values before use?
- Identify potential missing or incomplete initialization:
  - Are there resources that are declared but not initialized before being accessed? Is memory allocated without being set to a valid state?
- Generate a small number of targeted hypotheses:
  - H1: Resources (e.g., variables, memory) are declared but not initialized before being used.
  - H2: Memory is allocated but not initialized, leading to the use of garbage values.
  - H3: System resources (e.g., file handles, network sockets) are used before they are properly initialized.
  - H4: Initialization is handled outside the visible code, in libraries or frameworks not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., uninitialized variables, unconfigured resources),
  (b) evidence needed to confirm it (e.g., initialization logic, memory management functions, resource configuration),
  (c) counter-evidence that would refute it (e.g., explicit initialization, proper resource management).

Quick red flags in partial code (weak → strong)
- Strong: variables or resources are used without initialization (e.g., uninitialized variables or memory).
- Medium: memory is allocated but not initialized, or system resources are used before being properly configured.
- Medium: objects or data structures initialized incompletely, with missing or invalid values.
- Weak: initialization logic may be handled in external libraries or frameworks not visible → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_665_RULE)
