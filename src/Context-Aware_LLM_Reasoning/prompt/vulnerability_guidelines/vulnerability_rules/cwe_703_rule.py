CWE_703_RULE = """
[CWE-703 Reference Guideline | Improper Check or Handling of Exceptional Conditions | Non-binding, Evidence-first]

Overview
- CWE-703 occurs when the product does not properly anticipate or handle exceptional conditions that rarely occur during normal operation (e.g., uncommon error returns, partial failures, timeouts, resource exhaustion, malformed inputs, edge-case states).
- Poor handling can lead to crashes, inconsistent state, security bypass, data corruption, resource leaks, or denial of service—especially when attackers can intentionally trigger “rare” conditions.
- In partial snippets, seeing a missing check is not automatically CWE-703: checks may exist elsewhere or conditions may be impossible under established invariants. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “exceptional conditions” (static analysis framing)
- Exceptional condition:
  - Any non-happy-path outcome that code must handle safely:
    - API failures (NULL returns, error codes, exceptions).
    - Timeouts, partial reads/writes, interrupted syscalls.
    - Resource exhaustion (OOM, file descriptor limits).
    - Parsing/validation failures (malformed input).
    - Unexpected states (state machine violations).
    - Concurrency anomalies (race windows, cancellation).
- Improper handling:
  - Not checking errors, checking but ignoring, using unsafe defaults, leaving state half-updated, or handling inconsistently across paths.

Where CWE-703 typically occurs (sensitive sinks)
- Return-value and error-code boundaries:
  - Calls that signal failure via return codes, errno, NULL pointers, or exceptions.
- I/O and network operations:
  - Partial reads/writes, connection resets, retries without cleanup, timeouts.
- Parsing and conversions:
  - Numeric parsing, buffer sizing, decoding, handling empty/oversized inputs.
- Resource management:
  - Allocation failures, lock acquisition failures, file open errors; cleanup on error paths.
- Security-critical checks:
  - Authorization/authentication steps that fail open under error conditions.
- Transaction-like updates:
  - Multi-step state changes that must be atomic or rolled back on failure.

Common failure modes (reasoning hints, not assumptions)
- Unchecked or ignored failure:
  - Calling an API and not checking its return/error; or checking but proceeding anyway.
- Fail-open behavior:
  - On exception/error, default to “allow”, “skip validation”, or “continue with privileged action”.
- Partial update without rollback:
  - First half of an operation succeeds, second fails; system left in inconsistent/insecure state.
- Inconsistent error handling across code paths:
  - Some callers handle errors properly, others don’t; leads to exploitable corner cases.
- Retry loops without bounds/cleanup:
  - Retrying forever, leaking resources per retry, or reusing corrupted state.
- Over-broad catch/handler:
  - Catching all exceptions and swallowing them, masking failures and continuing unsafely.

What “robust exceptional-condition handling” looks like (context-specific)
- Check and propagate errors:
  - Always handle failure signals; if you can’t recover safely, return an error and stop the sensitive operation.
- Fail closed for security decisions:
  - On uncertain/error states, deny access or reject the input rather than allowing.
- Preserve invariants:
  - On failure, either roll back to prior safe state or ensure the system remains consistent.
- Structured cleanup:
  - Ensure resources acquired before the failure are released; avoid partially initialized objects escaping.
- Bounded retries with backoff/cleanup:
  - Retry only when safe, with limits, and with state reset.

Common weak/insufficient defenses (signals of possible risk)
- “Should never fail” assumptions:
  - Treating rare failures as impossible (allocation, I/O, parsing).
- Logging-only handling:
  - Emitting a warning but continuing with unsafe state.
- Silent catch:
  - Swallowing exceptions and proceeding as if success occurred.
- Defaulting to permissive behavior:
  - Returning success, using empty values, or skipping checks on failure.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit checks for known failure modes of called APIs, with safe recovery or error returns.
  - Clear fail-closed handling around auth/validation and other security-sensitive steps.
  - Cleanup/rollback logic that covers all early returns/exceptions.
  - Defensive handling of partial I/O (loop until complete or error; validate lengths).
  - Explicitly bounded retry logic with resource cleanup between attempts.
- Evidence suggesting vulnerability:
  - Failure-prone calls whose return values are unused/unchecked.
  - Catch blocks that swallow exceptions and continue with privileged operations or sensitive sinks.
  - Error handling that substitutes unsafe defaults (e.g., treat parse failure as “0” and proceed).
  - Multi-step updates without rollback/compensation on intermediate failure.
  - Proceeding after an error flag is set, or ignoring error codes.

How to use this guideline under incomplete context
- Identify failure-prone operations:
  - Allocation, I/O, parsing, external calls, lock acquisition, security checks, multi-step updates.
- Identify how failure is signaled:
  - Return codes, NULL, exceptions, status objects, errno.
- Verify handling at call sites:
  - Is failure checked? Is handling safe? Does control flow prevent reaching sensitive operations under failure?
- Generate a small number of targeted hypotheses:
  - H1: A failure condition is not checked/handled, leading to unsafe continuation (crash/state corruption).
  - H2: Error handling is fail-open, enabling security bypass under rare/attacker-triggered failures.
  - H3: Partial failures leave the system in inconsistent state (no rollback/cleanup).
  - H4: Exceptional handling is performed elsewhere (wrappers, higher-level framework, centralized error policy) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unchecked return, swallowed exception, unsafe default),
  (b) evidence needed to confirm it (e.g., semantics of API, upstream guarantees, wrapper behavior),
  (c) counter-evidence that would refute it (e.g., immediate error return, rollback/cleanup, fail-closed guards).

Quick red flags in partial code (weak → strong)
- Strong: Unchecked error returns from critical operations, or catch-all that continues into sensitive actions.
- Medium: Fail-open defaults on parsing/auth/validation failure; partial updates without compensation.
- Medium: Retry loops without bounds or cleanup, especially on attacker-influenced triggers.
- Weak: Error handling may be centralized in omitted layers; semantics of called APIs not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_703_RULE)
