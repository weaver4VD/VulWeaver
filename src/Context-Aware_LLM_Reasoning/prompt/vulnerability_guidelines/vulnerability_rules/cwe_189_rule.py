CWE_189_RULE = """
[CWE-189 Reference Guideline | Numeric Errors (Category) | Non-binding, Evidence-first]

Overview
- CWE-189 is a category covering weaknesses related to improper calculation or conversion of numbers.
- Numeric errors can lead to security-relevant outcomes such as out-of-bounds access, incorrect authorization decisions, logic bypass, resource exhaustion, and data corruption, often by causing values to wrap, truncate, underflow/overflow, or become NaN/Infinity.
- In partial snippets, the absence of visible checks is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as "numeric error" (static analysis framing)
- Numeric error (broad):
  - A flaw where numeric values are computed, compared, cast, or interpreted incorrectly, producing unintended results that influence control flow or memory/resource operations.
- Common numeric error families:
  - Overflow/underflow (signed/unsigned, integer wraparound).
  - Truncation/precision loss (narrowing casts, float-to-int, long-to-int).
  - Sign confusion (treating negative as large due to unsigned conversion).
  - Incorrect boundary checks (off-by-one, wrong comparator, wrong units).
  - Divide-by-zero and exceptional floating-point states (NaN/Infinity).
  - Parsing/conversion mistakes (radix, locale, unexpected formats, partial parse).

Where numeric errors typically occur (sensitive sinks)
- Memory sizing and indexing:
  - Array index, pointer offset, `size + offset`, `count * elemSize`, buffer allocation lengths.
- Loop bounds and termination:
  - `for`/`while` conditions driven by counters that can wrap or never reach the intended bound.
- Resource allocation and limits:
  - Calculating quotas, timeouts, chunk sizes, pagination, rate controls, recursion depth.
- Security decisions and validation:
  - Comparing numeric IDs, privilege levels, timestamps/expirations, token/nonce counters.
- Serialization/deserialization and protocol handling:
  - Reading length fields, converting numeric fields, computing checksums/offsets.

Common failure modes (reasoning hints, not assumptions)
- Overflow in arithmetic before validation:
  - `len = a + b` overflows, then `if (len < MAX)` passes unexpectedly.
- Multiplication overflow in size computation:
  - `bytes = count * elemSize` wraps smaller, leading to undersized allocation and later overflow.
- Signed/unsigned mismatch:
  - Negative values bypass checks or become huge after conversion.
- Narrowing casts:
  - `long` to `int`, `double` to `int`, dropping high bits or fractional parts.
- Off-by-one boundaries:
  - Using `<=` where `<` is intended, inclusive/exclusive mistakes in ranges.
- Parsing ambiguity:
  - `parseInt` on untrusted strings without range checks; partial parsing accepted.
- Floating-point corner cases:
  - NaN comparisons, Infinity propagation, rounding affecting thresholds.

What “robust numeric handling” looks like (context-specific)
- Validate before use at the sink:
  - Check ranges and invariants immediately before indexing/allocation/authorization decisions.
- Use wider types and checked arithmetic:
  - Use APIs/libraries that detect overflow, or manually check (e.g., `if (a > MAX - b)`).
- Normalize units and signedness:
  - Keep consistent units (bytes vs elements, ms vs s) and consistent signedness across computations.
- Safe parsing and conversions:
  - Strict parsing with explicit radix/format; reject invalid/extra characters; apply min/max constraints.
- Defensive boundary logic:
  - Prefer clear inclusive/exclusive conventions; centralize helpers like `isInRange(x, min, maxExclusive)`.

Common weak/insufficient defenses (signals of possible risk)
- Checking after truncation:
  - Casting to smaller type then validating loses information.
- Assumptions about input ranges:
  - Trusting “count won’t be negative” or “size fits in int” without enforcing.
- One-sided checks:
  - Only checking upper bound, missing lower bound (or vice versa).
- Mixed-type arithmetic:
  - Implicit promotions/boxing/unboxing that change semantics.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Explicit range checks (min/max) on externally influenced numbers before they drive sizing/indexing/loops/security decisions.
  - Overflow-aware computations (checked add/mul, guard conditions).
  - Consistent signedness and explicit conversions with validation.
  - Use of safe numeric utilities (e.g., exact/checked operations) and clear invariants near sinks.
- Evidence suggesting vulnerability:
  - Externally influenced numeric values used in allocations, indexing, slicing, loop bounds, or security decisions without visible validation.
  - Narrowing casts on untrusted values before checks.
  - Mixed signed/unsigned comparisons or suspicious conditions that can be bypassed on wraparound.
  - Size math like `count * elemSize` or `offset + len` without overflow guards.

How to use this guideline under incomplete context
- Identify numeric inputs and their provenance:
  - Are numbers derived from user input, file/network, headers, query params, config, environment?
- Identify numeric sinks:
  - Where do these numbers influence memory bounds, resource allocation, loops, or security logic?
- Generate a small number of targeted hypotheses:
  - H1: Overflow/underflow can occur in size/index math, enabling out-of-bounds or undersized allocation.
  - H2: Signed/unsigned or narrowing conversions can bypass validation or flip semantics.
  - H3: Boundary checks are off-by-one or applied to the wrong variable/unit.
  - H4: Numeric validation exists outside the snippet (helpers/framework) → Unknown without evidence.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (e.g., unguarded arithmetic, casts, comparisons),
  (b) evidence needed to confirm it (e.g., upstream validation, checked arithmetic helpers),
  (c) counter-evidence that would refute it (e.g., explicit min/max + overflow guards at sinks).

Quick red flags in partial code (weak → strong)
- Strong: Externally controlled numbers directly drive allocation/indexing/authorization with no nearby range/overflow checks.
- Medium: Size computations using `+`/`*` on untrusted values without overflow guards; narrowing casts before checks.
- Medium: Signed/unsigned mixing where negative values or wraparound could bypass validation.
- Weak: Numeric validation may be centralized elsewhere (validators/parsers/middleware) not visible in the snippet → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_189_RULE)
