CWE_79_RULE = """
[CWE-79 Reference Guideline | Cross-Site Scripting (XSS) | Non-binding, Evidence-first]

Overview
- CWE-79 (Cross-Site Scripting) occurs when user-controllable input is included in web page output without correct, context-appropriate neutralization, causing scripts or script-like payloads to execute in a victim’s browser.
- The key is the output context: HTML body, HTML attribute, URL, JavaScript string, CSS, or DOM insertion each requires different neutralization rules.
- In partial snippets, missing encoding evidence is not proof of vulnerability. Use this guideline to form hypotheses and identify code evidence that would confirm or refute them.

What counts as “user-controllable input” (typical sources)
- HTTP-derived data: query parameters, form fields, path variables, headers (e.g., User-Agent), cookies.
- Persisted user content: DB-stored comments/profiles/messages that are later rendered (stored XSS).
- Indirect sources: message/RPC payload fields or configuration values only if attacker-controllable in context.

Web output sinks / rendering contexts (typical in Java web apps)
- Server-side template rendering:
  - JSP/Servlet output (response.getWriter().print/println/write)
  - Thymeleaf/Freemarker/Velocity/Mustache template variables
  - Spring MVC Model attributes rendered into views
- HTML/JSON generation used by browsers:
  - Returning HTML fragments, inline scripts, JSON embedded in HTML
- Client-side sinks (if code snippet includes JS/templating):
  - DOM insertion patterns (innerHTML, document.write, etc.) or framework bindings

XSS execution contexts (why context matters)
- HTML context: untrusted input placed into HTML body content.
- Attribute context: untrusted input in attributes (href/src/on* handlers, style, data-*).
- URL context: untrusted input used in href/src or redirects; can enable javascript: or data: if not restricted.
- JavaScript context: untrusted input embedded inside JS code or JSON-in-script blocks.
- CSS context: untrusted input in style blocks/attributes (less common but context-sensitive).

What “proper neutralization” looks like (context-specific)
- Prefer safe-by-construction rendering:
  - Use templating engines/framework features that auto-escape by default, and do not disable escaping unless strictly necessary.
  - Treat “render as raw HTML” features (e.g., unescaped output directives) as high-risk and require strict allow-listing/sanitization.
- Apply output encoding that matches the exact context:
  - HTML entity encoding for HTML body.
  - Attribute encoding for attributes; additionally restrict URL schemes for href/src.
  - JavaScript string escaping for JS context; avoid string concatenation in scripts.
  - CSS escaping for CSS context if applicable.
- Constrain input when feasible:
  - For expected formats (names/IDs), enforce allow-list patterns to reduce risky characters.
  - For rich text, use a well-defined allow-list HTML sanitizer (tag/attribute allow-list), not ad-hoc stripping.

Common weak/insufficient defenses (signals of possible risk)
- Blacklist filtering:
  - Removing "<script>" or a few characters/tokens is bypassable (event handlers, SVG, broken tags, encoding tricks).
- Wrong-context encoding:
  - HTML-escaping used inside JS context, or URL context not scheme-restricted, etc.
- Validate-then-transform pitfalls:
  - Validate raw input, then decode/normalize/concatenate later, reintroducing dangerous characters.
- Building HTML/JS by string concatenation:
  - "..." + userInput + "..." in HTML or script blocks.
- “Escaped somewhere else” assumptions:
  - Relying on upstream escaping without visible evidence; treat as Unknown if not shown.

Evidence to look for in code (static snippet oriented)
- Strong evidence of mitigation:
  - Use of templates/framework rendering with default auto-escaping (no raw/unescaped directives for user input).
  - Explicit, context-appropriate encoding at the output boundary (HTML/attribute/JS/CSS), close to the sink.
  - URL scheme restrictions for href/src when user input influences URLs (e.g., allow only http/https, disallow javascript:).
  - Sanitization with allow-list rules when rendering rich HTML content.
- Evidence suggesting vulnerability:
  - User-controllable input written into response HTML (writer.print/write) or template output without visible escaping, especially if used in attributes or scripts.
  - Use of unescaped/raw output mechanisms with user data.
  - HTML/JS assembled via concatenation or format strings with user input.

How to use this guideline under incomplete context
- First identify the output context implied by the sink:
  - HTML body vs attribute vs inline script vs URL vs JSON-in-HTML.
- Generate a small number of targeted hypotheses based on observed rendering pattern:
  - H1: User input reaches HTML output without correct context-specific encoding.
  - H2: Auto-escaping is disabled or bypassed (raw output), enabling injection.
  - H3: Escaping/sanitization exists elsewhere (template defaults, filters, helper methods), but is not shown here.
- For each hypothesis, specify:
  (a) evidence in the snippet supporting it (where data enters output),
  (b) evidence needed to confirm it (template settings, escaping calls, raw output directives),
  (c) counter-evidence that would refute it (auto-escape default preserved, explicit context-aware encoding, allow-list sanitizer).

Quick red flags in partial code (weak → strong)
- Strong: request-derived or persisted user data written into response HTML/JS via string concatenation or raw/unescaped template output.
- Medium: generic “sanitize” or blacklist filtering with unclear semantics or wrong output context.
- Medium: user input used in href/src/on* attributes or inline scripts without clear context-aware handling.
- Weak: escaping may be handled by template defaults or upstream filters not shown → treat as Unknown and reduce confidence.
"""
if __name__ == "__main__":
    print(CWE_79_RULE)
