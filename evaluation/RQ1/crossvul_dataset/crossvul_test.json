[
    {
        "target_file_name": "UsersResource.java",
        "target_method": "graylog2-server/src/main/java/org/graylog2/rest/resources/users/UsersResource.java#generateNewToken",
        "project_url": "https://github.com/Graylog2/graylog2-server",
        "commit_id": "6936bd16a783c2944a3d2f1e83902062520f90e3",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-53106",
        "project_name": "graylog2-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "create",
            "getOrDefault",
            "getTTL",
            "isPermitted",
            "loadUserById"
        ],
        "target_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n\n        if (!isPermitted(USERS_TOKENCREATE, futureOwner.getName())) {\n            throw new ForbiddenException(\"You are not allowed to create a token for user \" + futureOwner.getName() + \".\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "idx": "0"
    },
    {
        "target_file_name": "UsersResource.java",
        "target_method": "graylog2-server/src/main/java/org/graylog2/rest/resources/users/UsersResource.java#generateNewToken",
        "project_url": "https://github.com/Graylog2/graylog2-server",
        "commit_id": "6936bd16a783c2944a3d2f1e83902062520f90e3^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-53106",
        "project_name": "graylog2-server",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "create",
            "getCurrentUser",
            "getOrDefault",
            "isPermitted",
            "loadUserById"
        ],
        "target_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n        final User currentUser = getCurrentUser();\n\n        if (currentUser == null) {\n            throw new ForbiddenException(\"Not allowed to create tokens for unknown user.\");\n        }\n        if (!isPermitted(USERS_TOKENCREATE, currentUser.getName())) {\n            throw new ForbiddenException(currentUser.getName() + \" is not allowed to create token.\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "idx": "1"
    },
    {
        "target_file_name": "UsersResource.java",
        "target_method": "graylog2-server/src/main/java/org/graylog2/rest/resources/users/UsersResource.java#generateNewToken",
        "project_url": "https://github.com/Graylog2/graylog2-server",
        "commit_id": "9215b8f1fd32566c31e6f7447ed864df3590c157",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-53106",
        "project_name": "graylog2-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "create",
            "getOrDefault",
            "getTTL",
            "isPermitted",
            "loadUserById"
        ],
        "target_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n\n        if (!isPermitted(USERS_TOKENCREATE, futureOwner.getName())) {\n            throw new ForbiddenException(\"You are not allowed to create a token for user \" + futureOwner.getName() + \".\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "idx": "2"
    },
    {
        "target_file_name": "UsersResource.java",
        "target_method": "graylog2-server/src/main/java/org/graylog2/rest/resources/users/UsersResource.java#generateNewToken",
        "project_url": "https://github.com/Graylog2/graylog2-server",
        "commit_id": "9215b8f1fd32566c31e6f7447ed864df3590c157^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-53106",
        "project_name": "graylog2-server",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "create",
            "getCurrentUser",
            "getOrDefault",
            "isPermitted",
            "loadUserById"
        ],
        "target_code": "@POST\n    @Path(\"{userId}/tokens/{name}\")\n    @ApiOperation(\"Generates a new access token for a user\")\n    @AuditEvent(type = AuditEventTypes.USER_ACCESS_TOKEN_CREATE)\n    public Token generateNewToken(\n            @ApiParam(name = \"userId\", required = true) @PathParam(\"userId\") String userId,\n            @ApiParam(name = \"name\", value = \"Descriptive name for this token (e.g. 'cronjob') \", required = true) @PathParam(\"name\") String name,\n            @ApiParam(name = \"JSON Body\", value = \"Can optionally contain the token's TTL.\", defaultValue = \"{\\\"token_ttl\\\":null}\") GenerateTokenTTL body) {\n        final User futureOwner = loadUserById(userId);\n        final User currentUser = getCurrentUser();\n\n        if (currentUser == null) {\n            throw new ForbiddenException(\"Not allowed to create tokens for unknown user.\");\n        }\n        if (!isPermitted(USERS_TOKENCREATE, currentUser.getName())) {\n            throw new ForbiddenException(currentUser.getName() + \" is not allowed to create token.\");\n        }\n\n        if (body == null) {\n            body = new GenerateTokenTTL(Optional.empty());\n        }\n        final AccessToken accessToken = accessTokenService.create(futureOwner.getName(), name, body.getTTL(() -> clusterConfigService.getOrDefault(UserConfiguration.class, UserConfiguration.DEFAULT_VALUES).defaultTTLForNewTokens()));\n\n        return Token.create(accessToken.getId(), accessToken.getName(), accessToken.getToken(), accessToken.getLastAccess());\n    }",
        "idx": "3"
    },
    {
        "target_file_name": "AbstractResponseWrapper.java",
        "target_method": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/AbstractResponseWrapper.java#write",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "write"
        ],
        "target_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "idx": "4"
    },
    {
        "target_file_name": "AbstractResponseWrapper.java",
        "target_method": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/AbstractResponseWrapper.java#write",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1^",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "write"
        ],
        "target_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "idx": "5"
    },
    {
        "target_file_name": "ContextualEmitterImpl.java",
        "target_method": "extensions/smallrye-reactive-messaging/runtime/src/main/java/io/quarkus/smallrye/reactivemessaging/runtime/ContextualEmitterImpl.java#sendMessage",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Context.runOnContext",
            "Message.ack",
            "Message.nack",
            "Vertx.currentContext"
        ],
        "target_code": "@Override\n    @CheckReturnValue\n    public <M extends Message<? extends T>> Uni<Void> sendMessage(M msg) {\n        if (msg == null) {\n            throw ex.illegalArgumentForNullValue();\n        }\n\n        // If we are running on a Vert.x context, we need to capture the context to switch back\n        // during the emission.\n        Context context = Vertx.currentContext();\n        // context propagation capture and duplicate the context\n        var msgUni = Uni.createFrom().item(() -> createContextualMessage((Message<? extends T>) msg, context));\n        if (context != null) {\n            msgUni = msgUni.emitOn(r -> context.runOnContext(x -> r.run()));\n        }\n        // emit the message, skip context propagation as it is unnecessary here\n        Uni<Void> uni = transformToUni(msgUni, message -> ContextualEmitterImpl.emitter(e -> {\n            try {\n                emit(message\n                        .withAck(() -> {\n                            e.complete(null);\n                            return msg.ack();\n                        })\n                        .withNack(t -> {\n                            e.fail(t);\n                            return msg.nack(t);\n                        }));\n            } catch (Exception t) {\n                // Capture synchronous exception and nack the message.\n                msg.nack(t);\n                throw t;\n            }\n        }));\n        // switch back to the caller context\n        if (context != null) {\n            return uni.emitOn(r -> context.runOnContext(x -> r.run()));\n        } else {\n            return uni;\n        }\n    }",
        "idx": "6"
    },
    {
        "target_file_name": "ContextualEmitterImpl.java",
        "target_method": "extensions/smallrye-reactive-messaging/runtime/src/main/java/io/quarkus/smallrye/reactivemessaging/runtime/ContextualEmitterImpl.java#sendMessage",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "2b58f59f4bf0bae7d35b1abb585b65f2a66787d1^",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Context.runOnContext",
            "ContextAwareMessage.withContextMetadata",
            "Vertx.currentContext",
            "ack",
            "emit",
            "nack"
        ],
        "target_code": "@Override\n    @CheckReturnValue\n    public <M extends Message<? extends T>> Uni<Void> sendMessage(M msg) {\n        if (msg == null) {\n            throw ex.illegalArgumentForNullValue();\n        }\n\n        // If we are running on a Vert.x context, we need to capture the context to switch back\n        // during the emission.\n        Context context = Vertx.currentContext();\n        // context propagation capture and duplicate the context\n        var msgUni = Uni.createFrom().item(() -> ContextAwareMessage.withContextMetadata((Message<? extends T>) msg));\n        if (context != null) {\n            msgUni = msgUni.emitOn(r -> context.runOnContext(x -> r.run()));\n        }\n        // emit the message, skip context propagation as it is unnecessary here\n        Uni<Void> uni = transformToUni(msgUni, message -> ContextualEmitterImpl.emitter(e -> {\n            try {\n                emit(message\n                        .withAck(() -> {\n                            e.complete(null);\n                            return msg.ack();\n                        })\n                        .withNack(t -> {\n                            e.fail(t);\n                            return msg.nack(t);\n                        }));\n            } catch (Exception t) {\n                // Capture synchronous exception and nack the message.\n                msg.nack(t);\n                throw t;\n            }\n        }));\n        // switch back to the caller context\n        if (context != null) {\n            return uni.emitOn(r -> context.runOnContext(x -> r.run()));\n        } else {\n            return uni;\n        }\n    }",
        "idx": "7"
    },
    {
        "target_file_name": "OpenTestReportGeneratingListener.java",
        "target_method": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListener.java#isEnabled",
        "project_url": "https://github.com/junit-team/junit-framework",
        "commit_id": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
        "CWE_id": "CWE-312",
        "CVE_id": "CVE-2025-53103",
        "project_name": "junit-framework",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getBoolean"
        ],
        "target_code": "private boolean isEnabled(ConfigurationParameters config) {\n\t\treturn config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);\n\t}",
        "idx": "8"
    },
    {
        "target_file_name": "OpenTestReportGeneratingListener.java",
        "target_method": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListener.java#reportInfrastructure",
        "project_url": "https://github.com/junit-team/junit-framework",
        "commit_id": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
        "CWE_id": "CWE-312",
        "CVE_id": "CVE-2025-53103",
        "project_name": "junit-framework",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "InetAddress.getLocalHost",
            "Runtime.getRuntime",
            "Runtime.maxMemory",
            "System.getProperty"
        ],
        "target_code": "private void reportInfrastructure(ConfigurationParameters config) {\n\t\teventsFileWriter.append(infrastructure(), infrastructure -> {\n\t\t\ttry {\n\t\t\t\tString hostName = InetAddress.getLocalHost().getHostName();\n\t\t\t\tinfrastructure.append(hostName(hostName));\n\t\t\t}\n\t\t\tcatch (UnknownHostException ignored) {\n\t\t\t}\n\t\t\tinfrastructure //\n\t\t\t\t\t.append(userName(System.getProperty(\"user.name\"))) //\n\t\t\t\t\t.append(operatingSystem(System.getProperty(\"os.name\"))) //\n\t\t\t\t\t.append(cpuCores(Runtime.getRuntime().availableProcessors())) //\n\t\t\t\t\t.append(javaVersion(System.getProperty(\"java.version\"))) //\n\t\t\t\t\t.append(fileEncoding(System.getProperty(\"file.encoding\"))) //\n\t\t\t\t\t.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));\n\n\t\t\tif (isGitEnabled(config)) {\n\t\t\t\tGitInfoCollector.get(workingDir).ifPresent(git -> addGitInfo(infrastructure, git));\n\t\t\t}\n\t\t});\n\t}",
        "idx": "9"
    },
    {
        "target_file_name": "OpenTestReportGeneratingListener.java",
        "target_method": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListener.java#addGitInfo",
        "project_url": "https://github.com/junit-team/junit-framework",
        "commit_id": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc",
        "CWE_id": "CWE-312",
        "CVE_id": "CVE-2025-53103",
        "project_name": "junit-framework",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getBranch",
            "getCommitHash",
            "getOriginUrl",
            "getStatus"
        ],
        "target_code": "private void addGitInfo(Infrastructure infrastructure, GitInfoCollector git) {\n\t\tgit.getOriginUrl() //\n\t\t\t\t.ifPresent(\n\t\t\t\t\tgitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));\n\t\tgit.getBranch() //\n\t\t\t\t.ifPresent(branch -> infrastructure.append(branch(branch)));\n\t\tgit.getCommitHash() //\n\t\t\t\t.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));\n\t\tgit.getStatus() //\n\t\t\t\t.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),\n\t\t\t\t\tstatus -> status.withClean(statusOutput.isEmpty())));\n\t}",
        "idx": "10"
    },
    {
        "target_file_name": "OpenTestReportGeneratingListener.java",
        "target_method": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListener.java#isEnabled",
        "project_url": "https://github.com/junit-team/junit-framework",
        "commit_id": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc^",
        "CWE_id": "CWE-312",
        "CVE_id": "CVE-2025-53103",
        "project_name": "junit-framework",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getBoolean"
        ],
        "target_code": "private Boolean isEnabled(ConfigurationParameters config) {\n\t\treturn config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);\n\t}",
        "idx": "11"
    },
    {
        "target_file_name": "OpenTestReportGeneratingListener.java",
        "target_method": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListener.java#reportInfrastructure",
        "project_url": "https://github.com/junit-team/junit-framework",
        "commit_id": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc^",
        "CWE_id": "CWE-312",
        "CVE_id": "CVE-2025-53103",
        "project_name": "junit-framework",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "InetAddress.getLocalHost",
            "Runtime.getRuntime",
            "Runtime.getRuntime.availableProcessors",
            "Runtime.getRuntime.maxMemory",
            "System.getProperty"
        ],
        "target_code": "private void reportInfrastructure() {\n\t\teventsFileWriter.append(infrastructure(), infrastructure -> {\n\t\t\ttry {\n\t\t\t\tString hostName = InetAddress.getLocalHost().getHostName();\n\t\t\t\tinfrastructure.append(hostName(hostName));\n\t\t\t}\n\t\t\tcatch (UnknownHostException ignored) {\n\t\t\t}\n\t\t\tinfrastructure //\n\t\t\t\t\t.append(userName(System.getProperty(\"user.name\"))) //\n\t\t\t\t\t.append(operatingSystem(System.getProperty(\"os.name\"))) //\n\t\t\t\t\t.append(cpuCores(Runtime.getRuntime().availableProcessors())) //\n\t\t\t\t\t.append(javaVersion(System.getProperty(\"java.version\"))) //\n\t\t\t\t\t.append(fileEncoding(System.getProperty(\"file.encoding\"))) //\n\t\t\t\t\t.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));\n\n\t\t\taddGitInfo(infrastructure);\n\t\t});\n\t}",
        "idx": "12"
    },
    {
        "target_file_name": "OpenTestReportGeneratingListener.java",
        "target_method": "junit-platform-reporting/src/main/java/org/junit/platform/reporting/open/xml/OpenTestReportGeneratingListener.java#addGitInfo",
        "project_url": "https://github.com/junit-team/junit-framework",
        "commit_id": "d4fc834c8c1c0b3168cd030c13551d1d041f51bc^",
        "CWE_id": "CWE-312",
        "CVE_id": "CVE-2025-53103",
        "project_name": "junit-framework",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "exec"
        ],
        "target_code": "private void addGitInfo(Infrastructure infrastructure) {\n\t\tboolean gitInstalled = exec(\"git\", \"--version\").isPresent();\n\t\tif (gitInstalled) {\n\t\t\texec(\"git\", \"config\", \"--get\", \"remote.origin.url\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(\n\t\t\t\t\t\tgitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));\n\t\t\texec(\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(branch -> infrastructure.append(branch(branch)));\n\t\t\texec(\"git\", \"rev-parse\", \"--verify\", \"HEAD\") //\n\t\t\t\t\t.filter(StringUtils::isNotBlank) //\n\t\t\t\t\t.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));\n\t\t\texec(\"git\", \"status\", \"--porcelain\") //\n\t\t\t\t\t.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),\n\t\t\t\t\t\tstatus -> status.withClean(statusOutput.isEmpty())));\n\t\t}\n\t}",
        "idx": "13"
    },
    {
        "target_file_name": "AbstractResponseWrapper.java",
        "target_method": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/AbstractResponseWrapper.java#write",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "d1ee57e7b826872b6355cfec0ae13465840e232c",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "write"
        ],
        "target_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "idx": "14"
    },
    {
        "target_file_name": "AbstractResponseWrapper.java",
        "target_method": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/AbstractResponseWrapper.java#write",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "d1ee57e7b826872b6355cfec0ae13465840e232c^",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "write"
        ],
        "target_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "idx": "15"
    },
    {
        "target_file_name": "AbstractResponseWrapper.java",
        "target_method": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/AbstractResponseWrapper.java#write",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "31e8a3bfcf4e223788615d5ce25eb929ca251275",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "write"
        ],
        "target_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "idx": "16"
    },
    {
        "target_file_name": "AbstractResponseWrapper.java",
        "target_method": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/AbstractResponseWrapper.java#write",
        "project_url": "https://github.com/quarkusio/quarkus",
        "commit_id": "31e8a3bfcf4e223788615d5ce25eb929ca251275^",
        "CWE_id": "CWE-668",
        "CVE_id": "CVE-2025-49574",
        "project_name": "quarkus",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "write"
        ],
        "target_code": "@Override\n\n    public Future<Void> write(String chunk, String enc) {\n        return delegate.write(chunk, enc);\n    }",
        "idx": "17"
    },
    {
        "target_file_name": "DefaultEncoder.java",
        "target_method": "src/main/java/org/owasp/esapi/reference/DefaultEncoder.java#encodeForSQL",
        "project_url": "https://github.com/ESAPI/esapi-java-legacy",
        "commit_id": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512",
        "CWE_id": "CWE-138",
        "CVE_id": "CVE-2025-5878",
        "project_name": "esapi-java-legacy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "encodeForSQL"
        ],
        "target_code": "@Deprecated\n    public String encodeForSQL(Codec codec, String input) {\n\n        // This will throw if this method is not explicitly enabled in ESAPI.properties.\n        ensureDangerousMethodExplicitlyEnabled( DefaultEncoder.class.getName() + \".encodeForSQL\",\n                                                \"<default>\",\n                                                \"see CVE-2025-5878 and ESAPI Security Bulletin #13 for details\" );\n\n        if( input == null ) {\n            return null;\n        }\n        return codec.encode(IMMUNE_SQL, input);\n    }",
        "idx": "18"
    },
    {
        "target_file_name": "Encoder.java",
        "target_method": "src/main/java/org/owasp/esapi/Encoder.java#encodeForSQL",
        "project_url": "https://github.com/ESAPI/esapi-java-legacy",
        "commit_id": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512",
        "CWE_id": "CWE-138",
        "CVE_id": "CVE-2025-5878",
        "project_name": "esapi-java-legacy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "encodeForSQL"
        ],
        "target_code": "@Deprecated\n     String encodeForSQL(Codec codec, String input);",
        "idx": "19"
    },
    {
        "target_file_name": "DefaultEncoder.java",
        "target_method": "src/main/java/org/owasp/esapi/reference/DefaultEncoder.java#encodeForSQL",
        "project_url": "https://github.com/ESAPI/esapi-java-legacy",
        "commit_id": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512^",
        "CWE_id": "CWE-138",
        "CVE_id": "CVE-2025-5878",
        "project_name": "esapi-java-legacy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "encode"
        ],
        "target_code": "public String encodeForSQL(Codec codec, String input) {\n        if( input == null ) {\n            return null;\n        }\n        return codec.encode(IMMUNE_SQL, input);\n    }",
        "idx": "20"
    },
    {
        "target_file_name": "Encoder.java",
        "target_method": "src/main/java/org/owasp/esapi/Encoder.java#encodeForSQL",
        "project_url": "https://github.com/ESAPI/esapi-java-legacy",
        "commit_id": "f75ac2c2647a81d2cfbdc9c899f8719c240ed512^",
        "CWE_id": "CWE-138",
        "CVE_id": "CVE-2025-5878",
        "project_name": "esapi-java-legacy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "encodeForSQL"
        ],
        "target_code": "String encodeForSQL(Codec codec, String input);",
        "idx": "21"
    },
    {
        "target_file_name": "FileTempleteUtils.java",
        "target_method": "modules/cms/src/main/java/com/jeesite/modules/cms/utils/FileTempleteUtils.java#getFileTempleteByResource",
        "project_url": "https://github.com/thinkgem/jeesite5",
        "commit_id": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-7759",
        "project_name": "jeesite5",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ResourceUtils.getResource"
        ],
        "target_code": "public static FileTemplete getFileTempleteByResource(String fileName) {\n\t\tif (!StringUtils.startsWith(fileName, \"views/modules/cmsfront\")) {\n\t\t\tfileName = \"views/modules/cmsfront/themes/default/index.html\";\n\t\t}\n\t\tResource resource = ResourceUtils.getResource(fileName);\n\t\treturn new FileTemplete(resource, fileName);\n\t}",
        "idx": "22"
    },
    {
        "target_file_name": "ActionEnter.java",
        "target_method": "modules/core/src/main/java/com/jeesite/common/ueditor/ActionEnter.java#invoke",
        "project_url": "https://github.com/thinkgem/jeesite5",
        "commit_id": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-7759",
        "project_name": "jeesite5",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "FileManager",
            "Uploader",
            "listFile"
        ],
        "target_code": "public String invoke() {\n        if (actionType == null || !ActionMap.mapping.containsKey(actionType)) {\n            return new BaseState(false, AppInfo.INVALID_ACTION).toJSONString();\n        }\n        if (this.configManager == null || !this.configManager.valid()) {\n            return new BaseState(false, AppInfo.CONFIG_ERROR).toJSONString();\n        }\n        State state = null;\n        int actionCode = ActionMap.getType(this.actionType);\n        Map<String, Object> conf = null;\n        switch (actionCode) {\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = this.configManager.getConfig(actionCode);\n                state = new Uploader(request, conf).doExec();\n                break;\n            case ActionMap.CATCH_IMAGE:\n//                if (Global.isDemoMode()) {\n//                    state = new BaseState(false, \"演示模式，不允许操作！\");\n//                    break;\n//                }\n//                conf = configManager.getConfig(actionCode);\n//                String[] list = this.request.getParameterValues((String) conf.get(\"fieldName\"));\n//                state = new ImageHunter(request, conf).capture(list);\n\t\t\t\tstate = new BaseState(false, \"该功能暂不提供支持\");\n                break;\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                int start = this.getStartIndex();\n                state = new FileManager(conf).listFile(this.request, start);\n                break;\n        }\n        return state.toJSONString();\n    }",
        "idx": "23"
    },
    {
        "target_file_name": "FileTempleteUtils.java",
        "target_method": "modules/cms/src/main/java/com/jeesite/modules/cms/utils/FileTempleteUtils.java#getFileTempleteByResource",
        "project_url": "https://github.com/thinkgem/jeesite5",
        "commit_id": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-7759",
        "project_name": "jeesite5",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ResourceUtils.getResource"
        ],
        "target_code": "public static FileTemplete getFileTempleteByResource(String fileName) throws IOException {\n\t\tResource resource = ResourceUtils.getResource(fileName);\n\t\treturn new FileTemplete(resource, fileName);\n\t}",
        "idx": "24"
    },
    {
        "target_file_name": "ActionEnter.java",
        "target_method": "modules/core/src/main/java/com/jeesite/common/ueditor/ActionEnter.java#invoke",
        "project_url": "https://github.com/thinkgem/jeesite5",
        "commit_id": "1c5e49b0818037452148e0f8ff69ed04cb8fefdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-7759",
        "project_name": "jeesite5",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "FileManager.listFile",
            "ImageHunter.capture",
            "Uploader.doExec"
        ],
        "target_code": "public String invoke() {\n        if (actionType == null || !ActionMap.mapping.containsKey(actionType)) {\n            return new BaseState(false, AppInfo.INVALID_ACTION).toJSONString();\n        }\n        if (this.configManager == null || !this.configManager.valid()) {\n            return new BaseState(false, AppInfo.CONFIG_ERROR).toJSONString();\n        }\n        State state = null;\n        int actionCode = ActionMap.getType(this.actionType);\n        Map<String, Object> conf = null;\n        switch (actionCode) {\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = this.configManager.getConfig(actionCode);\n                state = new Uploader(request, conf).doExec();\n                break;\n            case ActionMap.CATCH_IMAGE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                String[] list = this.request.getParameterValues((String) conf.get(\"fieldName\"));\n                state = new ImageHunter(request, conf).capture(list);\n                break;\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                if (Global.isDemoMode()) {\n                    state = new BaseState(false, \"演示模式，不允许操作！\");\n                    break;\n                }\n                conf = configManager.getConfig(actionCode);\n                int start = this.getStartIndex();\n                state = new FileManager(conf).listFile(this.request, start);\n                break;\n        }\n        return state.toJSONString();\n    }",
        "idx": "25"
    },
    {
        "target_file_name": "CmsWebFileAdminController.java",
        "target_method": "publiccms-parent/publiccms-core/src/main/java/com/publiccms/controller/admin/cms/CmsWebFileAdminController.java#uploadIco",
        "project_url": "https://github.com/sanluan/PublicCMS",
        "commit_id": "c1e79f124e3f4c458315d908ed7dee06f9f12a76",
        "CWE_id": "CWE-601",
        "CVE_id": "CVE-2025-7949",
        "project_name": "PublicCMS",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteArrayInputStream",
            "CmsFileUtils.delete",
            "CmsFileUtils.mkdirsParent",
            "ImageUtils.image2Ico"
        ],
        "target_code": "@RequestMapping(\"doUploadIco\")\n    @Csrf\n    public String uploadIco(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, String path, MultipartFile file,\n            String filename, String base64File, String originalFilename, int size, boolean overwrite, HttpServletRequest request,\n            ModelMap model) {\n        if (filename.endsWith(\".ico\") && (null != file && !file.isEmpty() || CommonUtils.notEmpty(base64File))) {\n            String originalName;\n            String suffix;\n            if (null != file && !file.isEmpty()) {\n                originalName = file.getOriginalFilename();\n            } else {\n                originalName = originalFilename;\n            }\n            suffix = CmsFileUtils.getSuffix(originalName);\n            String filepath = CommonUtils.joinString(path, Constants.SEPARATOR, filename);\n            String fuleFilePath = siteComponent.getWebFilePath(site.getId(), filepath);\n            try {\n                if (overwrite || !CmsFileUtils.exists(fuleFilePath)) {\n                    CmsFileUtils.mkdirsParent(fuleFilePath);\n                    if (CommonUtils.notEmpty(base64File)) {\n                        try (InputStream inputStream = new ByteArrayInputStream(VerificationUtils.base64Decode(base64File))) {\n                            ImageUtils.image2Ico(inputStream, suffix, size, fuleFilePath);\n                        }\n                    } else {\n                        try (InputStream inputStream = file.getInputStream()) {\n                            ImageUtils.image2Ico(inputStream, suffix, size, fuleFilePath);\n                        }\n                    }\n                    FileUploadResult uploadResult = CmsFileUtils.getFileSize(fuleFilePath, originalName, suffix);\n                    logUploadService.save(new LogUpload(site.getId(), admin.getId(), LogLoginService.CHANNEL_WEB_MANAGER,\n                            filename, false, CmsFileUtils.FILE_TYPE_IMAGE, uploadResult.getFileSize(), uploadResult.getWidth(),\n                            uploadResult.getHeight(), RequestUtils.getIpAddress(request), CommonUtils.getDate(), filepath));\n                }\n            } catch (IOException e) {\n                CmsFileUtils.delete(fuleFilePath);\n                model.addAttribute(CommonConstants.ERROR, e.getMessage());\n                log.error(e.getMessage(), e);\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }",
        "idx": "26"
    },
    {
        "target_file_name": "CmsWebFileAdminController.java",
        "target_method": "publiccms-parent/publiccms-core/src/main/java/com/publiccms/controller/admin/cms/CmsWebFileAdminController.java#uploadIco",
        "project_url": "https://github.com/sanluan/PublicCMS",
        "commit_id": "c1e79f124e3f4c458315d908ed7dee06f9f12a76^",
        "CWE_id": "CWE-601",
        "CVE_id": "CVE-2025-7949",
        "project_name": "PublicCMS",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteArrayInputStream",
            "CmsFileUtils.getFileSize",
            "CmsFileUtils.mkdirsParent",
            "ImageUtils.image2Ico",
            "LogUpload",
            "logUploadService.save"
        ],
        "target_code": "@RequestMapping(\"doUploadIco\")\n    @Csrf\n    public String uploadIco(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, String path, MultipartFile file,\n            String filename, String base64File, String originalFilename, int size, boolean overwrite, HttpServletRequest request,\n            ModelMap model) {\n        if (null != file && !file.isEmpty() || CommonUtils.notEmpty(base64File)) {\n            String originalName;\n            String suffix;\n            if (null != file && !file.isEmpty()) {\n                originalName = file.getOriginalFilename();\n            } else {\n                originalName = originalFilename;\n            }\n            suffix = CmsFileUtils.getSuffix(originalName);\n            try {\n                String filepath = CommonUtils.joinString(path, Constants.SEPARATOR, filename);\n                String fuleFilePath = siteComponent.getWebFilePath(site.getId(), filepath);\n                if (overwrite || !CmsFileUtils.exists(fuleFilePath)) {\n                    CmsFileUtils.mkdirsParent(fuleFilePath);\n                    if (CommonUtils.notEmpty(base64File)) {\n                        try (InputStream inputStream = new ByteArrayInputStream(VerificationUtils.base64Decode(base64File))) {\n                            ImageUtils.image2Ico(inputStream, suffix, size, fuleFilePath);\n                        }\n                    } else {\n                        try (InputStream inputStream = file.getInputStream()) {\n                            ImageUtils.image2Ico(inputStream, suffix, size, fuleFilePath);\n                        }\n                    }\n                    FileUploadResult uploadResult = CmsFileUtils.getFileSize(fuleFilePath, originalName, suffix);\n                    logUploadService.save(new LogUpload(site.getId(), admin.getId(), LogLoginService.CHANNEL_WEB_MANAGER,\n                            filename, false, CmsFileUtils.FILE_TYPE_IMAGE, uploadResult.getFileSize(), uploadResult.getWidth(),\n                            uploadResult.getHeight(), RequestUtils.getIpAddress(request), CommonUtils.getDate(), filepath));\n                }\n            } catch (IOException e) {\n                model.addAttribute(CommonConstants.ERROR, e.getMessage());\n                log.error(e.getMessage(), e);\n                return CommonConstants.TEMPLATE_ERROR;\n            }\n        }\n        return CommonConstants.TEMPLATE_DONE;\n    }",
        "idx": "27"
    },
    {
        "target_file_name": "XWikiDocument.java",
        "target_method": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java#display",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "12b780ccd5bca5fc8f74f46648d7e02fa04fbc11",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-66474",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getMethods",
            "invoke"
        ],
        "target_code": "@Unstable\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, boolean number, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument) context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n\n            StringBuilder builder = new StringBuilder(pref);\n            builder.append(LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()));\n            if (number) {\n                builder.append('_');\n                builder.append(obj.getNumber());\n            }\n            builder.append('_');\n            String prefix = builder.toString();\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1)) {\n                // Escapes closing and opening HTML macro syntax. We need to escape the opening HTML macro syntax in\n                // addition to the closing one as otherwise, the wrapping HTML macro might not close correctly.\n                // For simplicity, to avoid having to deal with complex expressions that would need to be\n                // synchronized with the parser, match just the start of the opening/closing macro syntax.\n                return \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\"\n                    + StringUtils.replaceEach(result.toString(), HTML_MACRO_SEARCH_STRINGS, HTML_MACRO_REPLACE_STRINGS)\n                    + \"{{/html}}\";\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }",
        "idx": "28"
    },
    {
        "target_file_name": "XWikiDocument.java",
        "target_method": "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDocument.java#display",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "12b780ccd5bca5fc8f74f46648d7e02fa04fbc11^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-66474",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getMethods",
            "invoke"
        ],
        "target_code": "@Unstable\n    public String display(String fieldname, String type, String pref, BaseObject obj, String wrappingSyntaxId,\n        boolean isolated, boolean number, XWikiContext context)\n    {\n        if (obj == null) {\n            return \"\";\n        }\n\n        boolean isInRenderingEngine = BooleanUtils.toBoolean((Boolean) context.get(\"isInRenderingEngine\"));\n        HashMap<String, Object> backup = new HashMap<String, Object>();\n        XWikiDocument currentSDoc = (XWikiDocument) context.get(CKEY_SDOC);\n        try {\n            if (isolated) {\n                backupContext(backup, context);\n                setAsContextDoc(context);\n            }\n\n            // Make sure to execute with the right of the document author instead of the content author\n            // (because modifying object property does not modify content author)\n            XWikiDocument sdoc = obj.getOwnerDocument();\n            if (sdoc != null && !Objects.equals(sdoc.getContentAuthorReference(), sdoc.getAuthorReference())) {\n                // Hack the sdoc to make test module believe the content author is the author\n                sdoc = sdoc.clone();\n                sdoc.setContentAuthorReference(sdoc.getAuthorReference());\n                context.put(CKEY_SDOC, sdoc);\n            }\n\n            type = type.toLowerCase();\n            StringBuffer result = new StringBuffer();\n            PropertyClass pclass = (PropertyClass) obj.getXClass(context).get(fieldname);\n\n            StringBuilder builder = new StringBuilder(pref);\n            builder.append(LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()));\n            if (number) {\n                builder.append('_');\n                builder.append(obj.getNumber());\n            }\n            builder.append('_');\n            String prefix = builder.toString();\n\n            if (pclass == null) {\n                return \"\";\n            } else if (pclass.isCustomDisplayed(context)) {\n                pclass.displayCustom(result, fieldname, prefix, type, obj, context);\n            } else if (type.equals(\"view\")) {\n                pclass.displayView(result, fieldname, prefix, obj, isolated, context);\n            } else if (type.equals(\"rendered\")) {\n                String fcontent = pclass.displayView(fieldname, prefix, obj, context);\n                // This mode is deprecated for the new rendering and should also be removed for the old rendering\n                // since the way to implement this now is to choose the type of rendering to do in the class itself.\n                // Thus for the new rendering we simply make this mode work like the \"view\" mode.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    result.append(getRenderedContent(fcontent, getSyntaxId(), context));\n                } else {\n                    result.append(fcontent);\n                }\n            } else if (type.equals(\"edit\")) {\n                context.addDisplayedField(fieldname);\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId)) {\n                    // Don't use pre when not in the rendernig engine since for template we don't evaluate wiki syntax.\n                    if (isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                }\n                pclass.displayEdit(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId)) {\n                    if (isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                }\n            } else if (type.equals(\"hidden\")) {\n                // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does the\n                // escaping. For example for a textarea check the TextAreaClass class.\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{pre}\");\n                }\n                pclass.displayHidden(result, fieldname, prefix, obj, context);\n                if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                    result.append(\"{/pre}\");\n                }\n            } else if (type.equals(\"search\")) {\n                // Backward compatibility\n\n                // Check if the method has been injected using aspects\n                Method searchMethod = null;\n                for (Method method : pclass.getClass().getMethods()) {\n                    if (method.getName().equals(\"displaySearch\") && method.getParameterTypes().length == 5) {\n                        searchMethod = method;\n                        break;\n                    }\n                }\n\n                if (searchMethod != null) {\n                    // If the Syntax id is \"xwiki/1.0\" then use the old rendering subsystem and prevent wiki syntax\n                    // rendering using the pre macro. In the new rendering system it's the XWiki Class itself that does\n                    // the\n                    // escaping. For example for a textarea check the TextAreaClass class.\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{pre}\");\n                    }\n                    prefix = LOCAL_REFERENCE_SERIALIZER.serialize(obj.getXClass(context).getDocumentReference()) + \"_\";\n                    searchMethod.invoke(pclass, result, fieldname, prefix, context.get(\"query\"), context);\n                    if (is10Syntax(wrappingSyntaxId) && isInRenderingEngine) {\n                        result.append(\"{/pre}\");\n                    }\n                } else {\n                    pclass.displayView(result, fieldname, prefix, obj, context);\n                }\n            } else {\n                pclass.displayView(result, fieldname, prefix, obj, context);\n            }\n\n            // If we're in new rendering engine we want to wrap the HTML returned by displayView() in\n            // a {{html/}} macro so that the user doesn't have to do it.\n            // We test if we're inside the rendering engine since it's also possible that this display() method is\n            // called directly from a template and in this case we only want HTML as a result and not wiki syntax.\n            // TODO: find a more generic way to handle html macro because this works only for XWiki 1.0 and XWiki 2.0\n            // Add the {{html}}{{/html}} only when result really contains html or { which could be part of an XWiki\n            // macro syntax since it's not needed for pure text\n            if (isInRenderingEngine && !is10Syntax(wrappingSyntaxId)\n                && (HTMLUtils.containsElementText(result) || result.indexOf(\"{\") != -1)) {\n                result.insert(0, \"{{html clean=\\\"false\\\" wiki=\\\"false\\\"}}\");\n                // Escape closing HTML macro syntax.\n                int startIndex = 0;\n                // Start searching at the last match to avoid scanning the whole string again.\n                while ((startIndex = result.indexOf(CLOSE_HTML_MACRO, startIndex)) != -1) {\n                    result.replace(startIndex, startIndex + 2, \"&#123;&#123;\");\n                }\n                result.append(CLOSE_HTML_MACRO);\n            }\n\n            return result.toString();\n        } catch (Exception ex) {\n            // TODO: It would better to check if the field exists rather than catching an exception\n            // raised by a NPE as this is currently the case here...\n            LOGGER.warn(\"Failed to display field [\" + fieldname + \"] in [\" + type + \"] mode for Object of Class [\"\n                + getDefaultEntityReferenceSerializer().serialize(obj.getDocumentReference()) + \"]\", ex);\n            return \"\";\n        } finally {\n            if (!backup.isEmpty()) {\n                restoreContext(backup, context);\n            }\n            context.put(CKEY_SDOC, currentSDoc);\n        }\n    }",
        "idx": "29"
    },
    {
        "target_file_name": "XHTMLWikiPrinter.java",
        "target_method": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java#printRaw",
        "project_url": "https://github.com/xwiki/xwiki-rendering",
        "commit_id": "9b71a2ee035815cfc29cebbfe81dbdd98f941d49",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-66474",
        "project_name": "xwiki-rendering",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "StringUtils.replaceEach",
            "endsWith",
            "substring"
        ],
        "target_code": "@Override\n    public void printRaw(String raw)\n    {\n        handleSpaceWhenStartElement();\n        // Prevent injecting {{/html}}. As there can be an arbitrary number of spaces before the }}, we actually\n        // escape {{/html. We escape {{/html as well as prefixes of {/html and {html at the end of the raw content to\n        // avoid that raw content and plain texts can be combined to construct the full {{/html}} or {{html}}. This may\n        // cause errors as we might not be using the right escaping for the context (e.g., JSON or HTML comments), but\n        // for this reason we also escape { in JSON output and HTML comments.\n        String escapedRaw = StringUtils.replaceEach(raw, FORBIDDEN_RAW_STRINGS, FORBIDDEN_RAW_REPLACEMENTS);\n\n        // Check all prefixes, they are pre-computed to ensure that this code is as efficient as possible in\n        // particular in the very likely case that no such suffix actually exists.\n        for (String prefix : FORBIDDEN_RAW_SUFFIX_PREFIXES) {\n            if (escapedRaw.endsWith(prefix)) {\n                escapedRaw =\n                    escapedRaw.substring(0, escapedRaw.length() - prefix.length()) + \"&#123;\" + prefix.substring(1);\n                break;\n            }\n        }\n        super.printRaw(escapedRaw);\n        this.elementEnded = true;\n    }",
        "idx": "30"
    },
    {
        "target_file_name": "XHTMLWikiPrinter.java",
        "target_method": "xwiki-rendering-xml/src/main/java/org/xwiki/rendering/renderer/printer/XHTMLWikiPrinter.java#printRaw",
        "project_url": "https://github.com/xwiki/xwiki-rendering",
        "commit_id": "9b71a2ee035815cfc29cebbfe81dbdd98f941d49^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-66474",
        "project_name": "xwiki-rendering",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "endsWith",
            "replace",
            "substring"
        ],
        "target_code": "@Override\n    public void printRaw(String raw)\n    {\n        handleSpaceWhenStartElement();\n        // Prevent injecting {{/html}}. We escape {{/html}} as well as prefixes of {{/html}} at the end of the raw\n        // content to avoid that raw content and plain texts can be combined to construct the full {{/html}}. This may\n        // cause errors as we might not be using the right escaping for the context (e.g., JSON or HTML comments) but\n        // for this reason we also escape in JSON output and HTML comments.\n        String escapedRaw = raw.replace(\"{{/html}}\", \"&#123;&#123;/html}}\");\n\n        StringBuilder prefix = new StringBuilder();\n        for (Character nextChar : List.of('{', '/', 'h', 't', 'm', 'l', '}', '}')) {\n            prefix.append(nextChar);\n\n            if (escapedRaw.endsWith(prefix.toString())) {\n                escapedRaw =\n                    escapedRaw.substring(0, escapedRaw.length() - prefix.length()) + \"&#123;\" + prefix.substring(1);\n                break;\n            }\n        }\n        super.printRaw(escapedRaw);\n        this.elementEnded = true;\n    }",
        "idx": "31"
    },
    {
        "target_file_name": "SQLManager.java",
        "target_method": "h2o-core/src/main/java/water/jdbc/SQLManager.java#validateJdbcUrl",
        "project_url": "https://github.com/h2oai/h2o-3",
        "commit_id": "0298ee348f5c73673b7b542158081e79605f5f25",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-6544",
        "project_name": "h2o-3",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public static void validateJdbcUrl(String jdbcUrl) throws IllegalArgumentException {\n    if (jdbcUrl == null || jdbcUrl.trim().isEmpty()) {\n      throw new IllegalArgumentException(\"JDBC URL is null or empty\");\n    }\n\n    String previous = null;\n    String jdbcUrlDecode = jdbcUrl;\n    try {\n      for (int i = 0; i < 10; i++) {\n        previous = jdbcUrlDecode;\n        jdbcUrlDecode = URLDecoder.decode(jdbcUrlDecode, \"UTF-8\");\n        if (previous.equals(jdbcUrlDecode)) {\n          break;\n        }\n      }\n    } catch (UnsupportedEncodingException e) {\n      throw new IllegalArgumentException(\"JDBC URL has wrong encoding\");\n    }\n    \n    if (!previous.equals(jdbcUrlDecode)) {\n      throw new IllegalArgumentException(\"JDBC URL contains invalid characters\");\n    }\n\n    if (!jdbcUrlDecode.toLowerCase().startsWith(\"jdbc:\")) {\n      throw new IllegalArgumentException(\"JDBC URL must start with 'jdbc:'\");\n    }\n\n    Matcher matcher = JDBC_PARAMETERS_REGEX_PATTERN.matcher(jdbcUrlDecode);\n    String property = System.getProperty(DISALLOWED_JDBC_PARAMETERS_PARAM);\n    List<String> disallowedParameters = property == null ?\n            DEFAULT_JDBC_DISALLOWED_PARAMETERS :\n            Arrays.stream(property.split(\",\")).map(String::toLowerCase).collect(Collectors.toList());\n\n    while (matcher.find()) {\n      String key = matcher.group(1);\n      if (disallowedParameters.contains(key.toLowerCase())) {\n        throw new IllegalArgumentException(\"Potentially dangerous JDBC parameter found: \" + key +\n                \". That behavior can be altered by setting \" + DISALLOWED_JDBC_PARAMETERS_PARAM + \" env variable to another comma separated list.\");\n      }\n    }\n  }",
        "idx": "32"
    },
    {
        "target_file_name": "SQLManager.java",
        "target_method": "h2o-core/src/main/java/water/jdbc/SQLManager.java#validateJdbcUrl",
        "project_url": "https://github.com/h2oai/h2o-3",
        "commit_id": "0298ee348f5c73673b7b542158081e79605f5f25^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-6544",
        "project_name": "h2o-3",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Arrays.stream",
            "Collectors.toList",
            "System.getProperty"
        ],
        "target_code": "public static void validateJdbcUrl(String jdbcUrl) throws IllegalArgumentException {\n    if (jdbcUrl == null || jdbcUrl.trim().isEmpty()) {\n      throw new IllegalArgumentException(\"JDBC URL is null or empty\");\n    }\n\n    if (!jdbcUrl.toLowerCase().startsWith(\"jdbc:\")) {\n      throw new IllegalArgumentException(\"JDBC URL must start with 'jdbc:'\");\n    }\n\n    Matcher matcher = JDBC_PARAMETERS_REGEX_PATTERN.matcher(jdbcUrl);\n    String property = System.getProperty(DISALLOWED_JDBC_PARAMETERS_PARAM);\n    List<String> disallowedParameters = property == null ?\n            DEFAULT_JDBC_DISALLOWED_PARAMETERS :\n            Arrays.stream(property.split(\",\")).map(String::toLowerCase).collect(Collectors.toList());\n\n    while (matcher.find()) {\n      String key = matcher.group(1);\n      if (disallowedParameters.contains(key.toLowerCase())) {\n        throw new IllegalArgumentException(\"Potentially dangerous JDBC parameter found: \" + key +\n                \". That behavior can be altered by setting \" + DISALLOWED_JDBC_PARAMETERS_PARAM + \" env variable to another comma separated list.\");\n      }\n    }\n  }",
        "idx": "33"
    },
    {
        "target_file_name": "ConvertMarkdownToPdf.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertMarkdownToPdf.java#markdownToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "FileToPdf.convertHtmlToPdf",
            "pdfDocumentFactory.createNewBytesBasedOnOldDocument"
        ],
        "target_code": "@PostMapping(consumes = \"multipart/form-data\", value = \"/markdown/pdf\")\n    @Operation(\n            summary = \"Convert a Markdown file to PDF\",\n            description =\n                    \"This endpoint takes a Markdown file input, converts it to HTML, and then to\"\n                            + \" PDF format. Input:MARKDOWN Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> markdownToPdf(@ModelAttribute GeneralFile generalFile)\n            throws Exception {\n        MultipartFile fileInput = generalFile.getFileInput();\n\n        if (fileInput == null) {\n            throw ExceptionUtils.createIllegalArgumentException(\n                    \"error.fileFormatRequired\", \"File must be in {0} format\", \"Markdown\");\n        }\n\n        String originalFilename = Filenames.toSimpleFileName(fileInput.getOriginalFilename());\n        if (originalFilename == null || !originalFilename.endsWith(\".md\")) {\n            throw ExceptionUtils.createIllegalArgumentException(\n                    \"error.fileFormatRequired\", \"File must be in {0} format\", \".md\");\n        }\n\n        // Convert Markdown to HTML using CommonMark\n        List<Extension> extensions = List.of(TablesExtension.create());\n        Parser parser = Parser.builder().extensions(extensions).build();\n\n        Node document = parser.parse(new String(fileInput.getBytes()));\n        HtmlRenderer renderer =\n                HtmlRenderer.builder()\n                        .attributeProviderFactory(context -> new TableAttributeProvider())\n                        .extensions(extensions)\n                        .build();\n\n        String htmlContent = renderer.render(document);\n\n        byte[] pdfBytes =\n                FileToPdf.convertHtmlToPdf(\n                        runtimePathConfig.getWeasyPrintPath(),\n                        null,\n                        htmlContent.getBytes(),\n                        \"converted.html\",\n                        tempFileManager,\n                        customHtmlSanitizer);\n        pdfBytes = pdfDocumentFactory.createNewBytesBasedOnOldDocument(pdfBytes);\n        String outputFilename =\n                originalFilename.replaceFirst(\"[.][^.]+$\", \"\")\n                        + \".pdf\"; // Remove file extension and append .pdf\n        return WebResponseUtils.bytesToWebResponse(pdfBytes, outputFilename);\n    }",
        "idx": "34"
    },
    {
        "target_file_name": "EmlToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/EmlToPdf.java#convertEmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "attachFilesToPdf",
            "convertHtmlToPdf"
        ],
        "target_code": "public static byte[] convertEmlToPdf(\n            String weasyprintPath,\n            EmlToPdfRequest request,\n            byte[] emlBytes,\n            String fileName,\n            stirling.software.common.service.CustomPDFDocumentFactory pdfDocumentFactory,\n            TempFileManager tempFileManager,\n            CustomHtmlSanitizer customHtmlSanitizer)\n            throws IOException, InterruptedException {\n\n        validateEmlInput(emlBytes);\n\n        try {\n            // Generate HTML representation\n            EmailContent emailContent = null;\n            String htmlContent;\n\n            if (isJakartaMailAvailable()) {\n                emailContent = extractEmailContentAdvanced(emlBytes, request);\n                htmlContent = generateEnhancedEmailHtml(emailContent, request);\n            } else {\n                htmlContent = convertEmlToHtmlBasic(emlBytes, request);\n            }\n\n            // Convert HTML to PDF\n            byte[] pdfBytes =\n                    convertHtmlToPdf(\n                            weasyprintPath,\n                            request,\n                            htmlContent,\n                            tempFileManager,\n                            customHtmlSanitizer);\n\n            // Attach files if available and requested\n            if (shouldAttachFiles(emailContent, request)) {\n                pdfBytes =\n                        attachFilesToPdf(\n                                pdfBytes, emailContent.getAttachments(), pdfDocumentFactory);\n            }\n\n            return pdfBytes;\n\n        } catch (IOException | InterruptedException e) {\n            log.error(\"Failed to convert EML to PDF for file: {}\", fileName, e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Unexpected error during EML to PDF conversion for file: {}\", fileName, e);\n            throw new IOException(\"Conversion failed: \" + e.getMessage(), e);\n        }\n    }",
        "idx": "35"
    },
    {
        "target_file_name": "EmlToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/EmlToPdf.java#convertHtmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "FileToPdf.convertHtmlToPdf",
            "getBytes",
            "simplifyHtmlContent"
        ],
        "target_code": "private static byte[] convertHtmlToPdf(\n            String weasyprintPath,\n            EmlToPdfRequest request,\n            String htmlContent,\n            TempFileManager tempFileManager,\n            CustomHtmlSanitizer customHtmlSanitizer)\n            throws IOException, InterruptedException {\n\n        HTMLToPdfRequest htmlRequest = createHtmlRequest(request);\n\n        try {\n            return FileToPdf.convertHtmlToPdf(\n                    weasyprintPath,\n                    htmlRequest,\n                    htmlContent.getBytes(StandardCharsets.UTF_8),\n                    \"email.html\",\n                    tempFileManager,\n                    customHtmlSanitizer);\n        } catch (IOException | InterruptedException e) {\n            log.warn(\"Initial HTML to PDF conversion failed, trying with simplified HTML\");\n            String simplifiedHtml = simplifyHtmlContent(htmlContent);\n            return FileToPdf.convertHtmlToPdf(\n                    weasyprintPath,\n                    htmlRequest,\n                    simplifiedHtml.getBytes(StandardCharsets.UTF_8),\n                    \"email.html\",\n                    tempFileManager,\n                    customHtmlSanitizer);\n        }\n    }",
        "idx": "36"
    },
    {
        "target_file_name": "ConvertEmlToPDF.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertEmlToPDF.java#convertEmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "EmlToPdf.convertEmlToPdf",
            "MultipartFile",
            "WebResponseUtils.bytesToWebResponse",
            "getBytes"
        ],
        "target_code": "@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n    @Operation(\n            summary = \"Convert EML to PDF\",\n            description =\n                    \"This endpoint converts EML (email) files to PDF format with extensive\"\n                            + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n                            + \" and HTML debug output. Input: EML file, Output: PDF\"\n                            + \" or HTML file. Type: SISO\")\n    public ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n\n        MultipartFile inputFile = request.getFileInput();\n        String originalFilename = inputFile.getOriginalFilename();\n\n        // Validate input\n        if (inputFile.isEmpty()) {\n            log.error(\"No file provided for EML to PDF conversion.\");\n            return ResponseEntity.badRequest()\n                    .body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        if (originalFilename == null || originalFilename.trim().isEmpty()) {\n            log.error(\"Filename is null or empty.\");\n            return ResponseEntity.badRequest()\n                    .body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        // Validate file type - support EML\n        String lowerFilename = originalFilename.toLowerCase();\n        if (!lowerFilename.endsWith(\".eml\")) {\n            log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n            return ResponseEntity.badRequest()\n                    .body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n\n        try {\n            byte[] fileBytes = inputFile.getBytes();\n\n            if (request.isDownloadHtml()) {\n                try {\n                    String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                    log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                    return WebResponseUtils.bytesToWebResponse(\n                            htmlContent.getBytes(StandardCharsets.UTF_8),\n                            baseFilename + \".html\",\n                            MediaType.TEXT_HTML);\n                } catch (IOException | IllegalArgumentException e) {\n                    log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                            .body(\n                                    (\"HTML conversion failed: \" + e.getMessage())\n                                            .getBytes(StandardCharsets.UTF_8));\n                }\n            }\n\n            // Convert EML to PDF with enhanced options\n            try {\n                byte[] pdfBytes =\n                        EmlToPdf.convertEmlToPdf(\n                                runtimePathConfig\n                                        .getWeasyPrintPath(), // Use configured WeasyPrint path\n                                request,\n                                fileBytes,\n                                originalFilename,\n                                pdfDocumentFactory,\n                                tempFileManager,\n                                customHtmlSanitizer);\n\n                if (pdfBytes == null || pdfBytes.length == 0) {\n                    log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                            .body(\n                                    \"PDF conversion failed - empty output\"\n                                            .getBytes(StandardCharsets.UTF_8));\n                }\n                log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(\n                        pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n            } catch (IllegalArgumentException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\n                        \"EML to PDF conversion failed for {}: {}\",\n                        originalFilename,\n                        errorMessage,\n                        e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            } catch (RuntimeException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\n                        \"EML to PDF conversion failed for {}: {}\",\n                        originalFilename,\n                        errorMessage,\n                        e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            }\n\n        } catch (IOException e) {\n            log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n        }\n    }",
        "idx": "37"
    },
    {
        "target_file_name": "ApplicationProperties.java",
        "target_method": "app/common/src/main/java/stirling/software/common/model/ApplicationProperties.java#getLibreofficeDir",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getBaseTmpDir"
        ],
        "target_code": "public String getLibreofficeDir() {\n            return libreofficeDir != null && !libreofficeDir.isEmpty()\n                    ? libreofficeDir\n                    : getBaseTmpDir() + \"/libreoffice\";\n        }",
        "idx": "38"
    },
    {
        "target_file_name": "ApplicationProperties.java",
        "target_method": "app/common/src/main/java/stirling/software/common/model/ApplicationProperties.java#getLibreofficeDir",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getBaseTmpDir"
        ],
        "target_code": "public String getLibreofficeDir() {\n            return libreofficeDir != null && !libreofficeDir.isEmpty()\n                    ? libreofficeDir\n                    : getBaseTmpDir() + \"/libreoffice\";\n        }",
        "idx": "39"
    },
    {
        "target_file_name": "ConvertOfficeController.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertOfficeController.java#convertToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Files.createTempFile",
            "Files.deleteIfExists",
            "Files.write",
            "ProcessExecutor.runCommandWithOutputHandling"
        ],
        "target_code": "public File convertToPdf(MultipartFile inputFile) throws IOException, InterruptedException {\n        // Check for valid file extension\n        String originalFilename = Filenames.toSimpleFileName(inputFile.getOriginalFilename());\n        if (originalFilename == null\n                || !isValidFileExtension(FilenameUtils.getExtension(originalFilename))) {\n            throw new IllegalArgumentException(\"Invalid file extension\");\n        }\n\n        // Save the uploaded file to a temporary location\n        Path tempInputFile =\n                Files.createTempFile(\"input_\", \".\" + FilenameUtils.getExtension(originalFilename));\n\n        // Check if the file is HTML and apply sanitization if needed\n        String fileExtension = FilenameUtils.getExtension(originalFilename).toLowerCase();\n        if (\"html\".equals(fileExtension) || \"htm\".equals(fileExtension)) {\n            // Read and sanitize HTML content\n            String htmlContent = new String(inputFile.getBytes(), StandardCharsets.UTF_8);\n            String sanitizedHtml = customHtmlSanitizer.sanitize(htmlContent);\n            Files.write(tempInputFile, sanitizedHtml.getBytes(StandardCharsets.UTF_8));\n        } else {\n            inputFile.transferTo(tempInputFile);\n        }\n\n        // Prepare the output file path\n        Path tempOutputFile = Files.createTempFile(\"output_\", \".pdf\");\n\n        try {\n            // Run the LibreOffice command\n            List<String> command =\n                    new ArrayList<>(\n                            Arrays.asList(\n                                    runtimePathConfig.getUnoConvertPath(),\n                                    \"--port\",\n                                    \"2003\",\n                                    \"--convert-to\",\n                                    \"pdf\",\n                                    tempInputFile.toString(),\n                                    tempOutputFile.toString()));\n            ProcessExecutorResult returnCode =\n                    ProcessExecutor.getInstance(ProcessExecutor.Processes.LIBRE_OFFICE)\n                            .runCommandWithOutputHandling(command);\n\n            // Read the converted PDF file\n            return tempOutputFile.toFile();\n        } finally {\n            // Clean up the temporary files\n            if (tempInputFile != null) Files.deleteIfExists(tempInputFile);\n        }\n    }",
        "idx": "40"
    },
    {
        "target_file_name": "CustomHtmlSanitizer.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/CustomHtmlSanitizer.java#sanitize",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "sanitize"
        ],
        "target_code": "public String sanitize(String html) {\n        boolean disableSanitize =\n                Boolean.TRUE.equals(applicationProperties.getSystem().getDisableSanitize());\n        return disableSanitize ? html : POLICY.sanitize(html);\n    }",
        "idx": "41"
    },
    {
        "target_file_name": "ConvertHtmlToPDF.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertHtmlToPDF.java#HtmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "FileToPdf.convertHtmlToPdf",
            "MultipartFile.getBytes"
        ],
        "target_code": "@PostMapping(consumes = \"multipart/form-data\", value = \"/html/pdf\")\n    @Operation(\n            summary = \"Convert an HTML or ZIP (containing HTML and CSS) to PDF\",\n            description =\n                    \"This endpoint takes an HTML or ZIP file input and converts it to a PDF format.\"\n                            + \" Input:HTML Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> HtmlToPdf(@ModelAttribute HTMLToPdfRequest request)\n            throws Exception {\n        MultipartFile fileInput = request.getFileInput();\n\n        if (fileInput == null) {\n            throw ExceptionUtils.createHtmlFileRequiredException();\n        }\n\n        String originalFilename = Filenames.toSimpleFileName(fileInput.getOriginalFilename());\n        if (originalFilename == null\n                || (!originalFilename.endsWith(\".html\") && !originalFilename.endsWith(\".zip\"))) {\n            throw ExceptionUtils.createIllegalArgumentException(\n                    \"error.fileFormatRequired\", \"File must be in {0} format\", \".html or .zip\");\n        }\n\n        byte[] pdfBytes =\n                FileToPdf.convertHtmlToPdf(\n                        runtimePathConfig.getWeasyPrintPath(),\n                        request,\n                        fileInput.getBytes(),\n                        originalFilename,\n                        tempFileManager,\n                        customHtmlSanitizer);\n\n        pdfBytes = pdfDocumentFactory.createNewBytesBasedOnOldDocument(pdfBytes);\n\n        String outputFilename =\n                originalFilename.replaceFirst(\"[.][^.]+$\", \"\")\n                        + \".pdf\"; // Remove file extension and append .pdf\n\n        return WebResponseUtils.bytesToWebResponse(pdfBytes, outputFilename);\n    }",
        "idx": "42"
    },
    {
        "target_file_name": "FileToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/FileToPdf.java#convertHtmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ProcessExecutor",
            "runCommandWithOutputHandling"
        ],
        "target_code": "public static byte[] convertHtmlToPdf(\n            String weasyprintPath,\n            HTMLToPdfRequest request,\n            byte[] fileBytes,\n            String fileName,\n            TempFileManager tempFileManager,\n            CustomHtmlSanitizer customHtmlSanitizer)\n            throws IOException, InterruptedException {\n\n        try (TempFile tempOutputFile = new TempFile(tempFileManager, \".pdf\")) {\n            try (TempFile tempInputFile =\n                    new TempFile(\n                            tempFileManager,\n                            fileName.toLowerCase().endsWith(\".html\") ? \".html\" : \".zip\")) {\n\n                if (fileName.toLowerCase().endsWith(\".html\")) {\n                    String sanitizedHtml =\n                            sanitizeHtmlContent(\n                                    new String(fileBytes, StandardCharsets.UTF_8),\n                                    customHtmlSanitizer);\n                    Files.write(\n                            tempInputFile.getPath(),\n                            sanitizedHtml.getBytes(StandardCharsets.UTF_8));\n                } else if (fileName.toLowerCase().endsWith(\".zip\")) {\n                    Files.write(tempInputFile.getPath(), fileBytes);\n                    sanitizeHtmlFilesInZip(\n                            tempInputFile.getPath(), tempFileManager, customHtmlSanitizer);\n                } else {\n                    throw ExceptionUtils.createHtmlFileRequiredException();\n                }\n\n                List<String> command = new ArrayList<>();\n                command.add(weasyprintPath);\n                command.add(\"-e\");\n                command.add(\"utf-8\");\n                command.add(\"-v\");\n                command.add(\"--pdf-forms\");\n                command.add(tempInputFile.getAbsolutePath());\n                command.add(tempOutputFile.getAbsolutePath());\n\n                ProcessExecutorResult returnCode =\n                        ProcessExecutor.getInstance(ProcessExecutor.Processes.WEASYPRINT)\n                                .runCommandWithOutputHandling(command);\n\n                byte[] pdfBytes = Files.readAllBytes(tempOutputFile.getPath());\n                try {\n                    return pdfBytes;\n                } catch (Exception e) {\n                    pdfBytes = Files.readAllBytes(tempOutputFile.getPath());\n                    if (pdfBytes.length < 1) {\n                        throw e;\n                    }\n                    return pdfBytes;\n                }\n            } // tempInputFile auto-closed\n        } // tempOutputFile auto-closed\n    }",
        "idx": "43"
    },
    {
        "target_file_name": "FileToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/FileToPdf.java#sanitizeHtmlContent",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "sanitize"
        ],
        "target_code": "private static String sanitizeHtmlContent(\n            String htmlContent, CustomHtmlSanitizer customHtmlSanitizer) {\n        return customHtmlSanitizer.sanitize(htmlContent);\n    }",
        "idx": "44"
    },
    {
        "target_file_name": "FileToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/FileToPdf.java#sanitizeHtmlFilesInZip",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Files.write",
            "ZipInputStream",
            "getNextEntry",
            "readAllBytes",
            "sanitizeHtmlContent"
        ],
        "target_code": "private static void sanitizeHtmlFilesInZip(\n            Path zipFilePath,\n            TempFileManager tempFileManager,\n            CustomHtmlSanitizer customHtmlSanitizer)\n            throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn =\n                    ZipSecurity.createHardenedInputStream(\n                            new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath =\n                            tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase().endsWith(\".html\")\n                                || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                            String content =\n                                    new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent =\n                                    sanitizeHtmlContent(content, customHtmlSanitizer);\n                            Files.write(\n                                    filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }",
        "idx": "45"
    },
    {
        "target_file_name": "ConvertMarkdownToPdf.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertMarkdownToPdf.java#markdownToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "FileToPdf.convertHtmlToPdf",
            "MultipartFile.getBytes",
            "String.getBytes"
        ],
        "target_code": "@PostMapping(consumes = \"multipart/form-data\", value = \"/markdown/pdf\")\n    @Operation(\n            summary = \"Convert a Markdown file to PDF\",\n            description =\n                    \"This endpoint takes a Markdown file input, converts it to HTML, and then to\"\n                            + \" PDF format. Input:MARKDOWN Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> markdownToPdf(@ModelAttribute GeneralFile generalFile)\n            throws Exception {\n        MultipartFile fileInput = generalFile.getFileInput();\n\n        if (fileInput == null) {\n            throw ExceptionUtils.createIllegalArgumentException(\n                    \"error.fileFormatRequired\", \"File must be in {0} format\", \"Markdown\");\n        }\n\n        String originalFilename = Filenames.toSimpleFileName(fileInput.getOriginalFilename());\n        if (originalFilename == null || !originalFilename.endsWith(\".md\")) {\n            throw ExceptionUtils.createIllegalArgumentException(\n                    \"error.fileFormatRequired\", \"File must be in {0} format\", \".md\");\n        }\n\n        // Convert Markdown to HTML using CommonMark\n        List<Extension> extensions = List.of(TablesExtension.create());\n        Parser parser = Parser.builder().extensions(extensions).build();\n\n        Node document = parser.parse(new String(fileInput.getBytes()));\n        HtmlRenderer renderer =\n                HtmlRenderer.builder()\n                        .attributeProviderFactory(context -> new TableAttributeProvider())\n                        .extensions(extensions)\n                        .build();\n\n        String htmlContent = renderer.render(document);\n\n        boolean disableSanitize =\n                Boolean.TRUE.equals(applicationProperties.getSystem().getDisableSanitize());\n\n        byte[] pdfBytes =\n                FileToPdf.convertHtmlToPdf(\n                        runtimePathConfig.getWeasyPrintPath(),\n                        null,\n                        htmlContent.getBytes(),\n                        \"converted.html\",\n                        disableSanitize,\n                        tempFileManager);\n        pdfBytes = pdfDocumentFactory.createNewBytesBasedOnOldDocument(pdfBytes);\n        String outputFilename =\n                originalFilename.replaceFirst(\"[.][^.]+$\", \"\")\n                        + \".pdf\"; // Remove file extension and append .pdf\n        return WebResponseUtils.bytesToWebResponse(pdfBytes, outputFilename);\n    }",
        "idx": "46"
    },
    {
        "target_file_name": "EmlToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/EmlToPdf.java#convertEmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "attachFilesToPdf",
            "convertHtmlToPdf"
        ],
        "target_code": "public static byte[] convertEmlToPdf(\n            String weasyprintPath,\n            EmlToPdfRequest request,\n            byte[] emlBytes,\n            String fileName,\n            boolean disableSanitize,\n            stirling.software.common.service.CustomPDFDocumentFactory pdfDocumentFactory,\n            TempFileManager tempFileManager)\n            throws IOException, InterruptedException {\n\n        validateEmlInput(emlBytes);\n\n        try {\n            // Generate HTML representation\n            EmailContent emailContent = null;\n            String htmlContent;\n\n            if (isJakartaMailAvailable()) {\n                emailContent = extractEmailContentAdvanced(emlBytes, request);\n                htmlContent = generateEnhancedEmailHtml(emailContent, request);\n            } else {\n                htmlContent = convertEmlToHtmlBasic(emlBytes, request);\n            }\n\n            // Convert HTML to PDF\n            byte[] pdfBytes =\n                    convertHtmlToPdf(\n                            weasyprintPath, request, htmlContent, disableSanitize, tempFileManager);\n\n            // Attach files if available and requested\n            if (shouldAttachFiles(emailContent, request)) {\n                pdfBytes =\n                        attachFilesToPdf(\n                                pdfBytes, emailContent.getAttachments(), pdfDocumentFactory);\n            }\n\n            return pdfBytes;\n\n        } catch (IOException | InterruptedException e) {\n            log.error(\"Failed to convert EML to PDF for file: {}\", fileName, e);\n            throw e;\n        } catch (Exception e) {\n            log.error(\"Unexpected error during EML to PDF conversion for file: {}\", fileName, e);\n            throw new IOException(\"Conversion failed: \" + e.getMessage(), e);\n        }\n    }",
        "idx": "47"
    },
    {
        "target_file_name": "EmlToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/EmlToPdf.java#convertHtmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "FileToPdf.convertHtmlToPdf"
        ],
        "target_code": "private static byte[] convertHtmlToPdf(\n            String weasyprintPath,\n            EmlToPdfRequest request,\n            String htmlContent,\n            boolean disableSanitize,\n            TempFileManager tempFileManager)\n            throws IOException, InterruptedException {\n\n        HTMLToPdfRequest htmlRequest = createHtmlRequest(request);\n\n        try {\n            return FileToPdf.convertHtmlToPdf(\n                    weasyprintPath,\n                    htmlRequest,\n                    htmlContent.getBytes(StandardCharsets.UTF_8),\n                    \"email.html\",\n                    disableSanitize,\n                    tempFileManager);\n        } catch (IOException | InterruptedException e) {\n            log.warn(\"Initial HTML to PDF conversion failed, trying with simplified HTML\");\n            String simplifiedHtml = simplifyHtmlContent(htmlContent);\n            return FileToPdf.convertHtmlToPdf(\n                    weasyprintPath,\n                    htmlRequest,\n                    simplifiedHtml.getBytes(StandardCharsets.UTF_8),\n                    \"email.html\",\n                    disableSanitize,\n                    tempFileManager);\n        }\n    }",
        "idx": "48"
    },
    {
        "target_file_name": "ConvertEmlToPDF.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertEmlToPDF.java#convertEmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "EmlToPdf.convertEmlToPdf",
            "MultipartFile",
            "getBytes",
            "runtimePathConfig.getWeasyPrintPath"
        ],
        "target_code": "@PostMapping(consumes = \"multipart/form-data\", value = \"/eml/pdf\")\n    @Operation(\n            summary = \"Convert EML to PDF\",\n            description =\n                    \"This endpoint converts EML (email) files to PDF format with extensive\"\n                            + \" customization options. Features include font settings, image constraints, display modes, attachment handling,\"\n                            + \" and HTML debug output. Input: EML file, Output: PDF\"\n                            + \" or HTML file. Type: SISO\")\n    public ResponseEntity<byte[]> convertEmlToPdf(@ModelAttribute EmlToPdfRequest request) {\n\n        MultipartFile inputFile = request.getFileInput();\n        String originalFilename = inputFile.getOriginalFilename();\n\n        // Validate input\n        if (inputFile.isEmpty()) {\n            log.error(\"No file provided for EML to PDF conversion.\");\n            return ResponseEntity.badRequest()\n                    .body(\"No file provided\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        if (originalFilename == null || originalFilename.trim().isEmpty()) {\n            log.error(\"Filename is null or empty.\");\n            return ResponseEntity.badRequest()\n                    .body(\"Please provide a valid filename\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        // Validate file type - support EML\n        String lowerFilename = originalFilename.toLowerCase();\n        if (!lowerFilename.endsWith(\".eml\")) {\n            log.error(\"Invalid file type for EML to PDF: {}\", originalFilename);\n            return ResponseEntity.badRequest()\n                    .body(\"Please upload a valid EML file\".getBytes(StandardCharsets.UTF_8));\n        }\n\n        String baseFilename = Filenames.toSimpleFileName(originalFilename); // Use Filenames utility\n\n        try {\n            byte[] fileBytes = inputFile.getBytes();\n\n            if (request.isDownloadHtml()) {\n                try {\n                    String htmlContent = EmlToPdf.convertEmlToHtml(fileBytes, request);\n                    log.info(\"Successfully converted EML to HTML: {}\", originalFilename);\n                    return WebResponseUtils.bytesToWebResponse(\n                            htmlContent.getBytes(StandardCharsets.UTF_8),\n                            baseFilename + \".html\",\n                            MediaType.TEXT_HTML);\n                } catch (IOException | IllegalArgumentException e) {\n                    log.error(\"HTML conversion failed for {}\", originalFilename, e);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                            .body(\n                                    (\"HTML conversion failed: \" + e.getMessage())\n                                            .getBytes(StandardCharsets.UTF_8));\n                }\n            }\n\n            // Convert EML to PDF with enhanced options\n            try {\n                byte[] pdfBytes =\n                        EmlToPdf.convertEmlToPdf(\n                                runtimePathConfig\n                                        .getWeasyPrintPath(), // Use configured WeasyPrint path\n                                request,\n                                fileBytes,\n                                originalFilename,\n                                false,\n                                pdfDocumentFactory,\n                                tempFileManager);\n\n                if (pdfBytes == null || pdfBytes.length == 0) {\n                    log.error(\"PDF conversion failed - empty output for {}\", originalFilename);\n                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                            .body(\n                                    \"PDF conversion failed - empty output\"\n                                            .getBytes(StandardCharsets.UTF_8));\n                }\n                log.info(\"Successfully converted EML to PDF: {}\", originalFilename);\n                return WebResponseUtils.bytesToWebResponse(\n                        pdfBytes, baseFilename + \".pdf\", MediaType.APPLICATION_PDF);\n\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.error(\"EML to PDF conversion was interrupted for {}\", originalFilename, e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(\"Conversion was interrupted\".getBytes(StandardCharsets.UTF_8));\n            } catch (IllegalArgumentException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\n                        \"EML to PDF conversion failed for {}: {}\",\n                        originalFilename,\n                        errorMessage,\n                        e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            } catch (RuntimeException e) {\n                String errorMessage = buildErrorMessage(e, originalFilename);\n                log.error(\n                        \"EML to PDF conversion failed for {}: {}\",\n                        originalFilename,\n                        errorMessage,\n                        e);\n                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                        .body(errorMessage.getBytes(StandardCharsets.UTF_8));\n            }\n\n        } catch (IOException e) {\n            log.error(\"File processing error for EML to PDF: {}\", originalFilename, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)\n                    .body(\"File processing error\".getBytes(StandardCharsets.UTF_8));\n        }\n    }",
        "idx": "49"
    },
    {
        "target_file_name": "ConvertOfficeController.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertOfficeController.java#convertToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Files.createTempFile",
            "ProcessExecutor.runCommandWithOutputHandling"
        ],
        "target_code": "public File convertToPdf(MultipartFile inputFile) throws IOException, InterruptedException {\n        // Check for valid file extension\n        String originalFilename = Filenames.toSimpleFileName(inputFile.getOriginalFilename());\n        if (originalFilename == null\n                || !isValidFileExtension(FilenameUtils.getExtension(originalFilename))) {\n            throw new IllegalArgumentException(\"Invalid file extension\");\n        }\n\n        // Save the uploaded file to a temporary location\n        Path tempInputFile =\n                Files.createTempFile(\"input_\", \".\" + FilenameUtils.getExtension(originalFilename));\n        inputFile.transferTo(tempInputFile);\n\n        // Prepare the output file path\n        Path tempOutputFile = Files.createTempFile(\"output_\", \".pdf\");\n\n        try {\n            // Run the LibreOffice command\n            List<String> command =\n                    new ArrayList<>(\n                            Arrays.asList(\n                                    runtimePathConfig.getUnoConvertPath(),\n                                    \"--port\",\n                                    \"2003\",\n                                    \"--convert-to\",\n                                    \"pdf\",\n                                    tempInputFile.toString(),\n                                    tempOutputFile.toString()));\n            ProcessExecutorResult returnCode =\n                    ProcessExecutor.getInstance(ProcessExecutor.Processes.LIBRE_OFFICE)\n                            .runCommandWithOutputHandling(command);\n\n            // Read the converted PDF file\n            return tempOutputFile.toFile();\n        } finally {\n            // Clean up the temporary files\n            if (tempInputFile != null) Files.deleteIfExists(tempInputFile);\n        }\n    }",
        "idx": "50"
    },
    {
        "target_file_name": "CustomHtmlSanitizer.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/CustomHtmlSanitizer.java#sanitize",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "sanitize"
        ],
        "target_code": "public static String sanitize(String html) {\n        String htmlAfter = POLICY.sanitize(html);\n        return htmlAfter;\n    }",
        "idx": "51"
    },
    {
        "target_file_name": "ConvertHtmlToPDF.java",
        "target_method": "app/core/src/main/java/stirling/software/SPDF/controller/api/converters/ConvertHtmlToPDF.java#HtmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "FileToPdf.convertHtmlToPdf",
            "pdfDocumentFactory.createNewBytesBasedOnOldDocument"
        ],
        "target_code": "@PostMapping(consumes = \"multipart/form-data\", value = \"/html/pdf\")\n    @Operation(\n            summary = \"Convert an HTML or ZIP (containing HTML and CSS) to PDF\",\n            description =\n                    \"This endpoint takes an HTML or ZIP file input and converts it to a PDF format.\"\n                            + \" Input:HTML Output:PDF Type:SISO\")\n    public ResponseEntity<byte[]> HtmlToPdf(@ModelAttribute HTMLToPdfRequest request)\n            throws Exception {\n        MultipartFile fileInput = request.getFileInput();\n\n        if (fileInput == null) {\n            throw ExceptionUtils.createHtmlFileRequiredException();\n        }\n\n        String originalFilename = Filenames.toSimpleFileName(fileInput.getOriginalFilename());\n        if (originalFilename == null\n                || (!originalFilename.endsWith(\".html\") && !originalFilename.endsWith(\".zip\"))) {\n            throw ExceptionUtils.createIllegalArgumentException(\n                    \"error.fileFormatRequired\", \"File must be in {0} format\", \".html or .zip\");\n        }\n\n        boolean disableSanitize =\n                Boolean.TRUE.equals(applicationProperties.getSystem().getDisableSanitize());\n\n        byte[] pdfBytes =\n                FileToPdf.convertHtmlToPdf(\n                        runtimePathConfig.getWeasyPrintPath(),\n                        request,\n                        fileInput.getBytes(),\n                        originalFilename,\n                        disableSanitize,\n                        tempFileManager);\n\n        pdfBytes = pdfDocumentFactory.createNewBytesBasedOnOldDocument(pdfBytes);\n\n        String outputFilename =\n                originalFilename.replaceFirst(\"[.][^.]+$\", \"\")\n                        + \".pdf\"; // Remove file extension and append .pdf\n\n        return WebResponseUtils.bytesToWebResponse(pdfBytes, outputFilename);\n    }",
        "idx": "52"
    },
    {
        "target_file_name": "FileToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/FileToPdf.java#convertHtmlToPdf",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ProcessExecutor",
            "runCommandWithOutputHandling"
        ],
        "target_code": "public static byte[] convertHtmlToPdf(\n            String weasyprintPath,\n            HTMLToPdfRequest request,\n            byte[] fileBytes,\n            String fileName,\n            boolean disableSanitize,\n            TempFileManager tempFileManager)\n            throws IOException, InterruptedException {\n\n        try (TempFile tempOutputFile = new TempFile(tempFileManager, \".pdf\")) {\n            try (TempFile tempInputFile =\n                    new TempFile(\n                            tempFileManager,\n                            fileName.toLowerCase().endsWith(\".html\") ? \".html\" : \".zip\")) {\n\n                if (fileName.toLowerCase().endsWith(\".html\")) {\n                    String sanitizedHtml =\n                            sanitizeHtmlContent(\n                                    new String(fileBytes, StandardCharsets.UTF_8), disableSanitize);\n                    Files.write(\n                            tempInputFile.getPath(),\n                            sanitizedHtml.getBytes(StandardCharsets.UTF_8));\n                } else if (fileName.toLowerCase().endsWith(\".zip\")) {\n                    Files.write(tempInputFile.getPath(), fileBytes);\n                    sanitizeHtmlFilesInZip(\n                            tempInputFile.getPath(), disableSanitize, tempFileManager);\n                } else {\n                    throw ExceptionUtils.createHtmlFileRequiredException();\n                }\n\n                List<String> command = new ArrayList<>();\n                command.add(weasyprintPath);\n                command.add(\"-e\");\n                command.add(\"utf-8\");\n                command.add(\"-v\");\n                command.add(\"--pdf-forms\");\n                command.add(tempInputFile.getAbsolutePath());\n                command.add(tempOutputFile.getAbsolutePath());\n\n                ProcessExecutorResult returnCode =\n                        ProcessExecutor.getInstance(ProcessExecutor.Processes.WEASYPRINT)\n                                .runCommandWithOutputHandling(command);\n\n                byte[] pdfBytes = Files.readAllBytes(tempOutputFile.getPath());\n                try {\n                    return pdfBytes;\n                } catch (Exception e) {\n                    pdfBytes = Files.readAllBytes(tempOutputFile.getPath());\n                    if (pdfBytes.length < 1) {\n                        throw e;\n                    }\n                    return pdfBytes;\n                }\n            } // tempInputFile auto-closed\n        } // tempOutputFile auto-closed\n    }",
        "idx": "53"
    },
    {
        "target_file_name": "FileToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/FileToPdf.java#sanitizeHtmlContent",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "CustomHtmlSanitizer.sanitize"
        ],
        "target_code": "private static String sanitizeHtmlContent(String htmlContent, boolean disableSanitize) {\n        return (!disableSanitize) ? CustomHtmlSanitizer.sanitize(htmlContent) : htmlContent;\n    }",
        "idx": "54"
    },
    {
        "target_file_name": "FileToPdf.java",
        "target_method": "app/common/src/main/java/stirling/software/common/util/FileToPdf.java#sanitizeHtmlFilesInZip",
        "project_url": "https://github.com/Stirling-Tools/Stirling-PDF",
        "commit_id": "7d6b70871bad2a3ff810825f7382c49f55293943^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-55150",
        "project_name": "Stirling-PDF",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Files.write",
            "ZipInputStream",
            "getNextEntry",
            "readAllBytes",
            "sanitizeHtmlContent"
        ],
        "target_code": "private static void sanitizeHtmlFilesInZip(\n            Path zipFilePath, boolean disableSanitize, TempFileManager tempFileManager)\n            throws IOException {\n        try (TempDirectory tempUnzippedDir = new TempDirectory(tempFileManager)) {\n            try (ZipInputStream zipIn =\n                    ZipSecurity.createHardenedInputStream(\n                            new ByteArrayInputStream(Files.readAllBytes(zipFilePath)))) {\n                ZipEntry entry = zipIn.getNextEntry();\n                while (entry != null) {\n                    Path filePath =\n                            tempUnzippedDir.getPath().resolve(sanitizeZipFilename(entry.getName()));\n                    if (!entry.isDirectory()) {\n                        Files.createDirectories(filePath.getParent());\n                        if (entry.getName().toLowerCase().endsWith(\".html\")\n                                || entry.getName().toLowerCase().endsWith(\".htm\")) {\n                            String content =\n                                    new String(zipIn.readAllBytes(), StandardCharsets.UTF_8);\n                            String sanitizedContent = sanitizeHtmlContent(content, disableSanitize);\n                            Files.write(\n                                    filePath, sanitizedContent.getBytes(StandardCharsets.UTF_8));\n                        } else {\n                            Files.copy(zipIn, filePath);\n                        }\n                    }\n                    zipIn.closeEntry();\n                    entry = zipIn.getNextEntry();\n                }\n            }\n\n            // Repack the sanitized files\n            zipDirectory(tempUnzippedDir.getPath(), zipFilePath);\n        } // tempUnzippedDir auto-cleaned\n    }",
        "idx": "55"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#login",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "BCryptPasswordEncoder",
            "matches"
        ],
        "target_code": "@PostMapping(\"/login\")\n    public Result login(@RequestBody Map<String, String> body, HttpSession session) {\n        String username = body.get(\"username\");\n        String password = body.get(\"password\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(username, \"请输入用户名\");\n        ApiAssert.notEmpty(password, \"请输入密码\");\n        User user = userService.selectByUsername(username);\n        ApiAssert.notNull(user, \"用户不存在\");\n        ApiAssert.isTrue(new BCryptPasswordEncoder().matches(password, user.getPassword()), \"用户名或密码不正确\");\n        return this.doUserStorage(session, user);\n    }",
        "idx": "56"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#register",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpSession.getAttribute",
            "HttpSession.removeAttribute"
        ],
        "target_code": "@PostMapping(\"/register\")\n    public Result register(@RequestBody Map<String, String> body, HttpSession session) {\n        String username = body.get(\"username\");\n        String password = body.get(\"password\");\n        String email = body.get(\"email\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(username, \"请输入用户名\");\n        ApiAssert.notEmpty(password, \"请输入密码\");\n        ApiAssert.notEmpty(email, \"请输入邮箱\");\n        ApiAssert.isTrue(StringUtil.check(username, StringUtil.USERNAMEREGEX), \"用户名只能为a-z,A-Z,0-9组合且2-16位\");\n        ApiAssert.isTrue(StringUtil.check(email, StringUtil.EMAILREGEX), \"请输入正确的邮箱地址\");\n        User user = userService.selectByUsername(username);\n        ApiAssert.isNull(user, \"用户名已存在\");\n        User emailUser = userService.selectByEmail(email);\n        ApiAssert.isNull(emailUser, \"这个邮箱已经被注册过了，请更换一个邮箱\");\n        user = userService.addUser(username, password, null, email, null, null, true);\n        return this.doUserStorage(session, user);\n    }",
        "idx": "57"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#sms_code",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "StringUtil.check",
            "StringUtils.isEmpty",
            "codeService.sendSms",
            "session.getAttribute",
            "session.removeAttribute"
        ],
        "target_code": "@GetMapping(\"/sms_code\")\n    public Result sms_code(String captcha, String mobile, HttpSession session) {\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(mobile, \"请输入手机号\");\n        ApiAssert.isTrue(StringUtil.check(mobile, StringUtil.MOBILEREGEX), \"请输入正确的手机号\");\n        boolean b = codeService.sendSms(mobile);\n        if (!b) {\n            return error(\"短信发送失败或者站长没有配置短信服务\");\n        } else {\n            return success();\n        }\n    }",
        "idx": "58"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#mobile_login",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "StringUtil.check",
            "StringUtils.isEmpty",
            "codeService.validateCode",
            "session.getAttribute",
            "session.removeAttribute",
            "userService.addUserWithMobile"
        ],
        "target_code": "@PostMapping(\"/mobile_login\")\n    public Result mobile_login(@RequestBody Map<String, String> body, HttpSession session) {\n        String mobile = body.get(\"mobile\");\n        String code = body.get(\"code\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(mobile, \"请输入手机号\");\n        ApiAssert.isTrue(StringUtil.check(mobile, StringUtil.MOBILEREGEX), \"请输入正确的手机号\");\n        ApiAssert.notEmpty(code, \"请输入手机验证码\");\n        Code validateCode = codeService.validateCode(null, null, mobile, code);\n        ApiAssert.notTrue(validateCode == null, \"手机验证码错误\");\n        User user = userService.addUserWithMobile(mobile);\n        return doUserStorage(session, user);\n    }",
        "idx": "59"
    },
    {
        "target_file_name": "IndexAdminController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/admin/IndexAdminController.java#adminlogin",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SecurityUtils.getSubject",
            "Subject.login",
            "UsernamePasswordToken"
        ],
        "target_code": "@PostMapping(\"/admin/login\")\n    public String adminlogin(String username, String password, String code, HttpSession session,\n                             @RequestParam(defaultValue = \"0\") Boolean rememberMe,\n                             HttpServletRequest request, RedirectAttributes redirectAttributes) {\n        String url = WebUtils.getSavedRequest(request) == null ? \"/admin/index\" : WebUtils.getSavedRequest(request).getRequestUrl();\n        String captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n        if (captcha == null || StringUtils.isEmpty(code) || !captcha.equalsIgnoreCase(code)) {\n            redirectAttributes.addFlashAttribute(\"error\", \"验证码不正确\");\n            redirectAttributes.addFlashAttribute(\"username\", username);\n            url = \"/adminlogin\";\n        } else {\n            try {\n                // 添加用户认证信息\n                Subject subject = SecurityUtils.getSubject();\n                UsernamePasswordToken token = new UsernamePasswordToken(username, password, rememberMe);\n                //进行验证，这里可以捕获异常，然后返回对应信息\n                subject.login(token);\n            } catch (UnknownAccountException e) {\n                log.error(e.getMessage());\n                redirectAttributes.addFlashAttribute(\"error\", \"用户不存在\");\n                redirectAttributes.addFlashAttribute(\"username\", username);\n                url = \"/adminlogin\";\n            } catch (IncorrectCredentialsException e) {\n                log.error(e.getMessage());\n                redirectAttributes.addFlashAttribute(\"error\", \"密码错误\");\n                redirectAttributes.addFlashAttribute(\"username\", username);\n                url = \"/adminlogin\";\n//            } catch (LockedAccountException e) {\n//                log.error(e.getMessage());\n//                redirectAttributes.addFlashAttribute(\"error\", \"用户被锁定\");\n//                redirectAttributes.addFlashAttribute(\"username\", username);\n//                url = \"/adminlogin\";\n//            } catch (ExcessiveAttemptsException e) {\n//                log.error(e.getMessage());\n//                redirectAttributes.addFlashAttribute(\"error\", \"登录尝试次数过多\");\n//                redirectAttributes.addFlashAttribute(\"username\", username);\n//                url = \"/adminlogin\";\n            } catch (AuthenticationException e) {\n                log.error(e.getMessage());\n                redirectAttributes.addFlashAttribute(\"error\", \"用户名或密码错误\");\n                redirectAttributes.addFlashAttribute(\"username\", username);\n                url = \"/adminlogin\";\n            }\n        }\n        return redirect(url);\n    }",
        "idx": "60"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#login",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf^",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "BCryptPasswordEncoder",
            "matches"
        ],
        "target_code": "@PostMapping(\"/login\")\n    public Result login(@RequestBody Map<String, String> body, HttpSession session) {\n        String username = body.get(\"username\");\n        String password = body.get(\"password\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(username, \"请输入用户名\");\n        ApiAssert.notEmpty(password, \"请输入密码\");\n        User user = userService.selectByUsername(username);\n        ApiAssert.notNull(user, \"用户不存在\");\n        ApiAssert.isTrue(new BCryptPasswordEncoder().matches(password, user.getPassword()), \"用户名或密码不正确\");\n        return this.doUserStorage(session, user);\n    }",
        "idx": "61"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#register",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf^",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpSession.getAttribute",
            "String.equalsIgnoreCase",
            "StringUtil.check",
            "StringUtils.isEmpty",
            "userService.addUser",
            "userService.selectByEmail",
            "userService.selectByUsername"
        ],
        "target_code": "@PostMapping(\"/register\")\n    public Result register(@RequestBody Map<String, String> body, HttpSession session) {\n        String username = body.get(\"username\");\n        String password = body.get(\"password\");\n        String email = body.get(\"email\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(username, \"请输入用户名\");\n        ApiAssert.notEmpty(password, \"请输入密码\");\n        ApiAssert.notEmpty(email, \"请输入邮箱\");\n        ApiAssert.isTrue(StringUtil.check(username, StringUtil.USERNAMEREGEX), \"用户名只能为a-z,A-Z,0-9组合且2-16位\");\n        ApiAssert.isTrue(StringUtil.check(email, StringUtil.EMAILREGEX), \"请输入正确的邮箱地址\");\n        User user = userService.selectByUsername(username);\n        ApiAssert.isNull(user, \"用户名已存在\");\n        User emailUser = userService.selectByEmail(email);\n        ApiAssert.isNull(emailUser, \"这个邮箱已经被注册过了，请更换一个邮箱\");\n        user = userService.addUser(username, password, null, email, null, null, true);\n        return this.doUserStorage(session, user);\n    }",
        "idx": "62"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#sms_code",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf^",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "StringUtil.check",
            "StringUtils.isEmpty",
            "codeService.sendSms"
        ],
        "target_code": "@GetMapping(\"/sms_code\")\n    public Result sms_code(String captcha, String mobile, HttpSession session) {\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(mobile, \"请输入手机号\");\n        ApiAssert.isTrue(StringUtil.check(mobile, StringUtil.MOBILEREGEX), \"请输入正确的手机号\");\n        boolean b = codeService.sendSms(mobile);\n        if (!b) {\n            return error(\"短信发送失败或者站长没有配置短信服务\");\n        } else {\n            return success();\n        }\n    }",
        "idx": "63"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#mobile_login",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf^",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpSession.getAttribute",
            "String.equalsIgnoreCase",
            "StringUtil.check",
            "StringUtils.isEmpty",
            "codeService.validateCode",
            "userService.addUserWithMobile"
        ],
        "target_code": "@PostMapping(\"/mobile_login\")\n    public Result mobile_login(@RequestBody Map<String, String> body, HttpSession session) {\n        String mobile = body.get(\"mobile\");\n        String code = body.get(\"code\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(mobile, \"请输入手机号\");\n        ApiAssert.isTrue(StringUtil.check(mobile, StringUtil.MOBILEREGEX), \"请输入正确的手机号\");\n        ApiAssert.notEmpty(code, \"请输入手机验证码\");\n        Code validateCode = codeService.validateCode(null, null, mobile, code);\n        ApiAssert.notTrue(validateCode == null, \"手机验证码错误\");\n        User user = userService.addUserWithMobile(mobile);\n        return doUserStorage(session, user);\n    }",
        "idx": "64"
    },
    {
        "target_file_name": "IndexAdminController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/admin/IndexAdminController.java#adminlogin",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "ecaf8d46944fd03e3c4ea05698f8acf0aaa570cf^",
        "CWE_id": "CWE-804",
        "CVE_id": "CVE-2025-8546",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SecurityUtils.getSubject",
            "Subject.login"
        ],
        "target_code": "@PostMapping(\"/admin/login\")\n    public String adminlogin(String username, String password, String code, HttpSession session,\n                             @RequestParam(defaultValue = \"0\") Boolean rememberMe,\n                             HttpServletRequest request, RedirectAttributes redirectAttributes) {\n        String url = WebUtils.getSavedRequest(request) == null ? \"/admin/index\" : WebUtils.getSavedRequest(request).getRequestUrl();\n        String captcha = (String) session.getAttribute(\"_captcha\");\n        if (captcha == null || StringUtils.isEmpty(code) || !captcha.equalsIgnoreCase(code)) {\n            redirectAttributes.addFlashAttribute(\"error\", \"验证码不正确\");\n            redirectAttributes.addFlashAttribute(\"username\", username);\n            url = \"/adminlogin\";\n        } else {\n            try {\n                // 添加用户认证信息\n                Subject subject = SecurityUtils.getSubject();\n                UsernamePasswordToken token = new UsernamePasswordToken(username, password, rememberMe);\n                //进行验证，这里可以捕获异常，然后返回对应信息\n                subject.login(token);\n            } catch (UnknownAccountException e) {\n                log.error(e.getMessage());\n                redirectAttributes.addFlashAttribute(\"error\", \"用户不存在\");\n                redirectAttributes.addFlashAttribute(\"username\", username);\n                url = \"/adminlogin\";\n            } catch (IncorrectCredentialsException e) {\n                log.error(e.getMessage());\n                redirectAttributes.addFlashAttribute(\"error\", \"密码错误\");\n                redirectAttributes.addFlashAttribute(\"username\", username);\n                url = \"/adminlogin\";\n//            } catch (LockedAccountException e) {\n//                log.error(e.getMessage());\n//                redirectAttributes.addFlashAttribute(\"error\", \"用户被锁定\");\n//                redirectAttributes.addFlashAttribute(\"username\", username);\n//                url = \"/adminlogin\";\n//            } catch (ExcessiveAttemptsException e) {\n//                log.error(e.getMessage());\n//                redirectAttributes.addFlashAttribute(\"error\", \"登录尝试次数过多\");\n//                redirectAttributes.addFlashAttribute(\"username\", username);\n//                url = \"/adminlogin\";\n            } catch (AuthenticationException e) {\n                log.error(e.getMessage());\n                redirectAttributes.addFlashAttribute(\"error\", \"用户名或密码错误\");\n                redirectAttributes.addFlashAttribute(\"username\", username);\n                url = \"/adminlogin\";\n            }\n        }\n        return redirect(url);\n    }",
        "idx": "65"
    },
    {
        "target_file_name": "SettingsApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/SettingsApiController.java#sendEmailCode",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "234197c4f8fc7ce24bdcff5430cd42492f28936a",
        "CWE_id": "CWE-209",
        "CVE_id": "CVE-2025-8548",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "sendEmail"
        ],
        "target_code": "@GetMapping(\"/sendEmailCode\")\n    public Result sendEmailCode(String email) {\n        User user = getApiUser();\n        ApiAssert.notEmpty(email, \"请输入邮箱 \");\n        ApiAssert.isTrue(StringUtil.check(email, StringUtil.EMAILREGEX), \"邮箱格式不正确\");\n        // 不能告知用户邮箱是否注册过\n//        User emailUser = userService.selectByEmail(email);\n//        ApiAssert.isNull(emailUser, \"这个邮箱已经被注册过了，请更换一个邮箱\");\n        if (codeService.sendEmail(user.getId(), email, \"修改邮箱验证码\", \"你的验证码是：<code>${code}</code><br>请在30分钟内使用\")) {\n            return success();\n        } else {\n            return error(\"邮件发送失败，也可能是站长没有配置邮箱\");\n        }\n    }",
        "idx": "66"
    },
    {
        "target_file_name": "SettingsApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/SettingsApiController.java#sendEmailCode",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "234197c4f8fc7ce24bdcff5430cd42492f28936a^",
        "CWE_id": "CWE-209",
        "CVE_id": "CVE-2025-8548",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "sendEmail"
        ],
        "target_code": "@GetMapping(\"/sendEmailCode\")\n    public Result sendEmailCode(String email) {\n        User user = getApiUser();\n        ApiAssert.notEmpty(email, \"请输入邮箱 \");\n        ApiAssert.isTrue(StringUtil.check(email, StringUtil.EMAILREGEX), \"邮箱格式不正确\");\n        User emailUser = userService.selectByEmail(email);\n        ApiAssert.isNull(emailUser, \"这个邮箱已经被注册过了，请更换一个邮箱\");\n        if (codeService.sendEmail(user.getId(), email, \"修改邮箱验证码\", \"你的验证码是：<code>${code}</code><br>请在30分钟内使用\")) {\n            return success();\n        } else {\n            return error(\"邮件发送失败，也可能是站长没有配置邮箱\");\n        }\n    }",
        "idx": "67"
    },
    {
        "target_file_name": "TelegramBotService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/config/service/TelegramBotService.java#setWebHook",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "restTemplate.exchange"
        ],
        "target_code": "public void setWebHook(Map<String, String> map) {\n        String baseUrl = map.get(\"base_url\");\n        String secretToken = map.get(\"tg_webhook_secret_token\");\n        String token = map.get(\"tg_access_token\");\n        if (!StringUtils.isEmpty(baseUrl) && !StringUtils.isEmpty(secretToken) && !StringUtils.isEmpty(token)) {\n            if (secretToken.equals(\"*******\")) {\n                secretToken = systemConfigService.selectAllConfig().get(\"tg_webhook_secret_token\");\n            }\n            if (token.equals(\"*******\")) {\n                token = systemConfigService.selectAllConfig().get(\"tg_access_token\");\n            }\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n            MultiValueMap<String, String> data = new LinkedMultiValueMap<>();\n            data.add(\"url\", baseUrl + \"/bot/tg/webhook\");\n            data.add(\"secret_token\", secretToken);\n            HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(data, headers);\n\n            ResponseEntity<String> exchange = restTemplate.exchange(\"https://api.telegram.org/bot\" + token + \"/setWebhook\", HttpMethod.POST, entity, String.class);\n            if (exchange.getStatusCodeValue() != 200) {\n                log.info(\"Telegram setWebhook失败，errorCode: {}\", exchange.getStatusCode());\n            } else {\n                log.info(\"Telegram setWebhook成功\");\n            }\n        } else {\n            log.info(\"Telegram未配置，跳过setWebhook\");\n        }\n    }",
        "idx": "68"
    },
    {
        "target_file_name": "IndexController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/front/IndexController.java#register",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpServletRequest",
            "setAttribute"
        ],
        "target_code": "@GetMapping(\"/register\")\n    public String register(HttpServletRequest request) {\n        User user = getUser();\n        if (user != null) return redirect(\"/\");\n\n        request.setAttribute(\"user_need_active\", systemConfigService.selectAllConfig().get(\"user_need_active\"));\n        return render(\"register\");\n    }",
        "idx": "69"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#register",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpSession.getAttribute",
            "HttpSession.removeAttribute",
            "String.equalsIgnoreCase",
            "StringUtil.check",
            "StringUtils.isEmpty",
            "codeService.validateCode",
            "systemConfigService.selectAllConfig",
            "userService.addUser",
            "userService.selectByEmail",
            "userService.selectByUsername"
        ],
        "target_code": "@PostMapping(\"/register\")\n    public Result register(@RequestBody Map<String, String> body, HttpSession session) {\n        String username = body.get(\"username\");\n        String password = body.get(\"password\");\n        String email = body.get(\"email\");\n        String emailCode = body.get(\"emailCode\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(username, \"请输入用户名\");\n        ApiAssert.notEmpty(password, \"请输入密码\");\n        ApiAssert.notEmpty(email, \"请输入邮箱\");\n        ApiAssert.isTrue(StringUtil.check(username, StringUtil.USERNAMEREGEX), \"用户名只能为a-z,A-Z,0-9组合且2-16位\");\n        ApiAssert.isTrue(StringUtil.check(email, StringUtil.EMAILREGEX), \"请输入正确的邮箱地址\");\n\n        if (systemConfigService.selectAllConfig().get(\"user_need_active\").equals(\"1\")) {\n            ApiAssert.notEmpty(emailCode, \"请输入邮箱验证码\");\n            Code code = codeService.validateCode(null, email, null, emailCode);\n            ApiAssert.notNull(code, \"邮箱验证码错误\");\n        }\n\n        User user = userService.selectByUsername(username);\n        ApiAssert.isNull(user, \"用户名已存在\");\n        User emailUser = userService.selectByEmail(email);\n        ApiAssert.isNull(emailUser, \"这个邮箱已经被注册过了，请更换一个邮箱\");\n        user = userService.addUser(username, password, null, email, null, null, false);\n        return this.doUserStorage(session, user);\n    }",
        "idx": "70"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#sms_code",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Integer.parseInt",
            "StringUtil.check",
            "StringUtils.isEmpty",
            "get",
            "sendSms"
        ],
        "target_code": "@GetMapping(\"/sms_code\")\n    public Result sms_code(String captcha, String mobile, HttpSession session) {\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(mobile, \"请输入手机号\");\n        ApiAssert.isTrue(StringUtil.check(mobile, StringUtil.MOBILEREGEX), \"请输入正确的手机号\");\n\n        Integer count = codeService.count(null, mobile);\n        if (count != null && count > Integer.parseInt(systemConfigService.selectAllConfig().get(\"email_mobile_code_count\"))) {\n            return error(\"短信验证码发送次数过多\");\n        }\n\n        boolean b = codeService.sendSms(mobile);\n        if (!b) {\n            return error(\"短信发送失败或者站长没有配置短信服务\");\n        } else {\n            return success();\n        }\n    }",
        "idx": "71"
    },
    {
        "target_file_name": "CodeService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/CodeService.java#validateCode",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "LambdaQueryWrapper",
            "QueryWrapper",
            "eq",
            "gt",
            "selectOne"
        ],
        "target_code": "@Override\n    public Code validateCode(Integer userId, String email, String mobile, String _code) {\n        QueryWrapper<Code> wrapper = new QueryWrapper<>();\n        LambdaQueryWrapper<Code> lambda = wrapper.lambda();\n        if (email != null) {\n            lambda.eq(Code::getEmail, email);\n        } else if (mobile != null) {\n            lambda.eq(Code::getMobile, mobile);\n        }\n        if (userId != null) lambda.eq(Code::getUserId, userId);\n        lambda.eq(Code::getCode, _code);\n        lambda.eq(Code::getUsed, false);\n        lambda.gt(Code::getExpireTime, new Date());\n        return codeMapper.selectOne(wrapper);\n    }",
        "idx": "72"
    },
    {
        "target_file_name": "UserService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/UserService.java#addUser",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "BCryptPasswordEncoder",
            "encode"
        ],
        "target_code": "@Override\n    public User addUser(String username, String password, String avatar, String email, String bio, String website,\n                        boolean needActiveEmail) {\n        String token = this.generateToken();\n        User user = new User();\n        user.setUsername(username);\n        if (!StringUtils.isEmpty(password)) user.setPassword(new BCryptPasswordEncoder().encode(password));\n        user.setToken(token);\n        user.setInTime(new Date());\n        if (avatar == null) avatar = identicon.generator(username);\n        user.setAvatar(avatar);\n        user.setEmail(email);\n        user.setBio(bio);\n        user.setWebsite(website);\n        user.setActive(true); // 邮箱即时验证，所以默认是激活状态\n        userMapper.insert(user);\n//        if (needActiveEmail) {\n//            // 发送激活邮件\n//            new Thread(() -> {\n//                String title = \"感谢注册%s，点击下面链接激活帐号\";\n//                String content = \"如果不是你注册了%s，请忽略此邮件&nbsp;&nbsp;<a href='%s/active?email=%s&code=${code}'>点击激活</a>\";\n//                codeService.sendEmail(user.getId(), email, String.format(title, systemConfigService.selectAllConfig().get(\n//                        \"base_url\").toString()), String.format(content,\n//                        systemConfigService.selectAllConfig().get(\"name\").toString(), systemConfigService.selectAllConfig().get(\n//                                \"base_url\").toString(), email));\n//            }).start();\n//        }\n        // 再查一下，有些数据库里默认值保存后，类里还是null\n        return this.selectById(user.getId());\n    }",
        "idx": "73"
    },
    {
        "target_file_name": "UserService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/UserService.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpServletRequest.getSession",
            "HttpSession.setAttribute"
        ],
        "target_code": "@Override\n    public void update(User user) {\n        userMapper.updateById(user);\n\n        // 更新session中的用户\n        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder\n                .getRequestAttributes())).getRequest();\n        HttpSession session = request.getSession();\n        session.setAttribute(\"_user\", user);\n\n        // 同类调用不走spring管理，无法使用aop编程调用\n        SpringContextUtil.getBean(UserService.class).delRedisUser(user);\n    }",
        "idx": "74"
    },
    {
        "target_file_name": "UserService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/UserService.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpServletRequest",
            "SpringContextUtil",
            "getBean",
            "getSession",
            "setAttribute"
        ],
        "target_code": "@Override\n    public void update(User user) {\n        userMapper.updateById(user);\n        \n        // 更新session中的用户\n        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder\n                .getRequestAttributes())).getRequest();\n        HttpSession session = request.getSession();\n        session.setAttribute(\"_user\", user);\n\n        // 同类调用不走spring管理，无法使用aop编程调用\n        SpringContextUtil.getBean(UserService.class).delRedisUser(user);\n    }",
        "idx": "75"
    },
    {
        "target_file_name": "TelegramBotService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/config/service/TelegramBotService.java#setWebHook",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "restTemplate.exchange"
        ],
        "target_code": "public void setWebHook(Map<String, String> map) {\n        String baseUrl = map.get(\"base_url\");\n        String secretToken = map.get(\"tg_webhook_secret_token\");\n        String token = map.get(\"tg_access_token\");\n        if (!StringUtils.isEmpty(baseUrl) && !StringUtils.isEmpty(secretToken) && !StringUtils.isEmpty(token)) {\n            if (secretToken.equals(\"*******\")) {\n                secretToken = systemConfigService.selectAllConfig().get(\"tg_webhook_secret_token\");\n            }\n            if (token.equals(\"*******\")) {\n                token = systemConfigService.selectAllConfig().get(\"tg_access_token\");\n            }\n            HttpHeaders headers = new HttpHeaders();\n            headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n\n            MultiValueMap<String, String> data = new LinkedMultiValueMap<>();\n            data.add(\"url\", baseUrl + \"/bot/tg/webhook\");\n            data.add(\"secret_token\", secretToken);\n            HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(data, headers);\n\n            ResponseEntity<String> exchange = restTemplate.exchange(\"https://api.telegram.org/bot\" + token + \"/setWebhook\", HttpMethod.POST, entity, String.class);\n            if (exchange.getStatusCodeValue() != 200) {\n                log.info(\"Telegram setWebhook失败，errorCode: {}\", exchange.getStatusCode());\n            } else {\n                log.info(\"Telegram setWebhook成功\");\n            }\n        } else {\n            log.info(\"Telegram未配置，路过setWebhook\");\n        }\n    }",
        "idx": "76"
    },
    {
        "target_file_name": "IndexController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/front/IndexController.java#register",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getUser",
            "redirect",
            "render"
        ],
        "target_code": "@GetMapping(\"/register\")\n    public String register() {\n        User user = getUser();\n        if (user != null) return redirect(\"/\");\n        return render(\"register\");\n    }",
        "idx": "77"
    },
    {
        "target_file_name": "CodeService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/CodeService.java#validateCode",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "LambdaQueryWrapper",
            "QueryWrapper",
            "eq",
            "gt",
            "selectOne"
        ],
        "target_code": "@Override\n    public Code validateCode(Integer userId, String email, String mobile, String _code) {\n        QueryWrapper<Code> wrapper = new QueryWrapper<>();\n        LambdaQueryWrapper<Code> lambda = wrapper.lambda();\n        if (email != null) {\n            lambda.eq(Code::getEmail, email);\n            lambda.eq(Code::getUserId, userId);\n        } else if (mobile != null) {\n            lambda.eq(Code::getMobile, mobile);\n        }\n        lambda.eq(Code::getCode, _code);\n        lambda.eq(Code::getUsed, false);\n        lambda.gt(Code::getExpireTime, new Date());\n        return codeMapper.selectOne(wrapper);\n    }",
        "idx": "78"
    },
    {
        "target_file_name": "UserService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/UserService.java#addUser",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "044f22893bee254dc2bb0d30f614913fab3c22c2^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-8547",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "BCryptPasswordEncoder",
            "String.format",
            "encode",
            "sendEmail"
        ],
        "target_code": "@Override\n    public User addUser(String username, String password, String avatar, String email, String bio, String website,\n                        boolean needActiveEmail) {\n        String token = this.generateToken();\n        User user = new User();\n        user.setUsername(username);\n        if (!StringUtils.isEmpty(password)) user.setPassword(new BCryptPasswordEncoder().encode(password));\n        user.setToken(token);\n        user.setInTime(new Date());\n        if (avatar == null) avatar = identicon.generator(username);\n        user.setAvatar(avatar);\n        user.setEmail(email);\n        user.setBio(bio);\n        user.setWebsite(website);\n        user.setActive(systemConfigService.selectAllConfig().get(\"user_need_active\").equals(\"0\"));\n        userMapper.insert(user);\n        if (needActiveEmail) {\n            // 发送激活邮件\n            new Thread(() -> {\n                String title = \"感谢注册%s，点击下面链接激活帐号\";\n                String content = \"如果不是你注册了%s，请忽略此邮件&nbsp;&nbsp;<a href='%s/active?email=%s&code=${code}'>点击激活</a>\";\n                codeService.sendEmail(user.getId(), email, String.format(title, systemConfigService.selectAllConfig().get(\n                        \"base_url\").toString()), String.format(content,\n                        systemConfigService.selectAllConfig().get(\"name\").toString(), systemConfigService.selectAllConfig().get(\n                                \"base_url\").toString(), email));\n            }).start();\n        }\n        // 再查一下，有些数据库里默认值保存后，类里还是null\n        return this.selectById(user.getId());\n    }",
        "idx": "79"
    },
    {
        "target_file_name": "UserAdminController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/admin/UserAdminController.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "d09cb19a8e7d7e5151282926ada54080244d499f",
        "CWE_id": "CWE-521",
        "CVE_id": "CVE-2025-8549",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "BCryptPasswordEncoder",
            "encode"
        ],
        "target_code": "@RequiresPermissions(\"user:edit\")\n    @PostMapping(\"/edit\")\n    @ResponseBody\n    public Result update(User user) {\n        if (!StringUtils.isEmpty(user.getPassword()) && !StringUtil.check(user.getPassword(), StringUtil.PASSWORDREGEX)) {\n            return error(\"密码：至少一个大写字母、至少一个小写字母、至少一个数字、至少16位\");\n        }\n        // 如果密码不为空，给加密一下再保存\n        if (!StringUtils.isEmpty(user.getPassword())) {\n            user.setPassword(new BCryptPasswordEncoder().encode(user.getPassword()));\n        } else {\n            user.setPassword(null);\n        }\n        // 如果邮件接收通知没有勾选，user对象里的属性就是null，手动设置成false\n        if (user.getEmailNotification() == null) user.setEmailNotification(false);\n        userService.update(user);\n        return success();\n    }",
        "idx": "80"
    },
    {
        "target_file_name": "IndexApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/IndexApiController.java#register",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "d09cb19a8e7d7e5151282926ada54080244d499f",
        "CWE_id": "CWE-521",
        "CVE_id": "CVE-2025-8549",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpSession.getAttribute",
            "HttpSession.removeAttribute",
            "Map.get",
            "String.equalsIgnoreCase",
            "StringUtil.check",
            "StringUtils.isEmpty",
            "codeService.validateCode",
            "systemConfigService.selectAllConfig",
            "userService.addUser",
            "userService.selectByEmail",
            "userService.selectByUsername"
        ],
        "target_code": "@PostMapping(\"/register\")\n    public Result register(@RequestBody Map<String, String> body, HttpSession session) {\n        String username = body.get(\"username\");\n        String password = body.get(\"password\");\n        String email = body.get(\"email\");\n        String emailCode = body.get(\"emailCode\");\n        String captcha = body.get(\"captcha\");\n        String _captcha = (String) session.getAttribute(\"_captcha\");\n        session.removeAttribute(\"_captcha\");\n\n        ApiAssert.notTrue(_captcha == null || StringUtils.isEmpty(captcha), \"请输入验证码\");\n        ApiAssert.notTrue(!_captcha.equalsIgnoreCase(captcha), \"验证码不正确\");\n        ApiAssert.notEmpty(username, \"请输入用户名\");\n        ApiAssert.notEmpty(password, \"请输入密码\");\n        ApiAssert.isTrue(StringUtil.check(password, StringUtil.PASSWORDREGEX), \"密码：至少一个大写字母、至少一个小写字母、至少一个数字、至少16位\");\n        ApiAssert.notEmpty(email, \"请输入邮箱\");\n        ApiAssert.isTrue(StringUtil.check(username, StringUtil.USERNAMEREGEX), \"用户名只能为a-z,A-Z,0-9组合且2-16位\");\n        ApiAssert.isTrue(StringUtil.check(email, StringUtil.EMAILREGEX), \"请输入正确的邮箱地址\");\n\n        if (systemConfigService.selectAllConfig().get(\"user_need_active\").equals(\"1\")) {\n            ApiAssert.notEmpty(emailCode, \"请输入邮箱验证码\");\n            Code code = codeService.validateCode(null, email, null, emailCode);\n            ApiAssert.notNull(code, \"邮箱验证码错误\");\n        }\n\n        User user = userService.selectByUsername(username);\n        ApiAssert.isNull(user, \"用户名已存在\");\n        User emailUser = userService.selectByEmail(email);\n        ApiAssert.isNull(emailUser, \"这个邮箱已经被注册过了，请更换一个邮箱\");\n        user = userService.addUser(username, password, null, email, null, null, false);\n        return this.doUserStorage(session, user);\n    }",
        "idx": "81"
    },
    {
        "target_file_name": "UserAdminController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/admin/UserAdminController.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "d09cb19a8e7d7e5151282926ada54080244d499f^",
        "CWE_id": "CWE-521",
        "CVE_id": "CVE-2025-8549",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "BCryptPasswordEncoder",
            "encode"
        ],
        "target_code": "@RequiresPermissions(\"user:edit\")\n    @PostMapping(\"/edit\")\n    @ResponseBody\n    public Result update(User user) {\n        // 如果密码不为空，给加密一下再保存\n        if (!StringUtils.isEmpty(user.getPassword())) {\n            user.setPassword(new BCryptPasswordEncoder().encode(user.getPassword()));\n        } else {\n            user.setPassword(null);\n        }\n        // 如果邮件接收通知没有勾选，user对象里的属性就是null，手动设置成false\n        if (user.getEmailNotification() == null) user.setEmailNotification(false);\n        userService.update(user);\n        return success();\n    }",
        "idx": "82"
    },
    {
        "target_file_name": "TopicService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/TopicService.java#insert",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "indexTopic",
            "insert",
            "insertTag",
            "insertTopicTag",
            "selectAllConfig",
            "update"
        ],
        "target_code": "@Override\n    public Topic insert(String title, String content, String tags, User user) {\n        Topic topic = new Topic();\n        topic.setTitle(title);\n        topic.setStyle(systemConfigService.selectAllConfig().get(\"content_style\"));\n        topic.setContent(content);\n        topic.setInTime(new Date());\n        topic.setUserId(user.getId());\n        topic.setTop(false);\n        topic.setGood(false);\n        topic.setView(1);\n        topic.setCollectCount(0);\n        topic.setCommentCount(0);\n        topicMapper.insert(topic);\n        // 增加用户积分\n        user.setScore(user.getScore() + Integer.parseInt(systemConfigService.selectAllConfig().get(\"create_topic_score\").toString()));\n        userService.update(user);\n        if (!StringUtils.isEmpty(tags)) {\n            // 保存标签\n            List<Tag> tagList = tagService.insertTag(tags);\n            // 处理标签与话题的关联\n            topicTagService.insertTopicTag(topic.getId(), tagList);\n        }\n        // 索引话题\n        indexedService.indexTopic(String.valueOf(topic.getId()), topic.getTitle(), topic.getContent());\n        return topic;\n    }",
        "idx": "83"
    },
    {
        "target_file_name": "TopicService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/TopicService.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "indexTopic",
            "insertTag",
            "insertTopicTag",
            "reduceTopicCount",
            "updateById"
        ],
        "target_code": "@Override\n    public void update(Topic topic, String tags) {\n        topicMapper.updateById(topic);\n        // 处理标签\n        if (!StringUtils.isEmpty(tags)) {\n            // 旧标签每个topicCount都-1\n            tagService.reduceTopicCount(topic.getId());\n            if (!StringUtils.isEmpty(tags)) {\n                // 保存标签\n                List<Tag> tagList = tagService.insertTag(tags);\n                // 处理标签与话题的关联\n                topicTagService.insertTopicTag(topic.getId(), tagList);\n            }\n        }\n        // 索引话题\n        indexedService.indexTopic(String.valueOf(topic.getId()), topic.getTitle(), topic.getContent());\n    }",
        "idx": "84"
    },
    {
        "target_file_name": "IndexController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/front/IndexController.java#search",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "@GetMapping(\"/search\")\n    public String search(@RequestParam(defaultValue = \"1\") Integer pageNo, @RequestParam String keyword, Model model) {\n        model.addAttribute(\"pageNo\", pageNo);\n//        model.addAttribute(\"keyword\", SecurityUtil.sanitizeInput(keyword));\n        model.addAttribute(\"keyword\", keyword.replace(\"\\\"\", \"\").replace(\"'\", \"\"));\n        return render(\"search\");\n    }",
        "idx": "85"
    },
    {
        "target_file_name": "TopicApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/TopicApiController.java#create",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SensitiveWordUtil.replaceSensitiveWord"
        ],
        "target_code": "@PostMapping\n    public Result create(@RequestBody Map<String, String> body) {\n        User user = getApiUser();\n        ApiAssert.isTrue(user.getActive(), \"你的帐号还没有激活，请去个人设置页面激活帐号\");\n        String title = body.get(\"title\");\n        String content = body.get(\"content\");\n        String tag = body.get(\"tag\");\n        //    String tags = body.get(\"tags\");\n        ApiAssert.notEmpty(title, \"请输入标题\");\n        ApiAssert.isNull(topicService.selectByTitle(title), \"话题标题重复\");\n        //    String[] strings = StringUtils.commaDelimitedListToStringArray(tags);\n        //    Set<String> set = StringUtil.removeEmpty(strings);\n        //    ApiAssert.notTrue(set.isEmpty() || set.size() > 5, \"请输入标签且标签最多5个\");\n        // 保存话题\n        // 再次将tag转成逗号隔开的字符串\n        //    tags = StringUtils.collectionToCommaDelimitedString(set);\n        Topic topic = topicService.insert(title, content, tag, user);\n        topic.setContent(SensitiveWordUtil.replaceSensitiveWord(topic.getContent(), \"*\", SensitiveWordUtil.MinMatchType));\n        return success(topic);\n    }",
        "idx": "86"
    },
    {
        "target_file_name": "TopicApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/TopicApiController.java#edit",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SensitiveWordUtil.replaceSensitiveWord"
        ],
        "target_code": "@PutMapping(value = \"/{id}\")\n    public Result edit(@PathVariable Integer id, @RequestBody Map<String, String> body) {\n        User user = getApiUser();\n        String title = body.get(\"title\");\n        String content = body.get(\"content\");\n        ApiAssert.notEmpty(title, \"请输入标题\");\n        // 更新话题\n        Topic topic = topicService.selectById(id);\n        ApiAssert.isTrue(topic.getUserId().equals(user.getId()), \"谁给你的权限修改别人的话题的？\");\n        topic.setTitle(title);\n        topic.setContent(content);\n        topic.setModifyTime(new Date());\n        topicService.update(topic, null);\n        topic.setContent(SensitiveWordUtil.replaceSensitiveWord(topic.getContent(), \"*\", SensitiveWordUtil.MinMatchType));\n        return success(topic);\n    }",
        "idx": "87"
    },
    {
        "target_file_name": "TopicAdminController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/admin/TopicAdminController.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "update"
        ],
        "target_code": "@RequiresPermissions(\"topic:edit\")\n    @PostMapping(\"edit\")\n    @ResponseBody\n    public Result update(Integer id, String title, String content, String tags) {\n        ApiAssert.notEmpty(title, \"话题标题不能为空\");\n\n        Topic topic = topicService.selectById(id);\n        topic.setTitle(title);\n        topic.setContent(content);\n        topic.setModifyTime(new Date());\n        topicService.update(topic, tags);\n        return success();\n    }",
        "idx": "88"
    },
    {
        "target_file_name": "TopicService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/TopicService.java#insert",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Jsoup.clean"
        ],
        "target_code": "@Override\n    public Topic insert(String title, String content, String tags, User user) {\n        Topic topic = new Topic();\n        topic.setTitle(Jsoup.clean(title, Whitelist.simpleText()));\n        topic.setStyle(systemConfigService.selectAllConfig().get(\"content_style\"));\n        topic.setContent(content);\n        topic.setInTime(new Date());\n        topic.setUserId(user.getId());\n        topic.setTop(false);\n        topic.setGood(false);\n        topic.setView(1);\n        topic.setCollectCount(0);\n        topic.setCommentCount(0);\n        topicMapper.insert(topic);\n        // 增加用户积分\n        user.setScore(user.getScore() + Integer.parseInt(systemConfigService.selectAllConfig().get(\"create_topic_score\").toString()));\n        userService.update(user);\n        if (!StringUtils.isEmpty(tags)) {\n            // 保存标签\n            List<Tag> tagList = tagService.insertTag(Jsoup.clean(tags, Whitelist.none()));\n            // 处理标签与话题的关联\n            topicTagService.insertTopicTag(topic.getId(), tagList);\n        }\n        // 索引话题\n        indexedService.indexTopic(String.valueOf(topic.getId()), topic.getTitle(), topic.getContent());\n        return topic;\n    }",
        "idx": "89"
    },
    {
        "target_file_name": "TopicService.java",
        "target_method": "src/main/java/co/yiiu/pybbs/service/impl/TopicService.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Jsoup.clean"
        ],
        "target_code": "@Override\n    public void update(Topic topic, String tags) {\n        topicMapper.updateById(topic);\n        // 处理标签\n        if (!StringUtils.isEmpty(tags)) {\n            // 旧标签每个topicCount都-1\n            tagService.reduceTopicCount(topic.getId());\n            if (!StringUtils.isEmpty(tags)) {\n                // 保存标签\n                List<Tag> tagList = tagService.insertTag(Jsoup.clean(tags, Whitelist.none()));\n                // 处理标签与话题的关联\n                topicTagService.insertTopicTag(topic.getId(), tagList);\n            }\n        }\n        // 索引话题\n        indexedService.indexTopic(String.valueOf(topic.getId()), topic.getTitle(), topic.getContent());\n    }",
        "idx": "90"
    },
    {
        "target_file_name": "IndexController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/front/IndexController.java#search",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Jsoup",
            "Whitelist",
            "basic",
            "clean"
        ],
        "target_code": "@GetMapping(\"/search\")\n    public String search(@RequestParam(defaultValue = \"1\") Integer pageNo, @RequestParam String keyword, Model model) {\n        model.addAttribute(\"pageNo\", pageNo);\n//        model.addAttribute(\"keyword\", SecurityUtil.sanitizeInput(keyword));\n        keyword = Jsoup.clean(keyword, Whitelist.basic());\n        model.addAttribute(\"keyword\", keyword.replace(\"\\\"\", \"\").replace(\"'\", \"\"));\n        return render(\"search\");\n    }",
        "idx": "91"
    },
    {
        "target_file_name": "TopicApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/TopicApiController.java#create",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Jsoup.clean",
            "Whitelist.basic"
        ],
        "target_code": "@PostMapping\n    public Result create(@RequestBody Map<String, String> body) {\n        User user = getApiUser();\n        ApiAssert.isTrue(user.getActive(), \"你的帐号还没有激活，请去个人设置页面激活帐号\");\n        String title = body.get(\"title\");\n        String content = body.get(\"content\");\n        String tag = body.get(\"tag\");\n        //    String tags = body.get(\"tags\");\n        title = Jsoup.clean(title, Whitelist.basic());\n        ApiAssert.notEmpty(title, \"请输入标题\");\n        ApiAssert.isNull(topicService.selectByTitle(title), \"话题标题重复\");\n        //    String[] strings = StringUtils.commaDelimitedListToStringArray(tags);\n        //    Set<String> set = StringUtil.removeEmpty(strings);\n        //    ApiAssert.notTrue(set.isEmpty() || set.size() > 5, \"请输入标签且标签最多5个\");\n        // 保存话题\n        // 再次将tag转成逗号隔开的字符串\n        //    tags = StringUtils.collectionToCommaDelimitedString(set);\n        Topic topic = topicService.insert(title, content, tag, user);\n        topic.setContent(SensitiveWordUtil.replaceSensitiveWord(topic.getContent(), \"*\", SensitiveWordUtil.MinMatchType));\n        return success(topic);\n    }",
        "idx": "92"
    },
    {
        "target_file_name": "TopicApiController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/api/TopicApiController.java#edit",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Jsoup.clean"
        ],
        "target_code": "@PutMapping(value = \"/{id}\")\n    public Result edit(@PathVariable Integer id, @RequestBody Map<String, String> body) {\n        User user = getApiUser();\n        String title = body.get(\"title\");\n        String content = body.get(\"content\");\n        ApiAssert.notEmpty(title, \"请输入标题\");\n        // 更新话题\n        Topic topic = topicService.selectById(id);\n        ApiAssert.isTrue(topic.getUserId().equals(user.getId()), \"谁给你的权限修改别人的话题的？\");\n        topic.setTitle(Jsoup.clean(title, Whitelist.none().addTags(\"video\")));\n        topic.setContent(content);\n        topic.setModifyTime(new Date());\n        topicService.update(topic, null);\n        topic.setContent(SensitiveWordUtil.replaceSensitiveWord(topic.getContent(), \"*\", SensitiveWordUtil.MinMatchType));\n        return success(topic);\n    }",
        "idx": "93"
    },
    {
        "target_file_name": "TopicAdminController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/admin/TopicAdminController.java#update",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "2fe4a51afbce0068c291bc1818bbc8f7f3b01a22^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-8550",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Jsoup.clean"
        ],
        "target_code": "@RequiresPermissions(\"topic:edit\")\n    @PostMapping(\"edit\")\n    @ResponseBody\n    public Result update(Integer id, String title, String content, String tags) {\n        title = Jsoup.clean(title, Whitelist.basic());\n        ApiAssert.notEmpty(title, \"话题标题不能为空\");\n\n        Topic topic = topicService.selectById(id);\n        topic.setTitle(title);\n        topic.setContent(content);\n        topic.setModifyTime(new Date());\n        topicService.update(topic, tags);\n        return success();\n    }",
        "idx": "94"
    },
    {
        "target_file_name": "IndexController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/front/IndexController.java#changeLanguage",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "edb14ff13e9e05394960ba46c3d31d844ff2deac",
        "CWE_id": "CWE-601",
        "CVE_id": "CVE-2025-8813",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setAttribute"
        ],
        "target_code": "@GetMapping(\"changeLanguage\")\n    public String changeLanguage(String lang, HttpSession session) {\n        if (\"zh\".equals(lang)) {\n            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, Locale.SIMPLIFIED_CHINESE);\n        } else if (\"en\".equals(lang)) {\n            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, Locale.US);\n        }\n        return redirect(\"/\");\n    }",
        "idx": "95"
    },
    {
        "target_file_name": "IndexController.java",
        "target_method": "src/main/java/co/yiiu/pybbs/controller/front/IndexController.java#changeLanguage",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "edb14ff13e9e05394960ba46c3d31d844ff2deac^",
        "CWE_id": "CWE-601",
        "CVE_id": "CVE-2025-8813",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getHeader",
            "setAttribute"
        ],
        "target_code": "@GetMapping(\"changeLanguage\")\n    public String changeLanguage(String lang, HttpSession session, HttpServletRequest request) {\n        String referer = request.getHeader(\"referer\");\n        if (\"zh\".equals(lang)) {\n            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, Locale.SIMPLIFIED_CHINESE);\n        } else if (\"en\".equals(lang)) {\n            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, Locale.US);\n        }\n        return StringUtils.isEmpty(referer) ? redirect(\"/\") : redirect(referer);\n    }",
        "idx": "96"
    },
    {
        "target_file_name": "CookieUtil.java",
        "target_method": "src/main/java/co/yiiu/pybbs/util/CookieUtil.java#setCookie",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "8aa2bb1aef3346e49aec6358edf5e47ce905ae7b",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-8814",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpServletResponse.addHeader",
            "ResponseCookie.build",
            "ResponseCookie.from",
            "ResponseCookie.httpOnly",
            "ResponseCookie.maxAge",
            "ResponseCookie.path",
            "ResponseCookie.sameSite",
            "ResponseCookie.secure"
        ],
        "target_code": "public void setCookie(String key, String value) {\n        HttpServletResponse response = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getResponse();\n        HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest();\n        ResponseCookie responseCookie = ResponseCookie.from(key, value)\n                // 设置 HttpOnly\n                .httpOnly(true)\n                // 设置 SameSite 为 Lax，不依赖浏览器默认行为\n                .sameSite(\"Lax\")\n                // 设置 Cookie 路径为网站根路径\n                .path(\"/\")\n                // 设置过期时间（单位：秒）\n                .maxAge(Integer.parseInt(systemConfigService.selectAllConfig().get(\"cookie_max_age\")))\n                // 为 https 访问开启 secure\n                .secure(request.isSecure())\n                .build();\n        assert response != null;\n        response.addHeader(HttpHeaders.SET_COOKIE, responseCookie.toString());\n    }",
        "idx": "97"
    },
    {
        "target_file_name": "CookieUtil.java",
        "target_method": "src/main/java/co/yiiu/pybbs/util/CookieUtil.java#clearCookie",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "8aa2bb1aef3346e49aec6358edf5e47ce905ae7b",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-8814",
        "project_name": "pybbs",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Cookie",
            "addCookie",
            "setDomain",
            "setHttpOnly",
            "setMaxAge",
            "setPath"
        ],
        "target_code": "public void clearCookie(String name) {\n        HttpServletResponse response = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder\n                .getRequestAttributes())).getResponse();\n        Cookie cookie = new Cookie(name, null);\n        cookie.setHttpOnly(true);\n        cookie.setMaxAge(-1);\n        cookie.setDomain(systemConfigService.selectAllConfig().get(\"cookie_domain\"));\n        cookie.setPath(\"/\");\n        assert response != null;\n        response.addCookie(cookie);\n    }",
        "idx": "98"
    },
    {
        "target_file_name": "CookieUtil.java",
        "target_method": "src/main/java/co/yiiu/pybbs/util/CookieUtil.java#setCookie",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "8aa2bb1aef3346e49aec6358edf5e47ce905ae7b^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-8814",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Cookie",
            "addCookie",
            "setDomain",
            "setHttpOnly",
            "setMaxAge",
            "setPath"
        ],
        "target_code": "public void setCookie(String key, String value) {\n        HttpServletResponse response = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder\n                .getRequestAttributes())).getResponse();\n        Cookie cookie = new Cookie(key, value);\n        cookie.setHttpOnly(true);\n        cookie.setPath(\"/\");\n        cookie.setMaxAge(Integer.parseInt(systemConfigService.selectAllConfig().get(\"cookie_max_age\").toString()));\n        cookie.setDomain(systemConfigService.selectAllConfig().get(\"cookie_domain\").toString());\n        assert response != null;\n        response.addCookie(cookie);\n    }",
        "idx": "99"
    },
    {
        "target_file_name": "CookieUtil.java",
        "target_method": "src/main/java/co/yiiu/pybbs/util/CookieUtil.java#clearCookie",
        "project_url": "https://github.com/atjiu/pybbs",
        "commit_id": "8aa2bb1aef3346e49aec6358edf5e47ce905ae7b^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-8814",
        "project_name": "pybbs",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Cookie",
            "addCookie",
            "setDomain",
            "setHttpOnly",
            "setMaxAge",
            "setPath"
        ],
        "target_code": "public void clearCookie(String name) {\n        HttpServletResponse response = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder\n                .getRequestAttributes())).getResponse();\n        Cookie cookie = new Cookie(name, null);\n        cookie.setHttpOnly(true);\n        cookie.setMaxAge(-1);\n        cookie.setDomain((String) systemConfigService.selectAllConfig().get(\"cookie_domain\"));\n        cookie.setPath(\"/\");\n        assert response != null;\n        response.addCookie(cookie);\n    }",
        "idx": "100"
    },
    {
        "target_file_name": "Db2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Db2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (getJdbcUrl().toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            if (!getJdbcUrl().startsWith(\"jdbc:db2\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                return \"jdbc:db2://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                return \"jdbc:db2://HOSTNAME:PORT/DATABASE:currentSchema=SCHEMA;\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            String url = \"jdbc:db2://HOSTNAME:PORT/DATABASE:EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n            for (String illegalParameter : illegalParameters) {\n                if (url.toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return url;\n        }\n    }",
        "idx": "101"
    },
    {
        "target_file_name": "Sqlserver.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Sqlserver.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:sqlserver\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            return \"jdbc:sqlserver://HOSTNAME:PORT;DatabaseName=DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            return \"jdbc:sqlserver://HOSTNAME:PORT;DatabaseName=DATABASE;EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "102"
    },
    {
        "target_file_name": "Mongo.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Mongo.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:mysql\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            return \"jdbc:mysql://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            for (String illegalParameter : illegalParameters) {\n                if (getExtraParams().contains(illegalParameter)) {\n                    throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n\n            return \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "103"
    },
    {
        "target_file_name": "Oracle.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace",
            "startsWith"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:oracle\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isNotEmpty(getConnectionType()) && getConnectionType().equalsIgnoreCase(\"serviceName\")) {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT:DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }\n    }",
        "idx": "104"
    },
    {
        "target_file_name": "Mysql.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(getExtraParams()).contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            if (!getJdbcUrl().startsWith(\"jdbc:mysql\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            jdbcUrl =  \"jdbc:mysql://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            jdbcUrl =  \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "105"
    },
    {
        "target_file_name": "Pg.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            if (!getJdbcUrl().startsWith(\"jdbc:postgresql\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?currentSchema=SCHEMA\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "106"
    },
    {
        "target_file_name": "Impala.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Impala.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:impala\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        if(StringUtils.isEmpty(extraParams.trim())){\n            return \"jdbc:impala://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:impala://HOSTNAME:PORT/DATABASE;EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "107"
    },
    {
        "target_file_name": "Redshift.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Redshift.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            if (!getJdbcUrl().startsWith(\"jdbc:redshift\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).contains(illegalParameter)) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "108"
    },
    {
        "target_file_name": "CK.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/CK.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            if (!getJdbcUrl().startsWith(\"jdbc:clickhouse\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            return \"jdbc:clickhouse://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            return \"jdbc:clickhouse://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "109"
    },
    {
        "target_file_name": "Oracle.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        if (StringUtils.isNotEmpty(getConnectionType()) && getConnectionType().equalsIgnoreCase(\"serviceName\")) {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT:DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }\n    }",
        "idx": "110"
    },
    {
        "target_file_name": "Mysql.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(getExtraParams()).contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            jdbcUrl =  \"jdbc:mysql://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            jdbcUrl =  \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "111"
    },
    {
        "target_file_name": "Pg.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?currentSchema=SCHEMA\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "112"
    },
    {
        "target_file_name": "Impala.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Impala.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        if(StringUtils.isEmpty(extraParams.trim())){\n            return \"jdbc:impala://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:impala://HOSTNAME:PORT/DATABASE;EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "113"
    },
    {
        "target_file_name": "Redshift.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Redshift.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).contains(illegalParameter)) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "114"
    },
    {
        "target_file_name": "CK.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/CK.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        if(StringUtils.isEmpty(extraParams.trim())){\n            return \"jdbc:clickhouse://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:clickhouse://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "115"
    },
    {
        "target_file_name": "Mongo.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Mongo.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            return \"jdbc:mysql://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            for (String illegalParameter : illegalParameters) {\n                if (getExtraParams().contains(illegalParameter)) {\n                    throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n\n            return \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "116"
    },
    {
        "target_file_name": "Sqlserver.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Sqlserver.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "1644d81dff46272b09570fa1f4a8f83f01f37440^",
        "CWE_id": "CWE-94",
        "CVE_id": "CVE-2025-57772",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            return \"jdbc:sqlserver://HOSTNAME:PORT;DatabaseName=DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            return \"jdbc:sqlserver://HOSTNAME:PORT;DatabaseName=DATABASE;EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "117"
    },
    {
        "target_file_name": "Db2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Db2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "8d04e92d44e1bac9284e9e64df5afd7f96d9373c",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-57773",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (getJdbcUrl().toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                return \"jdbc:db2://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                return \"jdbc:db2://HOSTNAME:PORT/DATABASE:currentSchema=SCHEMA;\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            String url = \"jdbc:db2://HOSTNAME:PORT/DATABASE:EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n            for (String illegalParameter : illegalParameters) {\n                if (url.toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return url;\n        }\n    }",
        "idx": "118"
    },
    {
        "target_file_name": "Db2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Db2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "8d04e92d44e1bac9284e9e64df5afd7f96d9373c^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-57773",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        if(StringUtils.isEmpty(extraParams.trim())){\n            if (StringUtils.isEmpty(getSchema())) {\n                return \"jdbc:db2://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                return \"jdbc:db2://HOSTNAME:PORT/DATABASE:currentSchema=SCHEMA;\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\",getSchema().trim());\n            }\n        }else {\n            return \"jdbc:db2://HOSTNAME:PORT/DATABASE:EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n    }",
        "idx": "119"
    },
    {
        "target_file_name": "DefaultNotificationsResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-notifications/xwiki-platform-notifications-rest/src/main/java/org/xwiki/notifications/rest/internal/DefaultNotificationsResource.java#toMaxCount",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "NumberUtils.toInt"
        ],
        "target_code": "private int toMaxCount(String maxCount, int defaultMaxCount)\n    {\n        return validateAndGetLimit(NumberUtils.toInt(maxCount, defaultMaxCount));\n    }",
        "idx": "120"
    },
    {
        "target_file_name": "WikisSearchQueryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-search/xwiki-platform-search-solr/xwiki-platform-search-solr-rest/src/main/java/org/xwiki/search/solr/internal/rest/WikisSearchQueryResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "solrSearch.search"
        ],
        "target_code": "@Override\n    public SearchResults search(String query, Integer number, Integer start, Boolean distinct, String searchWikis,\n        String orderField, String order, Boolean withPrettyNames, String className) throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n\n        try {\n            SearchResults searchResults = objectFactory.createSearchResults();\n            searchResults.setTemplate(String.format(\"%s?%s\", uriInfo.getBaseUri().toString(),\n                MULTIWIKI_QUERY_TEMPLATE_INFO));\n\n            searchResults.getSearchResults().addAll(\n                this.solrSearch.search(\n                    query,\n                    getXWikiContext().getWikiId(),\n                    searchWikis,\n                    Utils.getXWiki(componentManager).getRightService().hasProgrammingRights(\n                        Utils.getXWikiContext(componentManager)), orderField, order, distinct, limit, start,\n                        withPrettyNames, className, uriInfo));\n\n            return searchResults;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "121"
    },
    {
        "target_file_name": "PageChildrenResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/pages/PageChildrenResourceImpl.java#getPageChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren",
            "getDocumentReference",
            "getDocumentReferences",
            "matching"
        ],
        "target_code": "@Override\n    public Pages getPageChildren(String wikiName, String spaceName, String pageName, Integer start, Integer number,\n        Boolean withPrettyNames, String hierarchy, String search) throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n        try {\n            DocumentInfo documentInfo = getDocumentInfo(wikiName, spaceName, pageName, null, null, true, false);\n\n            if (\"nestedpages\".equals(hierarchy)) {\n                return getPages(this.nestedPageHierarchy.getChildren(documentInfo.getDocument().getDocumentReference())\n                    .withOffset(start).withLimit(limit).matching(search).getDocumentReferences(), withPrettyNames);\n            } else {\n                // We fall-back (default) to the parent-child hierarchy for backwards compatibility.\n                return getPages(getPageChildrenForParentChildHierarchy(documentInfo, start, limit), withPrettyNames);\n            }\n        } catch (XWikiException | QueryException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "122"
    },
    {
        "target_file_name": "PagesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PagesResource.java#getPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getPages(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"parentId\") String parentFilterExpression,\n            @QueryParam(\"order\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "123"
    },
    {
        "target_file_name": "WikiAttachmentsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiAttachmentsResourceImpl.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getAttachments"
        ],
        "target_code": "@Override\n    public Attachments getAttachments(String wiki, String name, String page, String space, String author,\n        String fileTypes, Integer offset, Integer limit, Boolean withPrettyNames) throws XWikiRestException\n    {\n        Map<String, String> filters = new HashMap<>();\n        filters.put(\"space\", space);\n        filters.put(\"page\", page);\n        filters.put(\"name\", name);\n        filters.put(\"author\", author);\n        filters.put(\"fileTypes\", fileTypes);\n\n        return super.getAttachments(new WikiReference(wiki), filters, offset, validateAndGetLimit(limit),\n            withPrettyNames);\n    }",
        "idx": "124"
    },
    {
        "target_file_name": "ClassesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/classes/ClassesResourceImpl.java#getClasses",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getClass",
            "getClassList"
        ],
        "target_code": "@Override\n    public Classes getClasses(String wikiName, Integer start, Integer number) throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        try {\n            getXWikiContext().setWikiId(wikiName);\n\n            List<String> classNames = Utils.getXWikiApi(componentManager).getClassList();\n            Collections.sort(classNames);\n\n            RangeIterable<String> ri = new RangeIterable<String>(classNames, start, limit);\n\n            Classes classes = objectFactory.createClasses();\n\n            for (String className : ri) {\n                DocumentReference classReference = this.resolver.resolve(className, new WikiReference(wikiName));\n                if (this.authorization.hasAccess(Right.VIEW, classReference)) {\n                    com.xpn.xwiki.api.Class xwikiClass = Utils.getXWikiApi(componentManager).getClass(classReference);\n                    classes.getClazzs().add(this.utils.toRestClass(uriInfo.getBaseUri(), xwikiClass));\n                }\n            }\n\n            return classes;\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "idx": "125"
    },
    {
        "target_file_name": "PageHistoryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PageHistoryResource.java#getPageHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET History getPageHistory(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"order\") @DefaultValue(\"desc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "126"
    },
    {
        "target_file_name": "WikiChildrenResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikiChildrenResource.java#getChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getChildren(\n        @PathParam(\"wikiName\") String wikiName,\n        @QueryParam(\"offset\") @DefaultValue(\"0\") Integer offset,\n        @QueryParam(\"limit\") Integer limit,\n        @QueryParam(\"search\") @DefaultValue(\"\") String search\n    ) throws XWikiRestException;",
        "idx": "127"
    },
    {
        "target_file_name": "AttachmentsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/attachments/AttachmentsResourceImpl.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DocumentReference",
            "parseSpaceSegments"
        ],
        "target_code": "@Override\n    public Attachments getAttachments(String wiki, String spaces, String page, Integer offset, Integer limit,\n        Boolean withPrettyNames, String name, String author, String fileTypes) throws XWikiRestException\n    {\n        Map<String, String> filters = new HashMap<>();\n        filters.put(NAME, name);\n        filters.put(\"author\", author);\n        filters.put(\"fileTypes\", fileTypes);\n\n        return super.getAttachments(new DocumentReference(wiki, parseSpaceSegments(spaces), page), filters, offset,\n            validateAndGetLimit(limit), withPrettyNames);\n    }",
        "idx": "128"
    },
    {
        "target_file_name": "AllObjectsForClassNameResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/objects/AllObjectsForClassNameResourceImpl.java#getObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset"
        ],
        "target_code": "@Override\n    public Objects getObjects(String wikiName, String className, Integer start, Integer number, String order,\n            Boolean withPrettyNames) throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n        int limit = validateAndGetLimit(number);\n\n        try {\n            Objects objects = new Objects();\n\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            String query = \"select doc, obj from BaseObject as obj, XWikiDocument as doc \"\n                + \"where obj.name=doc.fullName and obj.className=:className\";\n            if (\"date\".equals(order)) {\n                query += \" order by doc.date desc\";\n            }\n\n            List<Object> queryResult = null;\n            queryResult =\n                this.queryManager.createQuery(query, Query.XWQL).bindValue(\"className\", className)\n                    .setLimit(limit)\n                    .setOffset(start).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n                XWikiDocument xwikiDocument = (XWikiDocument) fields[0];\n                xwikiDocument.setDatabase(wikiName);\n\n                if (authorization.hasAccess(Right.VIEW, xwikiDocument.getDocumentReference())) {\n\n                    Document doc = new Document(xwikiDocument, Utils.getXWikiContext(componentManager));\n\n                    BaseObject xwikiObject = (BaseObject) fields[1];\n\n                    ObjectSummary objectSummary = DomainObjectFactory\n                        .createObjectSummary(objectFactory, uriInfo.getBaseUri(), Utils.getXWikiContext(\n                            componentManager), doc, xwikiObject, false, Utils.getXWikiApi(componentManager),\n                            withPrettyNames);\n\n                    objects.getObjectSummaries().add(objectSummary);\n                }\n            }\n\n            return objects;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "idx": "129"
    },
    {
        "target_file_name": "SpacesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/spaces/SpacesResourceImpl.java#getSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "createSpace",
            "execute",
            "exists",
            "getDocument",
            "getInstance",
            "getNamedQuery",
            "getPageId",
            "getSpacesFromSpaceId",
            "getXWikiApi",
            "hasAccessLevel",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public Spaces getSpaces(String wikiName, Integer start, Integer number)\n            throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n        Spaces spaces = objectFactory.createSpaces();\n\n        try {\n            List<String> spaceNames = queryManager.getNamedQuery(\"getSpaces\").addFilter(\n                    componentManager.<QueryFilter>getInstance(QueryFilter.class, \"hidden\")).setOffset(start)\n                .setLimit(limit).setWiki(wikiName).execute();\n\n            for (String spaceName : spaceNames) {\n                List<String> spaceList = Utils.getSpacesFromSpaceId(spaceName);\n                String homeId = Utils.getPageId(wikiName, spaceList, \"WebHome\");\n                Document home = null;\n\n                XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n                if (xwikiApi.hasAccessLevel(\"view\", homeId)) {\n                    if (xwikiApi.exists(homeId)) {\n                        home = Utils.getXWikiApi(componentManager).getDocument(homeId);\n                    }\n                    spaces.getSpaces().add(DomainObjectFactory.createSpace(objectFactory, uriInfo.getBaseUri(),\n                        wikiName, spaceList, home));\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n\n        return spaces;\n    }",
        "idx": "130"
    },
    {
        "target_file_name": "WikiSearchQueryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikiSearchQueryResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "@GET SearchResults search(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"q\") String query,\n            @QueryParam(\"type\") String queryTypeString,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"distinct\") @DefaultValue(\"true\") Boolean distinct,\n            @QueryParam(\"orderField\") @DefaultValue(\"\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"className\") @DefaultValue(\"\") String className\n    ) throws XWikiRestException;",
        "idx": "131"
    },
    {
        "target_file_name": "AttachmentsResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/attachments/AttachmentsResource.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Attachments getAttachments(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"name\") @DefaultValue(\"\") String name,\n            @QueryParam(\"author\") @DefaultValue(\"\") String author,\n            @QueryParam(\"types\") @DefaultValue(\"\") String types\n    ) throws XWikiRestException;",
        "idx": "132"
    },
    {
        "target_file_name": "ModificationsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/ModificationsResourceImpl.java#getModifications",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public History getModifications(String wikiName, Integer start, Integer number, String order, Long ts,\n            Boolean withPrettyNames) throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            History history = new History();\n\n            String query = String.format(\"select doc.space, doc.name, doc.language, rcs.id, rcs.date, rcs.author,\"\n                + \" rcs.comment from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" rcs.date > :date order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\",\n                validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"date\", new Date(ts))\n                .setLimit(limit).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[0];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[1];\n\n                DocumentReference documentReference =\n                    this.resolver.resolve(Utils.getPageId(wikiName, spaces, pageName));\n                if (this.authorizationManager.hasAccess(VIEW, documentReference)) {\n                    String language = (String) fields[2];\n                    if (language.equals(\"\")) {\n                        language = null;\n                    }\n                    XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[3];\n                    Timestamp timestamp = (Timestamp) fields[4];\n                    Date modified = new Date(timestamp.getTime());\n                    String modifier = (String) fields[5];\n                    String comment = (String) fields[6];\n\n                    HistorySummary historySummary =\n                        DomainObjectFactory.createHistorySummary(this.objectFactory, this.uriInfo.getBaseUri(),\n                            wikiName, spaces, pageName, language, nodeId.getVersion(), modifier, modified, comment,\n                            Utils.getXWikiApi(this.componentManager), withPrettyNames);\n                    history.getHistorySummaries().add(historySummary);\n                }\n            }\n\n            return history;\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "133"
    },
    {
        "target_file_name": "AttachmentHistoryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/attachments/AttachmentHistoryResource.java#getAttachmentHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Attachments getAttachmentHistory(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @PathParam(\"attachmentName\") String attachmentName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number\n    ) throws XWikiRestException;",
        "idx": "134"
    },
    {
        "target_file_name": "SpacesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/spaces/SpacesResource.java#getSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Spaces getSpaces(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number\n    ) throws XWikiRestException;",
        "idx": "135"
    },
    {
        "target_file_name": "AllObjectsForClassNameResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/objects/AllObjectsForClassNameResource.java#getObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Objects getObjects(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"className\") String className,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"order\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "136"
    },
    {
        "target_file_name": "SpaceAttachmentsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/spaces/SpaceAttachmentsResourceImpl.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SpaceReference",
            "getAttachments",
            "parseSpaceSegments",
            "validateAndGetLimit"
        ],
        "target_code": "@Override\n    public Attachments getAttachments(String wiki, String spaces, String name, String page, String author,\n        String fileTypes, Integer offset, Integer limit, Boolean withPrettyNames) throws XWikiRestException\n    {\n        Map<String, String> filters = new HashMap<>();\n        filters.put(\"page\", page);\n        filters.put(\"name\", name);\n        filters.put(\"author\", author);\n        filters.put(\"fileTypes\", fileTypes);\n\n        return super.getAttachments(new SpaceReference(wiki, parseSpaceSegments(spaces)), filters, offset,\n            validateAndGetLimit(limit), withPrettyNames);\n    }",
        "idx": "137"
    },
    {
        "target_file_name": "WikiChildrenResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiChildrenResourceImpl.java#getChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren",
            "getDocumentReferences",
            "matching",
            "withLimit",
            "withOffset"
        ],
        "target_code": "@Override\n    public Pages getChildren(String wikiName, Integer offset, Integer limit, String search) throws XWikiRestException\n    {\n        WikiReference wikiReference = new WikiReference(wikiName);\n        if (!this.contextualAuthorizationManager.hasAccess(Right.VIEW, wikiReference)) {\n            throw new WebApplicationException(Response.Status.FORBIDDEN);\n        }\n\n        int queryLimit = validateAndGetLimit(limit);\n\n        try {\n            return getPages(this.nestedPageHierarchy.getChildren(wikiReference).withOffset(offset).withLimit(queryLimit)\n                .matching(search).getDocumentReferences(), true);\n        } catch (QueryException e) {\n            throw new XWikiRestException(\"Failed to retrieve the top level pages.\", e);\n        }\n    }",
        "idx": "138"
    },
    {
        "target_file_name": "WikiPagesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiPagesResourceImpl.java#getPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Query",
            "bindValue",
            "createQuery",
            "execute"
        ],
        "target_code": "@Override\n    public Pages getPages(String wikiName, Integer start, String name, String space, String author, Integer number)\n            throws XWikiRestException\n    {\n        XWikiContext context = Utils.getXWikiContext(componentManager);\n        WikiReference wikiReference = context.getWikiReference();\n        context.setWikiReference(new WikiReference(wikiName));\n\n        Pages pages = objectFactory.createPages();\n        try {\n            Map<String, String> filters = new HashMap<>();\n            if (!StringUtils.isEmpty(name)) {\n                filters.put(\"name\", name);\n            }\n            if (!StringUtils.isEmpty(space)) {\n                filters.put(\"space\", Utils.getLocalSpaceId(parseSpaceSegments(space)));\n            }\n            if (!StringUtils.isEmpty(author)) {\n                filters.put(\"author\", author);\n            }\n\n            /* Build the query */\n            StringBuilder stringBuilder = new StringBuilder(\"select doc from XWikiDocument as doc\");\n\n            if (!filters.isEmpty()) {\n                stringBuilder.append(\" where (\");\n\n                int i = 0;\n                for (String param : filters.keySet()) {\n                    if (param.equals(\"name\")) {\n                        stringBuilder.append(\"upper(doc.fullName) like :name \");\n                    }\n                    if (param.equals(\"space\")) {\n                        stringBuilder.append(\"upper(doc.space) like :space \");\n                    }\n                    if (param.equals(\"author\")) {\n                        stringBuilder.append(\"upper(doc.contentAuthor) like :author \");\n                    }\n                    i++;\n\n                    if (i < filters.keySet().size()) {\n                        stringBuilder.append(\"and \");\n                    }\n                }\n\n                stringBuilder.append(\")\");\n            }\n\n            String queryString = stringBuilder.toString();\n\n            /* Execute the query by filling the parameters */\n            List<Object> queryResult = null;\n            Query query = queryManager.createQuery(queryString, Query.XWQL)\n                .setWiki(wikiName)\n                .setLimit(validateAndGetLimit(number))\n                .setOffset(start);\n\n            for (Map.Entry<String, String> filterEntry : filters.entrySet()) {\n                query.bindValue(filterEntry.getKey(), String.format(\"%%%s%%\", filterEntry.getValue().toUpperCase()));\n            }\n\n            queryResult = query.execute();\n            XWikiURLFactory urlFactory = context.getURLFactory();\n\n            /* Get the results and populate the returned representation */\n            for (Object object : queryResult) {\n                XWikiDocument xwikiDocument = (XWikiDocument) object;\n\n                Document doc = new Document(xwikiDocument, context);\n                if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, doc.getDocumentReference())) {\n                    /*\n                     * We manufacture page summaries in place because we don't have all the data for calling the\n                     * DomainObjectFactory method (doing so would require to retrieve an actual Document)\n                     */\n                    PageSummary pageSummary = objectFactory.createPageSummary();\n                    pageSummary.setId(doc.getPrefixedFullName());\n                    pageSummary.setFullName(doc.getFullName());\n                    pageSummary.setWiki(wikiName);\n                    pageSummary.setSpace(doc.getSpace());\n                    pageSummary.setName(doc.getDocumentReference().getName());\n                    pageSummary.setTitle(doc.getTitle());\n                    pageSummary.setParent(doc.getParent());\n\n                    URL absoluteUrl = urlFactory.createExternalURL(\n                        doc.getSpace(), doc.getDocumentReference().getName(), \"view\", null, null,\n                        context);\n                    pageSummary.setXwikiAbsoluteUrl(absoluteUrl.toString());\n                    pageSummary.setXwikiRelativeUrl(urlFactory.getURL(\n                        absoluteUrl, context));\n\n                    String pageUri = Utils\n                        .createURI(uriInfo.getBaseUri(), PageResource.class, doc.getWiki(),\n                            Utils.getSpacesURLElements(doc.getDocumentReference()),\n                            doc.getDocumentReference().getName())\n                        .toString();\n                    Link pageLink = objectFactory.createLink();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    pageSummary.getLinks().add(pageLink);\n\n                    pages.getPageSummaries().add(pageSummary);\n                }\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        } finally {\n            context.setWikiReference(wikiReference);\n        }\n\n        return pages;\n    }",
        "idx": "139"
    },
    {
        "target_file_name": "DefaultLiveDataEntriesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-livedata/xwiki-platform-livedata-rest/src/main/java/org/xwiki/livedata/internal/rest/DefaultLiveDataEntriesResource.java#getEntries",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getEntries"
        ],
        "target_code": "@Override\n    public Entries getEntries(String sourceId, String namespace, List<String> properties, List<String> matchAll,\n        List<String> sort, List<Boolean> descending, long offset, int limit) throws Exception\n    {\n        this.contextInitializer.initialize(namespace);\n\n        int validatedLimit = validateAndGetLimit(limit);\n\n        LiveDataConfiguration config =\n            initConfig(sourceId, properties, matchAll, sort, descending, offset, validatedLimit);\n        return getEntries(namespace, offset, validatedLimit, config);\n    }",
        "idx": "140"
    },
    {
        "target_file_name": "PagesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/pages/PagesResourceImpl.java#getPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Pattern.compile",
            "Pattern.matcher"
        ],
        "target_code": "@Override\n    public Pages getPages(String wikiName, String spaceName, Integer start, Integer number,\n            String parentFilterExpression, String order, Boolean withPrettyNames)\n            throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n        List<String> spaces = parseSpaceSegments(spaceName);\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        Pages pages = objectFactory.createPages();\n        int limit = validateAndGetLimit(number);\n\n        try {\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            Query query = (\"date\".equals(order)) ? queryManager.createQuery(\n                    \"select doc.name from Document doc where doc.space=:space and language='' order by doc.date desc\",\n                    \"xwql\") : queryManager.getNamedQuery(\"getSpaceDocsName\");\n\n            /* Use an explicit query to improve performance */\n            List<String> pageNames =\n                query.addFilter(componentManager.<QueryFilter>getInstance(QueryFilter.class, \"hidden\"))\n                    .bindValue(\"space\", spaceId)\n                    .setOffset(start)\n                    .setLimit(limit)\n                    .execute();\n\n            Pattern parentFilter = null;\n            if (parentFilterExpression != null) {\n                if (parentFilterExpression.equals(\"null\")) {\n                    parentFilter = Pattern.compile(\"\");\n                } else {\n                    parentFilter = Pattern.compile(parentFilterExpression);\n                }\n            }\n\n            for (String pageName : pageNames) {\n                String pageFullName = Utils.getPageId(wikiName, spaces, pageName);\n\n                if (!Utils.getXWikiApi(componentManager).exists(pageFullName)) {\n                    getLogger().warn(\"Page [{}] appears to be in space [{}] but no information is available.\", pageName,\n                        spaceId);\n                } else {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n\n                    /* We only add pages we have the right to access */\n                    if (doc != null) {\n                        boolean add = true;\n\n                        Document parent = Utils.getParentDocument(doc, Utils.getXWikiApi(componentManager));\n\n                        if (parentFilter != null) {\n                            String parentId = \"\";\n                            if (parent != null && !parent.isNew()) {\n                                parentId = parent.getPrefixedFullName();\n                            }\n                            add = parentFilter.matcher(parentId).matches();\n                        }\n\n                        if (add) {\n                            pages.getPageSummaries().add(DomainObjectFactory.createPageSummary(objectFactory,\n                                    uriInfo.getBaseUri(), doc, Utils.getXWikiApi(componentManager), withPrettyNames));\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n\n        return pages;\n    }",
        "idx": "141"
    },
    {
        "target_file_name": "PagesForTagsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/tags/PagesForTagsResourceImpl.java#getTags",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getDocument"
        ],
        "target_code": "@Override\n    public Pages getTags(String wikiName, String tagNames, Integer start, Integer number, Boolean withPrettyNames)\n            throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        int limit = validateAndGetLimit(number);\n\n        try {\n            Pages pages = objectFactory.createPages();\n\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            String[] tagNamesArray = tagNames.split(\",\");\n            List<String> documentNames = getDocumentsWithTags(tagNamesArray, start, limit);\n\n            for (String documentName : documentNames) {\n                Document doc = Utils.getXWikiApi(componentManager).getDocument(documentName);\n                if (doc != null) {\n                    pages.getPageSummaries().add(DomainObjectFactory\n                            .createPageSummary(objectFactory, uriInfo.getBaseUri(), doc, Utils.getXWikiApi(\n                                    componentManager), withPrettyNames));\n                }\n            }\n\n            return pages;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "idx": "142"
    },
    {
        "target_file_name": "WikisSearchQueryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikisSearchQueryResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SearchResults"
        ],
        "target_code": "@GET SearchResults search(\n            @QueryParam(\"q\") String query,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"distinct\") @DefaultValue(\"true\") Boolean distinct,\n            @QueryParam(\"wikis\") String searchWikis,\n            @QueryParam(\"orderField\") @DefaultValue(\"\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"className\") @DefaultValue(\"\") String className\n    ) throws XWikiRestException;",
        "idx": "143"
    },
    {
        "target_file_name": "PageHistoryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/pages/PageHistoryResourceImpl.java#getPageHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public History getPageHistory(String wikiName, String spaceName, String pageName, Integer start, Integer number,\n            String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            // Note that the query is made to work with Oracle which treats empty strings as null.\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and (doc.language = '' or doc.language is null)\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName)\n                .setLimit(validateAndGetLimit(number))\n                .setOffset(start)\n                .setWiki(wikiName)\n                .execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, null, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }",
        "idx": "144"
    },
    {
        "target_file_name": "PageChildrenResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PageChildrenResource.java#getPageChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getPageChildren(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"hierarchy\") @DefaultValue(\"parentchild\") String hierarchy,\n            @QueryParam(\"search\") @DefaultValue(\"\") String search\n    ) throws XWikiRestException;",
        "idx": "145"
    },
    {
        "target_file_name": "PageTranslationHistoryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/pages/PageTranslationHistoryResourceImpl.java#getPageTranslationHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public History getPageTranslationHistory(String wikiName, String spaceName, String pageName, String language,\n            Integer start, Integer number, String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n        int limit = validateAndGetLimit(number);\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and doc.language = :language\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n            \n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName)\n                .bindValue(\"language\", language)\n                .setLimit(limit)\n                .setOffset(start)\n                .setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, language, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }",
        "idx": "146"
    },
    {
        "target_file_name": "ClassPropertyValuesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/classes/ClassPropertyValuesResourceImpl.java#getClassPropertyValues",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getValue",
            "getValues"
        ],
        "target_code": "@Override\n    public PropertyValues getClassPropertyValues(String wikiName, String className, String propertyName, Integer limit,\n        List<String> filterParameters, Boolean isExactMatch) throws XWikiRestException\n    {\n        DocumentReference classReference = this.resolver.resolve(className, new WikiReference(wikiName));\n        ClassPropertyReference classPropertyReference = new ClassPropertyReference(propertyName, classReference);\n        try {\n            this.authorization.checkAccess(Right.VIEW, classPropertyReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(e, Status.UNAUTHORIZED);\n        }\n        if (!exists(classPropertyReference)) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        URI propertyURI =\n            Utils.createURI(this.uriInfo.getBaseUri(), ClassPropertyResource.class, wikiName, className, propertyName);\n        Link propertyLink = this.objectFactory.createLink();\n        propertyLink.setHref(propertyURI.toString());\n        propertyLink.setRel(Relations.PROPERTY);\n\n        PropertyValues propertyValues = new PropertyValues();\n        if (isExactMatch) {\n            for (String filterParameter : filterParameters) {\n                PropertyValue value =  this.propertyValuesProvider.getValue(classPropertyReference, filterParameter);\n                if (value != null) {\n                    propertyValues.getPropertyValues().add(value);\n                }\n            }\n        } else {\n            propertyValues = this.propertyValuesProvider\n                .getValues(classPropertyReference, validateAndGetLimit(limit), filterParameters.toArray());\n        }\n        propertyValues.getLinks().add(propertyLink);\n\n        return propertyValues;\n    }",
        "idx": "147"
    },
    {
        "target_file_name": "SpaceSearchResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/spaces/SpaceSearchResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "@GET SearchResults search(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @QueryParam(\"q\") String keywords,\n            @QueryParam(\"scope\") List<String> searchScopeStrings,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"orderField\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"localeAware\") @DefaultValue(\"false\") Boolean isLocaleAware\n    ) throws XWikiRestException;",
        "idx": "148"
    },
    {
        "target_file_name": "PageResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/PageResourceIT.java#setUp",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "delete",
            "page",
            "rest",
            "save",
            "setComment",
            "setParent"
        ],
        "target_code": "@Before\n    @Override\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.wikiName = getWiki();\n        this.space = getTestClassName();\n        this.spaces = List.of(this.space);\n        this.pageName = getTestMethodName();\n        this.reference = new DocumentReference(this.wikiName, this.spaces, this.pageName);\n\n        this.childPageName = \"child\";\n        this.childReference = new DocumentReference(this.wikiName, this.spaces, this.childPageName);\n\n        // Create a clean test page.\n        this.testUtils.rest().delete(this.reference);\n        Page page = this.testUtils.rest().page(this.reference);\n        page.setComment(\"Test page\");\n        this.testUtils.rest().save(page);\n\n        // Create a clean test page child.\n        this.testUtils.rest().delete(this.childReference);\n        Page childPage = this.testUtils.rest().page(this.childReference);\n        childPage.setComment(\"Test page child\");\n        childPage.setParent(this.space + '.' + this.pageName);\n        this.testUtils.rest().save(childPage);\n    }",
        "idx": "149"
    },
    {
        "target_file_name": "PageResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/PageResourceIT.java#getFirstPage",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "unmarshal"
        ],
        "target_code": "private Page getFirstPage() throws Exception\n    {\n        GetMethod getMethod = executeGet(getFullUri(WikisResource.class));\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n\n        Wikis wikis = (Wikis) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n        Assert.assertTrue(wikis.getWikis().size() > 0);\n        Wiki wiki = wikis.getWikis().get(0);\n\n        // Get a link to an index of spaces (http://localhost:8080/xwiki/rest/wikis/xwiki/spaces)\n        Link spacesLink = getFirstLinkByRelation(wiki, Relations.SPACES);\n        Assert.assertNotNull(spacesLink);\n        getMethod = executeGet(spacesLink.getHref());\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n        Spaces spaces = (Spaces) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n        Assert.assertTrue(spaces.getSpaces().size() > 0);\n\n        Space space = null;\n        for (final Space s : spaces.getSpaces()) {\n            if (this.space.equals(s.getName())) {\n                space = s;\n                break;\n            }\n        }\n\n        // get the pages list for the space\n        // eg: http://localhost:8080/xwiki/rest/wikis/xwiki/spaces/Main/pages\n        Link pagesInSpace = getFirstLinkByRelation(space, Relations.PAGES);\n        Assert.assertNotNull(pagesInSpace);\n        getMethod = executeGet(pagesInSpace.getHref());\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n        Pages pages = (Pages) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n        Assert.assertTrue(pages.getPageSummaries().size() > 0);\n\n        Link pageLink = null;\n        for (final PageSummary ps : pages.getPageSummaries()) {\n            if (this.pageName.equals(ps.getName())) {\n                pageLink = getFirstLinkByRelation(ps, Relations.PAGE);\n                Assert.assertNotNull(pageLink);\n                break;\n            }\n        }\n        Assert.assertNotNull(pageLink);\n\n        getMethod = executeGet(pageLink.getHref());\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n\n        Page page = (Page) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n\n        return page;\n    }",
        "idx": "150"
    },
    {
        "target_file_name": "PageTranslationHistoryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PageTranslationHistoryResource.java#getPageTranslationHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET History getPageTranslationHistory(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @PathParam(\"language\") String language,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"order\") @DefaultValue(\"desc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "151"
    },
    {
        "target_file_name": "SpaceSearchResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/spaces/SpaceSearchResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "build",
            "builder",
            "createSearchResults",
            "createURI",
            "getBaseUri",
            "getSearchResults",
            "isLocaleAware",
            "number",
            "order",
            "orderField",
            "parseSearchScopeStrings",
            "parseSpaceSegments",
            "search",
            "searchScopes",
            "setTemplate",
            "space",
            "start",
            "validateAndGetLimit",
            "wikiName",
            "withPrettyNames"
        ],
        "target_code": "@Override\n    public SearchResults search(String wikiName, String spaceName, String keywords, List<String> searchScopeStrings,\n        Integer number, Integer start, String orderField, String order, Boolean withPrettyNames, Boolean isLocaleAware)\n        throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        SearchResults searchResults = objectFactory.createSearchResults();\n        searchResults.setTemplate(String.format(\"%s?%s\",\n            Utils.createURI(uriInfo.getBaseUri(), SpaceSearchResource.class, wikiName, spaces).toString(),\n            SEARCH_TEMPLATE_INFO));\n\n        List<KeywordSearchScope> searchScopes = parseSearchScopeStrings(searchScopeStrings);\n\n        int limit = validateAndGetLimit(number);\n\n        KeywordSearchOptions searchOptions = KeywordSearchOptions.builder()\n            .searchScopes(searchScopes)\n            .wikiName(wikiName)\n            .space(Utils.getLocalSpaceId(spaces))\n            .number(limit)\n            .start(start)\n            .orderField(orderField)\n            .order(order)\n            .withPrettyNames(withPrettyNames)\n            .isLocaleAware(isLocaleAware)\n            .build();\n        searchResults.getSearchResults()\n            .addAll(this.keywordSearchSource.search(keywords, searchOptions, this.uriInfo.getBaseUri()));\n\n        return searchResults;\n    }",
        "idx": "152"
    },
    {
        "target_file_name": "WikiSearchResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiSearchResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "build",
            "builder",
            "createSearchResults",
            "createURI",
            "getBaseUri",
            "getSearchResults",
            "getXWikiContext",
            "isLocaleAware",
            "number",
            "order",
            "orderField",
            "parseSearchScopeStrings",
            "search",
            "searchScopes",
            "setTemplate",
            "setWikiId",
            "space",
            "start",
            "wikiName",
            "withPrettyNames"
        ],
        "target_code": "@Override\n    public SearchResults search(String wikiName, String keywords, List<String> searchScopeStrings, Integer number,\n        Integer start, String orderField, String order, Boolean withPrettyNames, Boolean isLocaleAware)\n            throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n\n        SearchResults searchResults = objectFactory.createSearchResults();\n        searchResults.setTemplate(String.format(\"%s?%s\",\n            Utils.createURI(uriInfo.getBaseUri(), WikiSearchResource.class, wikiName).toString(),\n            SEARCH_TEMPLATE_INFO));\n\n        if (wikiName != null) {\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n        }\n\n        List<KeywordSearchScope> searchScopes = parseSearchScopeStrings(searchScopeStrings);\n\n        KeywordSearchOptions searchOptions = KeywordSearchOptions.builder()\n            .searchScopes(searchScopes)\n            .wikiName(getXWikiContext().getWikiId())\n            .space(null)\n            .number(limit)\n            .start(start)\n            .orderField(orderField)\n            .order(order)\n            .withPrettyNames(withPrettyNames)\n            .isLocaleAware(isLocaleAware)\n            .build();\n        searchResults.getSearchResults().addAll(\n            this.keywordSearchSource.search(keywords, searchOptions, this.uriInfo.getBaseUri()));\n\n        return searchResults;\n    }",
        "idx": "153"
    },
    {
        "target_file_name": "WikisResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/WikisResourceIT.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "unmarshal"
        ],
        "target_code": "private SearchResults search(int expectedSize, String query)\n    {\n        try {\n            GetMethod getMethod = executeGet(URIUtil.encodeQuery(query));\n            Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n\n            SearchResults searchResults =\n                (SearchResults) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n\n            int resultSize = searchResults.getSearchResults().size();\n            if (resultSize == expectedSize) {\n                return searchResults;\n            }\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n\n        return null;\n    }",
        "idx": "154"
    },
    {
        "target_file_name": "WikisResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/WikisResourceIT.java#resetSearchSource",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "System.clearProperty"
        ],
        "target_code": "private void resetSearchSource(String sourceHint) throws Exception\n    {\n        Assert.assertEquals(sourceHint, this.testUtils.executeWikiPlain(\"\"\"\n            {{groovy}}\n            System.clearProperty(\"xconf.xwikiproperties.rest.keywordSearchSource\")\n            {{/groovy}}\n            \"\"\", Syntax.XWIKI_2_1).trim());\n    }",
        "idx": "155"
    },
    {
        "target_file_name": "WikisResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/WikisResourceIT.java#setSearchSource",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "System.setProperty"
        ],
        "target_code": "private void setSearchSource(String sourceHint) throws Exception\n    {\n        Assert.assertEquals(\"\", this.testUtils.executeWikiPlain(\"\"\"\n            {{groovy}}\n            System.setProperty(\"xconf.xwikiproperties.rest.keywordSearchSource\", \"%s\")\n            {{/groovy}}\n            \"\"\".formatted(sourceHint), Syntax.XWIKI_2_1).trim());\n    }",
        "idx": "156"
    },
    {
        "target_file_name": "AttachmentHistoryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/attachments/AttachmentHistoryResourceImpl.java#getAttachmentHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Attachment.getAttachmentRevision",
            "Attachment.getVersions",
            "URLFactory.createAttachmentRevisionURL",
            "URLFactory.getURL"
        ],
        "target_code": "@Override\n    public Attachments getAttachmentHistory(String wikiName, String spaceName, String pageName, String attachmentName,\n            Integer start, Integer number) throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n        \n        try {\n            DocumentInfo documentInfo = getDocumentInfo(wikiName, spaceName, pageName, null, null, true, false);\n            Document doc = documentInfo.getDocument();\n\n            final com.xpn.xwiki.api.Attachment xwikiAttachment = doc.getAttachment(attachmentName);\n            if (xwikiAttachment == null) {\n                throw new WebApplicationException(Status.NOT_FOUND);\n            }\n\n            Attachments attachments = new Attachments();\n\n            Version[] versions = xwikiAttachment.getVersions();\n            List<Version> versionList = new ArrayList<Version>();\n            for (Version version : versions) {\n                versionList.add(version);\n            }\n\n            RangeIterable<Version> ri = new RangeIterable<Version>(versionList, start, limit);\n\n            for (Version version : ri) {\n                com.xpn.xwiki.api.Attachment xwikiAttachmentAtVersion =\n                        xwikiAttachment.getAttachmentRevision(version.toString());\n\n                URL url = Utils.getXWikiContext(componentManager).getURLFactory().createAttachmentRevisionURL(\n                    attachmentName, doc.getSpace(), doc.getDocumentReference().getName(), version.toString(), null,\n                    wikiName, Utils.getXWikiContext(componentManager));\n                String attachmentXWikiAbsoluteUrl = url.toString();\n                String attachmentXWikiRelativeUrl =\n                    Utils.getXWikiContext(componentManager).getURLFactory().getURL(url,\n                        Utils.getXWikiContext(componentManager));\n\n                attachments.getAttachments().add(\n                    DomainObjectFactory.createAttachmentAtVersion(objectFactory, uriInfo.getBaseUri(),\n                        xwikiAttachmentAtVersion, attachmentXWikiRelativeUrl, attachmentXWikiAbsoluteUrl,\n                        Utils.getXWikiApi(componentManager), false));\n            }\n\n            return attachments;\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "157"
    },
    {
        "target_file_name": "WikiSearchResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikiSearchResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "@GET SearchResults search(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"q\") String keywords,\n            @QueryParam(\"scope\") List<String> searchScopeStrings,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"orderField\") @DefaultValue(\"\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"localeAware\") @DefaultValue(\"false\") Boolean isLocaleAware\n    ) throws XWikiRestException;",
        "idx": "158"
    },
    {
        "target_file_name": "WikiSearchQueryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiSearchQueryResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "createURI",
            "format",
            "getBaseUri",
            "getRightService",
            "getSearchResults",
            "getXWiki",
            "getXWikiContext",
            "hasProgrammingRights",
            "searchQuery",
            "toString"
        ],
        "target_code": "@Override\n    public SearchResults search(String wikiName, String query,\n            String queryTypeString, Integer number, Integer start, Boolean distinct, String orderField, String order,\n            Boolean withPrettyNames, String className) throws XWikiRestException\n    {\n        int limit = validateAndGetLimit(number);\n\n        try {\n            SearchResults searchResults = objectFactory.createSearchResults();\n            searchResults.setTemplate(String.format(\"%s?%s\",\n                Utils.createURI(uriInfo.getBaseUri(), WikiSearchQueryResource.class, wikiName).toString(),\n                QUERY_TEMPLATE_INFO));\n\n            searchResults.getSearchResults().addAll(searchQuery(query, queryTypeString, wikiName, null,\n                    Utils.getXWiki(componentManager).getRightService().hasProgrammingRights(\n                            Utils.getXWikiContext(componentManager)), orderField, order, distinct, limit, start,\n                    withPrettyNames, className));\n\n            return searchResults;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "159"
    },
    {
        "target_file_name": "PagesForTagsResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/tags/PagesForTagsResource.java#getTags",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getTags(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"tagNames\") String tagNames,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "160"
    },
    {
        "target_file_name": "ClassesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/classes/ClassesResource.java#getClasses",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Classes getClasses(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") Integer number\n    ) throws XWikiRestException;",
        "idx": "161"
    },
    {
        "target_file_name": "TreeElement.java",
        "target_method": "xwiki-platform-core/xwiki-platform-tree/xwiki-platform-tree-test-pageobjects/src/main/java/org/xwiki/tree/test/po/TreeElement.java#waitForIt",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "findElements",
            "getAttribute",
            "hasElement",
            "waitUntilCondition"
        ],
        "target_code": "public TreeElement waitForIt()\n    {\n        // Wait for the root node to be loaded.\n        getDriver().waitUntilCondition(driver ->\n            // Wait for the loading animation container. This element is generated from JavaScript when the tree is\n            // being initialized, so its presence guarantees that the tree initialization has started.\n            getDriver().hasElement(this.element, By.cssSelector(\".jstree-container-ul\"))\n                // The tree element is marked as busy while the tree nodes are being loaded.\n                && !Boolean.parseBoolean(this.element.getAttribute(\"aria-busy\"))\n                // Check if there is any descendant of the element that is marked as busy.\n                && this.element.findElements(By.cssSelector(\"[aria-busy = 'true']\")).isEmpty()\n        );\n        return this;\n    }",
        "idx": "162"
    },
    {
        "target_file_name": "DefaultNotificationsResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-notifications/xwiki-platform-notifications-rest/src/main/java/org/xwiki/notifications/rest/internal/DefaultNotificationsResource.java#toMaxCount",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "NumberUtils.toInt"
        ],
        "target_code": "private int toMaxCount(String maxCount, int defaultMaxCount)\n    {\n        return NumberUtils.toInt(maxCount, defaultMaxCount);\n    }",
        "idx": "163"
    },
    {
        "target_file_name": "WikisSearchQueryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-search/xwiki-platform-search-solr/xwiki-platform-search-solr-rest/src/main/java/org/xwiki/search/solr/internal/rest/WikisSearchQueryResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "solrSearch.search"
        ],
        "target_code": "@Override\n    public SearchResults search(String query, Integer number, Integer start, Boolean distinct, String searchWikis,\n        String orderField, String order, Boolean withPrettyNames, String className) throws XWikiRestException\n    {\n        try {\n            SearchResults searchResults = objectFactory.createSearchResults();\n            searchResults.setTemplate(String.format(\"%s?%s\", uriInfo.getBaseUri().toString(),\n                MULTIWIKI_QUERY_TEMPLATE_INFO));\n\n            searchResults.getSearchResults().addAll(\n                this.solrSearch.search(\n                    query,\n                    getXWikiContext().getWikiId(),\n                    searchWikis,\n                    Utils.getXWiki(componentManager).getRightService().hasProgrammingRights(\n                        Utils.getXWikiContext(componentManager)), orderField, order, distinct, number, start,\n                        withPrettyNames, className, uriInfo));\n\n            return searchResults;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "164"
    },
    {
        "target_file_name": "PageChildrenResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/pages/PageChildrenResourceImpl.java#getPageChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren",
            "getDocumentReference",
            "getDocumentReferences",
            "matching",
            "withLimit",
            "withOffset"
        ],
        "target_code": "@Override\n    public Pages getPageChildren(String wikiName, String spaceName, String pageName, Integer start, Integer number,\n        Boolean withPrettyNames, String hierarchy, String search) throws XWikiRestException\n    {\n        try {\n            DocumentInfo documentInfo = getDocumentInfo(wikiName, spaceName, pageName, null, null, true, false);\n\n            if (\"nestedpages\".equals(hierarchy)) {\n                return getPages(this.nestedPageHierarchy.getChildren(documentInfo.getDocument().getDocumentReference())\n                    .withOffset(start).withLimit(number).matching(search).getDocumentReferences(), withPrettyNames);\n            } else {\n                // We fall-back (default) to the parent-child hierarchy for backwards compatibility.\n                return getPages(getPageChildrenForParentChildHierarchy(documentInfo, start, number), withPrettyNames);\n            }\n        } catch (XWikiException | QueryException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "165"
    },
    {
        "target_file_name": "PagesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PagesResource.java#getPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getPages(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"parentId\") String parentFilterExpression,\n            @QueryParam(\"order\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "166"
    },
    {
        "target_file_name": "WikiAttachmentsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiAttachmentsResourceImpl.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "WikiReference",
            "getAttachments"
        ],
        "target_code": "@Override\n    public Attachments getAttachments(String wiki, String name, String page, String space, String author,\n        String fileTypes, Integer offset, Integer limit, Boolean withPrettyNames) throws XWikiRestException\n    {\n        Map<String, String> filters = new HashMap<>();\n        filters.put(\"space\", space);\n        filters.put(\"page\", page);\n        filters.put(\"name\", name);\n        filters.put(\"author\", author);\n        filters.put(\"fileTypes\", fileTypes);\n\n        return super.getAttachments(new WikiReference(wiki), filters, offset, limit, withPrettyNames);\n    }",
        "idx": "167"
    },
    {
        "target_file_name": "ClassesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/classes/ClassesResourceImpl.java#getClasses",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getClass",
            "getClassList"
        ],
        "target_code": "@Override\n    public Classes getClasses(String wikiName, Integer start, Integer number) throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        try {\n            getXWikiContext().setWikiId(wikiName);\n\n            List<String> classNames = Utils.getXWikiApi(componentManager).getClassList();\n            Collections.sort(classNames);\n\n            RangeIterable<String> ri = new RangeIterable<String>(classNames, start, number);\n\n            Classes classes = objectFactory.createClasses();\n\n            for (String className : ri) {\n                DocumentReference classReference = this.resolver.resolve(className, new WikiReference(wikiName));\n                if (this.authorization.hasAccess(Right.VIEW, classReference)) {\n                    com.xpn.xwiki.api.Class xwikiClass = Utils.getXWikiApi(componentManager).getClass(classReference);\n                    classes.getClazzs().add(this.utils.toRestClass(uriInfo.getBaseUri(), xwikiClass));\n                }\n            }\n\n            return classes;\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "idx": "168"
    },
    {
        "target_file_name": "PageHistoryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PageHistoryResource.java#getPageHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET History getPageHistory(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"order\") @DefaultValue(\"desc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "169"
    },
    {
        "target_file_name": "WikiChildrenResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikiChildrenResource.java#getChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getChildren(\n        @PathParam(\"wikiName\") String wikiName,\n        @QueryParam(\"offset\") @DefaultValue(\"0\") Integer offset,\n        @QueryParam(\"limit\") @DefaultValue(\"-1\") Integer limit,\n        @QueryParam(\"search\") @DefaultValue(\"\") String search\n    ) throws XWikiRestException;",
        "idx": "170"
    },
    {
        "target_file_name": "AttachmentsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/attachments/AttachmentsResourceImpl.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DocumentReference",
            "parseSpaceSegments"
        ],
        "target_code": "@Override\n    public Attachments getAttachments(String wiki, String spaces, String page, Integer offset, Integer limit,\n        Boolean withPrettyNames, String name, String author, String fileTypes) throws XWikiRestException\n    {\n        Map<String, String> filters = new HashMap<>();\n        filters.put(NAME, name);\n        filters.put(\"author\", author);\n        filters.put(\"fileTypes\", fileTypes);\n\n        return super.getAttachments(new DocumentReference(wiki, parseSpaceSegments(spaces), page), filters, offset,\n            limit, withPrettyNames);\n    }",
        "idx": "171"
    },
    {
        "target_file_name": "AllObjectsForClassNameResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/objects/AllObjectsForClassNameResourceImpl.java#getObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset"
        ],
        "target_code": "@Override\n    public Objects getObjects(String wikiName, String className, Integer start, Integer number, String order,\n            Boolean withPrettyNames) throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        try {\n            Objects objects = new Objects();\n\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            String query = \"select doc, obj from BaseObject as obj, XWikiDocument as doc \"\n                + \"where obj.name=doc.fullName and obj.className=:className\";\n            if (\"date\".equals(order)) {\n                query += \" order by doc.date desc\";\n            }\n\n            List<Object> queryResult = null;\n            queryResult =\n                    queryManager.createQuery(query, Query.XWQL).bindValue(\"className\", className).setLimit(number)\n                            .setOffset(start).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n                XWikiDocument xwikiDocument = (XWikiDocument) fields[0];\n                xwikiDocument.setDatabase(wikiName);\n\n                if (authorization.hasAccess(Right.VIEW, xwikiDocument.getDocumentReference())) {\n\n                    Document doc = new Document(xwikiDocument, Utils.getXWikiContext(componentManager));\n\n                    BaseObject xwikiObject = (BaseObject) fields[1];\n\n                    ObjectSummary objectSummary = DomainObjectFactory\n                        .createObjectSummary(objectFactory, uriInfo.getBaseUri(), Utils.getXWikiContext(\n                            componentManager), doc, xwikiObject, false, Utils.getXWikiApi(componentManager),\n                            withPrettyNames);\n\n                    objects.getObjectSummaries().add(objectSummary);\n                }\n            }\n\n            return objects;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "idx": "172"
    },
    {
        "target_file_name": "SpacesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/spaces/SpacesResourceImpl.java#getSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "createSpace",
            "execute",
            "exists",
            "getDocument",
            "getInstance",
            "getNamedQuery",
            "getPageId",
            "getSpacesFromSpaceId",
            "getXWikiApi",
            "hasAccessLevel",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public Spaces getSpaces(String wikiName, Integer start, Integer number)\n            throws XWikiRestException\n    {\n        Spaces spaces = objectFactory.createSpaces();\n\n        try {\n            List<String> spaceNames = queryManager.getNamedQuery(\"getSpaces\").addFilter(\n                    componentManager.<QueryFilter>getInstance(QueryFilter.class, \"hidden\")).setOffset(start)\n                    .setLimit(number).setWiki(wikiName).execute();\n\n            for (String spaceName : spaceNames) {\n                List<String> spaceList = Utils.getSpacesFromSpaceId(spaceName);\n                String homeId = Utils.getPageId(wikiName, spaceList, \"WebHome\");\n                Document home = null;\n\n                XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n                if (xwikiApi.hasAccessLevel(\"view\", homeId)) {\n                    if (xwikiApi.exists(homeId)) {\n                        home = Utils.getXWikiApi(componentManager).getDocument(homeId);\n                    }\n                    spaces.getSpaces().add(DomainObjectFactory.createSpace(objectFactory, uriInfo.getBaseUri(),\n                        wikiName, spaceList, home));\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n\n        return spaces;\n    }",
        "idx": "173"
    },
    {
        "target_file_name": "WikiSearchQueryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikiSearchQueryResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "@GET SearchResults search(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"q\") String query,\n            @QueryParam(\"type\") String queryTypeString,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"distinct\") @DefaultValue(\"true\") Boolean distinct,\n            @QueryParam(\"orderField\") @DefaultValue(\"\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"className\") @DefaultValue(\"\") String className\n    ) throws XWikiRestException;",
        "idx": "174"
    },
    {
        "target_file_name": "AttachmentsResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/attachments/AttachmentsResource.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Attachments getAttachments(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"name\") @DefaultValue(\"\") String name,\n            @QueryParam(\"author\") @DefaultValue(\"\") String author,\n            @QueryParam(\"types\") @DefaultValue(\"\") String types\n    ) throws XWikiRestException;",
        "idx": "175"
    },
    {
        "target_file_name": "AttachmentHistoryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/attachments/AttachmentHistoryResource.java#getAttachmentHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Attachments getAttachmentHistory(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @PathParam(\"attachmentName\") String attachmentName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number\n    ) throws XWikiRestException;",
        "idx": "176"
    },
    {
        "target_file_name": "SpacesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/spaces/SpacesResource.java#getSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Spaces getSpaces(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number\n    ) throws XWikiRestException;",
        "idx": "177"
    },
    {
        "target_file_name": "AllObjectsForClassNameResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/objects/AllObjectsForClassNameResource.java#getObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Objects getObjects(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"className\") String className,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"order\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "178"
    },
    {
        "target_file_name": "SpaceAttachmentsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/spaces/SpaceAttachmentsResourceImpl.java#getAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SpaceReference"
        ],
        "target_code": "@Override\n    public Attachments getAttachments(String wiki, String spaces, String name, String page, String author,\n        String fileTypes, Integer offset, Integer limit, Boolean withPrettyNames) throws XWikiRestException\n    {\n        Map<String, String> filters = new HashMap<>();\n        filters.put(\"page\", page);\n        filters.put(\"name\", name);\n        filters.put(\"author\", author);\n        filters.put(\"fileTypes\", fileTypes);\n\n        return super.getAttachments(new SpaceReference(wiki, parseSpaceSegments(spaces)), filters, offset, limit,\n            withPrettyNames);\n    }",
        "idx": "179"
    },
    {
        "target_file_name": "WikiChildrenResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiChildrenResourceImpl.java#getChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren",
            "getDocumentReferences",
            "matching",
            "withLimit",
            "withOffset"
        ],
        "target_code": "@Override\n    public Pages getChildren(String wikiName, Integer offset, Integer limit, String search) throws XWikiRestException\n    {\n        WikiReference wikiReference = new WikiReference(wikiName);\n        if (!this.contextualAuthorizationManager.hasAccess(Right.VIEW, wikiReference)) {\n            throw new WebApplicationException(Response.Status.FORBIDDEN);\n        }\n\n        try {\n            return getPages(this.nestedPageHierarchy.getChildren(wikiReference).withOffset(offset).withLimit(limit)\n                .matching(search).getDocumentReferences(), true);\n        } catch (QueryException e) {\n            throw new XWikiRestException(\"Failed to retrieve the top level pages.\", e);\n        }\n    }",
        "idx": "180"
    },
    {
        "target_file_name": "DefaultLiveDataEntriesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-livedata/xwiki-platform-livedata-rest/src/main/java/org/xwiki/livedata/internal/rest/DefaultLiveDataEntriesResource.java#getEntries",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getEntries"
        ],
        "target_code": "@Override\n    public Entries getEntries(String sourceId, String namespace, List<String> properties, List<String> matchAll,\n        List<String> sort, List<Boolean> descending, long offset, int limit) throws Exception\n    {\n        this.contextInitializer.initialize(namespace);\n\n        LiveDataConfiguration config = initConfig(sourceId, properties, matchAll, sort, descending, offset, limit);\n        return getEntries(namespace, offset, limit, config);\n    }",
        "idx": "181"
    },
    {
        "target_file_name": "PagesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/pages/PagesResourceImpl.java#getPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Pattern.compile",
            "Pattern.matcher"
        ],
        "target_code": "@Override\n    public Pages getPages(String wikiName, String spaceName, Integer start, Integer number,\n            String parentFilterExpression, String order, Boolean withPrettyNames)\n            throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n        List<String> spaces = parseSpaceSegments(spaceName);\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        Pages pages = objectFactory.createPages();\n\n        try {\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            Query query = (\"date\".equals(order)) ? queryManager.createQuery(\n                    \"select doc.name from Document doc where doc.space=:space and language='' order by doc.date desc\",\n                    \"xwql\") : queryManager.getNamedQuery(\"getSpaceDocsName\");\n\n            /* Use an explicit query to improve performance */\n            List<String> pageNames =\n                    query.addFilter(componentManager.<QueryFilter>getInstance(QueryFilter.class, \"hidden\"))\n                        .bindValue(\"space\", spaceId).setOffset(start).setLimit(number).execute();\n\n            Pattern parentFilter = null;\n            if (parentFilterExpression != null) {\n                if (parentFilterExpression.equals(\"null\")) {\n                    parentFilter = Pattern.compile(\"\");\n                } else {\n                    parentFilter = Pattern.compile(parentFilterExpression);\n                }\n            }\n\n            for (String pageName : pageNames) {\n                String pageFullName = Utils.getPageId(wikiName, spaces, pageName);\n\n                if (!Utils.getXWikiApi(componentManager).exists(pageFullName)) {\n                    getLogger().warn(\"Page [{}] appears to be in space [{}] but no information is available.\", pageName,\n                        spaceId);\n                } else {\n                    Document doc = Utils.getXWikiApi(componentManager).getDocument(pageFullName);\n\n                    /* We only add pages we have the right to access */\n                    if (doc != null) {\n                        boolean add = true;\n\n                        Document parent = Utils.getParentDocument(doc, Utils.getXWikiApi(componentManager));\n\n                        if (parentFilter != null) {\n                            String parentId = \"\";\n                            if (parent != null && !parent.isNew()) {\n                                parentId = parent.getPrefixedFullName();\n                            }\n                            add = parentFilter.matcher(parentId).matches();\n                        }\n\n                        if (add) {\n                            pages.getPageSummaries().add(DomainObjectFactory.createPageSummary(objectFactory,\n                                    uriInfo.getBaseUri(), doc, Utils.getXWikiApi(componentManager), withPrettyNames));\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n\n        return pages;\n    }",
        "idx": "182"
    },
    {
        "target_file_name": "PagesForTagsResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/tags/PagesForTagsResourceImpl.java#getTags",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getDocument"
        ],
        "target_code": "@Override\n    public Pages getTags(String wikiName, String tagNames, Integer start, Integer number, Boolean withPrettyNames)\n            throws XWikiRestException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        try {\n            Pages pages = objectFactory.createPages();\n\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n\n            String[] tagNamesArray = tagNames.split(\",\");\n\n            List<String> documentNames = new ArrayList<String>();\n            for (String tagName : tagNamesArray) {\n                List<String> documentNamesForTag = getDocumentsWithTag(tagName);\n\n                /* Avoid duplicates */\n                for (String documentName : documentNamesForTag) {\n                    if (!documentNames.contains(documentName)) {\n                        documentNames.add(documentName);\n                    }\n                }\n            }\n\n            RangeIterable<String> ri = new RangeIterable<String>(documentNames, start, number);\n\n            for (String documentName : ri) {\n                Document doc = Utils.getXWikiApi(componentManager).getDocument(documentName);\n                if (doc != null) {\n                    pages.getPageSummaries().add(DomainObjectFactory\n                            .createPageSummary(objectFactory, uriInfo.getBaseUri(), doc, Utils.getXWikiApi(\n                                    componentManager), withPrettyNames));\n                }\n            }\n\n            return pages;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }",
        "idx": "183"
    },
    {
        "target_file_name": "WikisSearchQueryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikisSearchQueryResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SearchResults"
        ],
        "target_code": "@GET SearchResults search(\n            @QueryParam(\"q\") String query,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"distinct\") @DefaultValue(\"true\") Boolean distinct,\n            @QueryParam(\"wikis\") String searchWikis,\n            @QueryParam(\"orderField\") @DefaultValue(\"\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"className\") @DefaultValue(\"\") String className\n    ) throws XWikiRestException;",
        "idx": "184"
    },
    {
        "target_file_name": "PageChildrenResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PageChildrenResource.java#getPageChildren",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getPageChildren(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"hierarchy\") @DefaultValue(\"parentchild\") String hierarchy,\n            @QueryParam(\"search\") @DefaultValue(\"\") String search\n    ) throws XWikiRestException;",
        "idx": "185"
    },
    {
        "target_file_name": "ClassPropertyValuesResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/classes/ClassPropertyValuesResourceImpl.java#getClassPropertyValues",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getValue",
            "getValues"
        ],
        "target_code": "@Override\n    public PropertyValues getClassPropertyValues(String wikiName, String className, String propertyName, Integer limit,\n        List<String> filterParameters, Boolean isExactMatch) throws XWikiRestException\n    {\n        DocumentReference classReference = this.resolver.resolve(className, new WikiReference(wikiName));\n        ClassPropertyReference classPropertyReference = new ClassPropertyReference(propertyName, classReference);\n        try {\n            this.authorization.checkAccess(Right.VIEW, classPropertyReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(e, Status.UNAUTHORIZED);\n        }\n        if (!exists(classPropertyReference)) {\n            throw new WebApplicationException(Status.NOT_FOUND);\n        }\n\n        URI propertyURI =\n            Utils.createURI(this.uriInfo.getBaseUri(), ClassPropertyResource.class, wikiName, className, propertyName);\n        Link propertyLink = this.objectFactory.createLink();\n        propertyLink.setHref(propertyURI.toString());\n        propertyLink.setRel(Relations.PROPERTY);\n\n        PropertyValues propertyValues = new PropertyValues();\n        if (isExactMatch) {\n            for (String filterParameter : filterParameters) {\n                PropertyValue value =  this.propertyValuesProvider.getValue(classPropertyReference, filterParameter);\n                if (value != null) {\n                    propertyValues.getPropertyValues().add(value);\n                }\n            }\n        } else {\n            propertyValues = this.propertyValuesProvider\n                .getValues(classPropertyReference, limit, filterParameters.toArray());\n        }\n        propertyValues.getLinks().add(propertyLink);\n\n        return propertyValues;\n    }",
        "idx": "186"
    },
    {
        "target_file_name": "SpaceSearchResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/spaces/SpaceSearchResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "@GET SearchResults search(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @QueryParam(\"q\") String keywords,\n            @QueryParam(\"scope\") List<String> searchScopeStrings,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"orderField\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"localeAware\") @DefaultValue(\"false\") Boolean isLocaleAware\n    ) throws XWikiRestException;",
        "idx": "187"
    },
    {
        "target_file_name": "PageResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/PageResourceIT.java#setUp",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "delete",
            "page",
            "rest",
            "save",
            "setParent"
        ],
        "target_code": "@Before\n    @Override\n    public void setUp() throws Exception\n    {\n        super.setUp();\n\n        this.wikiName = getWiki();\n        this.space = getTestClassName();\n        this.spaces = Arrays.asList(this.space);\n        this.pageName = getTestMethodName();\n        this.reference = new DocumentReference(this.wikiName, this.spaces, this.pageName);\n\n        this.childPageName = \"child\";\n        this.childReference = new DocumentReference(this.wikiName, this.spaces, this.childPageName);\n\n        // Create a clean test page.\n        this.testUtils.rest().delete(this.reference);\n        Page page = this.testUtils.rest().page(this.reference);\n        page.setComment(\"Test page\");\n        this.testUtils.rest().save(page);\n\n        // Create a clean test page child.\n        this.testUtils.rest().delete(this.childReference);\n        Page childPage = this.testUtils.rest().page(this.childReference);\n        childPage.setComment(\"Test page child\");\n        childPage.setParent(this.space + '.' + this.pageName);\n        this.testUtils.rest().save(childPage);\n    }",
        "idx": "188"
    },
    {
        "target_file_name": "PageResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/PageResourceIT.java#getFirstPage",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "unmarshaller.unmarshal"
        ],
        "target_code": "private Page getFirstPage() throws Exception\n    {\n        GetMethod getMethod = executeGet(getFullUri(WikisResource.class));\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n\n        Wikis wikis = (Wikis) unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n        Assert.assertTrue(wikis.getWikis().size() > 0);\n        Wiki wiki = wikis.getWikis().get(0);\n\n        // Get a link to an index of spaces (http://localhost:8080/xwiki/rest/wikis/xwiki/spaces)\n        Link spacesLink = getFirstLinkByRelation(wiki, Relations.SPACES);\n        Assert.assertNotNull(spacesLink);\n        getMethod = executeGet(spacesLink.getHref());\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n        Spaces spaces = (Spaces) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n        Assert.assertTrue(spaces.getSpaces().size() > 0);\n\n        Space space = null;\n        for (final Space s : spaces.getSpaces()) {\n            if (this.space.equals(s.getName())) {\n                space = s;\n                break;\n            }\n        }\n\n        // get the pages list for the space\n        // eg: http://localhost:8080/xwiki/rest/wikis/xwiki/spaces/Main/pages\n        Link pagesInSpace = getFirstLinkByRelation(space, Relations.PAGES);\n        Assert.assertNotNull(pagesInSpace);\n        getMethod = executeGet(pagesInSpace.getHref());\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n        Pages pages = (Pages) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n        Assert.assertTrue(pages.getPageSummaries().size() > 0);\n\n        Link pageLink = null;\n        for (final PageSummary ps : pages.getPageSummaries()) {\n            if (this.pageName.equals(ps.getName())) {\n                pageLink = getFirstLinkByRelation(ps, Relations.PAGE);\n                Assert.assertNotNull(pageLink);\n                break;\n            }\n        }\n        Assert.assertNotNull(pageLink);\n\n        getMethod = executeGet(pageLink.getHref());\n        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n\n        Page page = (Page) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n\n        return page;\n    }",
        "idx": "189"
    },
    {
        "target_file_name": "PageTranslationHistoryResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/pages/PageTranslationHistoryResource.java#getPageTranslationHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "Encoded",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET History getPageTranslationHistory(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"spaceName\") @Encoded String spaceName,\n            @PathParam(\"pageName\") String pageName,\n            @PathParam(\"language\") String language,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"order\") @DefaultValue(\"desc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "190"
    },
    {
        "target_file_name": "SpaceSearchResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/spaces/SpaceSearchResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "build",
            "builder",
            "createSearchResults",
            "createURI",
            "getBaseUri",
            "getSearchResults",
            "isLocaleAware",
            "number",
            "order",
            "orderField",
            "parseSearchScopeStrings",
            "parseSpaceSegments",
            "search",
            "searchScopes",
            "setTemplate",
            "space",
            "start",
            "wikiName",
            "withPrettyNames"
        ],
        "target_code": "@Override\n    public SearchResults search(String wikiName, String spaceName, String keywords, List<String> searchScopeStrings,\n        Integer number, Integer start, String orderField, String order, Boolean withPrettyNames, Boolean isLocaleAware)\n        throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        SearchResults searchResults = objectFactory.createSearchResults();\n        searchResults.setTemplate(String.format(\"%s?%s\",\n            Utils.createURI(uriInfo.getBaseUri(), SpaceSearchResource.class, wikiName, spaces).toString(),\n            SEARCH_TEMPLATE_INFO));\n\n        List<KeywordSearchScope> searchScopes = parseSearchScopeStrings(searchScopeStrings);\n\n        KeywordSearchOptions searchOptions = KeywordSearchOptions.builder()\n            .searchScopes(searchScopes)\n            .wikiName(wikiName)\n            .space(Utils.getLocalSpaceId(spaces))\n            .number(number)\n            .start(start)\n            .orderField(orderField)\n            .order(order)\n            .withPrettyNames(withPrettyNames)\n            .isLocaleAware(isLocaleAware)\n            .build();\n        searchResults.getSearchResults()\n            .addAll(this.keywordSearchSource.search(keywords, searchOptions, this.uriInfo.getBaseUri()));\n\n        return searchResults;\n    }",
        "idx": "191"
    },
    {
        "target_file_name": "WikiSearchResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiSearchResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "search"
        ],
        "target_code": "@Override\n    public SearchResults search(String wikiName, String keywords, List<String> searchScopeStrings, Integer number,\n        Integer start, String orderField, String order, Boolean withPrettyNames, Boolean isLocaleAware)\n            throws XWikiRestException\n    {\n        SearchResults searchResults = objectFactory.createSearchResults();\n        searchResults.setTemplate(String.format(\"%s?%s\",\n            Utils.createURI(uriInfo.getBaseUri(), WikiSearchResource.class, wikiName).toString(),\n            SEARCH_TEMPLATE_INFO));\n\n        if (wikiName != null) {\n            Utils.getXWikiContext(componentManager).setWikiId(wikiName);\n        }\n\n        List<KeywordSearchScope> searchScopes = parseSearchScopeStrings(searchScopeStrings);\n\n        KeywordSearchOptions searchOptions = KeywordSearchOptions.builder()\n            .searchScopes(searchScopes)\n            .wikiName(getXWikiContext().getWikiId())\n            .space(null)\n            .number(number)\n            .start(start)\n            .orderField(orderField)\n            .order(order)\n            .withPrettyNames(withPrettyNames)\n            .isLocaleAware(isLocaleAware)\n            .build();\n        searchResults.getSearchResults().addAll(\n            this.keywordSearchSource.search(keywords, searchOptions, this.uriInfo.getBaseUri()));\n\n        return searchResults;\n    }",
        "idx": "192"
    },
    {
        "target_file_name": "WikisResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/WikisResourceIT.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "unmarshal"
        ],
        "target_code": "private SearchResults search(int expectedSize, String query)\n    {\n        try {\n            GetMethod getMethod = executeGet(URIUtil.encodeQuery(query));\n            assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());\n\n            SearchResults searchResults =\n                (SearchResults) this.unmarshaller.unmarshal(getMethod.getResponseBodyAsStream());\n\n            int resultSize = searchResults.getSearchResults().size();\n            if (resultSize == expectedSize) {\n                return searchResults;\n            }\n        } catch (Exception e) {\n            throw new AssertionError(e);\n        }\n\n        return null;\n    }",
        "idx": "193"
    },
    {
        "target_file_name": "WikisResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/WikisResourceIT.java#resetSearchSource",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "System.clearProperty"
        ],
        "target_code": "private void resetSearchSource(String sourceHint) throws Exception\n    {\n        assertEquals(sourceHint, this.testUtils.executeWikiPlain(\"\"\"\n            {{groovy}}\n            System.clearProperty(\"xconf.xwikiproperties.rest.keywordSearchSource\")\n            {{/groovy}}\n            \"\"\", Syntax.XWIKI_2_1).trim());\n    }",
        "idx": "194"
    },
    {
        "target_file_name": "WikisResourceIT.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-test/xwiki-platform-rest-test-tests/src/test/it/org/xwiki/rest/test/WikisResourceIT.java#setSearchSource",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "System.setProperty"
        ],
        "target_code": "private void setSearchSource(String sourceHint) throws Exception\n    {\n        assertEquals(\"\", this.testUtils.executeWikiPlain(\"\"\"\n            {{groovy}}\n            System.setProperty(\"xconf.xwikiproperties.rest.keywordSearchSource\", \"%s\")\n            {{/groovy}}\n            \"\"\".formatted(sourceHint), Syntax.XWIKI_2_1).trim());\n    }",
        "idx": "195"
    },
    {
        "target_file_name": "AttachmentHistoryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/attachments/AttachmentHistoryResourceImpl.java#getAttachmentHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Attachment.getAttachmentRevision",
            "Attachment.getVersions",
            "URLFactory.createAttachmentRevisionURL",
            "URLFactory.getURL"
        ],
        "target_code": "@Override\n    public Attachments getAttachmentHistory(String wikiName, String spaceName, String pageName, String attachmentName,\n            Integer start, Integer number) throws XWikiRestException\n    {\n        try {\n            DocumentInfo documentInfo = getDocumentInfo(wikiName, spaceName, pageName, null, null, true, false);\n            Document doc = documentInfo.getDocument();\n\n            final com.xpn.xwiki.api.Attachment xwikiAttachment = doc.getAttachment(attachmentName);\n            if (xwikiAttachment == null) {\n                throw new WebApplicationException(Status.NOT_FOUND);\n            }\n\n            Attachments attachments = new Attachments();\n\n            Version[] versions = xwikiAttachment.getVersions();\n            List<Version> versionList = new ArrayList<Version>();\n            for (Version version : versions) {\n                versionList.add(version);\n            }\n\n            RangeIterable<Version> ri = new RangeIterable<Version>(versionList, start, number);\n\n            for (Version version : ri) {\n                com.xpn.xwiki.api.Attachment xwikiAttachmentAtVersion =\n                        xwikiAttachment.getAttachmentRevision(version.toString());\n\n                URL url = Utils.getXWikiContext(componentManager).getURLFactory().createAttachmentRevisionURL(\n                    attachmentName, doc.getSpace(), doc.getDocumentReference().getName(), version.toString(), null,\n                    wikiName, Utils.getXWikiContext(componentManager));\n                String attachmentXWikiAbsoluteUrl = url.toString();\n                String attachmentXWikiRelativeUrl =\n                    Utils.getXWikiContext(componentManager).getURLFactory().getURL(url,\n                        Utils.getXWikiContext(componentManager));\n\n                attachments.getAttachments().add(\n                    DomainObjectFactory.createAttachmentAtVersion(objectFactory, uriInfo.getBaseUri(),\n                        xwikiAttachmentAtVersion, attachmentXWikiRelativeUrl, attachmentXWikiAbsoluteUrl,\n                        Utils.getXWikiApi(componentManager), false));\n            }\n\n            return attachments;\n        } catch (XWikiException e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "196"
    },
    {
        "target_file_name": "WikiSearchResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/wikis/WikiSearchResource.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET SearchResults search(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"q\") String keywords,\n            @QueryParam(\"scope\") List<String> searchScopeStrings,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"orderField\") @DefaultValue(\"\") String orderField,\n            @QueryParam(\"order\") @DefaultValue(\"asc\") String order,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames,\n            @QueryParam(\"localeAware\") @DefaultValue(\"false\") Boolean isLocaleAware\n    ) throws XWikiRestException;",
        "idx": "197"
    },
    {
        "target_file_name": "WikiSearchQueryResourceImpl.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-server/src/main/java/org/xwiki/rest/internal/resources/wikis/WikiSearchQueryResourceImpl.java#search",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "createURI",
            "getBaseUri",
            "getRightService",
            "getSearchResults",
            "getXWikiContext",
            "hasProgrammingRights",
            "toString"
        ],
        "target_code": "@Override\n    public SearchResults search(String wikiName, String query,\n            String queryTypeString, Integer number, Integer start, Boolean distinct, String orderField, String order,\n            Boolean withPrettyNames, String className) throws XWikiRestException\n    {\n        try {\n            SearchResults searchResults = objectFactory.createSearchResults();\n            searchResults.setTemplate(String.format(\"%s?%s\",\n                Utils.createURI(uriInfo.getBaseUri(), WikiSearchQueryResource.class, wikiName).toString(),\n                QUERY_TEMPLATE_INFO));\n\n            searchResults.getSearchResults().addAll(searchQuery(query, queryTypeString, wikiName, null,\n                    Utils.getXWiki(componentManager).getRightService().hasProgrammingRights(\n                            Utils.getXWikiContext(componentManager)), orderField, order, distinct, number, start,\n                    withPrettyNames, className));\n\n            return searchResults;\n        } catch (Exception e) {\n            throw new XWikiRestException(e);\n        }\n    }",
        "idx": "198"
    },
    {
        "target_file_name": "PagesForTagsResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/tags/PagesForTagsResource.java#getTags",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Pages getTags(\n            @PathParam(\"wikiName\") String wikiName,\n            @PathParam(\"tagNames\") String tagNames,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number,\n            @QueryParam(\"prettyNames\") @DefaultValue(\"false\") Boolean withPrettyNames\n    ) throws XWikiRestException;",
        "idx": "199"
    },
    {
        "target_file_name": "ClassesResource.java",
        "target_method": "xwiki-platform-core/xwiki-platform-rest/xwiki-platform-rest-api/src/main/java/org/xwiki/rest/resources/classes/ClassesResource.java#getClasses",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultValue",
            "GET",
            "PathParam",
            "QueryParam"
        ],
        "target_code": "@GET Classes getClasses(\n            @PathParam(\"wikiName\") String wikiName,\n            @QueryParam(\"start\") @DefaultValue(\"0\") Integer start,\n            @QueryParam(\"number\") @DefaultValue(\"-1\") Integer number\n    ) throws XWikiRestException;",
        "idx": "200"
    },
    {
        "target_file_name": "TreeElement.java",
        "target_method": "xwiki-platform-core/xwiki-platform-tree/xwiki-platform-tree-test-pageobjects/src/main/java/org/xwiki/tree/test/po/TreeElement.java#waitForIt",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "e3c47745195fb445b054537be86f5c01ee69558b^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-66473",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "findElements",
            "getAttribute"
        ],
        "target_code": "public TreeElement waitForIt()\n    {\n        // Wait for the loading animation container. This element is generated from JavaScript when the tree is\n        // being initialized, so its presence guarantees that the tree initialization has started.\n        getDriver().waitUntilElementIsVisible(this.element, By.cssSelector(\".jstree-container-ul\"));\n        // Wait for the root node to be loaded.\n        getDriver().waitUntilCondition(driver ->\n            // The tree element is marked as busy while the tree nodes are being loaded.\n            !Boolean.parseBoolean(this.element.getAttribute(\"aria-busy\"))\n                // Check if there is any descendant of the element that is marked as busy.\n                && this.element.findElements(By.cssSelector(\"[aria-busy = 'true']\")).isEmpty()\n        );\n        return this;\n    }",
        "idx": "201"
    },
    {
        "target_file_name": "AttachController.java",
        "target_method": "perfree-system/perfree-system-biz/src/main/java/com/perfree/controller/auth/attach/AttachController.java#uploadAttachByUrl",
        "project_url": "https://github.com/PerfreeBlog/PerfreeBlog",
        "commit_id": "103c79165e3a41a1729188fdc8a1e90c97c0a06d",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-60319",
        "project_name": "PerfreeBlog",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "uploadAttachByUrl"
        ],
        "target_code": "@PostMapping(\"/uploadAttachByUrl\")\n    @Operation(summary = \"通过url下载并上传附件\")\n    @DemoMode\n    @PreAuthorize(\"@ss.hasPermission('admin:attach:update')\")\n    public CommonResult<AttachByUrlRespVO> uploadAttachByUrl(@Valid @RequestBody AttachUploadByUrlVO attachUploadByUrlVO) {\n        Attach attach = attachService.uploadAttachByUrl(attachUploadByUrlVO.getUrl());\n        AttachByUrlRespVO attachByUrlRespVO = AttachConvert.INSTANCE.convertByUrlRespVO(attach);\n        attachByUrlRespVO.setOriginalURL(attachUploadByUrlVO.getUrl());\n        return success(attachByUrlRespVO);\n    }",
        "idx": "202"
    },
    {
        "target_file_name": "AttachController.java",
        "target_method": "perfree-system/perfree-system-biz/src/main/java/com/perfree/controller/auth/attach/AttachController.java#uploadAttachByUrl",
        "project_url": "https://github.com/PerfreeBlog/PerfreeBlog",
        "commit_id": "103c79165e3a41a1729188fdc8a1e90c97c0a06d^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-60319",
        "project_name": "PerfreeBlog",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "uploadAttachByUrl"
        ],
        "target_code": "@PostMapping(\"/uploadAttachByUrl\")\n    @Operation(summary = \"通过url下载并上传附件\")\n    @DemoMode\n    public CommonResult<AttachByUrlRespVO> uploadAttachByUrl(@Valid @RequestBody AttachUploadByUrlVO attachUploadByUrlVO) {\n        Attach attach = attachService.uploadAttachByUrl(attachUploadByUrlVO.getUrl());\n        AttachByUrlRespVO attachByUrlRespVO = AttachConvert.INSTANCE.convertByUrlRespVO(attach);\n        attachByUrlRespVO.setOriginalURL(attachUploadByUrlVO.getUrl());\n        return success(attachByUrlRespVO);\n    }",
        "idx": "203"
    },
    {
        "target_file_name": "UIConfigRest.java",
        "target_method": "modules/user-interface-configuration/src/main/java/org/opencastproject/uiconfig/UIConfigRest.java#getConfigFile",
        "project_url": "https://github.com/opencast/opencast",
        "commit_id": "e2cc65d6fbe052ebb71d9f6b583bb54b181af009",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55202",
        "project_name": "opencast",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileInputStream",
            "Paths.get",
            "exists",
            "getCanonicalPath",
            "getPath",
            "length",
            "relativize",
            "toFile",
            "toPath",
            "toString"
        ],
        "target_code": "@GET\n  @Path(\"{component}/{filename : .+}\")\n  @Produces(MediaType.WILDCARD)\n  @RestQuery(name = \"getConfigFile\",\n      description = \"Returns the requested configuration file (json, css, etc..)\",\n      pathParameters = {\n          @RestParameter(description = \"Name of the component, which the configuration file belongs to\",\n              isRequired = true, name = \"component\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Name of the configuration file\", isRequired = true,\n              name = \"filename\", type = RestParameter.Type.STRING)\n      },\n      responses = {\n          @RestResponse(\n              description = \"the requested configuration file\",\n              responseCode = HttpServletResponse.SC_OK\n          ),\n          @RestResponse(\n              description = \"if the configuration file doesn't exist\",\n              responseCode = HttpServletResponse.SC_NOT_FOUND\n          ),\n      },\n      returnDescription = \"\"\n  )\n  public Response getConfigFile(@PathParam(\"component\") String component, @PathParam(\"filename\") String filename)\n          throws IOException, NotFoundException {\n    final String orgId = securityService.getOrganization().getId();\n    File configFile = Paths.get(uiConfigFolder, orgId, component, filename).toFile();\n\n    try {\n      final String basePath = new File(uiConfigFolder, orgId).getCanonicalPath() + File.separator;\n      final String configFileCanPath = configFile.getCanonicalPath();\n\n      // is configFile a subdirectory of basePath (additional directory traversal protection), if not stop\n      if (!configFileCanPath.startsWith(basePath)) {\n        logger.debug(\"Directory traversal prevented (trying to access '{}')\", configFile.getPath());\n        throw new AccessDeniedException(configFileCanPath);\n      }\n\n      // Falling back to default organization if file does not exist\n      if (!configFile.exists()) {\n        logger.debug(\"Falling back to default organization\");\n        configFile = Paths.get(uiConfigFolder, DEFAULT_ORGANIZATION_ID, component, filename).toFile();\n      }\n\n      if (xAccelRedirect != null) {\n        final String relative = Paths.get(uiConfigFolder).relativize(configFile.toPath()).toString();\n        return Response.noContent()\n            .header(\"X-Accel-Redirect\", Paths.get(xAccelRedirect, relative).toString())\n            .build();\n      }\n\n      // It is safe to pass the InputStream without closing it, JAX-RS takes care of that\n      return Response.ok(new FileInputStream(configFile))\n              .header(\"Content-Length\", configFile.length())\n              .header(\"Content-Type\", MimeTypes.getMimeType(filename))\n              .build();\n    } catch (FileNotFoundException e) {\n      logger.debug(\"Could not find requested configuration file '{}'\", configFile.getPath(), e);\n      throw new NotFoundException();\n    }\n  }",
        "idx": "204"
    },
    {
        "target_file_name": "UIConfigRest.java",
        "target_method": "modules/user-interface-configuration/src/main/java/org/opencastproject/uiconfig/UIConfigRest.java#getConfigFile",
        "project_url": "https://github.com/opencast/opencast",
        "commit_id": "e2cc65d6fbe052ebb71d9f6b583bb54b181af009^",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55202",
        "project_name": "opencast",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileInputStream",
            "Paths.get",
            "exists",
            "getCanonicalPath",
            "getMimeType",
            "length",
            "relativize",
            "toFile",
            "toPath",
            "toString"
        ],
        "target_code": "@GET\n  @Path(\"{component}/{filename : .+}\")\n  @Produces(MediaType.WILDCARD)\n  @RestQuery(name = \"getConfigFile\",\n      description = \"Returns the requested configuration file (json, css, etc..)\",\n      pathParameters = {\n          @RestParameter(description = \"Name of the component, which the configuration file belongs to\",\n              isRequired = true, name = \"component\", type = RestParameter.Type.STRING),\n          @RestParameter(description = \"Name of the configuration file\", isRequired = true,\n              name = \"filename\", type = RestParameter.Type.STRING)\n      },\n      responses = {\n          @RestResponse(\n              description = \"the requested configuration file\",\n              responseCode = HttpServletResponse.SC_OK\n          ),\n          @RestResponse(\n              description = \"if the configuration file doesn't exist\",\n              responseCode = HttpServletResponse.SC_NOT_FOUND\n          ),\n      },\n      returnDescription = \"\"\n  )\n  public Response getConfigFile(@PathParam(\"component\") String component, @PathParam(\"filename\") String filename)\n          throws IOException, NotFoundException {\n    final String orgId = securityService.getOrganization().getId();\n    File configFile = Paths.get(uiConfigFolder, orgId, component, filename).toFile();\n\n    try {\n      final String basePath = new File(uiConfigFolder, orgId).getCanonicalPath();\n      final String configFileCanPath = configFile.getCanonicalPath();\n\n      // is configFile a subdirectory of basePath (additional directory traversal protection), if not stop\n      if (!configFileCanPath.startsWith(basePath)) {\n        logger.debug(\"Directory traversal prevented (trying to access '{}')\", configFile.getPath());\n        throw new AccessDeniedException(configFileCanPath);\n      }\n\n      // Falling back to default organization if file does not exist\n      if (!configFile.exists()) {\n        logger.debug(\"Falling back to default organization\");\n        configFile = Paths.get(uiConfigFolder, DEFAULT_ORGANIZATION_ID, component, filename).toFile();\n      }\n\n      if (xAccelRedirect != null) {\n        final String relative = Paths.get(uiConfigFolder).relativize(configFile.toPath()).toString();\n        return Response.noContent()\n            .header(\"X-Accel-Redirect\", Paths.get(xAccelRedirect, relative).toString())\n            .build();\n      }\n\n      // It is safe to pass the InputStream without closing it, JAX-RS takes care of that\n      return Response.ok(new FileInputStream(configFile))\n              .header(\"Content-Length\", configFile.length())\n              .header(\"Content-Type\", MimeTypes.getMimeType(filename))\n              .build();\n    } catch (FileNotFoundException e) {\n      logger.debug(\"Could not find requested configuration file '{}'\", configFile.getPath(), e);\n      throw new NotFoundException();\n    }\n  }",
        "idx": "205"
    },
    {
        "target_file_name": "CommandUtil.java",
        "target_method": "f2cmd",
        "project_url": "https://github.com/lemon8866/StreamVault",
        "commit_id": "2e3f1f54b7d8a4e6389b640796866ac1108780ef",
        "CWE_id": "CWE-78",
        "CVE_id": "CVE-2025-57799",
        "project_name": "StreamVault",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "runCommandList"
        ],
        "target_code": "public static String f2cmd(String cookie, String aid, String fuc, String uid, String cid, Integer maxc,\n            String out) {\n\n        List<String> cmdList = new ArrayList<>();\n        cmdList.add(\"/opt/venv/bin/python3\");\n        cmdList.add(\"/home/app/script/douyin.py\");\n\n        switch (fuc) {\n            case \"fetch_video\":\n                cmdList.add(\"fetch_video\");\n                cmdList.add(\"--cookie\"); cmdList.add(cookie);\n                cmdList.add(\"--aweme_id\"); cmdList.add(aid);\n                break;\n\n            case \"fetch_user_like_videos\":\n            case \"fetch_user_post_videos\":\n                cmdList.add(fuc);\n                cmdList.add(\"--cookie\"); cmdList.add(cookie);\n                cmdList.add(\"--uid\"); cmdList.add(uid);\n                cmdList.add(\"--maxc\"); cmdList.add(String.valueOf(maxc));\n                cmdList.add(\"--output\"); cmdList.add(out);\n                break;\n\n            case \"fetch_user_collects\":\n                cmdList.add(\"fetch_user_collects\");\n                cmdList.add(\"--cookie\"); cmdList.add(cookie);\n                break;\n\n            case \"fetch_user_collects_videos\":\n                cmdList.add(\"fetch_user_collects_videos\");\n                cmdList.add(\"--cookie\"); cmdList.add(cookie);\n                cmdList.add(\"--cid\"); cmdList.add(cid);\n                cmdList.add(\"--maxc\"); cmdList.add(String.valueOf(maxc));\n                cmdList.add(\"--output\"); cmdList.add(out);\n                break;\n\n            case \"fetch_user_feed_videos\":\n                cmdList.add(\"fetch_user_feed_videos\");\n                cmdList.add(\"--cookie\"); cmdList.add(cookie);\n                cmdList.add(\"--uid\"); cmdList.add(uid);\n                cmdList.add(\"--output\"); cmdList.add(out);\n                break;\n\n            case \"fetch_post_data\":\n                cmdList.add(\"fetch_post_data\");\n                cmdList.add(\"--cookie\"); cmdList.add(cookie);\n                cmdList.add(\"--aweme_id\"); cmdList.add(aid);\n                cmdList.add(\"--output\"); cmdList.add(out);\n                break;\n\n            default:\n                throw new IllegalArgumentException(\"Unsupported function: \" + fuc);\n        }\n\n        return runCommandList(cmdList);\n    }",
        "idx": "206"
    },
    {
        "target_file_name": "CommandUtil.java",
        "target_method": "f2cmd",
        "project_url": "https://github.com/lemon8866/StreamVault",
        "commit_id": "2e3f1f54b7d8a4e6389b640796866ac1108780ef^",
        "CWE_id": "CWE-78",
        "CVE_id": "CVE-2025-57799",
        "project_name": "StreamVault",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "CommandUtil.commandos"
        ],
        "target_code": "public static String f2cmd(String cookie, String aid, String fuc, String uid, String cid, Integer maxc,\n            String out) {\n        StringBuilder cmd = new StringBuilder(\"/opt/venv/bin/python3 /home/app/script/douyin.py \");\n        switch (fuc) {\n            case \"fetch_video\":\n                cmd.append(\"fetch_video \")\n                        .append(\"--cookie \\\"\").append(cookie).append(\"\\\" \")\n                        .append(\"--aweme_id \\\"\").append(aid).append(\"\\\"\");\n                break;\n\n            case \"fetch_user_like_videos\":\n            case \"fetch_user_post_videos\":\n                cmd.append(fuc).append(\" \")\n                        .append(\"--cookie \\\"\").append(cookie).append(\"\\\" \")\n                        .append(\"--uid \\\"\").append(uid).append(\"\\\" \")\n                        .append(\"--maxc \\\"\").append(maxc).append(\"\\\" \")\n                        .append(\"--output \\\"\").append(out).append(\"\\\"\");\n                break;\n\n            case \"fetch_user_collects\":\n                cmd.append(\"fetch_user_collects \")\n                        .append(\"--cookie \\\"\").append(cookie).append(\"\\\"\");\n                break;\n\n            case \"fetch_user_collects_videos\":\n                cmd.append(\"fetch_user_collects_videos \")\n                        .append(\"--cookie \\\"\").append(cookie).append(\"\\\" \")\n                        .append(\"--cid \\\"\").append(cid).append(\"\\\" \")\n                        .append(\"--maxc \\\"\").append(maxc).append(\"\\\" \")\n                        .append(\"--output \\\"\").append(out).append(\"\\\"\");\n                break;\n\n            case \"fetch_user_feed_videos\":\n                cmd.append(\"fetch_user_feed_videos \")\n                        .append(\"--cookie \\\"\").append(cookie).append(\"\\\" \")\n                        .append(\"--uid \\\"\").append(uid).append(\"\\\" \")\n                        .append(\"--output \\\"\").append(out).append(\"\\\"\");\n                break;\n                \n            case \"fetch_post_data\":\n                cmd.append(\"fetch_post_data \")\n                        .append(\"--cookie \\\"\").append(cookie).append(\"\\\" \")\n                        .append(\"--aweme_id \\\"\").append(aid).append(\"\\\" \")\n                        .append(\"--output \\\"\").append(out).append(\"\\\"\");\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unsupported function: \" + fuc);\n        }\n\n        return CommandUtil.commandos(cmd.toString());\n    }",
        "idx": "207"
    },
    {
        "target_file_name": "CamundaContextConfiguration.java",
        "target_method": "core/src/main/java/com/ritense/valtimo/autoconfigure/CamundaContextConfiguration.java#camundaWhitelistedBeansPlugin",
        "project_url": "https://github.com/valtimo-platform/valtimo-backend-libraries",
        "commit_id": "45eb60b0b2df5964fb9917295d0dceb1fff8dd85",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-58059",
        "project_name": "valtimo-backend-libraries",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Bean",
            "ConditionalOnProperty",
            "Lazy",
            "Order",
            "ProcessBean"
        ],
        "target_code": "@Bean\n    @Order(Ordering.DEFAULT_ORDER - 1)\n    @ConditionalOnProperty(prefix = \"valtimo.camunda\", name = \"bean-whitelisting\", havingValue = \"true\", matchIfMissing = true)\n    public CamundaWhitelistedBeansPlugin camundaWhitelistedBeansPlugin(\n        @Lazy @ProcessBean Map<String, Object> processBeans,\n        ApplicationContext applicationContext\n    ) {\n        return new CamundaWhitelistedBeansPlugin(processBeans, applicationContext);\n    }",
        "idx": "208"
    },
    {
        "target_file_name": "CamundaContextConfiguration.java",
        "target_method": "core/src/main/java/com/ritense/valtimo/autoconfigure/CamundaContextConfiguration.java#camundaWhitelistedBeansPlugin",
        "project_url": "https://github.com/valtimo-platform/valtimo-backend-libraries",
        "commit_id": "45eb60b0b2df5964fb9917295d0dceb1fff8dd85^",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-58059",
        "project_name": "valtimo-backend-libraries",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ApplicationContext",
            "Bean",
            "Order",
            "ProcessBean"
        ],
        "target_code": "@Bean\n    @Order(Ordering.DEFAULT_ORDER - 1)\n    public CamundaWhitelistedBeansPlugin camundaWhitelistedBeansPlugin(\n        @Lazy @ProcessBean Map<String, Object> processBeans,\n        ApplicationContext applicationContext\n    ) {\n        return new CamundaWhitelistedBeansPlugin(processBeans, applicationContext);\n    }",
        "idx": "209"
    },
    {
        "target_file_name": "ImageController.java",
        "target_method": "application/src/main/java/org/thingsboard/server/controller/ImageController.java#downloadIfChanged",
        "project_url": "https://github.com/thingsboard/thingsboard",
        "commit_id": "b2ae6f92d12206ea185a2e882945a6b69234bf03",
        "CWE_id": "CWE-79",
        "CVE_id": "CVE-2025-34281",
        "project_name": "thingsboard",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "GZIPOutputStream",
            "finish",
            "write"
        ],
        "target_code": "private ResponseEntity<ByteArrayResource> downloadIfChanged(ImageCacheKey cacheKey, String etag, String acceptEncodingHeader, ThrowingSupplier<TbResourceInfo> imageInfoSupplier) throws Exception {\n        if (StringUtils.isNotEmpty(etag)) {\n            etag = StringUtils.remove(etag, '\\\"'); // etag is wrapped in double quotes due to HTTP specification\n            if (etag.equals(tbImageService.getETag(cacheKey))) {\n                return response(HttpStatus.NOT_MODIFIED);\n            }\n        }\n\n        TbResourceInfo imageInfo = checkNotNull(imageInfoSupplier.get());\n        String fileName = imageInfo.getFileName();\n        ImageDescriptor descriptor = imageInfo.getDescriptor(ImageDescriptor.class);\n        byte[] data;\n        if (cacheKey.isPreview()) {\n            descriptor = descriptor.getPreviewDescriptor();\n            data = imageService.getImagePreview(imageInfo.getTenantId(), imageInfo.getId());\n        } else {\n            data = imageService.getImageData(imageInfo.getTenantId(), imageInfo.getId());\n        }\n        tbImageService.putETag(cacheKey, descriptor.getEtag());\n        var result = ResponseEntity.ok()\n                .header(\"Content-Type\", descriptor.getMediaType())\n                .header(\"Content-Security-Policy\", \"default-src 'none'\")\n                .eTag(descriptor.getEtag());\n        if (!cacheKey.isPublic()) {\n            result\n                    .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment;filename=\" + fileName)\n                    .header(\"x-filename\", fileName);\n        }\n        if (systemImagesBrowserTtlInMinutes > 0 && imageInfo.getTenantId().isSysTenantId()) {\n            result.cacheControl(CacheControl.maxAge(systemImagesBrowserTtlInMinutes, TimeUnit.MINUTES));\n        } else if (tenantImagesBrowserTtlInMinutes > 0 && !imageInfo.getTenantId().isSysTenantId()) {\n            result.cacheControl(CacheControl.maxAge(tenantImagesBrowserTtlInMinutes, TimeUnit.MINUTES));\n        } else {\n            result.cacheControl(CacheControl.noCache());\n        }\n        var responseData = data;\n        if (mediaTypeToFileExtension(descriptor.getMediaType()).equals(\"svg\") &&\n                StringUtils.isNotEmpty(acceptEncodingHeader) && acceptEncodingHeader.contains(\"gzip\")) {\n            result.header(HttpHeaders.CONTENT_ENCODING, \"gzip\");\n            var outputStream = new ByteArrayOutputStream();\n            try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream)) {\n                gzipOutputStream.write(data);\n                gzipOutputStream.finish();\n            }\n            responseData = outputStream.toByteArray();\n        }\n        result.contentLength(responseData.length);\n        return result.body(new ByteArrayResource(responseData));\n    }",
        "idx": "210"
    },
    {
        "target_file_name": "ImageController.java",
        "target_method": "application/src/main/java/org/thingsboard/server/controller/ImageController.java#downloadIfChanged",
        "project_url": "https://github.com/thingsboard/thingsboard",
        "commit_id": "b2ae6f92d12206ea185a2e882945a6b69234bf03^",
        "CWE_id": "CWE-79",
        "CVE_id": "CVE-2025-34281",
        "project_name": "thingsboard",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "GZIPOutputStream",
            "finish",
            "write"
        ],
        "target_code": "private ResponseEntity<ByteArrayResource> downloadIfChanged(ImageCacheKey cacheKey, String etag, String acceptEncodingHeader, ThrowingSupplier<TbResourceInfo> imageInfoSupplier) throws Exception {\n        if (StringUtils.isNotEmpty(etag)) {\n            etag = StringUtils.remove(etag, '\\\"'); // etag is wrapped in double quotes due to HTTP specification\n            if (etag.equals(tbImageService.getETag(cacheKey))) {\n                return response(HttpStatus.NOT_MODIFIED);\n            }\n        }\n\n        TbResourceInfo imageInfo = checkNotNull(imageInfoSupplier.get());\n        String fileName = imageInfo.getFileName();\n        ImageDescriptor descriptor = imageInfo.getDescriptor(ImageDescriptor.class);\n        byte[] data;\n        if (cacheKey.isPreview()) {\n            descriptor = descriptor.getPreviewDescriptor();\n            data = imageService.getImagePreview(imageInfo.getTenantId(), imageInfo.getId());\n        } else {\n            data = imageService.getImageData(imageInfo.getTenantId(), imageInfo.getId());\n        }\n        tbImageService.putETag(cacheKey, descriptor.getEtag());\n        var result = ResponseEntity.ok()\n                .header(\"Content-Type\", descriptor.getMediaType())\n                .eTag(descriptor.getEtag());\n        if (!cacheKey.isPublic()) {\n            result\n                    .header(HttpHeaders.CONTENT_DISPOSITION, \"attachment;filename=\" + fileName)\n                    .header(\"x-filename\", fileName);\n        }\n        if (systemImagesBrowserTtlInMinutes > 0 && imageInfo.getTenantId().isSysTenantId()) {\n            result.cacheControl(CacheControl.maxAge(systemImagesBrowserTtlInMinutes, TimeUnit.MINUTES));\n        } else if (tenantImagesBrowserTtlInMinutes > 0 && !imageInfo.getTenantId().isSysTenantId()) {\n            result.cacheControl(CacheControl.maxAge(tenantImagesBrowserTtlInMinutes, TimeUnit.MINUTES));\n        } else {\n            result.cacheControl(CacheControl.noCache());\n        }\n        var responseData = data;\n        if (mediaTypeToFileExtension(descriptor.getMediaType()).equals(\"svg\") &&\n                StringUtils.isNotEmpty(acceptEncodingHeader) && acceptEncodingHeader.contains(\"gzip\")) {\n            result.header(HttpHeaders.CONTENT_ENCODING, \"gzip\");\n            var outputStream = new ByteArrayOutputStream();\n            try (GZIPOutputStream gzipOutputStream = new GZIPOutputStream(outputStream)) {\n                gzipOutputStream.write(data);\n                gzipOutputStream.finish();\n            }\n            responseData = outputStream.toByteArray();\n        }\n        result.contentLength(responseData.length);\n        return result.body(new ByteArrayResource(responseData));\n    }",
        "idx": "211"
    },
    {
        "target_file_name": "Impala.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Impala.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "77078658715bd85af5867afbfd5f1fcc37cf03c8",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-58045",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(getExtraParams()).contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n\n            if (!getJdbcUrl().startsWith(\"jdbc:impala\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            jdbcUrl = \"jdbc:impala://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            jdbcUrl = \"jdbc:impala://HOSTNAME:PORT/DATABASE;EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "212"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf.readRetainedSlice",
            "DefaultHttpContent",
            "DefaultLastHttpContent"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested.get()) {\n            resetNow();\n        }\n\n        switch (currentState) {\n        case SKIP_CONTROL_CHARS:\n            // Fall-through\n        case READ_INITIAL: try {\n            ByteBuf line = lineParser.parse(buffer, defaultStrictCRLFCheck);\n            if (line == null) {\n                return;\n            }\n            final String[] initialLine = splitInitialLine(line);\n            assert initialLine.length == 3 : \"initialLine::length must be 3\";\n\n            message = createMessage(initialLine);\n            currentState = State.READ_HEADER;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(message, buffer, e));\n            return;\n        }\n        case READ_HEADER: try {\n            State nextState = readHeaders(buffer);\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:\n                // fast-path\n                // No content is expected.\n                addCurrentMessage(out);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE:\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                addCurrentMessage(out);\n                return;\n            default:\n                /*\n                 * RFC 7230, 3.3.3 (https://tools.ietf.org/html/rfc7230#section-3.3.3) states that if a\n                 * request does not have either a transfer-encoding or a content-length header then the message body\n                 * length is 0. However, for a response the body length is the number of octets received prior to the\n                 * server closing the connection. So we treat this as variable length chunked encoding.\n                 */\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    addCurrentMessage(out);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                    resetNow();\n                    return;\n                }\n\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT;\n\n                addCurrentMessage(out);\n\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength;\n                }\n\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(message, buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {\n            int readLimit = buffer.readableBytes();\n\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create an HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);\n            chunkSize -= toRead;\n\n            if (chunkSize == 0) {\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, trailersFactory));\n                resetNow();\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /*\n         * Everything else after this point takes care of reading chunked content. Basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {\n            ByteBuf line = lineParser.parse(buffer, THROW_INVALID_CHUNK_EXTENSION);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.array(), line.arrayOffset() + line.readerIndex(), line.readableBytes());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: {\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            if (!allowPartialChunks && buffer.readableBytes() < toRead) {\n                return;\n            }\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n\n            out.add(chunk);\n\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {\n            if (buffer.readableBytes() >= 2) {\n                int rIdx = buffer.readerIndex();\n                if (buffer.getByte(rIdx) == HttpConstants.CR &&\n                        buffer.getByte(rIdx + 1) == HttpConstants.LF) {\n                    buffer.skipBytes(2);\n                    currentState = State.READ_CHUNK_SIZE;\n                } else {\n                    out.add(invalidChunk(buffer, new InvalidChunkTerminationException()));\n                }\n            }\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    }",
        "idx": "213"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#readHeaders",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpHeaders.add",
            "HttpHeaders.getAll",
            "HttpHeaders.set",
            "HttpUtil.getWebSocketContentLength",
            "HttpUtil.isTransferEncodingChunked",
            "HttpUtil.normalizeAndGetContentLength",
            "HttpUtil.setTransferEncodingChunked"
        ],
        "target_code": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        final HeaderParser headerParser = this.headerParser;\n\n        ByteBuf line = headerParser.parse(buffer, defaultStrictCRLFCheck);\n        if (line == null) {\n            return null;\n        }\n        int lineLength = line.readableBytes();\n        while (lineLength > 0) {\n            final byte[] lineContent = line.array();\n            final int startLine = line.arrayOffset() + line.readerIndex();\n            final byte firstChar = lineContent[startLine];\n            if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                //please do not make one line from below code\n                //as it breaks +XX:OptimizeStringConcat optimization\n                String trimmedLine = langAsciiString(lineContent, startLine, lineLength).trim();\n                String valueStr = value;\n                value = valueStr + ' ' + trimmedLine;\n            } else {\n                if (name != null) {\n                    headers.add(name, value);\n                }\n                splitHeader(lineContent, startLine, lineLength);\n            }\n\n            line = headerParser.parse(buffer, defaultStrictCRLFCheck);\n            if (line == null) {\n                return null;\n            }\n            lineLength = line.readableBytes();\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        // Done parsing initial line and headers. Set decoder result.\n        HttpMessageDecoderResult decoderResult = new HttpMessageDecoderResult(lineParser.size, headerParser.size);\n        message.setDecoderResult(decoderResult);\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                String lengthValue = contentLengthFields.get(0).trim();\n                if (contentLengthFields.size() > 1 || // don't unnecessarily re-order headers\n                        !lengthValue.equals(Long.toString(contentLength))) {\n                    headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n                }\n            }\n        } else {\n            // We know the content length if it's a Web Socket message even if\n            // Content-Length header is missing.\n            contentLength = HttpUtil.getWebSocketContentLength(message);\n        }\n        if (!isDecodingRequest() && message instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) message;\n            this.isSwitchingToNonHttp1Protocol = isSwitchingToNonHttp1Protocol(res);\n        }\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        }\n        if (HttpUtil.isTransferEncodingChunked(message)) {\n            this.chunked = true;\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        }\n        if (contentLength >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        }\n        return State.READ_VARIABLE_LENGTH_CONTENT;\n    }",
        "idx": "214"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#readTrailingHeaders",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "AsciiString.trim",
            "ByteBuf.array",
            "ByteBuf.arrayOffset",
            "ByteBuf.readerIndex",
            "List.get",
            "List.set",
            "trailingHeaders.add"
        ],
        "target_code": "private LastHttpContent readTrailingHeaders(ByteBuf buffer) {\n        final HeaderParser headerParser = this.headerParser;\n        ByteBuf line = headerParser.parse(buffer, defaultStrictCRLFCheck);\n        if (line == null) {\n            return null;\n        }\n        LastHttpContent trailer = this.trailer;\n        int lineLength = line.readableBytes();\n        if (lineLength == 0 && trailer == null) {\n            // We have received the empty line which signals the trailer is complete and did not parse any trailers\n            // before. Just return an empty last content to reduce allocations.\n            return LastHttpContent.EMPTY_LAST_CONTENT;\n        }\n\n        CharSequence lastHeader = null;\n        if (trailer == null) {\n            trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailersFactory);\n        }\n        while (lineLength > 0) {\n            final byte[] lineContent = line.array();\n            final int startLine = line.arrayOffset() + line.readerIndex();\n            final byte firstChar = lineContent[startLine];\n            if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                List<String> current = trailer.trailingHeaders().getAll(lastHeader);\n                if (!current.isEmpty()) {\n                    int lastPos = current.size() - 1;\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String lineTrimmed = langAsciiString(lineContent, startLine, line.readableBytes()).trim();\n                    String currentLastPos = current.get(lastPos);\n                    current.set(lastPos, currentLastPos + lineTrimmed);\n                }\n            } else {\n                splitHeader(lineContent, startLine, lineLength);\n                AsciiString headerName = name;\n                if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {\n                    trailer.trailingHeaders().add(headerName, value);\n                }\n                lastHeader = name;\n                // reset name and value fields\n                name = null;\n                value = null;\n            }\n            line = headerParser.parse(buffer, defaultStrictCRLFCheck);\n            if (line == null) {\n                return null;\n            }\n            lineLength = line.readableBytes();\n        }\n\n        this.trailer = null;\n        return trailer;\n    }",
        "idx": "215"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#parse",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf",
            "readableBytes",
            "readerIndex"
        ],
        "target_code": "@Override\n        public ByteBuf parse(ByteBuf buffer, Runnable strictCRLFCheck) {\n            // Suppress a warning because HeaderParser.reset() is supposed to be called\n            reset();\n            final int readableBytes = buffer.readableBytes();\n            if (readableBytes == 0) {\n                return null;\n            }\n            if (currentState == State.SKIP_CONTROL_CHARS &&\n                    skipControlChars(buffer, readableBytes, buffer.readerIndex())) {\n                return null;\n            }\n            return super.parse(buffer, strictCRLFCheck);\n        }",
        "idx": "216"
    },
    {
        "target_file_name": "HttpDecoderConfig.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpDecoderConfig.java#setTrailersFactory",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpHeadersFactory"
        ],
        "target_code": "public HttpDecoderConfig setTrailersFactory(HttpHeadersFactory trailersFactory) {\n        checkNotNull(trailersFactory, \"trailersFactory\");\n        this.trailersFactory = trailersFactory;\n        return this;\n    }",
        "idx": "217"
    },
    {
        "target_file_name": "HttpDecoderConfig.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpDecoderConfig.java#setTrailersFactory",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284^",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpHeadersFactory"
        ],
        "target_code": "public HttpDecoderConfig setTrailersFactory(HttpHeadersFactory trailersFactory) {\n        checkNotNull(trailersFactory, \"trailersFactory\");\n        this.trailersFactory = trailersFactory;\n        return this;\n    }",
        "idx": "218"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284^",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf.readRetainedSlice",
            "DefaultHttpContent",
            "DefaultLastHttpContent"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested.get()) {\n            resetNow();\n        }\n\n        switch (currentState) {\n        case SKIP_CONTROL_CHARS:\n            // Fall-through\n        case READ_INITIAL: try {\n            ByteBuf line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            final String[] initialLine = splitInitialLine(line);\n            assert initialLine.length == 3 : \"initialLine::length must be 3\";\n\n            message = createMessage(initialLine);\n            currentState = State.READ_HEADER;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(message, buffer, e));\n            return;\n        }\n        case READ_HEADER: try {\n            State nextState = readHeaders(buffer);\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:\n                // fast-path\n                // No content is expected.\n                addCurrentMessage(out);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE:\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                addCurrentMessage(out);\n                return;\n            default:\n                /*\n                 * RFC 7230, 3.3.3 (https://tools.ietf.org/html/rfc7230#section-3.3.3) states that if a\n                 * request does not have either a transfer-encoding or a content-length header then the message body\n                 * length is 0. However, for a response the body length is the number of octets received prior to the\n                 * server closing the connection. So we treat this as variable length chunked encoding.\n                 */\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    addCurrentMessage(out);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                    resetNow();\n                    return;\n                }\n\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT;\n\n                addCurrentMessage(out);\n\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength;\n                }\n\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(message, buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {\n            int readLimit = buffer.readableBytes();\n\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create an HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);\n            chunkSize -= toRead;\n\n            if (chunkSize == 0) {\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, trailersFactory));\n                resetNow();\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /*\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {\n            ByteBuf line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.array(), line.arrayOffset() + line.readerIndex(), line.readableBytes());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: {\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            if (!allowPartialChunks && buffer.readableBytes() < toRead) {\n                return;\n            }\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n\n            out.add(chunk);\n\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        default:\n            break;\n        }\n    }",
        "idx": "219"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#readHeaders",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284^",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpHeaders.add",
            "HttpHeaders.getAll",
            "HttpUtil.getWebSocketContentLength",
            "HttpUtil.isTransferEncodingChunked",
            "HttpUtil.normalizeAndGetContentLength",
            "HttpUtil.setTransferEncodingChunked"
        ],
        "target_code": "private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        final HeaderParser headerParser = this.headerParser;\n\n        ByteBuf line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        int lineLength = line.readableBytes();\n        while (lineLength > 0) {\n            final byte[] lineContent = line.array();\n            final int startLine = line.arrayOffset() + line.readerIndex();\n            final byte firstChar = lineContent[startLine];\n            if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                //please do not make one line from below code\n                //as it breaks +XX:OptimizeStringConcat optimization\n                String trimmedLine = langAsciiString(lineContent, startLine, lineLength).trim();\n                String valueStr = value;\n                value = valueStr + ' ' + trimmedLine;\n            } else {\n                if (name != null) {\n                    headers.add(name, value);\n                }\n                splitHeader(lineContent, startLine, lineLength);\n            }\n\n            line = headerParser.parse(buffer);\n            if (line == null) {\n                return null;\n            }\n            lineLength = line.readableBytes();\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        // Done parsing initial line and headers. Set decoder result.\n        HttpMessageDecoderResult decoderResult = new HttpMessageDecoderResult(lineParser.size, headerParser.size);\n        message.setDecoderResult(decoderResult);\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                String lengthValue = contentLengthFields.get(0).trim();\n                if (contentLengthFields.size() > 1 || // don't unnecessarily re-order headers\n                        !lengthValue.equals(Long.toString(contentLength))) {\n                    headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n                }\n            }\n        } else {\n            // We know the content length if it's a Web Socket message even if\n            // Content-Length header is missing.\n            contentLength = HttpUtil.getWebSocketContentLength(message);\n        }\n        if (!isDecodingRequest() && message instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) message;\n            this.isSwitchingToNonHttp1Protocol = isSwitchingToNonHttp1Protocol(res);\n        }\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        }\n        if (HttpUtil.isTransferEncodingChunked(message)) {\n            this.chunked = true;\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        }\n        if (contentLength >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        }\n        return State.READ_VARIABLE_LENGTH_CONTENT;\n    }",
        "idx": "220"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#readTrailingHeaders",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284^",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "AsciiString.trim",
            "ByteBuf.array",
            "ByteBuf.arrayOffset",
            "ByteBuf.readableBytes",
            "ByteBuf.readerIndex",
            "HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase",
            "HttpHeaderNames.TRAILER.contentEqualsIgnoreCase",
            "HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase",
            "List.add",
            "List.get",
            "List.set"
        ],
        "target_code": "private LastHttpContent readTrailingHeaders(ByteBuf buffer) {\n        final HeaderParser headerParser = this.headerParser;\n        ByteBuf line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        LastHttpContent trailer = this.trailer;\n        int lineLength = line.readableBytes();\n        if (lineLength == 0 && trailer == null) {\n            // We have received the empty line which signals the trailer is complete and did not parse any trailers\n            // before. Just return an empty last content to reduce allocations.\n            return LastHttpContent.EMPTY_LAST_CONTENT;\n        }\n\n        CharSequence lastHeader = null;\n        if (trailer == null) {\n            trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailersFactory);\n        }\n        while (lineLength > 0) {\n            final byte[] lineContent = line.array();\n            final int startLine = line.arrayOffset() + line.readerIndex();\n            final byte firstChar = lineContent[startLine];\n            if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                List<String> current = trailer.trailingHeaders().getAll(lastHeader);\n                if (!current.isEmpty()) {\n                    int lastPos = current.size() - 1;\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String lineTrimmed = langAsciiString(lineContent, startLine, line.readableBytes()).trim();\n                    String currentLastPos = current.get(lastPos);\n                    current.set(lastPos, currentLastPos + lineTrimmed);\n                }\n            } else {\n                splitHeader(lineContent, startLine, lineLength);\n                AsciiString headerName = name;\n                if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {\n                    trailer.trailingHeaders().add(headerName, value);\n                }\n                lastHeader = name;\n                // reset name and value fields\n                name = null;\n                value = null;\n            }\n            line = headerParser.parse(buffer);\n            if (line == null) {\n                return null;\n            }\n            lineLength = line.readableBytes();\n        }\n\n        this.trailer = null;\n        return trailer;\n    }",
        "idx": "221"
    },
    {
        "target_file_name": "HttpObjectDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java#parse",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "edb55fd8e0a3bcbd85881e423464f585183d1284^",
        "CWE_id": "CWE-444",
        "CVE_id": "CVE-2025-58056",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf.getByte",
            "ByteBuf.indexOf",
            "ByteBuf.readableBytes",
            "ByteBuf.readerIndex",
            "ByteBuf.writeBytes"
        ],
        "target_code": "public ByteBuf parse(ByteBuf buffer) {\n            final int readableBytes = buffer.readableBytes();\n            final int readerIndex = buffer.readerIndex();\n            final int maxBodySize = maxLength - size;\n            assert maxBodySize >= 0;\n            // adding 2 to account for both CR (if present) and LF\n            // don't remove 2L: it's key to cover maxLength = Integer.MAX_VALUE\n            final long maxBodySizeWithCRLF = maxBodySize + 2L;\n            final int toProcess = (int) Math.min(maxBodySizeWithCRLF, readableBytes);\n            final int toIndexExclusive = readerIndex + toProcess;\n            assert toIndexExclusive >= readerIndex;\n            final int indexOfLf = buffer.indexOf(readerIndex, toIndexExclusive, HttpConstants.LF);\n            if (indexOfLf == -1) {\n                if (readableBytes > maxBodySize) {\n                    // TODO: Respond with Bad Request and discard the traffic\n                    //    or close the connection.\n                    //       No need to notify the upstream handlers - just log.\n                    //       If decoding a response, just throw an exception.\n                    throw newException(maxLength);\n                }\n                return null;\n            }\n            final int endOfSeqIncluded;\n            if (indexOfLf > readerIndex && buffer.getByte(indexOfLf - 1) == HttpConstants.CR) {\n                // Drop CR if we had a CRLF pair\n                endOfSeqIncluded = indexOfLf - 1;\n            } else {\n                endOfSeqIncluded = indexOfLf;\n            }\n            final int newSize = endOfSeqIncluded - readerIndex;\n            if (newSize == 0) {\n                seq.clear();\n                buffer.readerIndex(indexOfLf + 1);\n                return seq;\n            }\n            int size = this.size + newSize;\n            if (size > maxLength) {\n                throw newException(maxLength);\n            }\n            this.size = size;\n            seq.clear();\n            seq.writeBytes(buffer, readerIndex, newSize);\n            buffer.readerIndex(indexOfLf + 1);\n            return seq;\n        }",
        "idx": "222"
    },
    {
        "target_file_name": "JZlibDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "inflate",
            "inflateEnd",
            "inflateSetDictionary"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        needsRead = true;\n        if (finished) {\n            // Skip data received after finished.\n            in.skipBytes(in.readableBytes());\n            return;\n        }\n\n        final int inputLength = in.readableBytes();\n        if (inputLength == 0) {\n            return;\n        }\n\n        try {\n            // Configure input.\n            z.avail_in = inputLength;\n            if (in.hasArray()) {\n                z.next_in = in.array();\n                z.next_in_index = in.arrayOffset() + in.readerIndex();\n            } else {\n                byte[] array = new byte[inputLength];\n                in.getBytes(in.readerIndex(), array);\n                z.next_in = array;\n                z.next_in_index = 0;\n            }\n            final int oldNextInIndex = z.next_in_index;\n\n            // Configure output.\n            ByteBuf decompressed = prepareDecompressBuffer(ctx, null, inputLength << 1);\n\n            try {\n                loop: for (;;) {\n                    decompressed = prepareDecompressBuffer(ctx, decompressed, z.avail_in << 1);\n                    z.avail_out = decompressed.writableBytes();\n                    z.next_out = decompressed.array();\n                    z.next_out_index = decompressed.arrayOffset() + decompressed.writerIndex();\n                    int oldNextOutIndex = z.next_out_index;\n\n                    // Decompress 'in' into 'out'\n                    int resultCode = z.inflate(JZlib.Z_SYNC_FLUSH);\n                    int outputLength = z.next_out_index - oldNextOutIndex;\n                    if (outputLength > 0) {\n                        decompressed.writerIndex(decompressed.writerIndex() + outputLength);\n                        if (maxAllocation == 0) {\n                            // If we don't limit the maximum allocations we should just\n                            // forward the buffer directly.\n                            ByteBuf buffer = decompressed;\n                            decompressed = null;\n                            needsRead = false;\n                            ctx.fireChannelRead(buffer);\n                        }\n                    }\n\n                    switch (resultCode) {\n                    case JZlib.Z_NEED_DICT:\n                        if (dictionary == null) {\n                            ZlibUtil.fail(z, \"decompression failure\", resultCode);\n                        } else {\n                            resultCode = z.inflateSetDictionary(dictionary, dictionary.length);\n                            if (resultCode != JZlib.Z_OK) {\n                                ZlibUtil.fail(z, \"failed to set the dictionary\", resultCode);\n                            }\n                        }\n                        break;\n                    case JZlib.Z_STREAM_END:\n                        finished = true; // Do not decode anymore.\n                        z.inflateEnd();\n                        break loop;\n                    case JZlib.Z_OK:\n                        break;\n                    case JZlib.Z_BUF_ERROR:\n                        if (z.avail_in <= 0) {\n                            break loop;\n                        }\n                        break;\n                    default:\n                        ZlibUtil.fail(z, \"decompression failure\", resultCode);\n                    }\n                }\n            } finally {\n                in.skipBytes(z.next_in_index - oldNextInIndex);\n                if (decompressed != null) {\n                    if (decompressed.isReadable()) {\n                        needsRead = false;\n                        ctx.fireChannelRead(decompressed);\n                    } else {\n                        decompressed.release();\n                    }\n                }\n            }\n        } finally {\n            // Deference the external references explicitly to tell the VM that\n            // the allocated byte arrays are temporary so that the call stack\n            // can be utilized.\n            // I'm not sure if the modern VMs do this optimization though.\n            z.next_in = null;\n            z.next_out = null;\n        }\n    }",
        "idx": "223"
    },
    {
        "target_file_name": "JZlibDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java#decompressionBufferExhausted",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf"
        ],
        "target_code": "@Override\n    protected void decompressionBufferExhausted(ByteBuf buffer) {\n        finished = true;\n    }",
        "idx": "224"
    },
    {
        "target_file_name": "JZlibDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java#decompressionBufferExhausted",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf"
        ],
        "target_code": "@Override\n    protected void decompressionBufferExhausted(ByteBuf buffer) {\n        finished = true;\n    }",
        "idx": "225"
    },
    {
        "target_file_name": "BrotliDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/BrotliDecoder.java#decompress",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "decoder.getInputBuffer",
            "decoder.push",
            "decoderInputBuffer.clear",
            "readBytes"
        ],
        "target_code": "private State decompress(ChannelHandlerContext ctx, ByteBuf input) {\n        for (;;) {\n            switch (decoder.getStatus()) {\n                case DONE:\n                    return State.DONE;\n\n                case OK:\n                    decoder.push(0);\n                    break;\n\n                case NEEDS_MORE_INPUT:\n                    if (decoder.hasOutput()) {\n                        forwardOutput(ctx);\n                    }\n\n                    if (!input.isReadable()) {\n                        return State.NEEDS_MORE_INPUT;\n                    }\n\n                    ByteBuffer decoderInputBuffer = decoder.getInputBuffer();\n                    decoderInputBuffer.clear();\n                    int readBytes = readBytes(input, decoderInputBuffer);\n                    decoder.push(readBytes);\n                    break;\n\n                case NEEDS_MORE_OUTPUT:\n                    forwardOutput(ctx);\n                    break;\n\n                default:\n                    return State.ERROR;\n            }\n        }\n    }",
        "idx": "226"
    },
    {
        "target_file_name": "BrotliDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/BrotliDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf",
            "DecompressionException",
            "decompress",
            "destroy",
            "isReadable",
            "readableBytes",
            "skipBytes"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        needsRead = true;\n        if (destroyed) {\n            // Skip data received after finished.\n            in.skipBytes(in.readableBytes());\n            return;\n        }\n\n        if (!in.isReadable()) {\n            return;\n        }\n\n        try {\n            State state = decompress(ctx, in);\n            if (state == State.DONE) {\n                destroy();\n            } else if (state == State.ERROR) {\n                throw new DecompressionException(\"Brotli stream corrupted\");\n            }\n        } catch (Exception e) {\n            destroy();\n            throw e;\n        }\n    }",
        "idx": "227"
    },
    {
        "target_file_name": "JdkZlibDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Inflater",
            "inflate",
            "setDictionary"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        needsRead = true;\n        if (finished) {\n            // Skip data received after finished.\n            in.skipBytes(in.readableBytes());\n            return;\n        }\n\n        int readableBytes = in.readableBytes();\n        if (readableBytes == 0) {\n            return;\n        }\n\n        if (decideZlibOrNone) {\n            // First two bytes are needed to decide if it's a ZLIB stream.\n            if (readableBytes < 2) {\n                return;\n            }\n\n            boolean nowrap = !looksLikeZlib(in.getShort(in.readerIndex()));\n            inflater = new Inflater(nowrap);\n            decideZlibOrNone = false;\n        }\n\n        if (crc != null) {\n            if (gzipState != GzipState.HEADER_END) {\n                if (gzipState == GzipState.FOOTER_START) {\n                    if (!handleGzipFooter(in)) {\n                        // Either there was not enough data or the input is finished.\n                        return;\n                    }\n                    // If we consumed the footer we will start with the header again.\n                    assert gzipState == GzipState.HEADER_START;\n                }\n                if (!readGZIPHeader(in)) {\n                    // There was not enough data readable to read the GZIP header.\n                    return;\n                }\n                // Some bytes may have been consumed, and so we must re-set the number of readable bytes.\n                readableBytes = in.readableBytes();\n                if (readableBytes == 0) {\n                    return;\n                }\n            }\n        }\n\n        if (inflater.needsInput()) {\n            if (in.hasArray()) {\n                inflater.setInput(in.array(), in.arrayOffset() + in.readerIndex(), readableBytes);\n            } else {\n                byte[] array = new byte[readableBytes];\n                in.getBytes(in.readerIndex(), array);\n                inflater.setInput(array);\n            }\n        }\n\n        ByteBuf decompressed = prepareDecompressBuffer(ctx, null, inflater.getRemaining() << 1);\n        try {\n            boolean readFooter = false;\n            while (!inflater.needsInput()) {\n                byte[] outArray = decompressed.array();\n                int writerIndex = decompressed.writerIndex();\n                int outIndex = decompressed.arrayOffset() + writerIndex;\n                int writable = decompressed.writableBytes();\n                int outputLength = inflater.inflate(outArray, outIndex, writable);\n                if (outputLength > 0) {\n                    decompressed.writerIndex(writerIndex + outputLength);\n                    if (crc != null) {\n                        crc.update(outArray, outIndex, outputLength);\n                    }\n                    if (maxAllocation == 0) {\n                        // If we don't limit the maximum allocations we should just\n                        // forward the buffer directly.\n                        ByteBuf buffer = decompressed;\n                        decompressed = null;\n                        needsRead = false;\n                        ctx.fireChannelRead(buffer);\n                    }\n                } else if (inflater.needsDictionary()) {\n                    if (dictionary == null) {\n                        throw new DecompressionException(\n                                \"decompression failure, unable to set dictionary as non was specified\");\n                    }\n                    inflater.setDictionary(dictionary);\n                }\n\n                if (inflater.finished()) {\n                    if (crc == null) {\n                        finished = true; // Do not decode anymore.\n                    } else {\n                        readFooter = true;\n                    }\n                    break;\n                } else {\n                    decompressed = prepareDecompressBuffer(ctx, decompressed, inflater.getRemaining() << 1);\n                }\n            }\n\n            in.skipBytes(readableBytes - inflater.getRemaining());\n\n            if (readFooter) {\n                gzipState = GzipState.FOOTER_START;\n                handleGzipFooter(in);\n            }\n        } catch (DataFormatException e) {\n            throw new DecompressionException(\"decompression failure\", e);\n        } finally {\n            if (decompressed != null) {\n                if (decompressed.isReadable()) {\n                    needsRead = false;\n                    ctx.fireChannelRead(decompressed);\n                } else {\n                    decompressed.release();\n                }\n            }\n        }\n    }",
        "idx": "228"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#onStreamRemoved",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Http2Decompressor",
            "cleanup"
        ],
        "target_code": "@Override\n            public void onStreamRemoved(Http2Stream stream) {\n                final Http2Decompressor decompressor = decompressor(stream);\n                if (decompressor != null) {\n                    decompressor.cleanup();\n                }\n            }",
        "idx": "229"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#onDataRead",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "decompress"
        ],
        "target_code": "@Override\n    public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n            throws Http2Exception {\n        final Http2Stream stream = connection.stream(streamId);\n        final Http2Decompressor decompressor = decompressor(stream);\n        if (decompressor == null) {\n            // The decompressor may be null if no compatible encoding type was found in this stream's headers\n            return listener.onDataRead(ctx, streamId, data, padding, endOfStream);\n        }\n        return decompressor.decompress(ctx, stream, data, padding, endOfStream);\n    }",
        "idx": "230"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#initDecompressor",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Http2Headers.get",
            "Http2Headers.remove",
            "Http2Headers.set",
            "Http2Stream.setProperty"
        ],
        "target_code": "private void initDecompressor(ChannelHandlerContext ctx, int streamId, Http2Headers headers, boolean endOfStream)\n            throws Http2Exception {\n        final Http2Stream stream = connection.stream(streamId);\n        if (stream == null) {\n            return;\n        }\n\n        Http2Decompressor decompressor = decompressor(stream);\n        if (decompressor == null && !endOfStream) {\n            // Determine the content encoding.\n            CharSequence contentEncoding = headers.get(CONTENT_ENCODING);\n            if (contentEncoding == null) {\n                contentEncoding = IDENTITY;\n            }\n            final EmbeddedChannel channel = newContentDecompressor(ctx, contentEncoding);\n            if (channel != null) {\n                decompressor = new Http2Decompressor(channel, connection, listener);\n                stream.setProperty(propertyKey, decompressor);\n                // Decode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                CharSequence targetContentEncoding = getTargetContentEncoding(contentEncoding);\n                if (IDENTITY.contentEqualsIgnoreCase(targetContentEncoding)) {\n                    headers.remove(CONTENT_ENCODING);\n                } else {\n                    headers.set(CONTENT_ENCODING, targetContentEncoding);\n                }\n            }\n        }\n\n        if (decompressor != null) {\n            // The content length will be for the compressed data. Since we will decompress the data\n            // this content-length will not be correct. Instead of queuing messages or delaying sending\n            // header frames just remove the content-length header.\n            headers.remove(CONTENT_LENGTH);\n\n            // The first time that we initialize a decompressor, decorate the local flow controller to\n            // properly convert consumed bytes.\n            if (!flowControllerInitialized) {\n                flowControllerInitialized = true;\n                connection.local().flowController(new ConsumedBytesConverter(connection.local().flowController()));\n            }\n        }\n    }",
        "idx": "231"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#cleanup",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "finishAndReleaseAll"
        ],
        "target_code": "void cleanup() {\n            decompressor.finishAndReleaseAll();\n        }",
        "idx": "232"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#decompressor",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Http2Decompressor",
            "getProperty"
        ],
        "target_code": "Http2Decompressor decompressor(Http2Stream stream) {\n        return stream == null ? null : (Http2Decompressor) stream.getProperty(propertyKey);\n    }",
        "idx": "233"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#incrementCompressedBytes",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "private void incrementCompressedBytes(int delta) {\n            assert delta >= 0;\n            compressed += delta;\n        }",
        "idx": "234"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#incrementDecompressedBytes",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "private void incrementDecompressedBytes(int delta) {\n            assert delta >= 0;\n            decompressed += delta;\n        }",
        "idx": "235"
    },
    {
        "target_file_name": "ZstdDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/ZstdDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf.release",
            "ByteBuf.writeBytes",
            "Zstd.getFrameContentSize"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        needsRead = true;\n        try {\n            if (currentState == State.CORRUPTED) {\n                in.skipBytes(in.readableBytes());\n\n                return;\n            }\n            inputStream.current = in;\n\n            ByteBuf outBuffer = null;\n\n            final int compressedLength = in.readableBytes();\n            try {\n                long uncompressedLength;\n                if (in.isDirect()) {\n                    uncompressedLength = com.github.luben.zstd.Zstd.getFrameContentSize(\n                            CompressionUtil.safeNioBuffer(in, in.readerIndex(), in.readableBytes()));\n                } else {\n                    uncompressedLength = com.github.luben.zstd.Zstd.getFrameContentSize(\n                            in.array(), in.readerIndex() + in.arrayOffset(), in.readableBytes());\n                }\n                if (uncompressedLength <= 0) {\n                    // Let's start with the compressedLength * 2 as often we will not have everything\n                    // we need in the in buffer and don't want to reserve too much memory.\n                    uncompressedLength = compressedLength * 2L;\n                }\n\n                int w;\n                do {\n                    if (outBuffer == null) {\n                        outBuffer = ctx.alloc().heapBuffer((int) (maximumAllocationSize == 0 ?\n                                uncompressedLength : Math.min(maximumAllocationSize, uncompressedLength)));\n                    }\n                    do {\n                        w = outBuffer.writeBytes(zstdIs, outBuffer.writableBytes());\n                    } while (w != -1 && outBuffer.isWritable());\n                    if (outBuffer.isReadable()) {\n                        needsRead = false;\n                        ctx.fireChannelRead(outBuffer);\n                        outBuffer = null;\n                    }\n                } while (w != -1);\n            } finally {\n                if (outBuffer != null) {\n                    outBuffer.release();\n                }\n            }\n        } catch (Exception e) {\n            currentState = State.CORRUPTED;\n            throw new DecompressionException(e);\n        } finally {\n            inputStream.current = null;\n        }\n    }",
        "idx": "236"
    },
    {
        "target_file_name": "HttpContentDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ComposedLastHttpContent",
            "DefaultHttpRequest",
            "DefaultHttpResponse",
            "HttpContent",
            "HttpHeaders",
            "HttpMessage",
            "HttpResponse",
            "LastHttpContent",
            "get",
            "remove",
            "set"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        needRead = true;\n        if (msg instanceof HttpResponse && ((HttpResponse) msg).status().code() == 100) {\n\n            if (!(msg instanceof LastHttpContent)) {\n                continueResponse = true;\n            }\n            // 100-continue response must be passed through.\n            needRead = false;\n            ctx.fireChannelRead(ReferenceCountUtil.retain(msg));\n            return;\n        }\n\n        if (continueResponse) {\n            if (msg instanceof LastHttpContent) {\n                continueResponse = false;\n            }\n            // 100-continue response must be passed through.\n            needRead = false;\n            ctx.fireChannelRead(ReferenceCountUtil.retain(msg));\n            return;\n        }\n\n        if (msg instanceof HttpMessage) {\n            cleanup();\n            final HttpMessage message = (HttpMessage) msg;\n            final HttpHeaders headers = message.headers();\n\n            // Determine the content encoding.\n            String contentEncoding = headers.get(HttpHeaderNames.CONTENT_ENCODING);\n            if (contentEncoding != null) {\n                contentEncoding = contentEncoding.trim();\n            } else {\n                String transferEncoding = headers.get(HttpHeaderNames.TRANSFER_ENCODING);\n                if (transferEncoding != null) {\n                    int idx = transferEncoding.indexOf(',');\n                    if (idx != -1) {\n                        contentEncoding = transferEncoding.substring(0, idx).trim();\n                    } else {\n                        contentEncoding = transferEncoding.trim();\n                    }\n                } else {\n                    contentEncoding = IDENTITY;\n                }\n            }\n            decoder = newContentDecoder(contentEncoding);\n\n            if (decoder == null) {\n                if (message instanceof HttpContent) {\n                    ((HttpContent) message).retain();\n                }\n                needRead = false;\n                ctx.fireChannelRead(message);\n                return;\n            }\n            decoder.pipeline().addLast(forwarder);\n            // Remove content-length header:\n            // the correct value can be set only after all chunks are processed/decoded.\n            // If buffering is not an issue, add HttpObjectAggregator down the chain, it will set the header.\n            // Otherwise, rely on LastHttpContent message.\n            if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n                headers.remove(HttpHeaderNames.CONTENT_LENGTH);\n                headers.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n            }\n            // Either it is already chunked or EOF terminated.\n            // See https://github.com/netty/netty/issues/5892\n\n            // set new content encoding,\n            CharSequence targetContentEncoding = getTargetContentEncoding(contentEncoding);\n            if (HttpHeaderValues.IDENTITY.contentEquals(targetContentEncoding)) {\n                // Do NOT set the 'Content-Encoding' header if the target encoding is 'identity'\n                // as per: https://tools.ietf.org/html/rfc2616#section-14.11\n                headers.remove(HttpHeaderNames.CONTENT_ENCODING);\n            } else {\n                headers.set(HttpHeaderNames.CONTENT_ENCODING, targetContentEncoding);\n            }\n\n            if (message instanceof HttpContent) {\n                // If message is a full request or response object (headers + data), don't copy data part into out.\n                // Output headers only; data part will be decoded below.\n                // Note: \"copy\" object must not be an instance of LastHttpContent class,\n                // as this would (erroneously) indicate the end of the HttpMessage to other handlers.\n                HttpMessage copy;\n                if (message instanceof HttpRequest) {\n                    HttpRequest r = (HttpRequest) message; // HttpRequest or FullHttpRequest\n                    copy = new DefaultHttpRequest(r.protocolVersion(), r.method(), r.uri());\n                } else if (message instanceof HttpResponse) {\n                    HttpResponse r = (HttpResponse) message; // HttpResponse or FullHttpResponse\n                    copy = new DefaultHttpResponse(r.protocolVersion(), r.status());\n                } else {\n                    throw new CodecException(\"Object of class \" + message.getClass().getName() +\n                                             \" is not an HttpRequest or HttpResponse\");\n                }\n                copy.headers().set(message.headers());\n                copy.setDecoderResult(message.decoderResult());\n                needRead = false;\n                ctx.fireChannelRead(copy);\n            } else {\n                needRead = false;\n                ctx.fireChannelRead(message);\n            }\n        }\n\n        if (msg instanceof HttpContent) {\n            final HttpContent c = (HttpContent) msg;\n            if (decoder == null) {\n                needRead = false;\n                ctx.fireChannelRead(c.retain());\n            } else {\n                // call retain here as it will call release after its written to the channel\n                decoder.writeInbound(c.content().retain());\n\n                if (c instanceof LastHttpContent) {\n                    boolean notEmpty = decoder.finish();\n                    decoder = null;\n                    assert !notEmpty;\n                    LastHttpContent last = (LastHttpContent) c;\n                    // Generate an additional chunk if the decoder produced\n                    // the last product on closure,\n                    HttpHeaders headers = last.trailingHeaders();\n                    needRead = false;\n                    if (headers.isEmpty()) {\n                        ctx.fireChannelRead(LastHttpContent.EMPTY_LAST_CONTENT);\n                    } else {\n                        ctx.fireChannelRead(new ComposedLastHttpContent(headers, DecoderResult.SUCCESS));\n                    }\n                }\n            }\n        }\n    }",
        "idx": "237"
    },
    {
        "target_file_name": "HttpContentDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java#handlerAdded",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBufForwarder"
        ],
        "target_code": "@Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        this.ctx = ctx;\n        forwarder = new ByteBufForwarder(ctx);\n        super.handlerAdded(ctx);\n    }",
        "idx": "238"
    },
    {
        "target_file_name": "HttpContentDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java#cleanup",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "finishAndReleaseAll"
        ],
        "target_code": "private void cleanup() {\n        if (decoder != null) {\n            // Clean-up the previous decoder if not cleaned up correctly.\n            boolean nonEmpty = decoder.finishAndReleaseAll();\n            decoder = null;\n            assert !nonEmpty;\n        }\n    }",
        "idx": "239"
    },
    {
        "target_file_name": "JZlibDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "inflate",
            "inflateEnd",
            "inflateSetDictionary"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        if (finished) {\n            // Skip data received after finished.\n            in.skipBytes(in.readableBytes());\n            return;\n        }\n\n        final int inputLength = in.readableBytes();\n        if (inputLength == 0) {\n            return;\n        }\n\n        try {\n            // Configure input.\n            z.avail_in = inputLength;\n            if (in.hasArray()) {\n                z.next_in = in.array();\n                z.next_in_index = in.arrayOffset() + in.readerIndex();\n            } else {\n                byte[] array = new byte[inputLength];\n                in.getBytes(in.readerIndex(), array);\n                z.next_in = array;\n                z.next_in_index = 0;\n            }\n            final int oldNextInIndex = z.next_in_index;\n\n            // Configure output.\n            ByteBuf decompressed = prepareDecompressBuffer(ctx, null, inputLength << 1);\n\n            try {\n                loop: for (;;) {\n                    decompressed = prepareDecompressBuffer(ctx, decompressed, z.avail_in << 1);\n                    z.avail_out = decompressed.writableBytes();\n                    z.next_out = decompressed.array();\n                    z.next_out_index = decompressed.arrayOffset() + decompressed.writerIndex();\n                    int oldNextOutIndex = z.next_out_index;\n\n                    // Decompress 'in' into 'out'\n                    int resultCode = z.inflate(JZlib.Z_SYNC_FLUSH);\n                    int outputLength = z.next_out_index - oldNextOutIndex;\n                    if (outputLength > 0) {\n                        decompressed.writerIndex(decompressed.writerIndex() + outputLength);\n                    }\n\n                    switch (resultCode) {\n                    case JZlib.Z_NEED_DICT:\n                        if (dictionary == null) {\n                            ZlibUtil.fail(z, \"decompression failure\", resultCode);\n                        } else {\n                            resultCode = z.inflateSetDictionary(dictionary, dictionary.length);\n                            if (resultCode != JZlib.Z_OK) {\n                                ZlibUtil.fail(z, \"failed to set the dictionary\", resultCode);\n                            }\n                        }\n                        break;\n                    case JZlib.Z_STREAM_END:\n                        finished = true; // Do not decode anymore.\n                        z.inflateEnd();\n                        break loop;\n                    case JZlib.Z_OK:\n                        break;\n                    case JZlib.Z_BUF_ERROR:\n                        if (z.avail_in <= 0) {\n                            break loop;\n                        }\n                        break;\n                    default:\n                        ZlibUtil.fail(z, \"decompression failure\", resultCode);\n                    }\n                }\n            } finally {\n                in.skipBytes(z.next_in_index - oldNextInIndex);\n                if (decompressed.isReadable()) {\n                    out.add(decompressed);\n                } else {\n                    decompressed.release();\n                }\n            }\n        } finally {\n            // Deference the external references explicitly to tell the VM that\n            // the allocated byte arrays are temporary so that the call stack\n            // can be utilized.\n            // I'm not sure if the modern VMs do this optimization though.\n            z.next_in = null;\n            z.next_out = null;\n        }\n    }",
        "idx": "240"
    },
    {
        "target_file_name": "BrotliDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/BrotliDecoder.java#decompress",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "clear",
            "getInputBuffer",
            "push",
            "readBytes"
        ],
        "target_code": "private State decompress(ByteBuf input, List<Object> output, ByteBufAllocator alloc) {\n        for (;;) {\n            switch (decoder.getStatus()) {\n                case DONE:\n                    return State.DONE;\n\n                case OK:\n                    decoder.push(0);\n                    break;\n\n                case NEEDS_MORE_INPUT:\n                    if (decoder.hasOutput()) {\n                        output.add(pull(alloc));\n                    }\n\n                    if (!input.isReadable()) {\n                        return State.NEEDS_MORE_INPUT;\n                    }\n\n                    ByteBuffer decoderInputBuffer = decoder.getInputBuffer();\n                    decoderInputBuffer.clear();\n                    int readBytes = readBytes(input, decoderInputBuffer);\n                    decoder.push(readBytes);\n                    break;\n\n                case NEEDS_MORE_OUTPUT:\n                    output.add(pull(alloc));\n                    break;\n\n                default:\n                    return State.ERROR;\n            }\n        }\n    }",
        "idx": "241"
    },
    {
        "target_file_name": "BrotliDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/BrotliDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf",
            "DecompressionException",
            "alloc",
            "decompress",
            "destroy",
            "isReadable",
            "readableBytes",
            "skipBytes"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        if (destroyed) {\n            // Skip data received after finished.\n            in.skipBytes(in.readableBytes());\n            return;\n        }\n\n        if (!in.isReadable()) {\n            return;\n        }\n\n        try {\n            State state = decompress(in, out, ctx.alloc());\n            if (state == State.DONE) {\n                destroy();\n            } else if (state == State.ERROR) {\n                throw new DecompressionException(\"Brotli stream corrupted\");\n            }\n        } catch (Exception e) {\n            destroy();\n            throw e;\n        }\n    }",
        "idx": "242"
    },
    {
        "target_file_name": "JdkZlibDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Inflater",
            "inflate",
            "setDictionary"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        if (finished) {\n            // Skip data received after finished.\n            in.skipBytes(in.readableBytes());\n            return;\n        }\n\n        int readableBytes = in.readableBytes();\n        if (readableBytes == 0) {\n            return;\n        }\n\n        if (decideZlibOrNone) {\n            // First two bytes are needed to decide if it's a ZLIB stream.\n            if (readableBytes < 2) {\n                return;\n            }\n\n            boolean nowrap = !looksLikeZlib(in.getShort(in.readerIndex()));\n            inflater = new Inflater(nowrap);\n            decideZlibOrNone = false;\n        }\n\n        if (crc != null) {\n            if (gzipState != GzipState.HEADER_END) {\n                if (gzipState == GzipState.FOOTER_START) {\n                    if (!handleGzipFooter(in)) {\n                        // Either there was not enough data or the input is finished.\n                        return;\n                    }\n                    // If we consumed the footer we will start with the header again.\n                    assert gzipState == GzipState.HEADER_START;\n                }\n                if (!readGZIPHeader(in)) {\n                    // There was not enough data readable to read the GZIP header.\n                    return;\n                }\n                // Some bytes may have been consumed, and so we must re-set the number of readable bytes.\n                readableBytes = in.readableBytes();\n                if (readableBytes == 0) {\n                    return;\n                }\n            }\n        }\n\n        if (inflater.needsInput()) {\n            if (in.hasArray()) {\n                inflater.setInput(in.array(), in.arrayOffset() + in.readerIndex(), readableBytes);\n            } else {\n                byte[] array = new byte[readableBytes];\n                in.getBytes(in.readerIndex(), array);\n                inflater.setInput(array);\n            }\n        }\n\n        ByteBuf decompressed = prepareDecompressBuffer(ctx, null, inflater.getRemaining() << 1);\n        try {\n            boolean readFooter = false;\n            while (!inflater.needsInput()) {\n                byte[] outArray = decompressed.array();\n                int writerIndex = decompressed.writerIndex();\n                int outIndex = decompressed.arrayOffset() + writerIndex;\n                int writable = decompressed.writableBytes();\n                int outputLength = inflater.inflate(outArray, outIndex, writable);\n                if (outputLength > 0) {\n                    decompressed.writerIndex(writerIndex + outputLength);\n                    if (crc != null) {\n                        crc.update(outArray, outIndex, outputLength);\n                    }\n                } else  if (inflater.needsDictionary()) {\n                    if (dictionary == null) {\n                        throw new DecompressionException(\n                                \"decompression failure, unable to set dictionary as non was specified\");\n                    }\n                    inflater.setDictionary(dictionary);\n                }\n\n                if (inflater.finished()) {\n                    if (crc == null) {\n                        finished = true; // Do not decode anymore.\n                    } else {\n                        readFooter = true;\n                    }\n                    break;\n                } else {\n                    decompressed = prepareDecompressBuffer(ctx, decompressed, inflater.getRemaining() << 1);\n                }\n            }\n\n            in.skipBytes(readableBytes - inflater.getRemaining());\n\n            if (readFooter) {\n                gzipState = GzipState.FOOTER_START;\n                handleGzipFooter(in);\n            }\n        } catch (DataFormatException e) {\n            throw new DecompressionException(\"decompression failure\", e);\n        } finally {\n            if (decompressed.isReadable()) {\n                out.add(decompressed);\n            } else {\n                decompressed.release();\n            }\n        }\n    }",
        "idx": "243"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#onStreamRemoved",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Http2Decompressor",
            "Http2Stream",
            "cleanup",
            "decompressor"
        ],
        "target_code": "@Override\n            public void onStreamRemoved(Http2Stream stream) {\n                final Http2Decompressor decompressor = decompressor(stream);\n                if (decompressor != null) {\n                    cleanup(decompressor);\n                }\n            }",
        "idx": "244"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#onDataRead",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "EmbeddedChannel",
            "Http2Decompressor",
            "Http2LocalFlowController",
            "consumeBytes",
            "decompressor",
            "finish",
            "flowController",
            "writeInbound"
        ],
        "target_code": "@Override\n    public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n            throws Http2Exception {\n        final Http2Stream stream = connection.stream(streamId);\n        final Http2Decompressor decompressor = decompressor(stream);\n        if (decompressor == null) {\n            // The decompressor may be null if no compatible encoding type was found in this stream's headers\n            return listener.onDataRead(ctx, streamId, data, padding, endOfStream);\n        }\n\n        final EmbeddedChannel channel = decompressor.decompressor();\n        final int compressedBytes = data.readableBytes() + padding;\n        decompressor.incrementCompressedBytes(compressedBytes);\n        try {\n            // call retain here as it will call release after its written to the channel\n            channel.writeInbound(data.retain());\n            ByteBuf buf = nextReadableBuf(channel);\n            if (buf == null && endOfStream && channel.finish()) {\n                buf = nextReadableBuf(channel);\n            }\n            if (buf == null) {\n                if (endOfStream) {\n                    listener.onDataRead(ctx, streamId, Unpooled.EMPTY_BUFFER, padding, true);\n                }\n                // No new decompressed data was extracted from the compressed data. This means the application could\n                // not be provided with data and thus could not return how many bytes were processed. We will assume\n                // there is more data coming which will complete the decompression block. To allow for more data we\n                // return all bytes to the flow control window (so the peer can send more data).\n                decompressor.incrementDecompressedBytes(compressedBytes);\n                return compressedBytes;\n            }\n            try {\n                Http2LocalFlowController flowController = connection.local().flowController();\n                decompressor.incrementDecompressedBytes(padding);\n                for (;;) {\n                    ByteBuf nextBuf = nextReadableBuf(channel);\n                    boolean decompressedEndOfStream = nextBuf == null && endOfStream;\n                    if (decompressedEndOfStream && channel.finish()) {\n                        nextBuf = nextReadableBuf(channel);\n                        decompressedEndOfStream = nextBuf == null;\n                    }\n\n                    decompressor.incrementDecompressedBytes(buf.readableBytes());\n                    // Immediately return the bytes back to the flow controller. ConsumedBytesConverter will convert\n                    // from the decompressed amount which the user knows about to the compressed amount which flow\n                    // control knows about.\n                    flowController.consumeBytes(stream,\n                            listener.onDataRead(ctx, streamId, buf, padding, decompressedEndOfStream));\n                    if (nextBuf == null) {\n                        break;\n                    }\n\n                    padding = 0; // Padding is only communicated once on the first iteration.\n                    buf.release();\n                    buf = nextBuf;\n                }\n                // We consume bytes each time we call the listener to ensure if multiple frames are decompressed\n                // that the bytes are accounted for immediately. Otherwise the user may see an inconsistent state of\n                // flow control.\n                return 0;\n            } finally {\n                buf.release();\n            }\n        } catch (Http2Exception e) {\n            throw e;\n        } catch (Throwable t) {\n            throw streamError(stream.id(), INTERNAL_ERROR, t,\n                    \"Decompressor error detected while delegating data read on streamId %d\", stream.id());\n        }\n    }",
        "idx": "245"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#initDecompressor",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Http2Headers.get",
            "Http2Headers.remove",
            "Http2Headers.set",
            "Http2Stream.setProperty"
        ],
        "target_code": "private void initDecompressor(ChannelHandlerContext ctx, int streamId, Http2Headers headers, boolean endOfStream)\n            throws Http2Exception {\n        final Http2Stream stream = connection.stream(streamId);\n        if (stream == null) {\n            return;\n        }\n\n        Http2Decompressor decompressor = decompressor(stream);\n        if (decompressor == null && !endOfStream) {\n            // Determine the content encoding.\n            CharSequence contentEncoding = headers.get(CONTENT_ENCODING);\n            if (contentEncoding == null) {\n                contentEncoding = IDENTITY;\n            }\n            final EmbeddedChannel channel = newContentDecompressor(ctx, contentEncoding);\n            if (channel != null) {\n                decompressor = new Http2Decompressor(channel);\n                stream.setProperty(propertyKey, decompressor);\n                // Decode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                CharSequence targetContentEncoding = getTargetContentEncoding(contentEncoding);\n                if (IDENTITY.contentEqualsIgnoreCase(targetContentEncoding)) {\n                    headers.remove(CONTENT_ENCODING);\n                } else {\n                    headers.set(CONTENT_ENCODING, targetContentEncoding);\n                }\n            }\n        }\n\n        if (decompressor != null) {\n            // The content length will be for the compressed data. Since we will decompress the data\n            // this content-length will not be correct. Instead of queuing messages or delaying sending\n            // header frames just remove the content-length header.\n            headers.remove(CONTENT_LENGTH);\n\n            // The first time that we initialize a decompressor, decorate the local flow controller to\n            // properly convert consumed bytes.\n            if (!flowControllerInitialized) {\n                flowControllerInitialized = true;\n                connection.local().flowController(new ConsumedBytesConverter(connection.local().flowController()));\n            }\n        }\n    }",
        "idx": "246"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#cleanup",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "finishAndReleaseAll"
        ],
        "target_code": "private static void cleanup(Http2Decompressor decompressor) {\n        decompressor.decompressor().finishAndReleaseAll();\n    }",
        "idx": "247"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#decompressor",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "EmbeddedChannel"
        ],
        "target_code": "EmbeddedChannel decompressor() {\n            return decompressor;\n        }",
        "idx": "248"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#incrementCompressedBytes",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "assert"
        ],
        "target_code": "void incrementCompressedBytes(int delta) {\n            assert delta >= 0;\n            compressed += delta;\n        }",
        "idx": "249"
    },
    {
        "target_file_name": "DelegatingDecompressorFrameListener.java",
        "target_method": "codec-http2/src/main/java/io/netty/handler/codec/http2/DelegatingDecompressorFrameListener.java#incrementDecompressedBytes",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [],
        "target_code": "void incrementDecompressedBytes(int delta) {\n            assert delta >= 0;\n            decompressed += delta;\n        }",
        "idx": "250"
    },
    {
        "target_file_name": "ZstdDecoder.java",
        "target_method": "codec-compression/src/main/java/io/netty/handler/codec/compression/ZstdDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ZstdInputStream",
            "writeBytes"
        ],
        "target_code": "@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        try {\n            if (currentState == State.CORRUPTED) {\n                in.skipBytes(in.readableBytes());\n                return;\n            }\n            final int compressedLength = in.readableBytes();\n\n            inputStream.current = in;\n\n            ByteBuf outBuffer = null;\n            try {\n                int w;\n                do {\n                    if (outBuffer == null) {\n                        // Let's start with the compressedLength * 2 as often we will not have everything\n                        // we need in the in buffer and don't want to reserve too much memory.\n                        outBuffer = ctx.alloc().heapBuffer(compressedLength * 2);\n                    }\n                    do {\n                        w = outBuffer.writeBytes(zstdIs, outBuffer.writableBytes());\n                    } while (w != -1 && outBuffer.isWritable());\n                    if (outBuffer.isReadable()) {\n                        out.add(outBuffer);\n                        outBuffer = null;\n                    }\n                } while (w != -1);\n            } finally {\n                if (outBuffer != null) {\n                    outBuffer.release();\n                }\n            }\n        } catch (Exception e) {\n            currentState = State.CORRUPTED;\n            throw new DecompressionException(e);\n        } finally {\n            inputStream.current = null;\n        }\n    }",
        "idx": "251"
    },
    {
        "target_file_name": "HttpContentDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java#decode",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ByteBuf.retain",
            "writeInbound"
        ],
        "target_code": "private void decode(ByteBuf in, List<Object> out) {\n        // call retain here as it will call release after its written to the channel\n        decoder.writeInbound(in.retain());\n        fetchDecoderOutput(out);\n    }",
        "idx": "252"
    },
    {
        "target_file_name": "HttpContentDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java#handlerAdded",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "ChannelHandlerContext",
            "handlerAdded"
        ],
        "target_code": "@Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        this.ctx = ctx;\n        super.handlerAdded(ctx);\n    }",
        "idx": "253"
    },
    {
        "target_file_name": "HttpContentDecoder.java",
        "target_method": "codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java#cleanup",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "9d804c54ce962408ae6418255a83a13924f7145d^",
        "CWE_id": "CWE-409",
        "CVE_id": "CVE-2025-58057",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "finishAndReleaseAll"
        ],
        "target_code": "private void cleanup() {\n        if (decoder != null) {\n            // Clean-up the previous decoder if not cleaned up correctly.\n            decoder.finishAndReleaseAll();\n            decoder = null;\n        }\n    }",
        "idx": "254"
    },
    {
        "target_file_name": "H2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/H2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "23a45e72a7abc37d5680b0a7cf691b8df378d4ef",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-58748",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace",
            "startsWith",
            "toUpperCase"
        ],
        "target_code": "public String getJdbc() {\n        for (String illegalParameter : getH2IllegalParameters()) {\n            if (jdbc.toUpperCase().replace(\"\\\\\", \"\").contains(illegalParameter)) {\n                DEException.throwException(\"Has illegal parameter: \" + jdbc);\n            }\n        }\n        if (!getJdbcUrl().startsWith(\"jdbc:h2\")) {\n            DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n        }\n        return jdbc;\n    }",
        "idx": "255"
    },
    {
        "target_file_name": "H2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/H2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "23a45e72a7abc37d5680b0a7cf691b8df378d4ef^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-58748",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace",
            "toUpperCase"
        ],
        "target_code": "public String getJdbc() {\n        for (String illegalParameter : getH2IllegalParameters()) {\n            if (jdbc.toUpperCase().replace(\"\\\\\", \"\").contains(illegalParameter)) {\n                DEException.throwException(\"Has illegal parameter: \" + jdbc);\n            }\n        }\n\n        return jdbc;\n    }",
        "idx": "256"
    },
    {
        "target_file_name": "JinjavaBeanELResolver.java",
        "target_method": "src/main/java/com/hubspot/jinjava/el/ext/JinjavaBeanELResolver.java#getValue",
        "project_url": "https://github.com/HubSpot/jinjava",
        "commit_id": "66df351e7e8ad71ca04dcacb4b65782af820b8b1",
        "CWE_id": "CWE-1336",
        "CVE_id": "CVE-2025-59340",
        "project_name": "jinjava",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getValue",
            "validatePropertyName"
        ],
        "target_code": "@Override\n  public Object getValue(ELContext context, Object base, Object property) {\n    if (isRestrictedClass(base)) {\n      return null;\n    }\n    Object result = super.getValue(context, base, validatePropertyName(property));\n    return result instanceof Class ? null : result;\n  }",
        "idx": "257"
    },
    {
        "target_file_name": "JinjavaBeanELResolver.java",
        "target_method": "src/main/java/com/hubspot/jinjava/el/ext/JinjavaBeanELResolver.java#getValue",
        "project_url": "https://github.com/HubSpot/jinjava",
        "commit_id": "66df351e7e8ad71ca04dcacb4b65782af820b8b1^",
        "CWE_id": "CWE-1336",
        "CVE_id": "CVE-2025-59340",
        "project_name": "jinjava",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getValue"
        ],
        "target_code": "@Override\n  public Object getValue(ELContext context, Object base, Object property) {\n    Object result = super.getValue(context, base, validatePropertyName(property));\n    return result instanceof Class ? null : result;\n  }",
        "idx": "258"
    },
    {
        "target_file_name": "ScramFunctions.java",
        "target_method": "scram-common/src/main/java/com/ongres/scram/common/ScramFunctions.java#verifyClientProof",
        "project_url": "https://github.com/ongres/scram",
        "commit_id": "f04975680d4a67bc84cc6c61bbffd5186223e2e2",
        "CWE_id": "CWE-385",
        "CVE_id": "CVE-2025-59432",
        "project_name": "scram",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "MessageDigest.isEqual"
        ],
        "target_code": "public static boolean verifyClientProof(\n      @NotNull ScramMechanism scramMechanism, byte @NotNull [] clientProof,\n      byte @NotNull [] storedKey, @NotNull String authMessage) {\n    byte[] clientSignature = clientSignature(scramMechanism, storedKey, authMessage);\n    byte[] clientKey = CryptoUtil.xor(clientSignature, clientProof);\n    byte[] computedStoredKey = hash(scramMechanism, clientKey);\n    return MessageDigest.isEqual(storedKey, computedStoredKey);\n  }",
        "idx": "259"
    },
    {
        "target_file_name": "ScramFunctions.java",
        "target_method": "scram-common/src/main/java/com/ongres/scram/common/ScramFunctions.java#verifyServerSignature",
        "project_url": "https://github.com/ongres/scram",
        "commit_id": "f04975680d4a67bc84cc6c61bbffd5186223e2e2",
        "CWE_id": "CWE-385",
        "CVE_id": "CVE-2025-59432",
        "project_name": "scram",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "MessageDigest.isEqual"
        ],
        "target_code": "public static boolean verifyServerSignature(\n      ScramMechanism scramMechanism, byte[] serverKey, String authMessage, byte[] serverSignature) {\n    byte[] computedServerSignature = serverSignature(scramMechanism, serverKey, authMessage);\n    return MessageDigest.isEqual(serverSignature, computedServerSignature);\n  }",
        "idx": "260"
    },
    {
        "target_file_name": "ScramFunctions.java",
        "target_method": "scram-common/src/main/java/com/ongres/scram/common/ScramFunctions.java#verifyClientProof",
        "project_url": "https://github.com/ongres/scram",
        "commit_id": "f04975680d4a67bc84cc6c61bbffd5186223e2e2^",
        "CWE_id": "CWE-385",
        "CVE_id": "CVE-2025-59432",
        "project_name": "scram",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Arrays.equals"
        ],
        "target_code": "public static boolean verifyClientProof(\n      @NotNull ScramMechanism scramMechanism, byte @NotNull [] clientProof,\n      byte @NotNull [] storedKey, @NotNull String authMessage) {\n    byte[] clientSignature = clientSignature(scramMechanism, storedKey, authMessage);\n    byte[] clientKey = CryptoUtil.xor(clientSignature, clientProof);\n    byte[] computedStoredKey = hash(scramMechanism, clientKey);\n\n    return Arrays.equals(storedKey, computedStoredKey);\n  }",
        "idx": "261"
    },
    {
        "target_file_name": "ScramFunctions.java",
        "target_method": "scram-common/src/main/java/com/ongres/scram/common/ScramFunctions.java#verifyServerSignature",
        "project_url": "https://github.com/ongres/scram",
        "commit_id": "f04975680d4a67bc84cc6c61bbffd5186223e2e2^",
        "CWE_id": "CWE-385",
        "CVE_id": "CVE-2025-59432",
        "project_name": "scram",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Arrays.equals"
        ],
        "target_code": "public static boolean verifyServerSignature(\n      ScramMechanism scramMechanism, byte[] serverKey, String authMessage, byte[] serverSignature) {\n    return Arrays.equals(serverSignature(scramMechanism, serverKey, authMessage), serverSignature);\n  }",
        "idx": "262"
    },
    {
        "target_file_name": "RequestInputFilter.java",
        "target_method": "JavaSource/gov/noaa/pmel/tmap/las/filter/RequestInputFilter.java#doFilter",
        "project_url": "https://github.com/NOAA-PMEL/LAS",
        "commit_id": "e69afb1898ae7e69f3e047513fc1e5570373912b",
        "CWE_id": "CWE-78",
        "CVE_id": "CVE-2025-62193",
        "project_name": "LAS",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "JDOMUtils.XML2JDOM",
            "JDOMUtils.decode"
        ],
        "target_code": "public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\t\t if ( ! ( servletRequest instanceof HttpServletRequest ) )\n\t\t    {\n\t\t      log.error( \"doFilter(): Not an HTTP request! How did this filter get here?\" );\n\t\t      filterChain.doFilter( servletRequest, servletResponse );\n\t\t      return;\n\t\t    }\n\t\t    HttpServletRequest request = (HttpServletRequest) servletRequest;\n\t\t    HttpServletResponse response = (HttpServletResponse) servletResponse;\n\t\t    if ( ! validPath(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validateParameters(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter.\", \"Request contains a parameter that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter.\");\n            \treturn;\n            }\n            if ( !validateTemplateAndImage(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validBooleanValues(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal boolean query parameter value.\");\n            \treturn;\n            }\n            if ( ! validIds(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal LAS ID query parameter value.\");\n            \treturn;\n            }\n            if ( !validBBOX(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal BBOX query parameter value.\");\n            \treturn;\n            }\n            if ( !validFormat(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal format query parameter value.\");\n            \treturn;\n            }\n            if ( !validWMSRequest(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal WMS query parameter value.\");\n            \treturn;\n            }\n            if ( !validView(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal view query parameter value.\");\n            \treturn;\n            }\n            if ( !validReinit(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal reinit query parameter value.\");\n            \treturn;\n            }\n            if ( !validLogLevel(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal log_level query parameter value.\");\n            \treturn;\n            }\n            String requestXML = request.getParameter(\"xml\");\n            if ( requestXML == null ) {\n              requestXML = request.getParameter(\"lasxmldoc\");\n            }\n            if ( (requestXML != null && !requestXML.equals(\"\")) ) {\n            \ttry {\n            \t\trequestXML = JDOMUtils.decode(requestXML, \"UTF-8\");\n\t\t\t\t\t    String expression = lasRequest.getProperty(\"ferret\", \"expression\");\n                        if (!expression.isEmpty()) {\n                            LASAction.logerror(request, \"Ferret expressions are no longer allowed.\", \"\");\n                            response.sendError(404, \"Ferret expressions are no longer allowed.\");\n                            return;\n                        }\n            \t} catch (UnsupportedEncodingException e) {\n            \t\tLASAction.logerror(request, \"Error decoding the XML request query string.\", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n\n            \t// Create a lasRequest object.\n            \tLASUIRequest lasRequest = new LASUIRequest();\n            \ttry {\n            \t\tJDOMUtils.XML2JDOM(requestXML, lasRequest);\n            \t\t// Set the lasRequest object in the HttpServletRequest so the product server does not have to rebuild it.\n            \t\trequest.setAttribute(\"las_request\", lasRequest);\n            \t} catch (Exception e) {\n            \t\tLASAction.logerror(request, \"Error parsing the request XML. \", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n            }\n\n\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\t\t    return;\n\t}",
        "idx": "263"
    },
    {
        "target_file_name": "RequestInputFilter.java",
        "target_method": "JavaSource/gov/noaa/pmel/tmap/las/filter/RequestInputFilter.java#doFilter",
        "project_url": "https://github.com/NOAA-PMEL/LAS",
        "commit_id": "e69afb1898ae7e69f3e047513fc1e5570373912b^",
        "CWE_id": "CWE-78",
        "CVE_id": "CVE-2025-62193",
        "project_name": "LAS",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "JDOMUtils.XML2JDOM"
        ],
        "target_code": "public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\t\t if ( ! ( servletRequest instanceof HttpServletRequest ) )\n\t\t    {\n\t\t      log.error( \"doFilter(): Not an HTTP request! How did this filter get here?\" );\n\t\t      filterChain.doFilter( servletRequest, servletResponse );\n\t\t      return;\n\t\t    }\n\t\t    HttpServletRequest request = (HttpServletRequest) servletRequest;\n\t\t    HttpServletResponse response = (HttpServletResponse) servletResponse;\n\t\t    if ( ! validPath(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validateParameters(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter.\", \"Request contains a parameter that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter.\");\n            \treturn;\n            }\n            if ( !validateTemplateAndImage(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validBooleanValues(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal boolean query parameter value.\");\n            \treturn;\n            }\n            if ( ! validIds(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal LAS ID query parameter value.\");\n            \treturn;\n            }\n            if ( !validBBOX(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal BBOX query parameter value.\");\n            \treturn;\n            }\n            if ( !validFormat(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal format query parameter value.\");\n            \treturn;\n            }\n            if ( !validWMSRequest(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal WMS query parameter value.\");\n            \treturn;\n            }\n            if ( !validView(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal view query parameter value.\");\n            \treturn;\n            }\n            if ( !validReinit(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal reinit query parameter value.\");\n            \treturn;\n            }\n            if ( !validLogLevel(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal log_level query parameter value.\");\n            \treturn;\n            }\n            String requestXML = request.getParameter(\"xml\");\n            if ( requestXML == null ) {\n              requestXML = request.getParameter(\"lasxmldoc\");\n            }\n            if ( (requestXML != null && !requestXML.equals(\"\")) ) {\n            \ttry {\n            \t\trequestXML = JDOMUtils.decode(requestXML, \"UTF-8\");\n            \t} catch (UnsupportedEncodingException e) {\n            \t\tLASAction.logerror(request, \"Error decoding the XML request query string.\", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n\n            \t// Create a lasRequest object.\n            \tLASUIRequest lasRequest = new LASUIRequest();\n            \ttry {\n            \t\tJDOMUtils.XML2JDOM(requestXML, lasRequest);\n            \t\t// Set the lasRequest object in the HttpServletRequest so the product server does not have to rebuild it.\n            \t\trequest.setAttribute(\"las_request\", lasRequest);\n            \t} catch (Exception e) {\n            \t\tLASAction.logerror(request, \"Error parsing the request XML. \", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n            }\n\n\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\t\t    return;\n\t}",
        "idx": "264"
    },
    {
        "target_file_name": "RequestInputFilter.java",
        "target_method": "JavaSource/gov/noaa/pmel/tmap/las/filter/RequestInputFilter.java#doFilter",
        "project_url": "https://github.com/NOAA-PMEL/LAS",
        "commit_id": "de5f9237bfd4ac5085bcc49a6e30bbc9507ddb29",
        "CWE_id": "CWE-78",
        "CVE_id": "CVE-2025-62193",
        "project_name": "LAS",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "JDOMUtils.XML2JDOM",
            "JDOMUtils.decode",
            "LASUIRequest",
            "getProperty"
        ],
        "target_code": "public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\t\t if ( ! ( servletRequest instanceof HttpServletRequest ) )\n\t\t    {\n\t\t      log.error( \"doFilter(): Not an HTTP request! How did this filter get here?\" );\n\t\t      filterChain.doFilter( servletRequest, servletResponse );\n\t\t      return;\n\t\t    }\n\t\t    HttpServletRequest request = (HttpServletRequest) servletRequest;\n\t\t    HttpServletResponse response = (HttpServletResponse) servletResponse;\n\t\t    if ( ! validPath(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validateParameters(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter.\", \"Request contains a parameter that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter.\");\n            \treturn;\n            }\n            if ( !validateTemplateAndImage(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validBooleanValues(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal boolean query parameter value.\");\n            \treturn;\n            }\n            if ( ! validIds(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal LAS ID query parameter value.\");\n            \treturn;\n            }\n            if ( !validBBOX(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal BBOX query parameter value.\");\n            \treturn;\n            }\n            if ( !validFormat(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal format query parameter value.\");\n            \treturn;\n            }\n            if ( !validWMSRequest(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal WMS query parameter value.\");\n            \treturn;\n            }\n            if ( !validView(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal view query parameter value.\");\n            \treturn;\n            }\n            if ( !validReinit(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal reinit query parameter value.\");\n            \treturn;\n            }\n            if ( !validLogLevel(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal log_level query parameter value.\");\n            \treturn;\n            }\n            String requestXML = request.getParameter(\"xml\");\n            if ( requestXML == null ) {\n              requestXML = request.getParameter(\"lasxmldoc\");\n            }\n            if ( (requestXML != null && !requestXML.equals(\"\")) ) {\n            \ttry {\n            \t\trequestXML = JDOMUtils.decode(requestXML, \"UTF-8\");\n            \t} catch (UnsupportedEncodingException e) {\n            \t\tLASAction.logerror(request, \"Error decoding the XML request query string.\", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n\n            \t// Create a lasRequest object.\n            \tLASUIRequest lasRequest = new LASUIRequest();\n            \ttry {\n            \t\tJDOMUtils.XML2JDOM(requestXML, lasRequest);\n            \t\t// Set the lasRequest object in the HttpServletRequest so the product server does not have to rebuild it.\n            \t\trequest.setAttribute(\"las_request\", lasRequest);\n\t\t\t\t\tString expression = lasRequest.getProperty(\"ferret\", \"expression\");\n                    if (!expression.isEmpty()) {\n                        LASAction.logerror(request, \"Ferret expressions are no longer allowed.\", \"\");\n                        response.sendError(404, \"Ferret expressions are no longer allowed.\");\n                        return;\n                    }\n            \t} catch (Exception e) {\n            \t\tLASAction.logerror(request, \"Error parsing the request XML. \", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n            }\n\n\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\t\t    return;\n\t}",
        "idx": "265"
    },
    {
        "target_file_name": "RequestInputFilter.java",
        "target_method": "JavaSource/gov/noaa/pmel/tmap/las/filter/RequestInputFilter.java#doFilter",
        "project_url": "https://github.com/NOAA-PMEL/LAS",
        "commit_id": "de5f9237bfd4ac5085bcc49a6e30bbc9507ddb29^",
        "CWE_id": "CWE-78",
        "CVE_id": "CVE-2025-62193",
        "project_name": "LAS",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "JDOMUtils.XML2JDOM",
            "JDOMUtils.decode",
            "LASUIRequest"
        ],
        "target_code": "public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n\t\t if ( ! ( servletRequest instanceof HttpServletRequest ) )\n\t\t    {\n\t\t      log.error( \"doFilter(): Not an HTTP request! How did this filter get here?\" );\n\t\t      filterChain.doFilter( servletRequest, servletResponse );\n\t\t      return;\n\t\t    }\n\t\t    HttpServletRequest request = (HttpServletRequest) servletRequest;\n\t\t    HttpServletResponse response = (HttpServletResponse) servletResponse;\n\t\t    if ( ! validPath(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validateParameters(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter.\", \"Request contains a parameter that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter.\");\n            \treturn;\n            }\n            if ( !validateTemplateAndImage(request) ) {\n\t\t\t\tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal query parameter value.\");\n\t\t\t\treturn;\n\t\t\t}\n            if ( ! validBooleanValues(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal boolean query parameter value.\");\n            \treturn;\n            }\n            if ( ! validIds(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal LAS ID query parameter value.\");\n            \treturn;\n            }\n            if ( !validBBOX(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal BBOX query parameter value.\");\n            \treturn;\n            }\n            if ( !validFormat(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal format query parameter value.\");\n            \treturn;\n            }\n            if ( !validWMSRequest(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal WMS query parameter value.\");\n            \treturn;\n            }\n            if ( !validView(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal view query parameter value.\");\n            \treturn;\n            }\n            if ( !validReinit(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal reinit query parameter value.\");\n            \treturn;\n            }\n            if ( !validLogLevel(request) ) {\n            \tLASAction.logerror(request, \"Illegal request parameter value.\", \"Request contains a parameter value that is not allowed.\");\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal log_level query parameter value.\");\n            \treturn;\n            }\n            String requestXML = request.getParameter(\"xml\");\n            if ( requestXML == null ) {\n              requestXML = request.getParameter(\"lasxmldoc\");\n            }\n            if ( (requestXML != null && !requestXML.equals(\"\")) ) {\n            \ttry {\n            \t\trequestXML = JDOMUtils.decode(requestXML, \"UTF-8\");\n\t\t\t\t\t    String expression = lasRequest.getProperty(\"ferret\", \"expression\");\n                        if (!expression.isEmpty()) {\n                            LASAction.logerror(request, \"Ferret expressions are no longer allowed.\", \"\");\n                            response.sendError(404, \"Ferret expressions are no longer allowed.\");\n                            return;\n                        }\n            \t} catch (UnsupportedEncodingException e) {\n            \t\tLASAction.logerror(request, \"Error decoding the XML request query string.\", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n\n            \t// Create a lasRequest object.\n            \tLASUIRequest lasRequest = new LASUIRequest();\n            \ttry {\n            \t\tJDOMUtils.XML2JDOM(requestXML, lasRequest);\n            \t\t// Set the lasRequest object in the HttpServletRequest so the product server does not have to rebuild it.\n            \t\trequest.setAttribute(\"las_request\", lasRequest);\n            \t} catch (Exception e) {\n            \t\tLASAction.logerror(request, \"Error parsing the request XML. \", e);\n            \t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND, \"Request contains an illegal xml query parameter value.\");\n            \t\treturn;\n            \t}\n            }\n\n\t\t\tfilterChain.doFilter(servletRequest, servletResponse);\n\t\t    return;\n\t}",
        "idx": "266"
    },
    {
        "target_file_name": "Db2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Db2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "bb320e42bf2cf862b9c4b438c1517547b53ed67b",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-62419",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            for (String illegalParameter : illegalParameters) {\n                if (getJdbcUrl().toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            if (!getJdbcUrl().startsWith(\"jdbc:db2\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String url = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                url = \"jdbc:db2://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                url = \"jdbc:db2://HOSTNAME:PORT/DATABASE:currentSchema=SCHEMA;\"\n                        .replace(\"HOSTNAME\", getLHost().trim())\n                        .replace(\"PORT\", getLPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            url = \"jdbc:db2://HOSTNAME:PORT/DATABASE:EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (url.toLowerCase().contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return url;\n    }",
        "idx": "267"
    },
    {
        "target_file_name": "Sqlserver.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Sqlserver.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "bb320e42bf2cf862b9c4b438c1517547b53ed67b",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-62419",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "URLDecoder.decode"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:sqlserver\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            jdbcUrl =  \"jdbc:sqlserver://HOSTNAME:PORT;DatabaseName=DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            jdbcUrl =  \"jdbc:sqlserver://HOSTNAME:PORT;DatabaseName=DATABASE;EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (URLDecoder.decode(jdbcUrl).toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "268"
    },
    {
        "target_file_name": "H2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/H2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "bb320e42bf2cf862b9c4b438c1517547b53ed67b",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-62419",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "startsWith"
        ],
        "target_code": "public String getJdbc() {\n        for (String illegalParameter : getH2IllegalParameters()) {\n            if (jdbc.toUpperCase().replace(\"\\\\\", \"\").contains(illegalParameter)) {\n                DEException.throwException(\"Has illegal parameter: \" + jdbc);\n            }\n        }\n        if (StringUtils.isNotEmpty(jdbc) && !jdbc.startsWith(\"jdbc:h2\")) {\n            DEException.throwException(\"Illegal jdbcUrl: \" + jdbc);\n        }\n        return jdbc;\n    }",
        "idx": "269"
    },
    {
        "target_file_name": "Mongo.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/Mongo.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "bb320e42bf2cf862b9c4b438c1517547b53ed67b",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-62419",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace"
        ],
        "target_code": "public String getJdbc() {\n        if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")) {\n            if (!getJdbcUrl().startsWith(\"jdbc:mysql\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            return getJdbcUrl();\n        }\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            jdbcUrl = \"jdbc:mysql://HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            jdbcUrl = \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : illegalParameters) {\n            if (jdbcUrl.contains(illegalParameter)) {\n                throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }",
        "idx": "270"
    },
    {
        "target_file_name": "H2.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/type/H2.java#getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "bb320e42bf2cf862b9c4b438c1517547b53ed67b^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-62419",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace",
            "startsWith",
            "toUpperCase"
        ],
        "target_code": "public String getJdbc() {\n        for (String illegalParameter : getH2IllegalParameters()) {\n            if (jdbc.toUpperCase().replace(\"\\\\\", \"\").contains(illegalParameter)) {\n                DEException.throwException(\"Has illegal parameter: \" + jdbc);\n            }\n        }\n        if (StringUtils.isNotEmpty(getJdbcUrl()) && !getJdbcUrl().startsWith(\"jdbc:h2\")) {\n            DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n        }\n        return jdbc;\n    }",
        "idx": "271"
    },
    {
        "target_file_name": "EsProvider.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/provider/EsProvider.java#fetchTableField",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "3c52cc26c4cca1000294346cf99a84b25d38bfb2",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-62422",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "execQuery"
        ],
        "target_code": "@Override\n    public List<TableField> fetchTableField(DatasourceRequest datasourceRequest) {\n        List<TableField> tableFields = new ArrayList<>();\n        try {\n            String sql;\n            if (datasourceRequest.getTable() != null) {\n                if (!getTables(datasourceRequest).stream().map(DatasetTableDTO::getTableName).collect(Collectors.toList()).contains(datasourceRequest.getTable())) {\n                    DEException.throwException(\"无效的表名！\");\n                }\n                sql = \"select * from \\\"\" + datasourceRequest.getTable() + \"\\\" limit 0\";\n            } else {\n                sql = datasourceRequest.getQuery();\n            }\n            String response = execQuery(datasourceRequest, sql, \"?format=json\");\n            tableFields = fetchResultField4Sql(response);\n        } catch (Exception e) {\n            DEException.throwException(e);\n        }\n        return tableFields;\n    }",
        "idx": "272"
    },
    {
        "target_file_name": "EsProvider.java",
        "target_method": "core/core-backend/src/main/java/io/dataease/datasource/provider/EsProvider.java#fetchTableField",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "3c52cc26c4cca1000294346cf99a84b25d38bfb2^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-62422",
        "project_name": "dataease",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "execQuery"
        ],
        "target_code": "@Override\n    public List<TableField> fetchTableField(DatasourceRequest datasourceRequest) {\n        List<TableField> tableFields = new ArrayList<>();\n        try {\n            String sql;\n            if (datasourceRequest.getTable() != null) {\n                sql = \"select * from \\\"\" + datasourceRequest.getTable() + \"\\\" limit 0\";\n            } else {\n                sql = datasourceRequest.getQuery();\n            }\n            String response = execQuery(datasourceRequest, sql, \"?format=json\");\n            tableFields = fetchResultField4Sql(response);\n        } catch (Exception e) {\n            DEException.throwException(e);\n        }\n        return tableFields;\n    }",
        "idx": "273"
    },
    {
        "target_file_name": "AuthenticationManager.java",
        "target_method": "services/src/main/java/org/keycloak/services/managers/AuthenticationManager.java#isSessionValid",
        "project_url": "https://github.com/keycloak/keycloak",
        "commit_id": "bda0e2a67c8cf41d1b3d9010e6dfcddaf79bf59b",
        "CWE_id": "CWE-613",
        "CVE_id": "CVE-2025-11429",
        "project_name": "keycloak",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Profile.isFeatureEnabled",
            "SessionExpirationUtils.calculateUserSessionIdleTimestamp",
            "SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp",
            "Time.currentTimeMillis"
        ],
        "target_code": "public static boolean isSessionValid(RealmModel realm, UserSessionModel userSession) {\n        if (userSession == null) {\n            logger.debug(\"No user session\");\n            return false;\n        }\n        if (userSession.isRememberMe() && !realm.isRememberMe()) {\n            logger.debugv(\"Session {0} invalid: created with remember me but remember me is disabled for the realm.\", userSession.getId());\n            return false;\n        }\n        if (userSession.getNote(Details.IDENTITY_PROVIDER) != null) {\n            String brokerAlias = userSession.getNote(Details.IDENTITY_PROVIDER);\n            if (realm.getIdentityProviderByAlias(brokerAlias) == null) {\n                // associated idp was removed, invalidate the session.\n                return false;\n            }\n        }\n        long currentTime = Time.currentTimeMillis();\n        long lifespan = SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getStarted()), realm);\n        long idle = SessionExpirationUtils.calculateUserSessionIdleTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getLastSessionRefresh()), realm);\n\n        boolean sessionIdleOk = idle > currentTime -\n                                       ((Profile.isFeatureEnabled(Profile.Feature.PERSISTENT_USER_SESSIONS) || Profile.isFeatureEnabled(Profile.Feature.CLUSTERLESS)) ? 0 : TimeUnit.SECONDS.toMillis(SessionTimeoutHelper.IDLE_TIMEOUT_WINDOW_SECONDS));\n        boolean sessionMaxOk = lifespan == -1L || lifespan > currentTime;\n        return sessionIdleOk && sessionMaxOk;\n    }",
        "idx": "274"
    },
    {
        "target_file_name": "AuthenticationManager.java",
        "target_method": "services/src/main/java/org/keycloak/services/managers/AuthenticationManager.java#isSessionValid",
        "project_url": "https://github.com/keycloak/keycloak",
        "commit_id": "bda0e2a67c8cf41d1b3d9010e6dfcddaf79bf59b^",
        "CWE_id": "CWE-613",
        "CVE_id": "CVE-2025-11429",
        "project_name": "keycloak",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Profile.isFeatureEnabled",
            "SessionExpirationUtils.calculateUserSessionIdleTimestamp",
            "SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp",
            "Time.currentTimeMillis"
        ],
        "target_code": "public static boolean isSessionValid(RealmModel realm, UserSessionModel userSession) {\n        if (userSession == null) {\n            logger.debug(\"No user session\");\n            return false;\n        }\n        if (userSession.getNote(Details.IDENTITY_PROVIDER) != null) {\n            String brokerAlias = userSession.getNote(Details.IDENTITY_PROVIDER);\n            if (realm.getIdentityProviderByAlias(brokerAlias) == null) {\n                // associated idp was removed, invalidate the session.\n                return false;\n            }\n        }\n        long currentTime = Time.currentTimeMillis();\n        long lifespan = SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getStarted()), realm);\n        long idle = SessionExpirationUtils.calculateUserSessionIdleTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getLastSessionRefresh()), realm);\n\n        boolean sessionIdleOk = idle > currentTime -\n                                       ((Profile.isFeatureEnabled(Profile.Feature.PERSISTENT_USER_SESSIONS) || Profile.isFeatureEnabled(Profile.Feature.CLUSTERLESS)) ? 0 : TimeUnit.SECONDS.toMillis(SessionTimeoutHelper.IDLE_TIMEOUT_WINDOW_SECONDS));\n        boolean sessionMaxOk = lifespan == -1L || lifespan > currentTime;\n        return sessionIdleOk && sessionMaxOk;\n    }",
        "idx": "275"
    },
    {
        "target_file_name": "InsecureSslEngineFactory.java",
        "target_method": "data-prepper-plugins/kafka-plugins/src/main/java/org/opensearch/dataprepper/plugins/kafka/util/InsecureSslEngineFactory.java#createClientSslEngine",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "db11ce8f27ebca018980b2bca863f7173de9ce56",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SSLContext.createSSLEngine",
            "SSLContext.getInstance",
            "SSLContext.init",
            "SSLEngine.setUseClientMode"
        ],
        "target_code": "@Override\n    public SSLEngine createClientSslEngine(String peerHost, int peerPort, String endpointIdentification) {\n        TrustManager[] trustManagers = new TrustManager[]{ INSECURE_TRUST_MANAGER };\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, trustManagers, new SecureRandom());\n            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);\n            sslEngine.setUseClientMode(true);\n            return sslEngine;\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "idx": "276"
    },
    {
        "target_file_name": "DBSource.java",
        "target_method": "data-prepper-plugins/geoip-processor/src/main/java/org/opensearch/dataprepper/plugins/geoip/extension/databasedownload/DBSource.java#initiateSSL",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "db11ce8f27ebca018980b2bca863f7173de9ce56",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpsURLConnection.setDefaultHostnameVerifier",
            "HttpsURLConnection.setDefaultSSLSocketFactory",
            "SSLContext.getInstance",
            "SSLContext.init"
        ],
        "target_code": "default void initiateSSL() throws NoSuchAlgorithmException, KeyManagementException {\n        final TrustManager[] trustAllCerts = new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {\n                        return;\n                    }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {\n                        return;\n                    }\n                }\n        };\n\n        final SSLContext sc = SSLContext.getInstance(\"TLS\");\n        sc.init(null, trustAllCerts, new SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        final HostnameVerifier hostnameVerifier = new HostnameVerifier() {\n            public boolean verify(String urlHostName, SSLSession session) {\n                return true;\n            }\n        };\n        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n    }",
        "idx": "277"
    },
    {
        "target_file_name": "CustomClientSslEngineFactory.java",
        "target_method": "data-prepper-plugins/kafka-plugins/src/main/java/org/opensearch/dataprepper/plugins/kafka/util/CustomClientSslEngineFactory.java#createClientSslEngine",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "db11ce8f27ebca018980b2bca863f7173de9ce56",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SSLContext.createSSLEngine",
            "SSLContext.getInstance",
            "SSLContext.init",
            "SSLEngine.setUseClientMode"
        ],
        "target_code": "@Override\n    public SSLEngine createClientSslEngine(final String peerHost, final int peerPort, final String endpointIdentification) {\n        try {\n            final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n            sslContext.init(null, getTrustManager(), new SecureRandom());\n            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);\n            sslEngine.setUseClientMode(true);\n            return sslEngine;\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "idx": "278"
    },
    {
        "target_file_name": "InsecureSslEngineFactory.java",
        "target_method": "data-prepper-plugins/kafka-plugins/src/main/java/org/opensearch/dataprepper/plugins/kafka/util/InsecureSslEngineFactory.java#createClientSslEngine",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "db11ce8f27ebca018980b2bca863f7173de9ce56^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SSLContext.getInstance",
            "SSLContext.init",
            "SSLEngine.setUseClientMode"
        ],
        "target_code": "@Override\n    public SSLEngine createClientSslEngine(String peerHost, int peerPort, String endpointIdentification) {\n        TrustManager[] trustManagers = new TrustManager[]{ INSECURE_TRUST_MANAGER };\n        try {\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init(null, trustManagers, new SecureRandom());\n            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);\n            sslEngine.setUseClientMode(true);\n            return sslEngine;\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "idx": "279"
    },
    {
        "target_file_name": "DBSource.java",
        "target_method": "data-prepper-plugins/geoip-processor/src/main/java/org/opensearch/dataprepper/plugins/geoip/extension/databasedownload/DBSource.java#initiateSSL",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "db11ce8f27ebca018980b2bca863f7173de9ce56^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HttpsURLConnection.setDefaultHostnameVerifier",
            "HttpsURLConnection.setDefaultSSLSocketFactory",
            "SSLContext.getInstance",
            "SSLContext.init"
        ],
        "target_code": "default void initiateSSL() throws NoSuchAlgorithmException, KeyManagementException {\n        final TrustManager[] trustAllCerts = new TrustManager[]{\n                new X509TrustManager() {\n                    public X509Certificate[] getAcceptedIssuers() {\n                        return null;\n                    }\n                    public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException {\n                        return;\n                    }\n                    public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException {\n                        return;\n                    }\n                }\n        };\n\n        final SSLContext sc = SSLContext.getInstance(\"SSL\");\n        sc.init(null, trustAllCerts, new SecureRandom());\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        final HostnameVerifier hostnameVerifier = new HostnameVerifier() {\n            public boolean verify(String urlHostName, SSLSession session) {\n                return true;\n            }\n        };\n        HttpsURLConnection.setDefaultHostnameVerifier(hostnameVerifier);\n    }",
        "idx": "280"
    },
    {
        "target_file_name": "CustomClientSslEngineFactory.java",
        "target_method": "data-prepper-plugins/kafka-plugins/src/main/java/org/opensearch/dataprepper/plugins/kafka/util/CustomClientSslEngineFactory.java#createClientSslEngine",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "db11ce8f27ebca018980b2bca863f7173de9ce56^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SSLContext.createSSLEngine",
            "SSLContext.getInstance",
            "SSLContext.init",
            "SSLEngine.setUseClientMode"
        ],
        "target_code": "@Override\n    public SSLEngine createClientSslEngine(final String peerHost, final int peerPort, final String endpointIdentification) {\n        try {\n            final SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init(null, getTrustManager(), new SecureRandom());\n            SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);\n            sslEngine.setUseClientMode(true);\n            return sslEngine;\n        } catch (NoSuchAlgorithmException | KeyManagementException e) {\n            throw new RuntimeException(e);\n        }\n    }",
        "idx": "281"
    },
    {
        "target_file_name": "HttpDBDownloadService.java",
        "target_method": "data-prepper-plugins/geoip-processor/src/main/java/org/opensearch/dataprepper/plugins/geoip/extension/databasedownload/HttpDBDownloadService.java#initiateDownload",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "b0386a5af3fb71094ba6c86cd8b2afc783246599",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File"
        ],
        "target_code": "public void initiateDownload() {\n        final String tarDir = destinationDirectory + File.separator + \"tar\";\n        final String downloadTarFilepath = tarDir + File.separator + \"out.tar.gz\";\n        final Set<String> databasePaths = maxMindDatabaseConfig.getDatabasePaths().keySet();\n        for (final String key: databasePaths) {\n            geoIPFileManager.createDirectoryIfNotExist(tarDir);\n            try {\n                buildRequestAndDownloadFile(maxMindDatabaseConfig.getDatabasePaths().get(key), downloadTarFilepath);\n                final File tarFile = decompressAndgetTarFile(tarDir, downloadTarFilepath);\n                unTarFile(tarFile, new File(destinationDirectory), key);\n                deleteTarFolder(tarDir);\n            } catch (Exception ex) {\n                throw new DownloadFailedException(\"Failed to download from \" + maxMindDatabaseConfig.getDatabasePaths().get(key)\n                        + \" due to: \" + ex.getMessage());\n            }\n        }\n    }",
        "idx": "282"
    },
    {
        "target_file_name": "HttpDBDownloadService.java",
        "target_method": "data-prepper-plugins/geoip-processor/src/main/java/org/opensearch/dataprepper/plugins/geoip/extension/databasedownload/HttpDBDownloadService.java#initiateDownload",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "b0386a5af3fb71094ba6c86cd8b2afc783246599^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "File.separator",
            "buildRequestAndDownloadFile",
            "createDirectoryIfNotExist",
            "decompressAndgetTarFile",
            "deleteTarFolder",
            "initiateSSL",
            "unTarFile"
        ],
        "target_code": "public void initiateDownload() {\n        final String tarDir = destinationDirectory + File.separator + \"tar\";\n        final String downloadTarFilepath = tarDir + File.separator + \"out.tar.gz\";\n        final Set<String> databasePaths = maxMindDatabaseConfig.getDatabasePaths().keySet();\n        for (final String key: databasePaths) {\n            geoIPFileManager.createDirectoryIfNotExist(tarDir);\n            try {\n                initiateSSL();\n                buildRequestAndDownloadFile(maxMindDatabaseConfig.getDatabasePaths().get(key), downloadTarFilepath);\n                final File tarFile = decompressAndgetTarFile(tarDir, downloadTarFilepath);\n                unTarFile(tarFile, new File(destinationDirectory), key);\n                deleteTarFolder(tarDir);\n            } catch (Exception ex) {\n                throw new DownloadFailedException(\"Failed to download from \" + maxMindDatabaseConfig.getDatabasePaths().get(key)\n                        + \" due to: \" + ex.getMessage());\n            }\n        }\n    }",
        "idx": "283"
    },
    {
        "target_file_name": "OpenSearchSinkIT.java",
        "target_method": "data-prepper-plugins/opensearch/src/integrationTest/java/org/opensearch/dataprepper/plugins/sink/opensearch/OpenSearchSinkIT.java#initializeConfigurationMetadata",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "System.getProperty"
        ],
        "target_code": "private Map<String, Object> initializeConfigurationMetadata(final String indexType, final String indexAlias,\n                                                                final String templateFilePath) {\n        final Map<String, Object> metadata = new HashMap<>();\n        metadata.put(IndexConfiguration.INDEX_TYPE, indexType);\n        metadata.put(ConnectionConfiguration.HOSTS, getHosts());\n        metadata.put(IndexConfiguration.INDEX_ALIAS, indexAlias);\n        metadata.put(IndexConfiguration.TEMPLATE_FILE, templateFilePath);\n        metadata.put(IndexConfiguration.FLUSH_TIMEOUT, -1);\n        metadata.put(\"insecure\", true);\n        final String user = System.getProperty(\"tests.opensearch.user\");\n        final String password = System.getProperty(\"tests.opensearch.password\");\n        if (user != null) {\n            metadata.put(AUTHENTICATION, Map.of(USERNAME, user, PASSWORD, password));\n        }\n        final String distributionVersion = DeclaredOpenSearchVersion.OPENDISTRO_0_10.compareTo(\n                OpenSearchIntegrationHelper.getVersion()) >= 0 ?\n                DistributionVersion.ES6.getVersion() : DistributionVersion.DEFAULT.getVersion();\n        metadata.put(IndexConfiguration.DISTRIBUTION_VERSION, distributionVersion);\n        return metadata;\n    }",
        "idx": "284"
    },
    {
        "target_file_name": "ConnectionConfiguration.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/sink/opensearch/ConnectionConfiguration.java#attachSSLContext",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "TrustManager",
            "tlsTrustManagersProvider"
        ],
        "target_code": "private void attachSSLContext(final ApacheHttpClient.Builder apacheHttpClientBuilder) {\n    TrustManager[] trustManagers = createTrustManagers(certPath, insecure);\n    if(trustManagers.length > 0) {\n      apacheHttpClientBuilder.tlsTrustManagersProvider(() -> trustManagers);\n    }\n  }",
        "idx": "285"
    },
    {
        "target_file_name": "ConnectionConfiguration.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/sink/opensearch/ConnectionConfiguration.java#createOpenSearchTransport",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "AwsSdk2Transport",
            "RestClientTransport"
        ],
        "target_code": "private OpenSearchTransport createOpenSearchTransport(final RestHighLevelClient restHighLevelClient, final AwsCredentialsSupplier awsCredentialsSupplier) {\n    if (awsSigv4) {\n      final AwsCredentialsOptions awsCredentialsOptions = createAwsCredentialsOptions();\n      final AwsCredentialsProvider credentialsProvider = awsCredentialsSupplier.getProvider(awsCredentialsOptions);\n      final String serviceName = serverless ? AOSS_SERVICE_NAME : AOS_SERVICE_NAME;\n\n      final AwsSdk2TransportOptions.Builder transportOptions = AwsSdk2TransportOptions.builder()\n              .setCredentials(credentialsProvider)\n              .setMapper(new PreSerializedJsonpMapper());\n\n      if (!isRequestCompressionEnabled()) {\n        // Disable compression for all requests\n        transportOptions.setRequestCompressionSize(Integer.MAX_VALUE);\n      }\n\n      return new AwsSdk2Transport(createSdkHttpClient(), HttpHost.create(hosts.get(0)).toHostString(),\n              serviceName, Region.of(awsRegion), transportOptions.build());\n    } else {\n      return new RestClientTransport(\n              restHighLevelClient.getLowLevelClient(), new PreSerializedJsonpMapper());\n    }\n  }",
        "idx": "286"
    },
    {
        "target_file_name": "ConnectionConfiguration.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/sink/opensearch/ConnectionConfiguration.java#createTrustManagers",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "CertificateFactory.generateCertificate",
            "CertificateFactory.getInstance",
            "KeyStore.getInstance",
            "KeyStore.load",
            "KeyStore.setCertificateEntry",
            "TrustManagerFactory.getInstance",
            "TrustManagerFactory.getTrustManagers",
            "TrustManagerFactory.init",
            "X509TrustAllManager"
        ],
        "target_code": "private static TrustManager[] createTrustManagers(final Path certPath, final boolean insecure) {\n    if (certPath != null) {\n      LOG.info(\"Using the cert provided in the config.\");\n      try (InputStream certificateInputStream = Files.newInputStream(certPath)) {\n        final CertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\n        final Certificate trustedCa = factory.generateCertificate(certificateInputStream);\n        final KeyStore trustStore = KeyStore.getInstance(\"pkcs12\");\n        trustStore.load(null, null);\n        trustStore.setCertificateEntry(\"ca\", trustedCa);\n\n        final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\"X509\");\n        trustManagerFactory.init(trustStore);\n        return trustManagerFactory.getTrustManagers();\n      } catch (Exception ex) {\n        throw new RuntimeException(ex.getMessage(), ex);\n      }\n    } else if(insecure) {\n      LOG.info(\"Using the trust all strategy\");\n      return new TrustManager[] { new X509TrustAllManager() };\n    } else {\n      return new TrustManager[0];\n    }\n  }",
        "idx": "287"
    },
    {
        "target_file_name": "OpenSearchClientFactory.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/source/opensearch/worker/client/OpenSearchClientFactory.java#attachSSLContext",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "TrustManager",
            "tlsTrustManagersProvider"
        ],
        "target_code": "private void attachSSLContext(final NettyNioAsyncHttpClient.Builder asyncClientBuilder, final OpenSearchSourceConfiguration openSearchSourceConfiguration) {\n        TrustManager[] trustManagers = createTrustManagers(openSearchSourceConfiguration.getConnectionConfiguration());\n        if (trustManagers.length > 0) {\n            asyncClientBuilder.tlsTrustManagersProvider(() -> trustManagers);\n        }\n    }",
        "idx": "288"
    },
    {
        "target_file_name": "OpenSearchClientFactory.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/source/opensearch/worker/client/OpenSearchClientFactory.java#createTrustManagers",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Path.of",
            "TrustStoreProvider.createTrustAllManager",
            "TrustStoreProvider.createTrustManager"
        ],
        "target_code": "private TrustManager[] createTrustManagers(final ConnectionConfiguration connectionConfiguration) {\n        final Path certPath = connectionConfiguration.getCertPath();\n        final String certificate = connectionConfiguration.getCertificate();\n        if (certPath != null) {\n            return TrustStoreProvider.createTrustManager(certPath);\n        } else if (certificate != null) {\n            if (PemObjectValidator.isPemObject(certificate)) {\n                return TrustStoreProvider.createTrustManager(certificate);\n            } else {\n                return TrustStoreProvider.createTrustManager(Path.of(certificate));}\n        } else if (connectionConfiguration.isInsecure()) {\n            return TrustStoreProvider.createTrustAllManager();\n\n        } else {\n            return new TrustManager[0];\n        }\n    }",
        "idx": "289"
    },
    {
        "target_file_name": "OpenSearchClientFactory.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/source/opensearch/worker/client/OpenSearchClientFactory.java#getCAStrategy",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Path.of",
            "TrustStoreProvider.createSSLContext",
            "TrustStoreProvider.createSSLContextWithTrustAllStrategy"
        ],
        "target_code": "private SSLContext getCAStrategy(final ConnectionConfiguration connectionConfiguration) {\n        final Path certPath = connectionConfiguration.getCertPath();\n        final String certificate = connectionConfiguration.getCertificate();\n        if (certPath != null) {\n            return TrustStoreProvider.createSSLContext(certPath);\n        } else if (certificate != null) {\n            if (PemObjectValidator.isPemObject(certificate)) {\n                return TrustStoreProvider.createSSLContext(certificate);\n            } else {\n                return TrustStoreProvider.createSSLContext(Path.of(connectionConfiguration.getCertificate()));\n            }\n        } else if (connectionConfiguration.isInsecure()) {\n                return TrustStoreProvider.createSSLContextWithTrustAllStrategy();\n        } else {\n            return null;\n        }\n    }",
        "idx": "290"
    },
    {
        "target_file_name": "OpenSearchSinkIT.java",
        "target_method": "data-prepper-plugins/opensearch/src/integrationTest/java/org/opensearch/dataprepper/plugins/sink/opensearch/OpenSearchSinkIT.java#initializeConfigurationMetadata",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "System.getProperty"
        ],
        "target_code": "private Map<String, Object> initializeConfigurationMetadata(final String indexType, final String indexAlias,\n                                                                final String templateFilePath) {\n        final Map<String, Object> metadata = new HashMap<>();\n        metadata.put(IndexConfiguration.INDEX_TYPE, indexType);\n        metadata.put(ConnectionConfiguration.HOSTS, getHosts());\n        metadata.put(IndexConfiguration.INDEX_ALIAS, indexAlias);\n        metadata.put(IndexConfiguration.TEMPLATE_FILE, templateFilePath);\n        metadata.put(IndexConfiguration.FLUSH_TIMEOUT, -1);\n        final String user = System.getProperty(\"tests.opensearch.user\");\n        final String password = System.getProperty(\"tests.opensearch.password\");\n        if (user != null) {\n            metadata.put(AUTHENTICATION, Map.of(USERNAME, user, PASSWORD, password));\n        }\n        final String distributionVersion = DeclaredOpenSearchVersion.OPENDISTRO_0_10.compareTo(\n                OpenSearchIntegrationHelper.getVersion()) >= 0 ?\n                DistributionVersion.ES6.getVersion() : DistributionVersion.DEFAULT.getVersion();\n        metadata.put(IndexConfiguration.DISTRIBUTION_VERSION, distributionVersion);\n        return metadata;\n    }",
        "idx": "291"
    },
    {
        "target_file_name": "ConnectionConfiguration.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/sink/opensearch/ConnectionConfiguration.java#attachSSLContext",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "TrustManager",
            "tlsTrustManagersProvider"
        ],
        "target_code": "private void attachSSLContext(final ApacheHttpClient.Builder apacheHttpClientBuilder) {\n    TrustManager[] trustManagers = createTrustManagers(certPath);\n    apacheHttpClientBuilder.tlsTrustManagersProvider(() -> trustManagers);\n  }",
        "idx": "292"
    },
    {
        "target_file_name": "ConnectionConfiguration.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/sink/opensearch/ConnectionConfiguration.java#createOpenSearchTransport",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "AwsSdk2Transport",
            "RestClientTransport"
        ],
        "target_code": "private OpenSearchTransport createOpenSearchTransport(final RestHighLevelClient restHighLevelClient, final AwsCredentialsSupplier awsCredentialsSupplier) {\n    if (awsSigv4) {\n      final AwsCredentialsOptions awsCredentialsOptions = createAwsCredentialsOptions();\n      final AwsCredentialsProvider credentialsProvider = awsCredentialsSupplier.getProvider(awsCredentialsOptions);\n      final String serviceName = serverless ? AOSS_SERVICE_NAME : AOS_SERVICE_NAME;\n\n      final AwsSdk2TransportOptions.Builder transportOptions = AwsSdk2TransportOptions.builder()\n              .setCredentials(credentialsProvider)\n              .setMapper(new PreSerializedJsonpMapper());\n\n      if (!isRequestCompressionEnabled()) {\n        // Disable compression for all requests\n        transportOptions.setRequestCompressionSize(Integer.MAX_VALUE);\n      }\n\n      return new AwsSdk2Transport(createSdkHttpClient(), HttpHost.create(hosts.get(0)).getHostName(),\n              serviceName, Region.of(awsRegion), transportOptions.build());\n    } else {\n      return new RestClientTransport(\n              restHighLevelClient.getLowLevelClient(), new PreSerializedJsonpMapper());\n    }\n  }",
        "idx": "293"
    },
    {
        "target_file_name": "ConnectionConfiguration.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/sink/opensearch/ConnectionConfiguration.java#createTrustManagers",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "CertificateFactory.getInstance",
            "KeyStore.getInstance",
            "TrustManagerFactory.getInstance",
            "X509TrustAllManager",
            "generateCertificate",
            "getTrustManagers",
            "init",
            "load",
            "setCertificateEntry"
        ],
        "target_code": "private static TrustManager[] createTrustManagers(final Path certPath) {\n    if (certPath != null) {\n      LOG.info(\"Using the cert provided in the config.\");\n      try (InputStream certificateInputStream = Files.newInputStream(certPath)) {\n        final CertificateFactory factory = CertificateFactory.getInstance(\"X.509\");\n        final Certificate trustedCa = factory.generateCertificate(certificateInputStream);\n        final KeyStore trustStore = KeyStore.getInstance(\"pkcs12\");\n        trustStore.load(null, null);\n        trustStore.setCertificateEntry(\"ca\", trustedCa);\n\n        final TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\"X509\");\n        trustManagerFactory.init(trustStore);\n        return trustManagerFactory.getTrustManagers();\n      } catch (Exception ex) {\n        throw new RuntimeException(ex.getMessage(), ex);\n      }\n    } else {\n      return new TrustManager[] { new X509TrustAllManager() };\n    }\n  }",
        "idx": "294"
    },
    {
        "target_file_name": "OpenSearchClientFactory.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/source/opensearch/worker/client/OpenSearchClientFactory.java#attachSSLContext",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "tlsTrustManagersProvider"
        ],
        "target_code": "private void attachSSLContext(final NettyNioAsyncHttpClient.Builder asyncClientBuilder, final OpenSearchSourceConfiguration openSearchSourceConfiguration) {\n        TrustManager[] trustManagers = createTrustManagers(openSearchSourceConfiguration.getConnectionConfiguration());\n        asyncClientBuilder.tlsTrustManagersProvider(() -> trustManagers);\n    }",
        "idx": "295"
    },
    {
        "target_file_name": "OpenSearchClientFactory.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/source/opensearch/worker/client/OpenSearchClientFactory.java#createTrustManagers",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Path.of",
            "TrustStoreProvider.createTrustAllManager",
            "TrustStoreProvider.createTrustManager"
        ],
        "target_code": "private TrustManager[] createTrustManagers(final ConnectionConfiguration connectionConfiguration) {\n        final Path certPath = connectionConfiguration.getCertPath();\n        if (Objects.nonNull(certPath)) {\n            return TrustStoreProvider.createTrustManager(certPath);\n        } else if (Objects.nonNull(connectionConfiguration.getCertificate())) {\n            if (PemObjectValidator.isPemObject(connectionConfiguration.getCertificate())) {\n                return TrustStoreProvider.createTrustManager(connectionConfiguration.getCertificate());\n            } else {\n                return TrustStoreProvider.createTrustManager(Path.of(connectionConfiguration.getCertificate()));\n            }\n        } else {\n            return TrustStoreProvider.createTrustAllManager();\n        }\n    }",
        "idx": "296"
    },
    {
        "target_file_name": "OpenSearchClientFactory.java",
        "target_method": "data-prepper-plugins/opensearch/src/main/java/org/opensearch/dataprepper/plugins/source/opensearch/worker/client/OpenSearchClientFactory.java#getCAStrategy",
        "project_url": "https://github.com/opensearch-project/data-prepper",
        "commit_id": "98fcf0d0ff9c18f1f7501e11dbed918814724b99^",
        "CWE_id": "CWE-295",
        "CVE_id": "CVE-2025-62371",
        "project_name": "data-prepper",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Objects.nonNull",
            "Path",
            "Path.of",
            "PemObjectValidator.isPemObject",
            "SSLContext",
            "TrustStoreProvider.createSSLContext",
            "TrustStoreProvider.createSSLContextWithTrustAllStrategy"
        ],
        "target_code": "private SSLContext getCAStrategy(final ConnectionConfiguration connectionConfiguration) {\n        final Path certPath = connectionConfiguration.getCertPath();\n        if (Objects.nonNull(certPath)) {\n            return TrustStoreProvider.createSSLContext(certPath);\n        } else if (Objects.nonNull(connectionConfiguration.getCertificate())) {\n            if (PemObjectValidator.isPemObject(connectionConfiguration.getCertificate())) {\n                return TrustStoreProvider.createSSLContext(connectionConfiguration.getCertificate());\n            } else {\n                return TrustStoreProvider.createSSLContext(Path.of(connectionConfiguration.getCertificate()));\n            }\n        } else {\n            return TrustStoreProvider.createSSLContextWithTrustAllStrategy();\n        }\n    }",
        "idx": "297"
    },
    {
        "target_file_name": "AuthenticationManager.java",
        "target_method": "services/src/main/java/org/keycloak/services/managers/AuthenticationManager.java#isSessionValid",
        "project_url": "https://github.com/keycloak/keycloak",
        "commit_id": "a34094100716b7c69ae38eaed6678ab4344d0a1d",
        "CWE_id": "CWE-613",
        "CVE_id": "CVE-2025-11429",
        "project_name": "keycloak",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Profile.isFeatureEnabled",
            "SessionExpirationUtils.calculateUserSessionIdleTimestamp",
            "SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp"
        ],
        "target_code": "public static boolean isSessionValid(RealmModel realm, UserSessionModel userSession) {\n        if (userSession == null) {\n            logger.debug(\"No user session\");\n            return false;\n        }\n        if (userSession.isRememberMe() && !realm.isRememberMe()) {\n            logger.debugv(\"Session {0} invalid: created with remember me but remember me is disabled for the realm.\", userSession.getId());\n            return false;\n        }\n        if (userSession.getNote(Details.IDENTITY_PROVIDER) != null) {\n            String brokerAlias = userSession.getNote(Details.IDENTITY_PROVIDER);\n            if (realm.getIdentityProviderByAlias(brokerAlias) == null) {\n                // associated idp was removed, invalidate the session.\n                return false;\n            }\n        }\n        long currentTime = Time.currentTimeMillis();\n        long lifespan = SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getStarted()), realm);\n        long idle = SessionExpirationUtils.calculateUserSessionIdleTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getLastSessionRefresh()), realm);\n\n        boolean sessionIdleOk = idle > currentTime -\n                                       ((Profile.isFeatureEnabled(Profile.Feature.PERSISTENT_USER_SESSIONS) || Profile.isFeatureEnabled(Profile.Feature.CLUSTERLESS)) ? 0 : TimeUnit.SECONDS.toMillis(SessionTimeoutHelper.IDLE_TIMEOUT_WINDOW_SECONDS));\n        boolean sessionMaxOk = lifespan == -1L || lifespan > currentTime;\n        return sessionIdleOk && sessionMaxOk;\n    }",
        "idx": "298"
    },
    {
        "target_file_name": "AuthenticationManager.java",
        "target_method": "services/src/main/java/org/keycloak/services/managers/AuthenticationManager.java#isSessionValid",
        "project_url": "https://github.com/keycloak/keycloak",
        "commit_id": "a34094100716b7c69ae38eaed6678ab4344d0a1d^",
        "CWE_id": "CWE-613",
        "CVE_id": "CVE-2025-11429",
        "project_name": "keycloak",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Profile.isFeatureEnabled",
            "SessionExpirationUtils.calculateUserSessionIdleTimestamp",
            "SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp",
            "Time.currentTimeMillis",
            "TimeUnit.SECONDS.toMillis"
        ],
        "target_code": "public static boolean isSessionValid(RealmModel realm, UserSessionModel userSession) {\n        if (userSession == null) {\n            logger.debug(\"No user session\");\n            return false;\n        }\n        if (userSession.getNote(Details.IDENTITY_PROVIDER) != null) {\n            String brokerAlias = userSession.getNote(Details.IDENTITY_PROVIDER);\n            if (realm.getIdentityProviderByAlias(brokerAlias) == null) {\n                // associated idp was removed, invalidate the session.\n                return false;\n            }\n        }\n        long currentTime = Time.currentTimeMillis();\n        long lifespan = SessionExpirationUtils.calculateUserSessionMaxLifespanTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getStarted()), realm);\n        long idle = SessionExpirationUtils.calculateUserSessionIdleTimestamp(userSession.isOffline(),\n                userSession.isRememberMe(), TimeUnit.SECONDS.toMillis(userSession.getLastSessionRefresh()), realm);\n\n        boolean sessionIdleOk = idle > currentTime -\n                                       ((Profile.isFeatureEnabled(Profile.Feature.PERSISTENT_USER_SESSIONS) || Profile.isFeatureEnabled(Profile.Feature.CLUSTERLESS)) ? 0 : TimeUnit.SECONDS.toMillis(SessionTimeoutHelper.IDLE_TIMEOUT_WINDOW_SECONDS));\n        boolean sessionMaxOk = lifespan == -1L || lifespan > currentTime;\n        return sessionIdleOk && sessionMaxOk;\n    }",
        "idx": "299"
    },
    {
        "target_file_name": "UserLoginService.java",
        "target_method": "framework/gateway/src/main/java/io/metersphere/gateway/service/UserLoginService.java#login",
        "project_url": "https://github.com/metersphere/metersphere",
        "commit_id": "b984fe74e84711ff326b0a348807c31fadf134af",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-62604",
        "project_name": "metersphere",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "LocaleContextHolder.setLocale",
            "SessionUser.fromUser",
            "session.getAttributes.put"
        ],
        "target_code": "public Optional<SessionUser> login(LoginRequest request, WebSession session, Locale locale) {\n        UserDTO userDTO;\n        if (locale != null) {\n            LocaleContextHolder.setLocale(locale, true);\n        }\n        userDTO = switch (request.getAuthenticate()) {\n            case \"OIDC\", \"CAS\", \"OAuth2\" -> loginSsoMode(request.getUsername(), request.getAuthenticate());\n            case \"LDAP\" -> loginLdapMode(request.getUsername());\n            default -> loginLocalMode(request.getUsername(), request.getPassword());\n        };\n        autoSwitch(session, userDTO);\n        SessionUser sessionUser = SessionUser.fromUser(userDTO, session.getId());\n        session.getAttributes().put(SessionConstants.ATTR_USER, sessionUser);\n        return Optional.of(sessionUser);\n    }",
        "idx": "300"
    },
    {
        "target_file_name": "LoginController.java",
        "target_method": "framework/gateway/src/main/java/io/metersphere/gateway/controller/LoginController.java#login",
        "project_url": "https://github.com/metersphere/metersphere",
        "commit_id": "b984fe74e84711ff326b0a348807c31fadf134af",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-62604",
        "project_name": "metersphere",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Mono",
            "map",
            "subscribeOn",
            "switchIfEmpty"
        ],
        "target_code": "@PostMapping(value = \"/signin\")\n    @MsAuditLog(module = OperLogModule.AUTH_TITLE, type = OperLogConstants.LOGIN, title = \"登录\")\n    public Mono<ResultHolder> login(@RequestBody LoginRequest request, WebSession session, Locale locale) {\n        return Mono.just(userLoginService.loginLocal(request, session, locale))\n                .subscribeOn(Schedulers.boundedElastic())\n                .switchIfEmpty(Mono.error(new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Not found user info or invalid password\")))\n                .map(ResultHolder::success)\n                .map(rh -> {\n                    // 登录是否提示修改密码\n                    boolean changePassword = userLoginService.checkWhetherChangePasswordOrNot(request);\n                    rh.setMessage(BooleanUtils.toStringTrueFalse(changePassword));\n                    return rh;\n                });\n    }",
        "idx": "301"
    },
    {
        "target_file_name": "UserLoginService.java",
        "target_method": "framework/gateway/src/main/java/io/metersphere/gateway/service/UserLoginService.java#login",
        "project_url": "https://github.com/metersphere/metersphere",
        "commit_id": "b984fe74e84711ff326b0a348807c31fadf134af^",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-62604",
        "project_name": "metersphere",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "LocaleContextHolder.setLocale",
            "SessionUser.fromUser",
            "session.getAttributes.put"
        ],
        "target_code": "public Optional<SessionUser> login(LoginRequest request, WebSession session, Locale locale) {\n        UserDTO userDTO;\n        if (locale != null) {\n            LocaleContextHolder.setLocale(locale, true);\n        }\n        switch (request.getAuthenticate()) {\n            case \"OIDC\":\n            case \"CAS\":\n            case \"OAuth2\":\n                userDTO = loginSsoMode(request.getUsername(), request.getAuthenticate());\n                break;\n            case \"LDAP\":\n                userDTO = loginLdapMode(request.getUsername());\n                break;\n            default:\n                userDTO = loginLocalMode(request.getUsername(), request.getPassword());\n                break;\n        }\n        autoSwitch(session, userDTO);\n        SessionUser sessionUser = SessionUser.fromUser(userDTO, session.getId());\n        session.getAttributes().put(SessionConstants.ATTR_USER, sessionUser);\n        return Optional.of(sessionUser);\n    }",
        "idx": "302"
    },
    {
        "target_file_name": "LoginController.java",
        "target_method": "framework/gateway/src/main/java/io/metersphere/gateway/controller/LoginController.java#login",
        "project_url": "https://github.com/metersphere/metersphere",
        "commit_id": "b984fe74e84711ff326b0a348807c31fadf134af^",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-62604",
        "project_name": "metersphere",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Mono",
            "map",
            "subscribeOn",
            "switchIfEmpty"
        ],
        "target_code": "@PostMapping(value = \"/signin\")\n    @MsAuditLog(module = OperLogModule.AUTH_TITLE, type = OperLogConstants.LOGIN, title = \"登录\")\n    public Mono<ResultHolder> login(@RequestBody LoginRequest request, WebSession session, Locale locale) {\n        return Mono.just(userLoginService.login(request, session, locale))\n                .subscribeOn(Schedulers.boundedElastic())\n                .switchIfEmpty(Mono.error(new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Not found user info or invalid password\")))\n                .map(ResultHolder::success)\n                .map(rh -> {\n                    // 登录是否提示修改密码\n                    boolean changePassword = userLoginService.checkWhetherChangePasswordOrNot(request);\n                    rh.setMessage(BooleanUtils.toStringTrueFalse(changePassword));\n                    return rh;\n                });\n    }",
        "idx": "303"
    },
    {
        "target_file_name": "CoverJwtFilter.java",
        "target_method": "booklore-api/src/main/java/com/adityachandel/booklore/config/security/filter/CoverJwtFilter.java#doFilterInternal",
        "project_url": "https://github.com/booklore-app/booklore",
        "commit_id": "b226c43343cd0cef4c1cd54bc3dcdef90b147133",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-62614",
        "project_name": "booklore",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "FilterChain.doFilter",
            "HttpServletRequest.getParameter",
            "HttpServletResponse.sendError",
            "appSettingService.getAppSettings",
            "authenticateLocalUser",
            "authenticateOidcUser",
            "jwtUtils.validateToken"
        ],
        "target_code": "@Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {\n        String token = request.getParameter(\"token\");\n        if (token == null || token.isEmpty()) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Missing authentication token\");\n            return;\n        }\n        try {\n            if (jwtUtils.validateToken(token)) {\n                authenticateLocalUser(token, request);\n            } else if (appSettingService.getAppSettings().isOidcEnabled()) {\n                authenticateOidcUser(token, request);\n            } else {\n                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Invalid token\");\n                return;\n            }\n        } catch (Exception ex) {\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication failed: \" + ex.getMessage());\n            return;\n        }\n\n        chain.doFilter(request, response);\n    }",
        "idx": "304"
    },
    {
        "target_file_name": "CoverJwtFilter.java",
        "target_method": "booklore-api/src/main/java/com/adityachandel/booklore/config/security/filter/CoverJwtFilter.java#doFilterInternal",
        "project_url": "https://github.com/booklore-app/booklore",
        "commit_id": "b226c43343cd0cef4c1cd54bc3dcdef90b147133^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-62614",
        "project_name": "booklore",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "doFilter",
            "sendError",
            "validateToken"
        ],
        "target_code": "@Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {\n        String token = request.getParameter(\"token\");\n        if (token != null) {\n            try {\n                if (jwtUtils.validateToken(token)) {\n                    authenticateLocalUser(token, request);\n                } else if (appSettingService.getAppSettings().isOidcEnabled()) {\n                    authenticateOidcUser(token, request);\n                } else {\n                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Missing or invalid token\");\n                    return;\n                }\n            } catch (Exception ex) {\n                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication failed: \" + ex.getMessage());\n                return;\n            }\n        }\n        chain.doFilter(request, response);\n    }",
        "idx": "305"
    },
    {
        "target_file_name": "GuiStorageElement.java",
        "target_method": "src/main/java/de/themoep/inventorygui/GuiStorageElement.java#getItem",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getItem"
        ],
        "target_code": "@Override\n    public ItemStack getItem(HumanEntity who, int slot) {\n        int index = getStorageSlot(who, slot);\n        if (index > -1 && index < storage.getSize()) {\n            return storage.getItem(index);\n        }\n        return null;\n    }",
        "idx": "306"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#setPageNumber",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "draw",
            "setPageNumber"
        ],
        "target_code": "public void setPageNumber(HumanEntity player, int pageNumber) {\n        setPageNumberInternal(player, pageNumber);\n        draw(player, false, false);\n    }",
        "idx": "307"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#draw",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "draw"
        ],
        "target_code": "public void draw() {\n        draw(true);\n    }",
        "idx": "308"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#onInventoryDrag",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "GuiView.of",
            "addItem",
            "dropItem",
            "getInventory",
            "getItem",
            "getLocation",
            "getSize",
            "getTopInventory",
            "getWhoClicked",
            "getWorld",
            "setItem"
        ],
        "target_code": "@EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)\n        public void onInventoryDrag(InventoryDragEvent event) {\n            Inventory inventory = getInventory(event.getWhoClicked());\n            if (event.getInventory().equals(inventory)) {\n                // Check if we only drag over one slot if so then handle that as a click with the element\n                if (event.getRawSlots().size() == 1) {\n                    int slot = event.getRawSlots().iterator().next();\n                    int size;\n                    try {\n                        size = GuiView.of(event.getView()).getTopInventory().getSize();\n                    } catch (Throwable t) {\n                        event.setCancelled(true);\n                        return;\n                    }\n                    if (slot < size) {\n                        GuiElement.Click click = handleInteract(\n                                event,\n                                // Map drag type to the button that caused it\n                                event.getType() == DragType.SINGLE ? ClickType.RIGHT : ClickType.LEFT,\n                                slot,\n                                event.getOldCursor()\n                        );\n\n                        // Update the cursor if necessary\n                        if (click != null && !event.getOldCursor().equals(click.getCursor())) {\n                            event.setCursor(click.getCursor());\n                        }\n                    }\n                    return;\n                }\n\n                int rest = 0;\n                Map<Integer, ItemStack> resetSlots = new HashMap<>();\n                for (Map.Entry<Integer, ItemStack> items : event.getNewItems().entrySet()) {\n                    if (items.getKey() < inventory.getSize()) {\n                        GuiElement element = getElement(items.getKey());\n                        if (!(element instanceof GuiStorageElement)\n                                || !((GuiStorageElement) element).setStorageItem(event.getWhoClicked(), items.getKey(), items.getValue())) {\n                            ItemStack slotItem = event.getInventory().getItem(items.getKey());\n                            if (!items.getValue().isSimilar(slotItem)) {\n                                rest += items.getValue().getAmount();\n                            } else if (slotItem != null) {\n                                rest += items.getValue().getAmount() - slotItem.getAmount();\n                            }\n                            //items.getValue().setAmount(0); // can't change resulting items :/\n                            resetSlots.put(items.getKey(), event.getInventory().getItem(items.getKey())); // reset them manually\n                        }\n                    }\n                }\n                \n                runTask(event.getWhoClicked(), () -> {\n                    for (Map.Entry<Integer, ItemStack> items : resetSlots.entrySet()) {\n                        GuiView.of(event.getView()).getTopInventory().setItem(items.getKey(), items.getValue());\n                    }\n                });\n                \n                if (rest > 0) {\n                    int cursorAmount = event.getCursor() != null ? event.getCursor().getAmount() : 0;\n                    if (!event.getOldCursor().isSimilar(event.getCursor())) {\n                        event.setCursor(event.getOldCursor());\n                        cursorAmount = 0;\n                    }\n                    int newCursorAmount = cursorAmount + rest;\n                    if (newCursorAmount <= event.getCursor().getMaxStackSize()) {\n                        event.getCursor().setAmount(newCursorAmount);\n                    } else {\n                        event.getCursor().setAmount(event.getCursor().getMaxStackSize());\n                        ItemStack add = event.getCursor().clone();\n                        int addAmount = newCursorAmount - event.getCursor().getMaxStackSize();\n                        if (addAmount > 0) {\n                            add.setAmount(addAmount);\n                            for (ItemStack drop : event.getWhoClicked().getInventory().addItem(add).values()) {\n                                event.getWhoClicked().getLocation().getWorld().dropItem(event.getWhoClicked().getLocation(), drop);\n                            }\n                        }\n                    }\n                }\n            }\n        }",
        "idx": "309"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#onInventoryClose",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "closeInventory"
        ],
        "target_code": "@EventHandler(priority = EventPriority.MONITOR)\n        public void onInventoryClose(InventoryCloseEvent event) {\n            Inventory inventory = getInventory(event.getPlayer());\n            if (event.getInventory().equals(inventory)) {\n                // go back. that checks if the player is in gui and has history\n                if (InventoryGui.this.equals(getOpen(event.getPlayer()))) {\n                    if (closeAction == null || closeAction.onClose(new Close(event.getPlayer(), InventoryGui.this, event))) {\n                        goBack(event.getPlayer());\n                    } else {\n                        clearHistory(event.getPlayer());\n                    }\n                }\n                if (inventories.size() <= 1) {\n                    destroy(false);\n                } else {\n                    inventory.clear();\n                    for (HumanEntity viewer : new ArrayList<>(inventory.getViewers())) {\n                        if (viewer != event.getPlayer()) {\n                            viewer.closeInventory();\n                        }\n                    }\n                    inventories.remove(event.getPlayer().getUniqueId());\n                    pageAmounts.remove(event.getPlayer().getUniqueId());\n                    pageNumbers.remove(event.getPlayer().getUniqueId());\n                    for (GuiElement element : getElements()) {\n                        if (element instanceof DynamicGuiElement) {\n                            ((DynamicGuiElement) element).removeCachedElement(event.getPlayer());\n                        }\n                    }\n                }\n            }\n        }",
        "idx": "310"
    },
    {
        "target_file_name": "GuiStorageElement.java",
        "target_method": "src/main/java/de/themoep/inventorygui/GuiStorageElement.java#getItem",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9^",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "HumanEntity",
            "ItemStack",
            "getStorageItem"
        ],
        "target_code": "@Override\n    public ItemStack getItem(HumanEntity who, int slot) {\n        return getStorageItem(who, slot);\n    }",
        "idx": "311"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#setPageNumber",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9^",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Inventory",
            "draw",
            "getInventory",
            "setPageNumberInternal",
            "storeItems"
        ],
        "target_code": "public void setPageNumber(HumanEntity player, int pageNumber) {\n        Inventory inventory = getInventory(player);\n        if (inventory != null) {\n            storeItems(player, inventory);\n        }\n        setPageNumberInternal(player, pageNumber);\n        draw(player, false, false, false);\n    }",
        "idx": "312"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#draw",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9^",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "Inventory",
            "clear",
            "create",
            "setItem"
        ],
        "target_code": "private void draw(HumanEntity who, boolean updateDynamic, boolean recreateInventory, boolean storeItems) {\n        if (updateDynamic) {\n            updateElements(who, elements.values());\n        }\n        calculatePageAmount(who);\n        Inventory inventory = getInventory(who);\n        if (storeItems && inventory != null) {\n            storeItems(who, inventory);\n        }\n        if (inventory == null || recreateInventory) {\n            build();\n            if (slots.length != inventoryType.getDefaultSize()) {\n                inventory = getInventoryCreator().getSizeCreator().create(this, who, slots.length);\n            } else {\n                inventory = getInventoryCreator().getTypeCreator().create(this, who, inventoryType);\n            }\n            inventories.put(who != null ? who.getUniqueId() : null, inventory);\n        } else {\n            inventory.clear();\n        }\n        for (int i = 0; i < inventory.getSize(); i++) {\n            GuiElement element = getElement(i);\n            if (element == null) {\n                element = getFiller();\n            }\n            if (element != null) {\n                inventory.setItem(i, element.getItem(who, i));\n            }\n        }\n    }",
        "idx": "313"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#onInventoryDrag",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9^",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "GuiView.of",
            "addItem",
            "dropItem",
            "getInventory",
            "getItem",
            "getLocation",
            "getSize",
            "getTopInventory",
            "getWhoClicked",
            "getWorld",
            "setItem"
        ],
        "target_code": "@EventHandler(ignoreCancelled = true, priority = EventPriority.MONITOR)\n        public void onInventoryDrag(InventoryDragEvent event) {\n            Inventory inventory = getInventory(event.getWhoClicked());\n            if (event.getInventory().equals(inventory)) {\n                // Check if we only drag over one slot if so then handle that as a click with the element\n                if (event.getRawSlots().size() == 1) {\n                    int slot = event.getRawSlots().iterator().next();\n                    int size;\n                    try {\n                        size = GuiView.of(event.getView()).getTopInventory().getSize();\n                    } catch (Throwable t) {\n                        event.setCancelled(true);\n                        return;\n                    }\n                    if (slot < size) {\n                        GuiElement.Click click = handleInteract(\n                                event,\n                                // Map drag type to the button that caused it\n                                event.getType() == DragType.SINGLE ? ClickType.RIGHT : ClickType.LEFT,\n                                slot,\n                                event.getOldCursor()\n                        );\n\n                        // Update the cursor if necessary\n                        if (click != null && !event.getOldCursor().equals(click.getCursor())) {\n                            event.setCursor(click.getCursor());\n                        }\n                    }\n                    return;\n                }\n\n                int rest = 0;\n                Map<Integer, ItemStack> resetSlots = new HashMap<>();\n                for (Map.Entry<Integer, ItemStack> items : event.getNewItems().entrySet()) {\n                    if (items.getKey() < inventory.getSize()) {\n                        GuiElement element = getElement(items.getKey());\n                        if (!(element instanceof GuiStorageElement)\n                                || !((GuiStorageElement) element).validateItemPlace(event.getWhoClicked(), items.getKey(), items.getValue())) {\n                            ItemStack slotItem = event.getInventory().getItem(items.getKey());\n                            if (!items.getValue().isSimilar(slotItem)) {\n                                rest += items.getValue().getAmount();\n                            } else if (slotItem != null) {\n                                rest += items.getValue().getAmount() - slotItem.getAmount();\n                            }\n                            //items.getValue().setAmount(0); // can't change resulting items :/\n                            resetSlots.put(items.getKey(), event.getInventory().getItem(items.getKey())); // reset them manually\n                        }\n                    }\n                }\n                \n                runTask(event.getWhoClicked(), () -> {\n                    for (Map.Entry<Integer, ItemStack> items : resetSlots.entrySet()) {\n                        GuiView.of(event.getView()).getTopInventory().setItem(items.getKey(), items.getValue());\n                    }\n                });\n                \n                if (rest > 0) {\n                    int cursorAmount = event.getCursor() != null ? event.getCursor().getAmount() : 0;\n                    if (!event.getOldCursor().isSimilar(event.getCursor())) {\n                        event.setCursor(event.getOldCursor());\n                        cursorAmount = 0;\n                    }\n                    int newCursorAmount = cursorAmount + rest;\n                    if (newCursorAmount <= event.getCursor().getMaxStackSize()) {\n                        event.getCursor().setAmount(newCursorAmount);\n                    } else {\n                        event.getCursor().setAmount(event.getCursor().getMaxStackSize());\n                        ItemStack add = event.getCursor().clone();\n                        int addAmount = newCursorAmount - event.getCursor().getMaxStackSize();\n                        if (addAmount > 0) {\n                            add.setAmount(addAmount);\n                            for (ItemStack drop : event.getWhoClicked().getInventory().addItem(add).values()) {\n                                event.getWhoClicked().getLocation().getWorld().dropItem(event.getWhoClicked().getLocation(), drop);\n                            }\n                        }\n                    }\n                }\n            }\n        }",
        "idx": "314"
    },
    {
        "target_file_name": "InventoryGui.java",
        "target_method": "src/main/java/de/themoep/inventorygui/InventoryGui.java#onInventoryClose",
        "project_url": "https://github.com/Phoenix616/InventoryGui",
        "commit_id": "690fc91d137c6cc04f6ed3a89449050964dd8cb9^",
        "CWE_id": "CWE-837",
        "CVE_id": "CVE-2025-62784",
        "project_name": "InventoryGui",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "InventoryCloseEvent",
            "clear",
            "clearHistory",
            "closeInventory",
            "destroy",
            "equals",
            "getElements",
            "getInventory",
            "getOpen",
            "getPlayer",
            "getUniqueId",
            "getViewers",
            "goBack",
            "onClose",
            "remove",
            "removeCachedElement",
            "storeItems"
        ],
        "target_code": "@EventHandler(priority = EventPriority.MONITOR)\n        public void onInventoryClose(InventoryCloseEvent event) {\n            Inventory inventory = getInventory(event.getPlayer());\n            if (event.getInventory().equals(inventory)) {\n                storeItems(event.getPlayer(), inventory);\n                // go back. that checks if the player is in gui and has history\n                if (InventoryGui.this.equals(getOpen(event.getPlayer()))) {\n                    if (closeAction == null || closeAction.onClose(new Close(event.getPlayer(), InventoryGui.this, event))) {\n                        goBack(event.getPlayer());\n                    } else {\n                        clearHistory(event.getPlayer());\n                    }\n                }\n                if (inventories.size() <= 1) {\n                    destroy(false);\n                } else {\n                    inventory.clear();\n                    for (HumanEntity viewer : new ArrayList<>(inventory.getViewers())) {\n                        if (viewer != event.getPlayer()) {\n                            viewer.closeInventory();\n                        }\n                    }\n                    inventories.remove(event.getPlayer().getUniqueId());\n                    pageAmounts.remove(event.getPlayer().getUniqueId());\n                    pageNumbers.remove(event.getPlayer().getUniqueId());\n                    for (GuiElement element : getElements()) {\n                        if (element instanceof DynamicGuiElement) {\n                            ((DynamicGuiElement) element).removeCachedElement(event.getPlayer());\n                        }\n                    }\n                }\n            }\n        }",
        "idx": "315"
    },
    {
        "target_file_name": "Oracle.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "869b7fb8b10069ac6c326554bfa8f060a539ba85",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-64163",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace",
            "startsWith",
            "toLowerCase"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:oracle\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            for (String illegalParameter : getIllegalParameters()) {\n                if (getJdbcUrl().toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal jdbcUrl: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isNotEmpty(getConnectionType()) && getConnectionType().equalsIgnoreCase(\"serviceName\")) {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT:DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }\n    }",
        "idx": "316"
    },
    {
        "target_file_name": "Oracle.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "7b68eb3dfccbbd12ec977e6320dbd3e32a7bbfe6",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-64164",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace",
            "startsWith",
            "toLowerCase"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            if (!getJdbcUrl().startsWith(\"jdbc:oracle\")) {\n                DEException.throwException(\"Illegal jdbcUrl: \" + getJdbcUrl());\n            }\n            for (String illegalParameter : getOracleIllegalParameters()) {\n                if (getJdbcUrl().toLowerCase().contains(illegalParameter.toLowerCase())) {\n                    DEException.throwException(\"Illegal jdbcUrl: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        if (StringUtils.isNotEmpty(getConnectionType()) && getConnectionType().equalsIgnoreCase(\"serviceName\")) {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT/DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }else {\n            return \"jdbc:oracle:thin:@HOSTNAME:PORT:DATABASE\"\n                    .replace(\"HOSTNAME\", getLHost().trim())\n                    .replace(\"PORT\", getLPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim());\n        }\n    }",
        "idx": "317"
    },
    {
        "target_file_name": "CycloneDxSchema.java",
        "target_method": "src/main/java/org/cyclonedx/CycloneDxSchema.java#getXmlSchema",
        "project_url": "https://github.com/CycloneDX/cyclonedx-core-java",
        "commit_id": "af0ec75c93c03f93733a070c5132554490af5314^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-64518",
        "project_name": "cyclonedx-core-java",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SchemaFactory",
            "StreamSource",
            "newInstance",
            "newSchema"
        ],
        "target_code": "public Schema getXmlSchema(InputStream... inputStreams) throws SAXException {\n    final SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n    final Source[] schemaFiles = new Source[inputStreams.length];\n    for (int i = 0; i < inputStreams.length; i++) {\n      schemaFiles[i] = new StreamSource(inputStreams[i]);\n    }\n    return schemaFactory.newSchema(schemaFiles);\n  }",
        "idx": "318"
    },
    {
        "target_file_name": "CycloneDxSchema.java",
        "target_method": "src/main/java/org/cyclonedx/CycloneDxSchema.java#getXmlSchema",
        "project_url": "https://github.com/CycloneDX/cyclonedx-core-java",
        "commit_id": "af0ec75c93c03f93733a070c5132554490af5314",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-64518",
        "project_name": "cyclonedx-core-java",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SchemaFactory",
            "StreamSource",
            "newInstance",
            "newSchema",
            "setFeature",
            "setProperty"
        ],
        "target_code": "public Schema getXmlSchema(InputStream... inputStreams) throws SAXException {\n    final SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n    schemaFactory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n    schemaFactory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n    schemaFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    final Source[] schemaFiles = new Source[inputStreams.length];\n    for (int i = 0; i < inputStreams.length; i++) {\n      schemaFiles[i] = new StreamSource(inputStreams[i]);\n    }\n    return schemaFactory.newSchema(schemaFiles);\n  }",
        "idx": "319"
    },
    {
        "target_file_name": "XmlParser.java",
        "target_method": "src/main/java/org/cyclonedx/parsers/XmlParser.java#createSecureDocument",
        "project_url": "https://github.com/CycloneDX/cyclonedx-core-java",
        "commit_id": "af0ec75c93c03f93733a070c5132554490af5314",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-64518",
        "project_name": "cyclonedx-core-java",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DocumentBuilderFactory",
            "XMLConstants.ACCESS_EXTERNAL_DTD",
            "XMLConstants.ACCESS_EXTERNAL_SCHEMA",
            "XMLConstants.FEATURE_SECURE_PROCESSING",
            "newDocumentBuilder",
            "newInstance",
            "parse",
            "setAttribute",
            "setFeature"
        ],
        "target_code": "private Document createSecureDocument(InputSource in) throws ParserConfigurationException, IOException, SAXException\n    {\n        //https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xpathexpression\n        DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();\n        df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n        df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n        df.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        DocumentBuilder builder = df.newDocumentBuilder();\n        return builder.parse(in);\n    }",
        "idx": "320"
    },
    {
        "target_file_name": "XmlParser.java",
        "target_method": "src/main/java/org/cyclonedx/parsers/XmlParser.java#createSecureDocument",
        "project_url": "https://github.com/CycloneDX/cyclonedx-core-java",
        "commit_id": "af0ec75c93c03f93733a070c5132554490af5314^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-64518",
        "project_name": "cyclonedx-core-java",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "DocumentBuilderFactory",
            "XMLConstants.ACCESS_EXTERNAL_DTD",
            "XMLConstants.ACCESS_EXTERNAL_SCHEMA",
            "newDocumentBuilder",
            "newInstance",
            "parse",
            "setAttribute"
        ],
        "target_code": "private Document createSecureDocument(InputSource in) throws ParserConfigurationException, IOException, SAXException\n    {\n        //https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xpathexpression\n        DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();\n        df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n        df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n        DocumentBuilder builder = df.newDocumentBuilder();\n        return builder.parse(in);\n    }",
        "idx": "321"
    },
    {
        "target_file_name": "ZdhUnstructureController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhUnstructureController.java#etl_task_unstructure_upload",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileInputStream",
            "IOUtils.toByteArray",
            "JobCommon2.writeFtp",
            "JobCommon2.writeHdfs",
            "JobCommon2.writeSftp"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_unstructure_upload\", blockHandler = \"handleReturn\")\n    @RequestMapping(value=\"/etl_task_unstructure_upload\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo etl_task_unstructure_upload(EtlTaskUnstructureInfo etlTaskUnstructureInfo,MultipartFile[] files) {\n        String owner = null;\n        try {\n            owner = getOwner();\n        } catch (Exception e) {\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n\n        String id=etlTaskUnstructureInfo.getId();\n        etlTaskUnstructureInfo = etlTaskUnstructureMapper.selectByPrimaryKey(id);\n        EtlTaskUnstructureLogInfo etlTaskUnstructureLogInfo=new EtlTaskUnstructureLogInfo();\n        try {\n            if(!StringUtils.isEmpty(etlTaskUnstructureInfo.getUnstructure_params_output())) {\n                //此处当做校验参数是否正常json格式\n                if(!JsonUtil.isJsonValid(etlTaskUnstructureInfo.getUnstructure_params_output())){\n                    throw new Exception(\"参数格式异常\");\n                }\n            }\n            etlTaskUnstructureLogInfo = MapStructMapper.INSTANCE.etlTaskUnstructureInfoToEtlTaskUnstructureLogInfo(etlTaskUnstructureInfo);\n            //BeanUtils.copyProperties(etlTaskUnstructureLogInfo, etlTaskUnstructureInfo);\n            etlTaskUnstructureLogInfo.setId(SnowflakeIdWorker.getInstance().nextId()+\"\");\n            etlTaskUnstructureLogInfo.setUnstructure_id(etlTaskUnstructureInfo.getId());\n            etlTaskUnstructureLogInfo.setCreate_time(new Timestamp(System.currentTimeMillis()));\n            etlTaskUnstructureLogInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n            etlTaskUnstructureLogInfo.setIs_delete(Const.NOT_DELETE);\n            etlTaskUnstructureLogInfo.setOwner(owner);\n        } catch (Exception e) {\n            LogUtil.error(this.getClass(), e);\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n        try{\n            //获取元数据输出源\n            String data_sources_choose_jdbc_output=etlTaskUnstructureInfo.getData_sources_choose_jdbc_output();\n            String data_sources_choose_file_output=etlTaskUnstructureInfo.getData_sources_choose_file_output();\n\n            DataSourcesInfo dataSourcesInfo = dataSourcesMapper.selectByPrimaryKey(data_sources_choose_jdbc_output);\n            DataSourcesInfo fileDataSourcesInfo =  dataSourcesMapper.selectByPrimaryKey(data_sources_choose_file_output);\n\n            List<String> etl_sqls=new ArrayList<>();\n            if (files != null && files.length > 0) {\n                for (MultipartFile jar_file : files) {\n                    String fileName = MultipartFileUtil.getFileName(jar_file);\n                    if(fileName==null||fileName.trim().equalsIgnoreCase(\"\")){\n                        continue;\n                    }\n                    System.out.println(\"上传文件不为空:\"+fileName);\n                    JarFileInfo jarFileInfo = new JarFileInfo();\n                    jarFileInfo.setId(SnowflakeIdWorker.getInstance().nextId() + \"\");\n                    jarFileInfo.setJar_etl_id(id);\n                    jarFileInfo.setFile_name(fileName);\n                    jarFileInfo.setCreate_time(DateUtil.formatTime(new Timestamp(System.currentTimeMillis())));\n                    jarFileInfo.setOwner(owner);\n                    etlTaskUnstructureInfo.setInput_path(fileName);\n                    ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n\n                    File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                    File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                    if (!fileDir.exists()) {\n                        fileDir.mkdirs();\n                    }\n                    try {\n                        FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                        Dsi_Info dsiInfo=new Dsi_Info();\n                        dsiInfo.setData_source_context(fileDataSourcesInfo.getData_source_context());\n                        dsiInfo.setId(fileDataSourcesInfo.getId());\n                        dsiInfo.setData_source_type(fileDataSourcesInfo.getData_source_type());\n                        dsiInfo.setDriver(fileDataSourcesInfo.getDriver());\n                        dsiInfo.setUrl(fileDataSourcesInfo.getUrl());\n                        dsiInfo.setUser(fileDataSourcesInfo.getUsername());\n                        dsiInfo.setPassword(fileDataSourcesInfo.getPassword());\n                        if(fileDataSourcesInfo.getData_source_type().equalsIgnoreCase(\"sftp\")){\n                            InputStream is = new FileInputStream(tempFile);\n                            JobCommon2.writeSftp(dsiInfo, etlTaskUnstructureInfo, IOUtils.toByteArray(is));\n                        }\n                        if(fileDataSourcesInfo.getData_source_type().equalsIgnoreCase(\"ftp\")){\n                            InputStream is = new FileInputStream(tempFile);\n                            JobCommon2.writeFtp(dsiInfo, etlTaskUnstructureInfo, IOUtils.toByteArray(is));\n                        }\n                        if(fileDataSourcesInfo.getData_source_type().equalsIgnoreCase(\"hdfs\")){\n                            InputStream is = new FileInputStream(tempFile);\n                            JobCommon2.writeHdfs(dsiInfo, etlTaskUnstructureInfo, IOUtils.toByteArray(is));\n                        }\n\n                    } catch (IOException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    } catch (SftpException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }\n\n                    //解析etl模板,目前先支持当前时间\n                    TaskLogInstance tli=new TaskLogInstance();\n                    tli.setCur_time(new Timestamp(System.currentTimeMillis()));\n                    tli.setOwner(getOwner());\n                    etl_sqls = JobCommon2.getUnstructureEtlSql(tli, etlTaskUnstructureInfo);\n\n                }\n            }\n            //入库\n            String[] result = new DBUtil().CUD(dataSourcesInfo.getDriver(), dataSourcesInfo.getUrl(), dataSourcesInfo.getUsername(), dataSourcesInfo.getPassword(),\n                    etl_sqls.toArray(new String[]{}));\n\n            String msg = \"目前支持以下参数,zdh_user:当前执行人,zdh_create_time:任务生成时间,zdh_date_time:调度ETL基准时间,file_name:上传文件名,file_path:文件写入路径\";\n\n            etlTaskUnstructureLogInfo.setMsg(msg+Const.LINE_SEPARATOR+StringUtils.join(etl_sqls,';'));\n            if(result[0].equalsIgnoreCase(\"false\")){\n                etlTaskUnstructureLogInfo.setStatus(Const.FALSE);\n                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n                etlTaskUnstructureLogMapper.insertSelective(etlTaskUnstructureLogInfo);\n                return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", result[1]);\n            }\n            etlTaskUnstructureLogInfo.setStatus(Const.TRUR);\n            etlTaskUnstructureLogMapper.insertSelective(etlTaskUnstructureLogInfo);\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),\"新增成功\", null);\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            etlTaskUnstructureLogInfo.setStatus(Const.FALSE);\n            etlTaskUnstructureLogInfo.setMsg(e.getMessage());\n            etlTaskUnstructureLogMapper.insertSelective(etlTaskUnstructureLogInfo);\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n    }",
        "idx": "322"
    },
    {
        "target_file_name": "AliMessagePush.java",
        "target_method": "src/main/java/com/zyc/zdh/push/impl/AliMessagePush.java#send",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultAcsClient",
            "DefaultProfile.getProfile",
            "SendSmsRequest",
            "getAcsResponse",
            "setOutId",
            "setPhoneNumbers",
            "setSignName",
            "setTemplateCode",
            "setTemplateParam"
        ],
        "target_code": "@Override\n    public Object send(MessageParam messageParam) throws Exception {\n        AliMessageParam aliMessageParam = (AliMessageParam)messageParam;\n        DefaultProfile profile = DefaultProfile.getProfile(aliMessageParam.getReginId(), aliMessageParam.getAk(),aliMessageParam.getSk());\n        IAcsClient client = new DefaultAcsClient(profile);\n\n        // 创建API请求并设置参数\n        SendSmsRequest request = new SendSmsRequest();\n        request.setPhoneNumbers(aliMessageParam.getPhoneNumbers());\n        request.setSignName(aliMessageParam.getSignName());\n        request.setTemplateCode(aliMessageParam.getTemplateCode());\n        request.setTemplateParam(aliMessageParam.getTemplateParam());\n        request.setOutId(aliMessageParam.getOutId());\n        try {\n            SendSmsResponse response = client.getAcsResponse(request);\n\n            return response;\n        } catch (ServerException e) {\n            e.printStackTrace();\n            throw e;\n        } catch (ClientException e) {\n            // 打印错误码\n//            System.out.println(\"ErrCode:\" + e.getErrCode());\n//            System.out.println(\"ErrMsg:\" + e.getErrMsg());\n//            System.out.println(\"RequestId:\" + e.getRequestId());\n            throw e;\n        }\n    }",
        "idx": "323"
    },
    {
        "target_file_name": "ZdhSshController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhSshController.java#etl_task_ssh_add",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileCopyUtils.copy",
            "FileInputStream",
            "Files.newOutputStream",
            "SFTPUtil",
            "mkdirs",
            "upload"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_ssh_add\", blockHandler = \"handleReturn\")\n    @RequestMapping(value=\"/etl_task_ssh_add\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo etl_task_ssh_add(SshTaskInfo sshTaskInfo,MultipartFile[] jar_files) {\n        try{\n            String owner = getOwner();\n            sshTaskInfo.setOwner(owner);\n            String id=SnowflakeIdWorker.getInstance().nextId() + \"\";\n            sshTaskInfo.setId(id);\n            sshTaskInfo.setCreate_time(new Timestamp(System.currentTimeMillis()));\n            sshTaskInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n            sshTaskInfo.setIs_delete(Const.NOT_DELETE);\n\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, sshTaskInfo.getProduct_code(), sshTaskInfo.getDim_group(), getAttrAdd());\n\n            sshTaskMapper.insertSelective(sshTaskInfo);\n\n\n            if (sshTaskInfo.getUpdate_context() != null && !sshTaskInfo.getUpdate_context().equals(\"\")) {\n                //插入更新日志表\n                EtlTaskUpdateLogs etlTaskUpdateLogs = new EtlTaskUpdateLogs();\n                etlTaskUpdateLogs.setId(sshTaskInfo.getId());\n                etlTaskUpdateLogs.setUpdate_context(sshTaskInfo.getUpdate_context());\n                etlTaskUpdateLogs.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                etlTaskUpdateLogs.setOwner(owner);\n                etlTaskUpdateLogsMapper.insertSelective(etlTaskUpdateLogs);\n            }\n\n            if (jar_files != null && jar_files.length > 0) {\n                for (MultipartFile jar_file : jar_files) {\n                    String fileName = MultipartFileUtil.getFileName(jar_file);\n                    if(fileName==null||fileName.trim().equalsIgnoreCase(\"\")){\n                        continue;\n                    }\n                    System.out.println(\"上传文件不为空:\"+fileName);\n                    JarFileInfo jarFileInfo = new JarFileInfo();\n                    jarFileInfo.setId(SnowflakeIdWorker.getInstance().nextId() + \"\");\n                    jarFileInfo.setJar_etl_id(id);\n                    jarFileInfo.setFile_name(fileName);\n                    jarFileInfo.setCreate_time(DateUtil.formatTime(new Timestamp(System.currentTimeMillis())));\n                    jarFileInfo.setOwner(owner);\n                    jarFileMapper.insertSelective(jarFileInfo);\n\n                    ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n                    File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                    File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                    if (!fileDir.exists()) {\n                        fileDir.mkdirs();\n                    }\n                    String nginx_dir = zdhNginx.getNginx_dir();\n                    try {\n                        FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                        if (!zdhNginx.getHost().equals(\"\")) {\n                            System.out.println(\"通过sftp上传文件\");\n                            SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                                    zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                            sftp.login();\n                            InputStream is = new FileInputStream(tempFile);\n                            sftp.upload(nginx_dir + \"/\" + owner + \"/\", fileName, is);\n                            sftp.logout();\n                        }\n                        jarFileInfo.setStatus(\"success\");\n                        jarFileMapper.updateByPrimaryKeySelective(jarFileInfo);\n                    } catch (IOException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    } catch (SftpException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }\n                }\n            }\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),\"新增成功\", null);\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n    }",
        "idx": "324"
    },
    {
        "target_file_name": "ZdhSshController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhSshController.java#sql_task_update",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileCopyUtils.copy",
            "Files.newOutputStream",
            "SFTPUtil",
            "mkdirs",
            "upload"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_ssh_update\", blockHandler = \"handleReturn\")\n    @RequestMapping(value = \"/etl_task_ssh_update\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo sql_task_update(SshTaskInfo sshTaskInfo,MultipartFile[] jar_files) {\n        try{\n            String owner = getOwner();\n            sshTaskInfo.setOwner(owner);\n            sshTaskInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n            sshTaskInfo.setIs_delete(Const.NOT_DELETE);\n\n            String id=sshTaskInfo.getId();\n\n            SshTaskInfo oldSshTaskInfo = sshTaskMapper.selectByPrimaryKey(sshTaskInfo.getId());\n\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, sshTaskInfo.getProduct_code(), sshTaskInfo.getDim_group(), getAttrEdit());\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, oldSshTaskInfo.getProduct_code(), oldSshTaskInfo.getDim_group(), getAttrEdit());\n\n            sshTaskMapper.updateByPrimaryKeySelective(sshTaskInfo);\n\n\n\n            if (sshTaskInfo.getUpdate_context() != null && !sshTaskInfo.getUpdate_context().equals(\"\")\n                    && !sshTaskInfo.getUpdate_context().equals(oldSshTaskInfo.getUpdate_context())) {\n                //插入更新日志表\n                EtlTaskUpdateLogs etlTaskUpdateLogs = new EtlTaskUpdateLogs();\n                etlTaskUpdateLogs.setId(sshTaskInfo.getId());\n                etlTaskUpdateLogs.setUpdate_context(sshTaskInfo.getUpdate_context());\n                etlTaskUpdateLogs.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                etlTaskUpdateLogs.setOwner(owner);\n                etlTaskUpdateLogsMapper.insertSelective(etlTaskUpdateLogs);\n            }\n\n            if (jar_files != null && jar_files.length > 0) {\n                for (MultipartFile jar_file : jar_files) {\n                    String fileName = MultipartFileUtil.getFileName(jar_file);\n                    if(fileName == null || fileName.isEmpty()){\n                        System.out.println(\"上传文件名称为空\"+fileName);\n                        continue;\n                    }\n                    System.out.println(\"上传文件不为空\"+fileName);\n                    JarFileInfo jarFileInfo = new JarFileInfo();\n                    jarFileInfo.setId(SnowflakeIdWorker.getInstance().nextId() + \"\");\n                    jarFileInfo.setJar_etl_id(id);\n                    jarFileInfo.setFile_name(fileName);\n                    jarFileInfo.setCreate_time(DateUtil.formatTime(new Timestamp(System.currentTimeMillis())));\n                    jarFileInfo.setOwner(owner);\n                    jarFileMapper.insertSelective(jarFileInfo);\n\n                    ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n                    File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                    File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                    if (!fileDir.exists()) {\n                        fileDir.mkdirs();\n                    }\n                    System.out.println(\"==================\"+tempFile.getAbsolutePath());\n                    String nginx_dir = zdhNginx.getNginx_dir();\n                    try {\n                        FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                        if (!zdhNginx.getHost().equals(\"\")) {\n                            System.out.println(\"通过sftp上传文件\");\n                            SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                                    zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                            sftp.login();\n                            InputStream is = new FileInputStream(tempFile);\n                            sftp.upload(nginx_dir + \"/\" + owner + \"/\", fileName, is);\n                            sftp.logout();\n                        }\n                        jarFileInfo.setStatus(\"success\");\n                        jarFileMapper.updateByPrimaryKeySelective(jarFileInfo);\n                    } catch (IOException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    } catch (SftpException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }\n                }\n            }\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),\"更新成功\", null);\n\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"更新失败\", e);\n        }\n    }",
        "idx": "325"
    },
    {
        "target_file_name": "CrowdFileController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/digitalmarket/CrowdFileController.java#crowd_file_add",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "File.createTempFile",
            "FileCopyUtils.copy",
            "Files.newOutputStream",
            "MinioClient",
            "MinioUtil.putObject",
            "SFTPUtil"
        ],
        "target_code": "@SentinelResource(value = \"crowd_file_add\", blockHandler = \"handleReturn\")\n    @RequestMapping(value = \"/crowd_file_add\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo crowd_file_add(CrowdFileInfo crowdFile, MultipartFile[] jar_files) {\n        try {\n\n            crowdFile.setOwner(getOwner());\n            crowdFile.setIs_delete(Const.NOT_DELETE);\n            crowdFile.setCreate_time(new Timestamp(System.currentTimeMillis()));\n            crowdFile.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, crowdFile.getProduct_code(), crowdFile.getDim_group(), getAttrAdd());\n\n            //校验文件名称是否已经存在\n            Example example=new Example(CrowdFileInfo.class);\n            Example.Criteria criteria=example.createCriteria();\n            criteria.andEqualTo(\"is_delete\", Const.NOT_DELETE);\n            criteria.andEqualTo(\"file_name\", crowdFile.getFile_name());\n            int count = crowdFileMapper.selectCountByExample(example);\n            if(count > 0){\n                return ReturnInfo.build(RETURN_CODE.FAIL.getCode(), \"文件名重复\", \"文件名重复\");\n            }\n\n            if (jar_files != null && jar_files.length > 0) {\n                for (MultipartFile jar_file : jar_files) {\n                    String fileName = MultipartFileUtil.getFileName(jar_file);\n                    if(fileName==null||fileName.trim().equalsIgnoreCase(\"\")){\n                        continue;\n                    }\n\n                    int lastIndex = fileName.lastIndexOf(\".\");\n                    if(lastIndex>0){\n                        String fileExtension = fileName.substring(lastIndex + 1);\n                        if(!crowdFile.getFile_name().endsWith(\".\"+fileExtension)){\n                            throw new Exception(\"特殊类型文件,文件名称必须以上传的文件类型后缀结尾,比如 xxx.xlsx\");\n                        }\n                    }\n\n                    crowdFile.setFile_url(fileName);\n                    File tempFile = File.createTempFile(\"crowd_file-temp-\", null);\n\n                    String crowdFileName = crowdFile.getFile_name();\n                    try {\n\n                        String store = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_STORE_TYPE, \"local\");//env.getProperty(\"digitalmarket.store.type\",\"local\");\n                        String host = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_HOST, \"\");//env.getProperty(\"digitalmarket.sftp.host\",\"\");\n                        String port = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_PORT, \"22\");//env.getProperty(\"digitalmarket.sftp.port\",\"22\");\n                        String username = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_USERNAME, \"\");//env.getProperty(\"digitalmarket.sftp.username\",\"\");\n                        String password = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_PASSWORD, \"\");//env.getProperty(\"digitalmarket.sftp.password\",\"\");\n                        String localPath = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_LOCAL_PATH, \"/home/data/file\");//env.getProperty(\"digitalmarket.local.path\",\"/home/data/file\");\n                        String stppath = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_PATH, \"\");//env.getProperty(\"digitalmarket.sftp.path\",\"\");\n                        String path = localPath+\"/crowd_file\";\n\n                        if(store.equalsIgnoreCase(\"local\")){\n                            //本地目录\n                            File fileDir = new File(path);\n                            if (!fileDir.exists()) {\n                                fileDir.mkdirs();\n                            }\n                            File localFile = new File( path + \"/\" +crowdFileName);\n                            LogUtil.info(this.getClass(), \"crowd file upload store type: {}, path: {}\", store, localFile.getAbsolutePath());\n                            FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(localFile.toPath()));\n\n                        }else if(store.equalsIgnoreCase(\"sftp\")){\n                            LogUtil.info(this.getClass(), \"crowd file upload store type: {}, path: {}\", store, path + \"/\" + crowdFileName);\n\n                            FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                            //sftp\n                            SFTPUtil sftp = new SFTPUtil(username, password,\n                                    host, new Integer(port));\n                            sftp.login();\n                            InputStream is = new FileInputStream(tempFile);\n                            sftp.upload(stppath+\"/crowd_file\", fileName, is);\n                            sftp.logout();\n                        }else if(store.equalsIgnoreCase(\"minio\")){\n                            LogUtil.info(this.getClass(), \"crowd file upload store type: {}, path: {}\", store, path + \"/\" + crowdFile.getFile_name());\n                            String object_name = path+\"/\"+crowdFile.getFile_name();\n                            String ak = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_AK);//env.getProperty(\"digitalmarket.minio.ak\");\n                            String sk = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_SK);//env.getProperty(\"digitalmarket.minio.sk\");\n                            String endpoint = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_ENDPOINT);//env.getProperty(\"digitalmarket.minio.endpoint\");\n                            String region = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_REGION);//env.getProperty(\"digitalmarket.minio.region\");\n                            String bucket = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_BUCKET);//env.getProperty(\"digitalmarket.minio.bucket\");\n                            MinioClient minioClient = MinioUtil.buildMinioClient(ak, sk, endpoint);\n                            MinioUtil.putObject(minioClient, bucket, region, \"application/octet-stream\", object_name, jar_file.getInputStream(), null);\n                        }\n\n                        crowdFileMapper.insertSelective(crowdFile);\n                    } catch (Exception e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }finally {\n                        if (tempFile.exists()) {\n                            tempFile.delete();\n                        }\n                    }\n                }\n            }\n\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(), \"新增成功\", null);\n        } catch (Exception e) {\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(), \"新增失败\", e);\n        }\n    }",
        "idx": "326"
    },
    {
        "target_file_name": "JobCommon2.java",
        "target_method": "src/main/java/com/zyc/zdh/job/JobCommon2.java#ssh_exec",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SSHUtil",
            "exec"
        ],
        "target_code": "public static boolean ssh_exec(TaskLogInstance tli, ZdhSshInfo zdhSshInfo) throws IOException, JSchException, SftpException {\n        try {\n            String system = System.getProperty(\"os.name\");\n            long t1 = System.currentTimeMillis();\n            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,当前系统为:\" + system + \",请耐心等待SSH任务开始执行....\");\n            String host = zdhSshInfo.getSshTaskInfo().getHost();\n            String port = zdhSshInfo.getSshTaskInfo().getPort();\n            String username = zdhSshInfo.getSshTaskInfo().getUser_name();\n            String password = zdhSshInfo.getSshTaskInfo().getPassword();\n            String ssh_cmd = zdhSshInfo.getSshTaskInfo().getSsh_cmd();\n            String id = zdhSshInfo.getSshTaskInfo().getId();\n            String t_id = zdhSshInfo.getTask_logs_id();\n            String script_path = zdhSshInfo.getSshTaskInfo().getSsh_script_path();\n            String script_context = zdhSshInfo.getSshTaskInfo().getSsh_script_context();\n            List<JarFileInfo> jarFileInfos = zdhSshInfo.getJarFileInfos();\n            ZdhNginx zdhNginx = zdhSshInfo.getZdhNginx();\n            insertLog(tli, \"DEBUG\", \"设置免密登录,请在密码中填写私钥地址,且以privateKey:开头, privateKey:/home/root/.ssh/id_rsa\");\n            if (!org.apache.commons.lang3.StringUtils.isEmpty(script_context) || (jarFileInfos != null && !jarFileInfos.isEmpty())) {\n                SFTPUtil sftpUtil = new SFTPUtil(username, password, host, Integer.parseInt(port));\n                sftpUtil.login();\n                if (!script_context.isEmpty()) {\n                    insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,发现在线脚本,使用在线脚本ssh 命令 可配合{{zdh_online_file}} 使用 example sh {{zdh_online_file}} 即是执行在线的脚本\");\n                    InputStream inputStream = new ByteArrayInputStream(script_context.replaceAll(\"\\r\\n\", \"\\n\").getBytes());\n                    sftpUtil.upload(script_path, t_id + \"_online\", inputStream);\n                }\n\n                if (!jarFileInfos.isEmpty()) {\n                    for (JarFileInfo jarFileInfo : jarFileInfos) {\n                        //下载文件\n                        if (zdhNginx.getHost() != null && !zdhNginx.getHost().equals(\"\")) {\n                            LogUtil.info(JobCommon2.class, \"开始下载文件:SFTP方式\" + jarFileInfo.getFile_name());\n                            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,开始下载文件:SFTP方式\" + jarFileInfo.getFile_name());\n                            //连接sftp 下载\n                            SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                                    zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                            sftp.login();\n                            byte[] fileByte = sftp.download(zdhNginx.getNginx_dir() + \"/\" + zdhNginx.getOwner(), jarFileInfo.getFile_name());\n                            sftpUtil.upload(script_path, jarFileInfo.getFile_name(), fileByte);\n                            sftp.logout();\n                        } else {\n                            LogUtil.info(JobCommon2.class, \"开始下载文件:本地方式\" + jarFileInfo.getFile_name());\n                            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,开始下载文件:本地方式\" + jarFileInfo.getFile_name());\n                            //本地文件\n\n                            FileInputStream in = null;\n                            try {\n                                in = new FileInputStream(zdhNginx.getTmp_dir() + \"/\" + zdhNginx.getOwner() + \"/\" + jarFileInfo.getFile_name());\n                                ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n                                //System.out.println(\"bytes available:\" + in.available());\n                                byte[] temp = new byte[1024];\n                                int size = 0;\n                                while ((size = in.read(temp)) != -1) {\n                                    out.write(temp, 0, size);\n                                }\n                                //byte[] bytes = out.toByteArray();\n                                //System.out.println(\"bytes size got is:\" + bytes.length);\n                                sftpUtil.upload(script_path, jarFileInfo.getFile_name(), in);\n\n                            } catch (Exception e) {\n                                LogUtil.error(JobCommon2.class, e);\n                                throw e;\n                            } finally {\n                                if (in != null) {\n                                    in.close();\n                                }\n                            }\n\n                        }\n                    }\n                }\n\n                sftpUtil.logout();\n            }\n\n            SSHUtil sshUtil = new SSHUtil(username, password, host, Integer.parseInt(port));\n            sshUtil.login();\n            chm_ssh.put(tli.getId(), sshUtil);\n            ssh_cmd = \"echo task_id=\" + tli.getId() + \" && \" + ssh_cmd;\n            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,使用在线脚本,\" + ssh_cmd);\n            String[] result = sshUtil.exec(ssh_cmd, tli.getId(), tli.getJob_id());\n            String error = result[0];\n            String out = result[1];\n            if (chm_ssh.get(tli.getId()) != null) {\n                chm_ssh.get(tli.getId()).logout();\n            }\n            chm_ssh.remove(tli.getId());\n            long t2 = System.currentTimeMillis();\n\n            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,SSH任务执行结束,耗时:\" + (t2 - t1) / 1000 + \"s\");\n\n            if (!error.isEmpty()) {\n                return false;\n            }\n            return true;\n\n        } catch (Exception e) {\n            LogUtil.error(JobCommon2.class, e);\n            throw e;\n        }\n\n    }",
        "idx": "327"
    },
    {
        "target_file_name": "JobCommon2.java",
        "target_method": "src/main/java/com/zyc/zdh/job/JobCommon2.java#datax_auto_exec",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "CommandUtils.exeCommand2",
            "FileUtils.forceMkdirParent",
            "FileUtils.write"
        ],
        "target_code": "public static boolean datax_auto_exec(TaskLogInstance tli, ZdhDataxAutoInfo zdhDataxAutoInfo) throws Exception {\n        try {\n            String system = System.getProperty(\"os.name\");\n            long t1 = System.currentTimeMillis();\n            insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,使用datax 服务,建议在datax 数据源中配置驱动格式: python_home/bin/python datax_home, 通过单个空格分割\");\n            insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,当前系统为:\" + system + \",请耐心等待DATAX任务开始执行....\");\n\n            DataxReader reader = generator_reader(zdhDataxAutoInfo);\n            DataxWriter writer = generator_writer(zdhDataxAutoInfo);\n            Content content=new Content();\n            content.setReader(reader);\n            content.setWriter(writer);\n\n            Map<String, Object> jsonObject=JsonUtil.toJavaMap(zdhDataxAutoInfo.getEtlTaskDataxAutoInfo().getData_sources_params_input());\n            DataxConfig dataxConfig=DataxConfig.build(Lists.newArrayList(content), jsonObject,jsonObject);\n\n            LogUtil.info(JobCommon2.class, JsonUtil.formatJsonString(dataxConfig));\n\n            String t_id = zdhDataxAutoInfo.getTask_logs_id();\n            String python_home=zdhDataxAutoInfo.getPython_home();\n            String datax_home=zdhDataxAutoInfo.getDatax_home();\n            String script_path = datax_home+\"/zdh_datax\";\n            String script_context = JsonUtil.formatJsonString(dataxConfig);\n            String file_name = script_path + \"/\" + t_id + \"_online\";\n            //校验是否本地datax\n            if (StringUtils.isEmpty(\"\")) {\n                //本地直接生成文件\n                insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,本地执行\");\n                FileUtils.forceMkdirParent(new File(file_name));\n                FileUtils.write(new File(file_name), script_context, Charset.defaultCharset().name(), false);\n                String newcommand = python_home + \" \" + datax_home + \"/bin/datax.py \" + file_name;\n                insertLog(tli, \"DEBUG\", script_context);\n                insertLog(tli, \"DEBUG\", newcommand);\n                Map result = new HashMap<String, String>();\n                insertLog(tli, \"DEBUG\", \"系统编码:\" + Charset.defaultCharset().name());\n                if (system.toLowerCase().startsWith(\"win\")) {\n                    result = CommandUtils.exeCommand2(tli, \"cmd.exe\", \"/c\", newcommand, Charset.defaultCharset().name());\n                } else {\n                    result = CommandUtils.exeCommand2(tli, \"sh\", \"-c\", newcommand, Charset.defaultCharset().name());\n                }\n                long t2 = System.currentTimeMillis();\n                insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,DATAX任务执行结束,耗时:\" + (t2 - t1) / 1000 + \"s\");\n                if (result.get(\"result\").equals(\"success\")) {\n                    return true;\n                }\n                return false;\n            }\n\n            return false;\n\n        } catch (Exception e) {\n            LogUtil.error(JobCommon2.class, e);\n            throw e;\n        }\n\n    }",
        "idx": "328"
    },
    {
        "target_file_name": "EmailJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/EmailJob.java#taskLogInstanceAlarm",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SpringContext.getBean",
            "TaskLogInstanceMapper.selectByStatus",
            "TaskLogInstanceMapper.selectNoNoticeFinish",
            "TaskLogInstanceMapper.selectOverTime",
            "TaskLogInstanceMapper.selectOverTimeFinish",
            "alarm"
        ],
        "target_code": "public static void taskLogInstanceAlarm(){\n        try{\n            LogUtil.debug(EmailJob.class, \"开始检测ETL失败任务...\");\n            TaskLogInstanceMapper taskLogInstanceMapper = (TaskLogInstanceMapper) SpringContext.getBean(\"taskLogInstanceMapper\");\n\n            //获取失败的任务\n            List<TaskLogInstance> tlis=taskLogInstanceMapper.selectByStatus(JobStatus.ERROR.getValue());\n            String line = Const.LINE_SEPARATOR;\n            //根据任务执行时间，主键 获取对应的日志信息\n            for(TaskLogInstance tli:tlis){\n\n                LogUtil.info(EmailJob.class, \"检测失败任务:\" + tli.getJob_id() + \",对应主键:\" + tli.getId() + \",对应任务组id:\" + tli.getGroup_id());\n\n                String msg=\"【失败告警】任务:\"+tli.getEtl_context()+\"\\r\\n\" +\n                        \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                        \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                        \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                        \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                        \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                        \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                        \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                        \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                        \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                alarm(tli, \"【失败告警】: \"+tli.getJob_context(),msg, MSG_TYPE_ALARM);\n                LogUtil.info(EmailJob.class, \"检测失败任务:\" + tli.getJob_id() + \",对应主键:\" + tli.getId() + \",并完成更新\");\n            }\n\n            //获取超时任务\n            List<TaskLogInstance> taskLogInstances= taskLogInstanceMapper.selectOverTime();\n            if(taskLogInstances!=null && taskLogInstances.size()>0){\n                //System.out.println(\"超时任务量:\"+taskLogInstances.size());\n                for(TaskLogInstance tli : taskLogInstances){\n                    String msg=\"【超时告警】任务:\\r\\n\" +\n                            \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                            \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                            \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                            \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                            \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                            \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                            \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                            \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                            \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                    if (tli.getJob_type().equalsIgnoreCase(ShellJob.jobType)){\n                        //msg = msg +\"\\r\\nSHELL任务超时自动杀死\";\n                        //ZdhMonitorController zdhmc = (ZdhMonitorController) SpringContext.getBean(\"zdhMonitorController\");\n                        //zdhmc.killJob(tli.getId());\n\n                    }\n                    alarm(tli, \"【超时告警】: \"+tli.getJob_context(),msg, MSG_TYPE_ALARM);\n                }\n            }\n\n            //超时,但之后完成任务\n            List<TaskLogInstance> taskLogInstances2= taskLogInstanceMapper.selectOverTimeFinish();\n            if(taskLogInstances2!=null && taskLogInstances2.size()>0){\n                for(TaskLogInstance tli : taskLogInstances2){\n                    String msg=\"【超时后完成通知】任务:\"+tli.getEtl_context()+\"\\r\\n\" +\n                            \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                            \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                            \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                            \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                            \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                            \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                            \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                            \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                            \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                    alarm(tli, \"【超时后完成通知】: \"+tli.getJob_context(),msg, MSG_TYPE_NOTICE);\n                }\n            }\n\n            //正常完成任务后通知\n            List<TaskLogInstance> taskLogInstances3= taskLogInstanceMapper.selectNoNoticeFinish();\n            if(taskLogInstances3!=null && taskLogInstances3.size()>0){\n                for(TaskLogInstance tli : taskLogInstances3){\n\n                    String msg= \"【完成通知】任务:\"+tli.getEtl_context()+\"\\r\\n\" +\n                            \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                            \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                            \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                            \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                            \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                            \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                            \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                            \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                            \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                    alarm(tli, \"【完成通知】: \"+tli.getJob_context(),msg, MSG_TYPE_NOTICE);\n                }\n            }\n\n        }catch (Exception e){\n            LogUtil.error(EmailJob.class, e);\n        }\n\n    }",
        "idx": "329"
    },
    {
        "target_file_name": "EmailJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/EmailJob.java#alarm",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SpringContext.getBean",
            "insertSelective",
            "sendEmail"
        ],
        "target_code": "public static void alarm(QuartzJobInfo qji, String title, String msg){\n        try{\n            JemailService jemailService= (JemailService) SpringContext.getBean(\"jemailServiceImpl\");\n            AccountService accountService=(AccountService) SpringContext.getBean(\"accountService\");\n            NoticeMapper noticeMapper = (NoticeMapper) SpringContext.getBean(\"noticeMapper\");\n            if(StringUtils.isEmpty(qji.getAlarm_account())){\n                LogUtil.warn(EmailJob.class, \"当前告警为找到告警账号:\" + JsonUtil.formatJsonString(qji));\n                return ;\n            }\n            List<User> users=accountService.findByUserName2(qji.getAlarm_account().split(\",\"));\n            List<String> emails=new ArrayList<>();\n            List<String> phones=new ArrayList<>();\n            for(User user:users){\n                if(user.getEmail()!=null){\n                    //System.out.println(\"email:\"+user.getEmail());\n                    emails.add(user.getEmail());\n                }\n                if(user.getPhone()!=null){\n                    phones.add(user.getPhone());\n                }\n            }\n\n            if(emails.size()>0 && qji.getAlarm_email()!=null  && qji.getAlarm_email().equalsIgnoreCase(Const.ON)){\n                jemailService.sendEmail(emails.toArray(new String[0]),title,msg);\n            }\n            if(phones.size()>0&& qji.getAlarm_sms()!=null && qji.getAlarm_sms().equalsIgnoreCase(Const.ON)){\n                LogUtil.info(EmailJob.class, \"手机短信监控,暂时未开通,需要连接第三方短信服务\");\n                try{\n                    //此处信息写入短信表,待平台接入短信服务\n                    AlarmSmsMapper alarmSmsMapper=  (AlarmSmsMapper) SpringContext.getBean(\"alarmSmsMapper\");\n                    AlarmSmsInfo alarmSmsInfo=new AlarmSmsInfo();\n                    alarmSmsInfo.setTitle(title);\n                    alarmSmsInfo.setMsg(msg);\n                    alarmSmsInfo.setMsg_url(\"\");\n                    alarmSmsInfo.setMsg_type(\"通知\");\n                    alarmSmsInfo.setStatus(Const.SMS_INIT);\n                    alarmSmsInfo.setCreate_time(new Timestamp(System.currentTimeMillis()));\n                    alarmSmsInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                    for(String phone:phones){\n                        alarmSmsInfo.setPhone(phone);\n                        alarmSmsMapper.insertSelective(alarmSmsInfo);\n                    }\n                }catch (Exception e){\n                    LogUtil.error(EmailJob.class, \"发送告警短信失败\", e);\n                }\n\n            }\n\n            if( !StringUtils.isEmpty(qji.getAlarm_account()) && qji.getAlarm_zdh()!=null  && qji.getAlarm_zdh().equalsIgnoreCase(\"on\")){\n                for(User user:users){\n                    NoticeInfo ni=new NoticeInfo();\n                    ni.setMsg_type(\"通知\");\n                    ni.setMsg_title(title);\n                    ni.setMsg_url(\"\");\n                    ni.setMsg(msg);\n                    ni.setIs_see(Const.FALSE);\n                    ni.setOwner(user.getUserName());\n                    ni.setCreate_time(new Timestamp(System.currentTimeMillis()));\n                    ni.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                    noticeMapper.insertSelective(ni);\n                }\n            }\n        }catch (Exception e){\n            LogUtil.error(EmailJob.class, e);\n        }\n\n    }",
        "idx": "330"
    },
    {
        "target_file_name": "JobBeaconFire.java",
        "target_method": "src/main/java/com/zyc/zdh/job/JobBeaconFire.java#run",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "GroovyFactory.execExpress",
            "Jinjava",
            "SqlExecutor.query",
            "render"
        ],
        "target_code": "@Override\n        public void run() {\n            //执行具体的告警信息\n            Connection conn = null;\n            try{\n                DataSource ds = new SimpleDataSource(dataSourcesInfo.getUrl(), dataSourcesInfo.getUsername(),\n                        dataSourcesInfo.getPassword());\n                conn = ds.getConnection();\n                String sql = beaconFireInfo.getSql_script();\n                Map<String, Object> jinJavaParam = getJinJavaParam(cur_time);\n                Jinjava jinjava=new Jinjava();\n\n                String new_sql = jinjava.render(sql, jinJavaParam);\n                List<Entity> entityList = SqlExecutor.query(conn, new_sql, new EntityListHandler());\n                Map<String, Object> params = new HashMap<>();\n                params.put(\"rs\", entityList);\n                params.put(\"out\", new Out());\n                String groovy = beaconFireInfo.getGroovy_script();\n                Out out = (Out)GroovyFactory.execExpress(groovy, params);\n                //System.out.println(JsonUtil.formatJsonString(out));\n                if(out != null && out.code != \"0\"){\n                    String frequency = beaconFireInfo.getFrequency_config();\n                    Long time = 1800L;\n                    int time_num = 1;\n                    if(!StringUtils.isEmpty(frequency) && frequency.split(\",\").length == 2){\n                        time = Long.parseLong(frequency.split(\",\")[0]);\n                        time_num = Integer.parseInt(frequency.split(\",\")[1]);\n                    }\n\n                    BeaconFireAlarmMsgInfo beaconFireAlarmMsgInfo = new BeaconFireAlarmMsgInfo();\n                    beaconFireAlarmMsgInfo.setStatus(Const.STATUS_COMMON_INIT);\n                    //获取\n                    String alarm_key = \"beacon_fire_\"+beaconFireInfo.getId();\n                    if(redisUtil.exists(alarm_key)){\n                        String num = redisUtil.get(alarm_key,\"1\").toString();\n                        if(Integer.valueOf(num) >= time_num){\n                            beaconFireAlarmMsgInfo.setStatus(Const.STATUS_COMMON_FAIL);\n                        }\n                        Long expire = redisUtil.getRedisTemplate().getExpire(alarm_key, TimeUnit.SECONDS);\n                        redisUtil.set(alarm_key, String.valueOf(Integer.valueOf(num) + 1), expire, TimeUnit.SECONDS);\n                    }else{\n                        redisUtil.set(alarm_key, \"1\", time, TimeUnit.SECONDS);\n                    }\n                    //告警\n                    out.sqlScript = new_sql;\n                    out.message = beaconFireInfo.getBeacon_fire_context();\n                    out.setAlarmConfig(beaconFireAlarmGroupInfo.getAlarm_config());\n                    beaconFireAlarmMsgInfo.setDim_group(beaconFireInfo.getDim_group());\n                    beaconFireAlarmMsgInfo.setProduct_code(beaconFireInfo.getProduct_code());\n                    beaconFireAlarmMsgInfo.setOwner(beaconFireInfo.getOwner());\n                    beaconFireAlarmMsgInfo.setAlarm_msg(JsonUtil.formatJsonString(out));\n                    beaconFireAlarmMsgMapper.insertSelective(beaconFireAlarmMsgInfo);\n                }\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }",
        "idx": "331"
    },
    {
        "target_file_name": "ZdhEtlController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhEtlController.java#etl_task_add_file",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileCopyUtils.copy",
            "FileInputStream",
            "Files.newOutputStream",
            "SFTPUtil",
            "mkdirs",
            "upload"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_add_file\", blockHandler = \"handleReturn\")\n    @RequestMapping(value=\"/etl_task_add_file\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    public ReturnInfo etl_task_add_file(MultipartFile up_file, HttpServletRequest request) {\n        try{\n            String owner = getOwner();\n            if (up_file != null) {\n                String fileName = MultipartFileUtil.getFileName(up_file);\n                ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n                String localDir = zdhNginx.getTmp_dir() + \"/\" + owner;\n                LogUtil.info(this.getClass(), \"fileName: {}, fileDir: {}\", fileName, localDir);\n                File tempFile = new File(localDir + \"/\" + fileName);\n                File fileDir = new File(localDir);\n                if (!fileDir.exists()) {\n                    fileDir.mkdirs();\n                }\n                String nginx_dir = zdhNginx.getNginx_dir();\n\n                FileCopyUtils.copy(up_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                if (!StringUtils.isEmpty(zdhNginx.getHost())) {\n                    SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                            zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                    sftp.login();\n                    InputStream is = new FileInputStream(tempFile);\n                    sftp.upload(nginx_dir + \"/\" + owner + \"/\", fileName, is);\n                    sftp.logout();\n                }\n            }\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),RETURN_CODE.SUCCESS.getDesc(), null);\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),e.getMessage(), null);\n        }\n    }",
        "idx": "332"
    },
    {
        "target_file_name": "SetUpJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/SetUpJob.java#run",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SSHUtil",
            "exec2"
        ],
        "target_code": "public static void run(ServerTaskInstance sti) {\n\n        //第一步：登陆构建服务器\n        //第二步：拉取git\n        //第三步：执行构建命令\n        //第四步：scp 远程服务器\n        SSHUtil sshUtil=null;\n        String system = System.getProperty(\"os.name\");\n        if(system.toLowerCase().startsWith(\"win\")){\n            sshUtil=new SSHUtil(sti.getBuild_username(),sti.getBuild_privatekey(),sti.getBuild_ip(),22);\n        }else{\n            sshUtil=new SSHUtil(sti.getBuild_username(),sti.getBuild_ip(),22,sti.getBuild_privatekey());\n        }\n\n        List<String> cmd_list=new ArrayList<>();\n        cmd_list.add(\"echo command start\");\n        if(!StringUtils.isEmpty(sti.getGit_url())){\n            String cmd=\"git clone -b \"+sti.getBuild_branch() + \" \"+sti.getGit_url() +\" \"+sti.getBuild_path();\n            cmd_list.add(\"echo command: \"+cmd);\n            cmd_list.add(cmd);\n        }\n        if(!StringUtils.isEmpty(sti.getBuild_path())){\n            String cmd2=\"cd \"+sti.getBuild_path();\n            cmd_list.add(\"echo command: \"+cmd2);\n            cmd_list.add(cmd2);\n        }\n        if(!StringUtils.isEmpty(sti.getBuild_command())){\n            String cmd3=sti.getBuild_command();\n            cmd_list.add(\"echo \"+cmd3);\n            cmd_list.add(cmd3);\n\n        }\n        if(!StringUtils.isEmpty(sti.getRemote_path())){\n            String cmd4=\"script -q -c \\\"scp -r \"+sti.getBuild_path()+\"/release/* \"+sti.getBuild_username()+\"@\"+sti.getRemote_ip()+\":\"+sti.getRemote_path() +\"\\\"\";\n            cmd_list.add(\"echo command: \"+cmd4);\n            cmd_list.add(cmd4);\n        }\n        cmd_list.add(\"echo command finish\");\n        String cmd=org.apache.commons.lang.StringUtils.join(cmd_list,\";\");\n        try {\n            sshUtil.login();\n            //System.out.println(cmd);\n            String[] out=sshUtil.exec2(cmd,sti.getId(),sti.getTemplete_id());\n            //System.out.println(out[0]+\"==\"+out[1]);\n            sshUtil.logout();\n        } catch (IOException e) {\n            LogUtil.error(SetUpJob.class, e);\n             JobCommon2.insertLog(sti.getTemplete_id(),sti.getId(),\"INFO\",e.getMessage());\n             setStatus(sti.getId(),\"2\");\n        } catch (JSchException e) {\n            LogUtil.error(SetUpJob.class, e);\n             JobCommon2.insertLog(sti.getTemplete_id(),sti.getId(),\"INFO\",e.getMessage());\n             setStatus(sti.getId(),\"2\");\n        }\n\n    }",
        "idx": "333"
    },
    {
        "target_file_name": "SystemCommandLineRunner.java",
        "target_method": "src/main/java/com/zyc/zdh/run/SystemCommandLineRunner.java#killJobGroup",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Future.cancel",
            "HttpUtil.getRequest",
            "HttpUtil.postJSON",
            "Process.destroyForcibly",
            "SSHUtil.logout",
            "SshUtils.kill",
            "Thread.interrupt"
        ],
        "target_code": "public void killJobGroup(){\n        LogUtil.info(this.getClass(), \"初始化监控杀死任务\");\n        TaskGroupLogInstanceMapper taskGroupLogInstanceMapper = (TaskGroupLogInstanceMapper) SpringContext.getBean(\"taskGroupLogInstanceMapper\");\n        TaskLogInstanceMapper taskLogInstanceMapper = (TaskLogInstanceMapper) SpringContext.getBean(\"taskLogInstanceMapper\");\n        ZdhHaInfoMapper zdhHaInfoMapper = (ZdhHaInfoMapper) SpringContext.getBean(\"zdhHaInfoMapper\");\n        String myid = ConfigUtil.getValue(ConfigUtil.MYID, \"0\");\n\n        ZdhRunableTask zdhRunableTask=new ZdhRunableTask(\"schedule kill job task\", new Runnable() {\n            @Override\n            public void run() {\n                while(true){\n                    try {\n                        LogUtil.debug(this.getClass(), \"检查要杀死的任务组..\");\n                        List<TaskLogInstance> tlis=taskLogInstanceMapper.selectThreadByStatus(\"kill\");\n                        for(TaskLogInstance tl : tlis){\n\n                            if(tl.getThread_id()!=null && tl.getThread_id().startsWith(myid)){\n                                Future<?> future = JobCommon2.chm.get(tl.getId());\n                                if(future!=null){\n                                    String msg=\"杀死线程:线程id:\"+tl.getThread_id()+\",任务名:\"+tl.getJob_context()+\",任务实例id:\"+tl.getId();\n                                    LogUtil.info(this.getClass(), msg);\n                                    JobCommon2.insertLog(tl,\"INFO\",msg);\n                                    if(tl.getMore_task().equalsIgnoreCase(\"ssh\") || tl.getMore_task().equalsIgnoreCase(\"datax\") || tl.getJob_type().equalsIgnoreCase(\"flume\")){\n                                        SSHUtil sshUtil =JobCommon2.chm_ssh.get(tl.getId());\n                                        if(sshUtil!=null){\n                                            String[] connectUri= sshUtil.createUri();\n                                            sshUtil.logout();\n                                            JobCommon2.chm_ssh.get(tl.getId()).logout();\n                                            JobCommon2.chm_ssh.remove(tl.getId());\n                                            if(connectUri.length==2 && !StringUtils.isEmpty(connectUri[1])){\n                                                try{\n                                                    String kill_cmd=String.format(\"kill -9 `ps -ef |grep '%s' |awk -F \\\" \\\" '{print $2}'`\",connectUri[1]);\n                                                    JobCommon2.insertLog(tl,\"INFO\",kill_cmd);\n                                                    SshUtils.kill(connectUri[0],kill_cmd);\n                                                }catch (Exception e){\n                                                    LogUtil.error(this.getClass(), e);\n                                                }\n\n                                            }\n                                        }\n                                    }\n\n                                    try{\n                                        Process process = JobCommon2.chm_process.get(tl.getId());\n                                        if(process != null){\n                                            process.getInputStream().close();\n                                            process.destroyForcibly();\n                                        }\n                                        msg=\"杀死进程完成\";\n                                        LogUtil.info(this.getClass(), msg);\n                                    }catch (Exception e){\n                                        e.printStackTrace();\n                                        msg=\"杀死进程异常\";\n                                        LogUtil.error(this.getClass(), msg, e);\n                                        JobCommon2.insertLog(tl,\"ERROR\",msg);\n                                    }\n\n                                    try{\n                                        Thread thread = JobCommon2.chm_thread.get(tl.getId());\n                                        if(thread != null){\n                                            thread.interrupt();\n                                        }\n                                    }catch (Exception e){\n                                        e.printStackTrace();\n                                    }\n\n                                    try{\n                                        future.cancel(true);\n                                    }catch (Exception e){\n                                        LogUtil.error(this.getClass(), e);\n                                    }finally {\n                                        JobCommon2.chm.remove(tl.getId());\n                                        JobCommon2.chm_thread.remove(tl.getId());\n                                        JobCommon2.chm_process.remove(tl.getId());\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                        JobCommon2.insertLog(tl,\"INFO\",\"已杀死当前任务\");\n                                    }\n                                }else{\n                                    String msg=\"调度部分已经执行完成,ETL部分正在执行提交到后端的任务进行杀死\";\n                                    LogUtil.info(this.getClass(), msg);\n                                    JobCommon2.insertLog(tl,\"INFO\",msg);\n                                    List<NameValuePair> npl=new ArrayList<>();\n\n                                    //如果是flink任务,需要调用远程地址杀死\n                                    if(tl.getMore_task().equalsIgnoreCase(MoreTask.FLINK.getValue())){\n                                        //如果找不到flink_job_id,历史服务器,则跳过\n                                        if(StringUtils.isEmpty(tl.getApplication_id()) || StringUtils.isEmpty(tl.getHistory_server())){\n                                            if(System.currentTimeMillis()-tl.getUpdate_time().getTime() > 2*60*1000){\n                                                taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                            }\n                                            continue;\n                                        }\n\n                                        String cancel_url = tl.getHistory_server()+\"/jobs/\"+tl.getApplication_id()+\"/yarn-cancel\";\n                                        npl.add(new BasicNameValuePair(\"mode\",\"cancel\"));\n                                        JobCommon2.insertLog(tl,\"INFO\",\"杀死任务url: \"+cancel_url);\n                                        try{\n                                            String restul=HttpUtil.getRequest(cancel_url,npl);\n                                        }catch (Exception e){\n                                            JobCommon2.insertLog(tl,\"INFO\",\"杀死当前任务异常,判定服务已死亡,自动更新状态为killed\");\n                                            taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                            continue;\n                                        }\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                        JobCommon2.insertLog(tl,\"INFO\",\"已杀死当前任务\");\n                                        continue;\n                                    }else{\n\n                                    }\n\n                                    String executor=tl.getExecutor();//数据采集机器id\n                                    ZdhHaInfo zdhHaInfo=zdhHaInfoMapper.selectByPrimaryKey(executor);\n                                    String jobGroup=\"jobGroup\";\n                                    if(zdhHaInfo!=null){\n                                        String url=\"http://\"+zdhHaInfo.getZdh_host()+\":\"+zdhHaInfo.getWeb_port()+\"/api/v1/applications/\"+zdhHaInfo.getApplication_id()+\"/jobs\";\n                                        //获取杀死的任务名称\n                                        //System.out.println(url);\n                                        //npl.add(new BasicNameValuePair(\"status\",\"running\"));\n                                        String restul=\"\";\n                                        try{\n                                            restul=HttpUtil.getRequest(url,npl);\n                                        }catch (Exception e){\n                                            taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                            continue;\n                                        }\n\n                                        List<Map<String, Object>> jsonArray= JsonUtil.toJavaListMap(restul);\n                                        List<String> killJobs=new ArrayList<>();\n                                        for(Map<String, Object> jo:jsonArray){\n                                            if(jo.getOrDefault(jobGroup, \"\").toString().startsWith(tl.getId())){\n                                                killJobs.add(jo.getOrDefault(jobGroup, \"\").toString());\n                                            }\n                                        }\n\n                                        Map<String, Object> js=JsonUtil.createEmptyMap();\n                                        js.put(\"task_logs_id\",tl.getId());//写日志使用\n                                        js.put(\"jobGroups\",killJobs);\n                                        js.put(\"job_id\",tl.getJob_id());\n                                        //发送杀死请求\n                                        String kill_url=\"http://\"+zdhHaInfo.getZdh_host()+\":\"+zdhHaInfo.getZdh_port()+\"/api/v1/kill\";\n                                        HttpUtil.postJSON(kill_url, JsonUtil.formatJsonString(js));\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                    }else{\n                                        String msg2=\"无法获取具体执行器,判断任务已杀死\";\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                        LogUtil.info(this.getClass(), msg2);\n                                        JobCommon2.insertLog(tl,\"INFO\",msg2);\n                                    }\n\n                                }\n                            }\n                        }\n                        // List<QuartzJobInfo> quartzJobInfos = quartzJobMapper.select(qj);\n                        Thread.sleep(1000*2);\n                    } catch (Exception e) {\n                        LogUtil.error(this.getClass(), e);\n                    }\n                }\n            }\n        });\n        threadPool.submit(zdhRunableTask);\n    }",
        "idx": "334"
    },
    {
        "target_file_name": "CheckBloodSourceJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/CheckBloodSourceJob.java#Check",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DateUtil.getCurrentTime",
            "List.addAll",
            "LogUtil.error",
            "SpringContext.getBean",
            "StringUtils.isEmpty",
            "bloodSourceMapper.insertSelective",
            "check_etl_blood_source",
            "check_more_etl_blood_source",
            "check_spark_sql_blood_source",
            "check_sql_blood_source"
        ],
        "target_code": "public static void Check(String product_code) {\n        try {\n            BloodSourceMapper bloodSourceMapper = (BloodSourceMapper) SpringContext.getBean(\"bloodSourceMapper\");\n            String version = DateUtil.getCurrentTime();\n            List<BloodSourceInfo> bsis = check_etl_blood_source(version, product_code);\n            List<BloodSourceInfo> bsis2 = check_more_etl_blood_source(version, product_code);\n            List<BloodSourceInfo> bsis3 = check_sql_blood_source(version, product_code);\n            List<BloodSourceInfo> bsis4 = check_spark_sql_blood_source(version, product_code);\n\n            bsis.addAll(bsis2);\n            bsis.addAll(bsis3);\n            bsis.addAll(bsis4);\n\n            for (BloodSourceInfo bsi : bsis) {\n                if (!StringUtils.isEmpty(bsi.getInput())&& !StringUtils.isEmpty(bsi.getOutput_type())){\n                    //System.out.println(\"Blood: \"+ JsonUtil.formatJsonString(bsi));\n                    bloodSourceMapper.insertSelective(bsi);\n                }\n\n            }\n        } catch (Exception e) {\n            LogUtil.error(CheckBloodSourceJob.class, e);\n        }\n    }",
        "idx": "335"
    },
    {
        "target_file_name": "CheckBloodSourceJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/CheckBloodSourceJob.java#check_sql_blood_source",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Jinjava",
            "SQLUtils",
            "accept",
            "createSchemaStatVisitor",
            "getCreateCount",
            "getDeleteCount",
            "getInsertCount",
            "getMergeCount",
            "getSelectCount",
            "getTables",
            "getUpdateCount",
            "insertSelective",
            "parseStatements",
            "render"
        ],
        "target_code": "public static List<BloodSourceInfo> check_sql_blood_source(String version, String product_code) {\n        BloodSourceMapper bloodSourceMappeer = (BloodSourceMapper) SpringContext.getBean(\"bloodSourceMapper\");\n        EtlTaskJdbcMapper etlTaskJdbcMapper = (EtlTaskJdbcMapper) SpringContext.getBean(\"etlTaskJdbcMapper\");\n        DataSourcesMapper dataSourcesMapper = (DataSourcesMapper) SpringContext.getBean(\"dataSourcesMapper\");\n        List<EtlTaskJdbcInfo> etlTaskJdbcInfos = etlTaskJdbcMapper.selectAll();\n        List<BloodSourceInfo> bsis = new ArrayList<>();\n        for (EtlTaskJdbcInfo etlTaskJdbcInfo : etlTaskJdbcInfos) {\n            if(!etlTaskJdbcInfo.getProduct_code().equalsIgnoreCase(product_code)){\n                continue;\n            }\n            ArrayList input_tables = new ArrayList<String>();\n            ArrayList output_tables = new ArrayList<String>();\n            DataSourcesInfo ds = dataSourcesMapper.selectByPrimaryKey(etlTaskJdbcInfo.getData_sources_choose_input());\n            String dbType = JdbcUtils.getDbType(ds.getUrl(), ds.getDriver());\n            Map<String, Object> jinJavaParam = getJinJavaParam(new Timestamp(System.currentTimeMillis()));\n            Jinjava jj = new Jinjava();\n            String etl_sql = jj.render(etlTaskJdbcInfo.getEtl_sql(), jinJavaParam);\n            String[] sqls = etl_sql.split(\";\\r\\n|;\\n\");\n            for (String sql : sqls) {\n                //System.out.println(sql);\n                //System.out.println(\"======\");\n                try {\n                    List<SQLStatement> sqlStatementList = SQLUtils.parseStatements(sql, dbType);\n                    SQLStatement stmt = sqlStatementList.get(0);\n                    SchemaStatVisitor ssv = SQLUtils.createSchemaStatVisitor(dbType);\n                    stmt.accept(ssv);\n                    for (Map.Entry<TableStat.Name, TableStat> entry : ssv.getTables().entrySet()) {\n\n                        String table_name = entry.getKey().getName();\n                        if (entry.getValue().getInsertCount() > 0 || entry.getValue().getUpdateCount() > 0 || entry.getValue().getDeleteCount() > 0 || entry.getValue().getMergeCount() > 0) {\n                            output_tables.add(table_name);\n                        }\n                        if (entry.getValue().getSelectCount() > 0 || entry.getValue().getCreateCount() > 0) {\n                            input_tables.add(table_name);\n                        }\n\n                    }\n\n                    BloodSourceInfo bsi = new BloodSourceInfo();\n                    bsi.setProduct_code(etlTaskJdbcInfo.getProduct_code());\n                    bsi.setContext(etlTaskJdbcInfo.getEtl_context());\n                    bsi.setOwner(etlTaskJdbcInfo.getOwner());\n                    bsi.setCreate_time(new Date());\n                    bsi.setInput_type(etlTaskJdbcInfo.getData_source_type_input());\n                    DataSourcesInfo dsi_input = dataSourcesMapper.selectByPrimaryKey(etlTaskJdbcInfo.getData_sources_choose_input());\n                    String md5 = DigestUtils.md5DigestAsHex((dsi_input.getData_source_type() + dsi_input.getUrl()).getBytes());\n                    bsi.setInput_md5(md5);\n                    dsi_input.setPassword(\"\");\n                    bsi.setInput_json(JsonUtil.formatJsonString(dsi_input));\n                    bsi.setInput(StringUtils.join(input_tables, \",\"));\n\n                    bsi.setOutput_md5(md5);\n                    dsi_input.setPassword(\"\");\n                    bsi.setOutput_json(JsonUtil.formatJsonString(dsi_input));\n                    bsi.setOutput_type(etlTaskJdbcInfo.getData_source_type_input());\n                    bsi.setOutput(StringUtils.join(output_tables, \",\"));\n                    bsi.setVersion(version);\n                    bloodSourceMappeer.insertSelective(bsi);\n                    bsis.add(bsi);\n                } catch (Exception e) {\n                    LogUtil.error(CheckBloodSourceJob.class, e);\n                    continue;\n                }\n            }\n        }\n        return bsis;\n    }",
        "idx": "336"
    },
    {
        "target_file_name": "CheckBloodSourceJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/CheckBloodSourceJob.java#check_spark_sql_blood_source",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SQLUtils.createSchemaStatVisitor",
            "SQLUtils.parseStatements",
            "SchemaStatVisitor.getTables",
            "TableStat.Name.getName",
            "TableStat.getCreateCount",
            "TableStat.getDeleteCount",
            "TableStat.getInsertCount",
            "TableStat.getMergeCount",
            "TableStat.getSelectCount",
            "TableStat.getUpdateCount"
        ],
        "target_code": "public static List<BloodSourceInfo> check_spark_sql_blood_source(String version, String product_code) {\n        BloodSourceMapper bloodSourceMappeer = (BloodSourceMapper) SpringContext.getBean(\"bloodSourceMapper\");\n        SqlTaskMapper sqlTaskMapper = (SqlTaskMapper) SpringContext.getBean(\"sqlTaskMapper\");\n        DataSourcesMapper dataSourcesMapper = (DataSourcesMapper) SpringContext.getBean(\"dataSourcesMapper\");\n        List<SqlTaskInfo> sqlTaskInfos = sqlTaskMapper.selectAll();\n        List<BloodSourceInfo> bsis = new ArrayList<>();\n        for (SqlTaskInfo sqlTaskInfo : sqlTaskInfos) {\n            if(!sqlTaskInfo.getProduct_code().equalsIgnoreCase(product_code)){\n                continue;\n            }\n            ArrayList input_tables = new ArrayList<String>();\n            ArrayList output_tables = new ArrayList<String>();\n            DataSourcesInfo ds = new DataSourcesInfo();//dataSourcesMapper.selectByPrimaryKey(sqlTaskInfo.getData_sources_choose_input());\n            ds.setData_source_type(\"HIVE\");\n            ds.setData_source_context(\"默认HIVE数据源\");\n            ds.setUrl(\"\");\n\n            String dbType = \"hive\";//JdbcUtils.getDbType(ds.getUrl(), ds.getDriver());\n            String[] sqls = sqlTaskInfo.getEtl_sql().split(\";\\r\\n|;\\n\");\n            for (String sql : sqls) {\n                List<SQLStatement> sqlStatementList = SQLUtils.parseStatements(sql, dbType);\n                SQLStatement stmt = sqlStatementList.get(0);\n                SchemaStatVisitor ssv = SQLUtils.createSchemaStatVisitor(dbType);\n                stmt.accept(ssv);\n                for (Map.Entry<TableStat.Name, TableStat> entry : ssv.getTables().entrySet()) {\n\n                    String table_name = entry.getKey().getName();\n                    if (entry.getValue().getInsertCount() > 0 || entry.getValue().getUpdateCount() > 0 || entry.getValue().getDeleteCount() > 0 || entry.getValue().getMergeCount() > 0) {\n                        output_tables.add(table_name);\n                    }\n                    if (entry.getValue().getSelectCount() > 0 || entry.getValue().getCreateCount() > 0) {\n                        input_tables.add(table_name);\n                    }\n\n                }\n\n                BloodSourceInfo bsi = new BloodSourceInfo();\n                bsi.setProduct_code(sqlTaskInfo.getProduct_code());\n                bsi.setContext(sqlTaskInfo.getSql_context());\n                bsi.setOwner(sqlTaskInfo.getOwner());\n                bsi.setCreate_time(new Date());\n                bsi.setInput_type(ds.getData_source_type());\n                //DataSourcesInfo dsi_input = dataSourcesMapper.selectByPrimaryKey(sqlTaskInfo.getData_sources_choose_input());\n                String md5 = DigestUtils.md5DigestAsHex((ds.getData_source_type() + ds.getUrl()).getBytes());\n                bsi.setInput_json(JsonUtil.formatJsonString(ds));\n                bsi.setInput_md5(md5);\n                bsi.setInput(StringUtils.join(input_tables, \",\"));\n\n                DataSourcesInfo dsi_output = dataSourcesMapper.selectByPrimaryKey(sqlTaskInfo.getData_sources_choose_output());\n                if(dsi_output == null) {\n                    continue;\n                }\n                String md5_output = DigestUtils.md5DigestAsHex((dsi_output.getData_source_type() + dsi_output.getUrl()).getBytes());\n\n                bsi.setOutput_md5(md5_output);\n                bsi.setOutput_type(sqlTaskInfo.getData_source_type_output());\n                String out = dsi_output.getData_source_type().equalsIgnoreCase(\"jdbc\") ? sqlTaskInfo.getData_sources_table_name_output() : sqlTaskInfo.getData_sources_file_name_output();\n                dsi_output.setPassword(\"\");\n                bsi.setOutput_json(JsonUtil.formatJsonString(dsi_output));\n                if(!StringUtils.isEmpty(out)) {\n                    output_tables.add(out);\n                }\n                bsi.setOutput(StringUtils.join(output_tables, \",\"));\n                bsi.setVersion(version);\n                bloodSourceMappeer.insertSelective(bsi);\n                //System.out.println(\"Spark: \"+JsonUtil.formatJsonString(bsi));\n                bsis.add(bsi);\n            }\n\n        }\n\n        return bsis;\n\n    }",
        "idx": "337"
    },
    {
        "target_file_name": "ZdhUnstructureController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhUnstructureController.java#etl_task_unstructure_upload",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileInputStream",
            "IOUtils.toByteArray",
            "JobCommon2.writeFtp",
            "JobCommon2.writeHdfs",
            "JobCommon2.writeSftp"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_unstructure_upload\", blockHandler = \"handleReturn\")\n    @RequestMapping(value=\"/etl_task_unstructure_upload\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo etl_task_unstructure_upload(EtlTaskUnstructureInfo etlTaskUnstructureInfo,MultipartFile[] files) {\n        String owner = null;\n        try {\n            owner = getOwner();\n        } catch (Exception e) {\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n\n        String id=etlTaskUnstructureInfo.getId();\n        etlTaskUnstructureInfo = etlTaskUnstructureMapper.selectByPrimaryKey(id);\n        EtlTaskUnstructureLogInfo etlTaskUnstructureLogInfo=new EtlTaskUnstructureLogInfo();\n        try {\n            if(!StringUtils.isEmpty(etlTaskUnstructureInfo.getUnstructure_params_output())) {\n                //此处当做校验参数是否正常json格式\n                if(!JsonUtil.isJsonValid(etlTaskUnstructureInfo.getUnstructure_params_output())){\n                    throw new Exception(\"参数格式异常\");\n                }\n            }\n            etlTaskUnstructureLogInfo = MapStructMapper.INSTANCE.etlTaskUnstructureInfoToEtlTaskUnstructureLogInfo(etlTaskUnstructureInfo);\n            //BeanUtils.copyProperties(etlTaskUnstructureLogInfo, etlTaskUnstructureInfo);\n            etlTaskUnstructureLogInfo.setId(SnowflakeIdWorker.getInstance().nextId()+\"\");\n            etlTaskUnstructureLogInfo.setUnstructure_id(etlTaskUnstructureInfo.getId());\n            etlTaskUnstructureLogInfo.setCreate_time(new Timestamp(System.currentTimeMillis()));\n            etlTaskUnstructureLogInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n            etlTaskUnstructureLogInfo.setIs_delete(Const.NOT_DELETE);\n            etlTaskUnstructureLogInfo.setOwner(owner);\n        } catch (Exception e) {\n            LogUtil.error(this.getClass(), e);\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n        try{\n            //获取元数据输出源\n            String data_sources_choose_jdbc_output=etlTaskUnstructureInfo.getData_sources_choose_jdbc_output();\n            String data_sources_choose_file_output=etlTaskUnstructureInfo.getData_sources_choose_file_output();\n\n            DataSourcesInfo dataSourcesInfo = dataSourcesMapper.selectByPrimaryKey(data_sources_choose_jdbc_output);\n            DataSourcesInfo fileDataSourcesInfo =  dataSourcesMapper.selectByPrimaryKey(data_sources_choose_file_output);\n\n            List<String> etl_sqls=new ArrayList<>();\n            if (files != null && files.length > 0) {\n                for (MultipartFile jar_file : files) {\n                    String fileName = jar_file.getOriginalFilename();\n                    if(fileName==null||fileName.trim().equalsIgnoreCase(\"\")){\n                        continue;\n                    }\n                    System.out.println(\"上传文件不为空:\"+fileName);\n                    JarFileInfo jarFileInfo = new JarFileInfo();\n                    jarFileInfo.setId(SnowflakeIdWorker.getInstance().nextId() + \"\");\n                    jarFileInfo.setJar_etl_id(id);\n                    jarFileInfo.setFile_name(fileName);\n                    jarFileInfo.setCreate_time(DateUtil.formatTime(new Timestamp(System.currentTimeMillis())));\n                    jarFileInfo.setOwner(owner);\n                    etlTaskUnstructureInfo.setInput_path(fileName);\n                    ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n\n                    File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                    File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                    if (!fileDir.exists()) {\n                        fileDir.mkdirs();\n                    }\n                    try {\n                        FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                        Dsi_Info dsiInfo=new Dsi_Info();\n                        dsiInfo.setData_source_context(fileDataSourcesInfo.getData_source_context());\n                        dsiInfo.setId(fileDataSourcesInfo.getId());\n                        dsiInfo.setData_source_type(fileDataSourcesInfo.getData_source_type());\n                        dsiInfo.setDriver(fileDataSourcesInfo.getDriver());\n                        dsiInfo.setUrl(fileDataSourcesInfo.getUrl());\n                        dsiInfo.setUser(fileDataSourcesInfo.getUsername());\n                        dsiInfo.setPassword(fileDataSourcesInfo.getPassword());\n                        if(fileDataSourcesInfo.getData_source_type().equalsIgnoreCase(\"sftp\")){\n                            InputStream is = new FileInputStream(tempFile);\n                            JobCommon2.writeSftp(dsiInfo, etlTaskUnstructureInfo, IOUtils.toByteArray(is));\n                        }\n                        if(fileDataSourcesInfo.getData_source_type().equalsIgnoreCase(\"ftp\")){\n                            InputStream is = new FileInputStream(tempFile);\n                            JobCommon2.writeFtp(dsiInfo, etlTaskUnstructureInfo, IOUtils.toByteArray(is));\n                        }\n                        if(fileDataSourcesInfo.getData_source_type().equalsIgnoreCase(\"hdfs\")){\n                            InputStream is = new FileInputStream(tempFile);\n                            JobCommon2.writeHdfs(dsiInfo, etlTaskUnstructureInfo, IOUtils.toByteArray(is));\n                        }\n\n                    } catch (IOException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    } catch (SftpException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }\n\n                    //解析etl模板,目前先支持当前时间\n                    TaskLogInstance tli=new TaskLogInstance();\n                    tli.setCur_time(new Timestamp(System.currentTimeMillis()));\n                    tli.setOwner(getOwner());\n                    etl_sqls = JobCommon2.getUnstructureEtlSql(tli, etlTaskUnstructureInfo);\n\n                }\n            }\n            //入库\n            String[] result = new DBUtil().CUD(dataSourcesInfo.getDriver(), dataSourcesInfo.getUrl(), dataSourcesInfo.getUsername(), dataSourcesInfo.getPassword(),\n                    etl_sqls.toArray(new String[]{}));\n\n            String msg = \"目前支持以下参数,zdh_user:当前执行人,zdh_create_time:任务生成时间,zdh_date_time:调度ETL基准时间,file_name:上传文件名,file_path:文件写入路径\";\n\n            etlTaskUnstructureLogInfo.setMsg(msg+Const.LINE_SEPARATOR+StringUtils.join(etl_sqls,';'));\n            if(result[0].equalsIgnoreCase(\"false\")){\n                etlTaskUnstructureLogInfo.setStatus(Const.FALSE);\n                TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n                etlTaskUnstructureLogMapper.insertSelective(etlTaskUnstructureLogInfo);\n                return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", result[1]);\n            }\n            etlTaskUnstructureLogInfo.setStatus(Const.TRUR);\n            etlTaskUnstructureLogMapper.insertSelective(etlTaskUnstructureLogInfo);\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),\"新增成功\", null);\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            etlTaskUnstructureLogInfo.setStatus(Const.FALSE);\n            etlTaskUnstructureLogInfo.setMsg(e.getMessage());\n            etlTaskUnstructureLogMapper.insertSelective(etlTaskUnstructureLogInfo);\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n    }",
        "idx": "338"
    },
    {
        "target_file_name": "AliMessagePush.java",
        "target_method": "src/main/java/com/zyc/zdh/push/impl/AliMessagePush.java#send",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DefaultAcsClient",
            "DefaultProfile.getProfile",
            "SendSmsRequest",
            "getAcsResponse",
            "setOutId",
            "setPhoneNumbers",
            "setSignName",
            "setTemplateCode",
            "setTemplateParam"
        ],
        "target_code": "@Override\n    public Object send(MessageParam messageParam) throws Exception {\n        AliMessageParam aliMessageParam = (AliMessageParam)messageParam;\n        DefaultProfile profile = DefaultProfile.getProfile(aliMessageParam.getReginId(), aliMessageParam.getAk(),aliMessageParam.getSk());\n        IAcsClient client = new DefaultAcsClient(profile);\n\n        // 创建API请求并设置参数\n        SendSmsRequest request = new SendSmsRequest();\n        request.setPhoneNumbers(aliMessageParam.getPhoneNumbers());\n        request.setSignName(aliMessageParam.getSignName());\n        request.setTemplateCode(aliMessageParam.getTemplateCode());\n        request.setTemplateParam(aliMessageParam.getTemplateParam());\n        request.setOutId(aliMessageParam.getOutId());\n        try {\n            SendSmsResponse response = client.getAcsResponse(request);\n\n            return response;\n        } catch (ServerException e) {\n            e.printStackTrace();\n            throw e;\n        } catch (ClientException e) {\n            // 打印错误码\n            System.out.println(\"ErrCode:\" + e.getErrCode());\n            System.out.println(\"ErrMsg:\" + e.getErrMsg());\n            System.out.println(\"RequestId:\" + e.getRequestId());\n            throw e;\n        }\n    }",
        "idx": "339"
    },
    {
        "target_file_name": "ZdhSshController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhSshController.java#etl_task_ssh_add",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileCopyUtils.copy",
            "FileInputStream",
            "Files.newOutputStream",
            "SFTPUtil",
            "mkdirs",
            "upload"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_ssh_add\", blockHandler = \"handleReturn\")\n    @RequestMapping(value=\"/etl_task_ssh_add\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo etl_task_ssh_add(SshTaskInfo sshTaskInfo,MultipartFile[] jar_files) {\n        try{\n            String owner = getOwner();\n            sshTaskInfo.setOwner(owner);\n            String id=SnowflakeIdWorker.getInstance().nextId() + \"\";\n            sshTaskInfo.setId(id);\n            sshTaskInfo.setCreate_time(new Timestamp(System.currentTimeMillis()));\n            sshTaskInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n            sshTaskInfo.setIs_delete(Const.NOT_DELETE);\n\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, sshTaskInfo.getProduct_code(), sshTaskInfo.getDim_group(), getAttrAdd());\n\n            sshTaskMapper.insertSelective(sshTaskInfo);\n\n\n            if (sshTaskInfo.getUpdate_context() != null && !sshTaskInfo.getUpdate_context().equals(\"\")) {\n                //插入更新日志表\n                EtlTaskUpdateLogs etlTaskUpdateLogs = new EtlTaskUpdateLogs();\n                etlTaskUpdateLogs.setId(sshTaskInfo.getId());\n                etlTaskUpdateLogs.setUpdate_context(sshTaskInfo.getUpdate_context());\n                etlTaskUpdateLogs.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                etlTaskUpdateLogs.setOwner(owner);\n                etlTaskUpdateLogsMapper.insertSelective(etlTaskUpdateLogs);\n            }\n\n            if (jar_files != null && jar_files.length > 0) {\n                for (MultipartFile jar_file : jar_files) {\n                    String fileName = jar_file.getOriginalFilename();\n                    if(fileName==null||fileName.trim().equalsIgnoreCase(\"\")){\n                        continue;\n                    }\n                    System.out.println(\"上传文件不为空:\"+fileName);\n                    JarFileInfo jarFileInfo = new JarFileInfo();\n                    jarFileInfo.setId(SnowflakeIdWorker.getInstance().nextId() + \"\");\n                    jarFileInfo.setJar_etl_id(id);\n                    jarFileInfo.setFile_name(fileName);\n                    jarFileInfo.setCreate_time(DateUtil.formatTime(new Timestamp(System.currentTimeMillis())));\n                    jarFileInfo.setOwner(owner);\n                    jarFileMapper.insertSelective(jarFileInfo);\n\n                    ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n                    File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                    File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                    if (!fileDir.exists()) {\n                        fileDir.mkdirs();\n                    }\n                    String nginx_dir = zdhNginx.getNginx_dir();\n                    try {\n                        FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                        if (!zdhNginx.getHost().equals(\"\")) {\n                            System.out.println(\"通过sftp上传文件\");\n                            SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                                    zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                            sftp.login();\n                            InputStream is = new FileInputStream(tempFile);\n                            sftp.upload(nginx_dir + \"/\" + owner + \"/\", fileName, is);\n                            sftp.logout();\n                        }\n                        jarFileInfo.setStatus(\"success\");\n                        jarFileMapper.updateByPrimaryKeySelective(jarFileInfo);\n                    } catch (IOException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    } catch (SftpException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }\n                }\n            }\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),\"新增成功\", null);\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"新增失败\", e);\n        }\n    }",
        "idx": "340"
    },
    {
        "target_file_name": "ZdhSshController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhSshController.java#sql_task_update",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileInputStream",
            "SFTPUtil",
            "upload"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_ssh_update\", blockHandler = \"handleReturn\")\n    @RequestMapping(value = \"/etl_task_ssh_update\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo sql_task_update(SshTaskInfo sshTaskInfo,MultipartFile[] jar_files) {\n        try{\n            String owner = getOwner();\n            sshTaskInfo.setOwner(owner);\n            sshTaskInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n            sshTaskInfo.setIs_delete(Const.NOT_DELETE);\n\n            String id=sshTaskInfo.getId();\n\n            SshTaskInfo oldSshTaskInfo = sshTaskMapper.selectByPrimaryKey(sshTaskInfo.getId());\n\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, sshTaskInfo.getProduct_code(), sshTaskInfo.getDim_group(), getAttrEdit());\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, oldSshTaskInfo.getProduct_code(), oldSshTaskInfo.getDim_group(), getAttrEdit());\n\n            sshTaskMapper.updateByPrimaryKeySelective(sshTaskInfo);\n\n\n\n            if (sshTaskInfo.getUpdate_context() != null && !sshTaskInfo.getUpdate_context().equals(\"\")\n                    && !sshTaskInfo.getUpdate_context().equals(oldSshTaskInfo.getUpdate_context())) {\n                //插入更新日志表\n                EtlTaskUpdateLogs etlTaskUpdateLogs = new EtlTaskUpdateLogs();\n                etlTaskUpdateLogs.setId(sshTaskInfo.getId());\n                etlTaskUpdateLogs.setUpdate_context(sshTaskInfo.getUpdate_context());\n                etlTaskUpdateLogs.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                etlTaskUpdateLogs.setOwner(owner);\n                etlTaskUpdateLogsMapper.insertSelective(etlTaskUpdateLogs);\n            }\n\n            if (jar_files != null && jar_files.length > 0) {\n                for (MultipartFile jar_file : jar_files) {\n                    String fileName = jar_file.getOriginalFilename();\n                    if(fileName.isEmpty()){\n                        System.out.println(\"上传文件名称为空\"+fileName);\n                        continue;\n                    }\n                    System.out.println(\"上传文件不为空\"+fileName);\n                    JarFileInfo jarFileInfo = new JarFileInfo();\n                    jarFileInfo.setId(SnowflakeIdWorker.getInstance().nextId() + \"\");\n                    jarFileInfo.setJar_etl_id(id);\n                    jarFileInfo.setFile_name(fileName);\n                    jarFileInfo.setCreate_time(DateUtil.formatTime(new Timestamp(System.currentTimeMillis())));\n                    jarFileInfo.setOwner(owner);\n                    jarFileMapper.insertSelective(jarFileInfo);\n\n                    ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n                    File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                    File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                    if (!fileDir.exists()) {\n                        fileDir.mkdirs();\n                    }\n                    System.out.println(\"==================\"+tempFile.getAbsolutePath());\n                    String nginx_dir = zdhNginx.getNginx_dir();\n                    try {\n                        FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                        if (!zdhNginx.getHost().equals(\"\")) {\n                            System.out.println(\"通过sftp上传文件\");\n                            SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                                    zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                            sftp.login();\n                            InputStream is = new FileInputStream(tempFile);\n                            sftp.upload(nginx_dir + \"/\" + owner + \"/\", fileName, is);\n                            sftp.logout();\n                        }\n                        jarFileInfo.setStatus(\"success\");\n                        jarFileMapper.updateByPrimaryKeySelective(jarFileInfo);\n                    } catch (IOException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    } catch (SftpException e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }\n                }\n            }\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),\"更新成功\", null);\n\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),\"更新失败\", e);\n        }\n    }",
        "idx": "341"
    },
    {
        "target_file_name": "CrowdFileController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/digitalmarket/CrowdFileController.java#crowd_file_add",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "File.createTempFile",
            "FileCopyUtils.copy",
            "Files.newOutputStream",
            "MinioClient",
            "MinioUtil.putObject",
            "SFTPUtil"
        ],
        "target_code": "@SentinelResource(value = \"crowd_file_add\", blockHandler = \"handleReturn\")\n    @RequestMapping(value = \"/crowd_file_add\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    @Transactional(propagation= Propagation.NESTED)\n    public ReturnInfo crowd_file_add(CrowdFileInfo crowdFile, MultipartFile[] jar_files) {\n        try {\n\n            crowdFile.setOwner(getOwner());\n            crowdFile.setIs_delete(Const.NOT_DELETE);\n            crowdFile.setCreate_time(new Timestamp(System.currentTimeMillis()));\n            crowdFile.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n\n            checkAttrPermissionByProductAndDimGroup(zdhPermissionService, crowdFile.getProduct_code(), crowdFile.getDim_group(), getAttrAdd());\n\n            //校验文件名称是否已经存在\n            Example example=new Example(CrowdFileInfo.class);\n            Example.Criteria criteria=example.createCriteria();\n            criteria.andEqualTo(\"is_delete\", Const.NOT_DELETE);\n            criteria.andEqualTo(\"file_name\", crowdFile.getFile_name());\n            int count = crowdFileMapper.selectCountByExample(example);\n            if(count > 0){\n                return ReturnInfo.build(RETURN_CODE.FAIL.getCode(), \"文件名重复\", \"文件名重复\");\n            }\n\n            if (jar_files != null && jar_files.length > 0) {\n                for (MultipartFile jar_file : jar_files) {\n                    String fileName = jar_file.getOriginalFilename();\n                    if(fileName==null||fileName.trim().equalsIgnoreCase(\"\")){\n                        continue;\n                    }\n\n                    int lastIndex = fileName.lastIndexOf(\".\");\n                    if(lastIndex>0){\n                        String fileExtension = fileName.substring(lastIndex + 1);\n                        if(!crowdFile.getFile_name().endsWith(\".\"+fileExtension)){\n                            throw new Exception(\"特殊类型文件,文件名称必须以上传的文件类型后缀结尾,比如 xxx.xlsx\");\n                        }\n                    }\n\n                    crowdFile.setFile_url(fileName);\n                    File tempFile = File.createTempFile(\"crowd_file-temp-\", null);\n\n                    String crowdFileName = crowdFile.getFile_name();\n                    try {\n\n                        String store = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_STORE_TYPE, \"local\");//env.getProperty(\"digitalmarket.store.type\",\"local\");\n                        String host = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_HOST, \"\");//env.getProperty(\"digitalmarket.sftp.host\",\"\");\n                        String port = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_PORT, \"22\");//env.getProperty(\"digitalmarket.sftp.port\",\"22\");\n                        String username = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_USERNAME, \"\");//env.getProperty(\"digitalmarket.sftp.username\",\"\");\n                        String password = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_PASSWORD, \"\");//env.getProperty(\"digitalmarket.sftp.password\",\"\");\n                        String localPath = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_LOCAL_PATH, \"/home/data/file\");//env.getProperty(\"digitalmarket.local.path\",\"/home/data/file\");\n                        String stppath = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_SFTP_PATH, \"\");//env.getProperty(\"digitalmarket.sftp.path\",\"\");\n                        String path = localPath+\"/crowd_file\";\n\n                        if(store.equalsIgnoreCase(\"local\")){\n                            //本地目录\n                            File fileDir = new File(path);\n                            if (!fileDir.exists()) {\n                                fileDir.mkdirs();\n                            }\n                            File localFile = new File( path + \"/\" +crowdFileName);\n                            LogUtil.info(this.getClass(), \"crowd file upload store type: {}, path: {}\", store, localFile.getAbsolutePath());\n                            FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(localFile.toPath()));\n\n                        }else if(store.equalsIgnoreCase(\"sftp\")){\n                            LogUtil.info(this.getClass(), \"crowd file upload store type: {}, path: {}\", store, path + \"/\" + crowdFileName);\n\n                            FileCopyUtils.copy(jar_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                            //sftp\n                            SFTPUtil sftp = new SFTPUtil(username, password,\n                                    host, new Integer(port));\n                            sftp.login();\n                            InputStream is = new FileInputStream(tempFile);\n                            sftp.upload(stppath+\"/crowd_file\", fileName, is);\n                            sftp.logout();\n                        }else if(store.equalsIgnoreCase(\"minio\")){\n                            LogUtil.info(this.getClass(), \"crowd file upload store type: {}, path: {}\", store, path + \"/\" + crowdFile.getFile_name());\n                            String object_name = path+\"/\"+crowdFile.getFile_name();\n                            String ak = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_AK);//env.getProperty(\"digitalmarket.minio.ak\");\n                            String sk = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_SK);//env.getProperty(\"digitalmarket.minio.sk\");\n                            String endpoint = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_ENDPOINT);//env.getProperty(\"digitalmarket.minio.endpoint\");\n                            String region = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_REGION);//env.getProperty(\"digitalmarket.minio.region\");\n                            String bucket = ConfigUtil.getValue(ConfigUtil.DIGITALMARKET_MINIO_BUCKET);//env.getProperty(\"digitalmarket.minio.bucket\");\n                            MinioClient minioClient = MinioUtil.buildMinioClient(ak, sk, endpoint);\n                            MinioUtil.putObject(minioClient, bucket, region, \"application/octet-stream\", object_name, jar_file.getInputStream(), null);\n                        }\n\n                        crowdFileMapper.insertSelective(crowdFile);\n                    } catch (Exception e) {\n                        LogUtil.error(this.getClass(), e);\n                        throw e;\n                    }finally {\n                        if (tempFile.exists()) {\n                            tempFile.delete();\n                        }\n                    }\n                }\n            }\n\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(), \"新增成功\", null);\n        } catch (Exception e) {\n            LogUtil.error(this.getClass(), e);\n            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(), \"新增失败\", e);\n        }\n    }",
        "idx": "342"
    },
    {
        "target_file_name": "JobCommon2.java",
        "target_method": "src/main/java/com/zyc/zdh/job/JobCommon2.java#ssh_exec",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SSHUtil",
            "exec"
        ],
        "target_code": "public static boolean ssh_exec(TaskLogInstance tli, ZdhSshInfo zdhSshInfo) throws IOException, JSchException, SftpException {\n        try {\n            String system = System.getProperty(\"os.name\");\n            long t1 = System.currentTimeMillis();\n            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,当前系统为:\" + system + \",请耐心等待SSH任务开始执行....\");\n            String host = zdhSshInfo.getSshTaskInfo().getHost();\n            String port = zdhSshInfo.getSshTaskInfo().getPort();\n            String username = zdhSshInfo.getSshTaskInfo().getUser_name();\n            String password = zdhSshInfo.getSshTaskInfo().getPassword();\n            String ssh_cmd = zdhSshInfo.getSshTaskInfo().getSsh_cmd();\n            String id = zdhSshInfo.getSshTaskInfo().getId();\n            String t_id = zdhSshInfo.getTask_logs_id();\n            String script_path = zdhSshInfo.getSshTaskInfo().getSsh_script_path();\n            String script_context = zdhSshInfo.getSshTaskInfo().getSsh_script_context();\n            List<JarFileInfo> jarFileInfos = zdhSshInfo.getJarFileInfos();\n            ZdhNginx zdhNginx = zdhSshInfo.getZdhNginx();\n            insertLog(tli, \"DEBUG\", \"设置免密登录,请在密码中填写私钥地址,且以privateKey:开头, privateKey:/home/root/.ssh/id_rsa\");\n            if (!org.apache.commons.lang3.StringUtils.isEmpty(script_context) || (jarFileInfos != null && !jarFileInfos.isEmpty())) {\n                SFTPUtil sftpUtil = new SFTPUtil(username, password, host, Integer.parseInt(port));\n                sftpUtil.login();\n                if (!script_context.isEmpty()) {\n                    insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,发现在线脚本,使用在线脚本ssh 命令 可配合{{zdh_online_file}} 使用 example sh {{zdh_online_file}} 即是执行在线的脚本\");\n                    InputStream inputStream = new ByteArrayInputStream(script_context.replaceAll(\"\\r\\n\", \"\\n\").getBytes());\n                    sftpUtil.upload(script_path, t_id + \"_online\", inputStream);\n                }\n\n                if (!jarFileInfos.isEmpty()) {\n                    for (JarFileInfo jarFileInfo : jarFileInfos) {\n                        //下载文件\n                        if (zdhNginx.getHost() != null && !zdhNginx.getHost().equals(\"\")) {\n                            LogUtil.info(JobCommon2.class, \"开始下载文件:SFTP方式\" + jarFileInfo.getFile_name());\n                            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,开始下载文件:SFTP方式\" + jarFileInfo.getFile_name());\n                            //连接sftp 下载\n                            SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                                    zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                            sftp.login();\n                            byte[] fileByte = sftp.download(zdhNginx.getNginx_dir() + \"/\" + zdhNginx.getOwner(), jarFileInfo.getFile_name());\n                            sftpUtil.upload(script_path, jarFileInfo.getFile_name(), fileByte);\n                            sftp.logout();\n                        } else {\n                            LogUtil.info(JobCommon2.class, \"开始下载文件:本地方式\" + jarFileInfo.getFile_name());\n                            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,开始下载文件:本地方式\" + jarFileInfo.getFile_name());\n                            //本地文件\n\n                            FileInputStream in = null;\n                            try {\n                                in = new FileInputStream(zdhNginx.getTmp_dir() + \"/\" + zdhNginx.getOwner() + \"/\" + jarFileInfo.getFile_name());\n                                ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n                                System.out.println(\"bytes available:\" + in.available());\n                                byte[] temp = new byte[1024];\n                                int size = 0;\n                                while ((size = in.read(temp)) != -1) {\n                                    out.write(temp, 0, size);\n                                }\n                                byte[] bytes = out.toByteArray();\n                                System.out.println(\"bytes size got is:\" + bytes.length);\n                                sftpUtil.upload(script_path, jarFileInfo.getFile_name(), in);\n\n                            } catch (Exception e) {\n                                LogUtil.error(JobCommon2.class, e);\n                                throw e;\n                            } finally {\n                                if (in != null) {\n                                    in.close();\n                                }\n                            }\n\n                        }\n                    }\n                }\n\n                sftpUtil.logout();\n            }\n\n            SSHUtil sshUtil = new SSHUtil(username, password, host, Integer.parseInt(port));\n            sshUtil.login();\n            chm_ssh.put(tli.getId(), sshUtil);\n            ssh_cmd = \"echo task_id=\" + tli.getId() + \" && \" + ssh_cmd;\n            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,使用在线脚本,\" + ssh_cmd);\n            String[] result = sshUtil.exec(ssh_cmd, tli.getId(), tli.getJob_id());\n            String error = result[0];\n            String out = result[1];\n            if (chm_ssh.get(tli.getId()) != null) {\n                chm_ssh.get(tli.getId()).logout();\n            }\n            chm_ssh.remove(tli.getId());\n            long t2 = System.currentTimeMillis();\n\n            insertLog(tli, \"DEBUG\", \"[调度平台]:SSH,SSH任务执行结束,耗时:\" + (t2 - t1) / 1000 + \"s\");\n\n            if (!error.isEmpty()) {\n                return false;\n            }\n            return true;\n\n        } catch (Exception e) {\n            LogUtil.error(JobCommon2.class, e);\n            throw e;\n        }\n\n    }",
        "idx": "343"
    },
    {
        "target_file_name": "JobCommon2.java",
        "target_method": "src/main/java/com/zyc/zdh/job/JobCommon2.java#datax_auto_exec",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "CommandUtils.exeCommand2",
            "FileUtils.forceMkdirParent",
            "FileUtils.write"
        ],
        "target_code": "public static boolean datax_auto_exec(TaskLogInstance tli, ZdhDataxAutoInfo zdhDataxAutoInfo) throws Exception {\n        try {\n            String system = System.getProperty(\"os.name\");\n            long t1 = System.currentTimeMillis();\n            insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,使用datax 服务,建议在datax 数据源中配置驱动格式: python_home/bin/python datax_home, 通过单个空格分割\");\n            insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,当前系统为:\" + system + \",请耐心等待DATAX任务开始执行....\");\n\n            DataxReader reader = generator_reader(zdhDataxAutoInfo);\n            DataxWriter writer = generator_writer(zdhDataxAutoInfo);\n            Content content=new Content();\n            content.setReader(reader);\n            content.setWriter(writer);\n\n            Map<String, Object> jsonObject=JsonUtil.toJavaMap(zdhDataxAutoInfo.getEtlTaskDataxAutoInfo().getData_sources_params_input());\n            DataxConfig dataxConfig=DataxConfig.build(Lists.newArrayList(content), jsonObject,jsonObject);\n\n            System.out.println(JsonUtil.formatJsonString(dataxConfig));\n\n            String t_id = zdhDataxAutoInfo.getTask_logs_id();\n            String python_home=zdhDataxAutoInfo.getPython_home();\n            String datax_home=zdhDataxAutoInfo.getDatax_home();\n            String script_path = datax_home+\"/zdh_datax\";\n            String script_context = JsonUtil.formatJsonString(dataxConfig);\n            String file_name = script_path + \"/\" + t_id + \"_online\";\n            //校验是否本地datax\n            if (StringUtils.isEmpty(\"\")) {\n                //本地直接生成文件\n                insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,本地执行\");\n                FileUtils.forceMkdirParent(new File(file_name));\n                FileUtils.write(new File(file_name), script_context, Charset.defaultCharset().name(), false);\n                String newcommand = python_home + \" \" + datax_home + \"/bin/datax.py \" + file_name;\n                insertLog(tli, \"DEBUG\", script_context);\n                insertLog(tli, \"DEBUG\", newcommand);\n                Map result = new HashMap<String, String>();\n                insertLog(tli, \"DEBUG\", \"系统编码:\" + Charset.defaultCharset().name());\n                if (system.toLowerCase().startsWith(\"win\")) {\n                    result = CommandUtils.exeCommand2(tli, \"cmd.exe\", \"/c\", newcommand, Charset.defaultCharset().name());\n                } else {\n                    result = CommandUtils.exeCommand2(tli, \"sh\", \"-c\", newcommand, Charset.defaultCharset().name());\n                }\n                long t2 = System.currentTimeMillis();\n                insertLog(tli, \"DEBUG\", \"[调度平台]:DATAX,DATAX任务执行结束,耗时:\" + (t2 - t1) / 1000 + \"s\");\n                if (result.get(\"result\").equals(\"success\")) {\n                    return true;\n                }\n                return false;\n            }\n\n            return false;\n\n        } catch (Exception e) {\n            LogUtil.error(JobCommon2.class, e);\n            throw e;\n        }\n\n    }",
        "idx": "344"
    },
    {
        "target_file_name": "EmailJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/EmailJob.java#taskLogInstanceAlarm",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SpringContext.getBean",
            "TaskLogInstanceMapper.selectByStatus",
            "TaskLogInstanceMapper.selectNoNoticeFinish",
            "TaskLogInstanceMapper.selectOverTime",
            "TaskLogInstanceMapper.selectOverTimeFinish",
            "alarm"
        ],
        "target_code": "public static void taskLogInstanceAlarm(){\n        try{\n            LogUtil.debug(EmailJob.class, \"开始检测ETL失败任务...\");\n            TaskLogInstanceMapper taskLogInstanceMapper = (TaskLogInstanceMapper) SpringContext.getBean(\"taskLogInstanceMapper\");\n\n            //获取失败的任务\n            List<TaskLogInstance> tlis=taskLogInstanceMapper.selectByStatus(JobStatus.ERROR.getValue());\n            String line = Const.LINE_SEPARATOR;\n            //根据任务执行时间，主键 获取对应的日志信息\n            for(TaskLogInstance tli:tlis){\n\n                LogUtil.info(EmailJob.class, \"检测失败任务:\" + tli.getJob_id() + \",对应主键:\" + tli.getId() + \",对应任务组id:\" + tli.getGroup_id());\n\n                String msg=\"【失败告警】任务:\"+tli.getEtl_context()+\"\\r\\n\" +\n                        \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                        \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                        \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                        \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                        \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                        \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                        \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                        \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                        \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                alarm(tli, \"【失败告警】: \"+tli.getJob_context(),msg, MSG_TYPE_ALARM);\n                LogUtil.info(EmailJob.class, \"检测失败任务:\" + tli.getJob_id() + \",对应主键:\" + tli.getId() + \",并完成更新\");\n            }\n\n            //获取超时任务\n            List<TaskLogInstance> taskLogInstances= taskLogInstanceMapper.selectOverTime();\n            if(taskLogInstances!=null && taskLogInstances.size()>0){\n                System.out.println(\"超时任务量:\"+taskLogInstances.size());\n                for(TaskLogInstance tli : taskLogInstances){\n                    String msg=\"【超时告警】任务:\\r\\n\" +\n                            \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                            \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                            \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                            \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                            \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                            \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                            \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                            \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                            \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                    if (tli.getJob_type().equalsIgnoreCase(ShellJob.jobType)){\n                        //msg = msg +\"\\r\\nSHELL任务超时自动杀死\";\n                        //ZdhMonitorController zdhmc = (ZdhMonitorController) SpringContext.getBean(\"zdhMonitorController\");\n                        //zdhmc.killJob(tli.getId());\n\n                    }\n                    alarm(tli, \"【超时告警】: \"+tli.getJob_context(),msg, MSG_TYPE_ALARM);\n                }\n            }\n\n            //超时,但之后完成任务\n            List<TaskLogInstance> taskLogInstances2= taskLogInstanceMapper.selectOverTimeFinish();\n            if(taskLogInstances2!=null && taskLogInstances2.size()>0){\n                for(TaskLogInstance tli : taskLogInstances2){\n                    String msg=\"【超时后完成通知】任务:\"+tli.getEtl_context()+\"\\r\\n\" +\n                            \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                            \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                            \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                            \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                            \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                            \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                            \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                            \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                            \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                    alarm(tli, \"【超时后完成通知】: \"+tli.getJob_context(),msg, MSG_TYPE_NOTICE);\n                }\n            }\n\n            //正常完成任务后通知\n            List<TaskLogInstance> taskLogInstances3= taskLogInstanceMapper.selectNoNoticeFinish();\n            if(taskLogInstances3!=null && taskLogInstances3.size()>0){\n                for(TaskLogInstance tli : taskLogInstances3){\n\n                    String msg= \"【完成通知】任务:\"+tli.getEtl_context()+\"\\r\\n\" +\n                            \"调度任务:\"+tli.getJob_id()+\",调度名:\"+tli.getJob_context()+\"\\r\\n\"+\n                            \"任务组:\"+tli.getGroup_id()+\",任务组名:\"+tli.getGroup_context()+\"\\r\\n\"+\n                            \"任务类型:\"+tli.getJob_type()+\"\\r\\n\"+\n                            \"任务ID:\"+tli.getEtl_task_id()+\",任务名:\"+tli.getEtl_context()+\"\\r\\n\"+\n                            \"ETL任务类型:\"+tli.getMore_task()+\"\\r\\n\"+\n                            \"任务实例id:\"+tli.getId()+\",任务实例名:\"+tli.getEtl_context() +\"\\r\\n\"+\n                            \"ETL日期:\"+tli.getEtl_date()+\"\\r\\n\"+\n                            \"开始时间:\"+DateUtil.formatTime(tli.getRun_time())+\"\\r\\n\"+\n                            \"更新时间:\"+DateUtil.formatTime(tli.getUpdate_time())+\"\\r\\n\";\n                    alarm(tli, \"【完成通知】: \"+tli.getJob_context(),msg, MSG_TYPE_NOTICE);\n                }\n            }\n\n        }catch (Exception e){\n            LogUtil.error(EmailJob.class, e);\n        }\n\n    }",
        "idx": "345"
    },
    {
        "target_file_name": "EmailJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/EmailJob.java#alarm",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SpringContext.getBean",
            "insertSelective",
            "sendEmail"
        ],
        "target_code": "public static void alarm(QuartzJobInfo qji, String title, String msg){\n        try{\n            JemailService jemailService= (JemailService) SpringContext.getBean(\"jemailServiceImpl\");\n            AccountService accountService=(AccountService) SpringContext.getBean(\"accountService\");\n            NoticeMapper noticeMapper = (NoticeMapper) SpringContext.getBean(\"noticeMapper\");\n            if(StringUtils.isEmpty(qji.getAlarm_account())){\n                LogUtil.warn(EmailJob.class, \"当前告警为找到告警账号:\" + JsonUtil.formatJsonString(qji));\n                return ;\n            }\n            List<User> users=accountService.findByUserName2(qji.getAlarm_account().split(\",\"));\n            List<String> emails=new ArrayList<>();\n            List<String> phones=new ArrayList<>();\n            for(User user:users){\n                if(user.getEmail()!=null){\n                    System.out.println(\"email:\"+user.getEmail());\n                    emails.add(user.getEmail());\n                }\n                if(user.getPhone()!=null){\n                    phones.add(user.getPhone());\n                }\n            }\n\n            if(emails.size()>0 && qji.getAlarm_email()!=null  && qji.getAlarm_email().equalsIgnoreCase(Const.ON)){\n                jemailService.sendEmail(emails.toArray(new String[0]),title,msg);\n            }\n            if(phones.size()>0&& qji.getAlarm_sms()!=null && qji.getAlarm_sms().equalsIgnoreCase(Const.ON)){\n                LogUtil.info(EmailJob.class, \"手机短信监控,暂时未开通,需要连接第三方短信服务\");\n                try{\n                    //此处信息写入短信表,待平台接入短信服务\n                    AlarmSmsMapper alarmSmsMapper=  (AlarmSmsMapper) SpringContext.getBean(\"alarmSmsMapper\");\n                    AlarmSmsInfo alarmSmsInfo=new AlarmSmsInfo();\n                    alarmSmsInfo.setTitle(title);\n                    alarmSmsInfo.setMsg(msg);\n                    alarmSmsInfo.setMsg_url(\"\");\n                    alarmSmsInfo.setMsg_type(\"通知\");\n                    alarmSmsInfo.setStatus(Const.SMS_INIT);\n                    alarmSmsInfo.setCreate_time(new Timestamp(System.currentTimeMillis()));\n                    alarmSmsInfo.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                    for(String phone:phones){\n                        alarmSmsInfo.setPhone(phone);\n                        alarmSmsMapper.insertSelective(alarmSmsInfo);\n                    }\n                }catch (Exception e){\n                    LogUtil.error(EmailJob.class, \"发送告警短信失败\", e);\n                }\n\n            }\n\n            if( !StringUtils.isEmpty(qji.getAlarm_account()) && qji.getAlarm_zdh()!=null  && qji.getAlarm_zdh().equalsIgnoreCase(\"on\")){\n                for(User user:users){\n                    NoticeInfo ni=new NoticeInfo();\n                    ni.setMsg_type(\"通知\");\n                    ni.setMsg_title(title);\n                    ni.setMsg_url(\"\");\n                    ni.setMsg(msg);\n                    ni.setIs_see(Const.FALSE);\n                    ni.setOwner(user.getUserName());\n                    ni.setCreate_time(new Timestamp(System.currentTimeMillis()));\n                    ni.setUpdate_time(new Timestamp(System.currentTimeMillis()));\n                    noticeMapper.insertSelective(ni);\n                }\n            }\n        }catch (Exception e){\n            LogUtil.error(EmailJob.class, e);\n        }\n\n    }",
        "idx": "346"
    },
    {
        "target_file_name": "JobBeaconFire.java",
        "target_method": "src/main/java/com/zyc/zdh/job/JobBeaconFire.java#run",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "GroovyFactory.execExpress",
            "Jinjava",
            "SqlExecutor.query",
            "render"
        ],
        "target_code": "@Override\n        public void run() {\n            //执行具体的告警信息\n            Connection conn = null;\n            try{\n                DataSource ds = new SimpleDataSource(dataSourcesInfo.getUrl(), dataSourcesInfo.getUsername(),\n                        dataSourcesInfo.getPassword());\n                conn = ds.getConnection();\n                String sql = beaconFireInfo.getSql_script();\n                Map<String, Object> jinJavaParam = getJinJavaParam(cur_time);\n                Jinjava jinjava=new Jinjava();\n\n                String new_sql = jinjava.render(sql, jinJavaParam);\n                List<Entity> entityList = SqlExecutor.query(conn, new_sql, new EntityListHandler());\n                Map<String, Object> params = new HashMap<>();\n                params.put(\"rs\", entityList);\n                params.put(\"out\", new Out());\n                String groovy = beaconFireInfo.getGroovy_script();\n                Out out = (Out)GroovyFactory.execExpress(groovy, params);\n                System.out.println(JsonUtil.formatJsonString(out));\n                if(out != null && out.code != \"0\"){\n                    String frequency = beaconFireInfo.getFrequency_config();\n                    Long time = 1800L;\n                    int time_num = 1;\n                    if(!StringUtils.isEmpty(frequency) && frequency.split(\",\").length == 2){\n                        time = Long.parseLong(frequency.split(\",\")[0]);\n                        time_num = Integer.parseInt(frequency.split(\",\")[1]);\n                    }\n\n                    BeaconFireAlarmMsgInfo beaconFireAlarmMsgInfo = new BeaconFireAlarmMsgInfo();\n                    beaconFireAlarmMsgInfo.setStatus(Const.STATUS_COMMON_INIT);\n                    //获取\n                    String alarm_key = \"beacon_fire_\"+beaconFireInfo.getId();\n                    if(redisUtil.exists(alarm_key)){\n                        String num = redisUtil.get(alarm_key,\"1\").toString();\n                        if(Integer.valueOf(num) >= time_num){\n                            beaconFireAlarmMsgInfo.setStatus(Const.STATUS_COMMON_FAIL);\n                        }\n                        Long expire = redisUtil.getRedisTemplate().getExpire(alarm_key, TimeUnit.SECONDS);\n                        redisUtil.set(alarm_key, String.valueOf(Integer.valueOf(num) + 1), expire, TimeUnit.SECONDS);\n                    }else{\n                        redisUtil.set(alarm_key, \"1\", time, TimeUnit.SECONDS);\n                    }\n                    //告警\n                    out.sqlScript = new_sql;\n                    out.message = beaconFireInfo.getBeacon_fire_context();\n                    out.setAlarmConfig(beaconFireAlarmGroupInfo.getAlarm_config());\n                    beaconFireAlarmMsgInfo.setDim_group(beaconFireInfo.getDim_group());\n                    beaconFireAlarmMsgInfo.setProduct_code(beaconFireInfo.getProduct_code());\n                    beaconFireAlarmMsgInfo.setOwner(beaconFireInfo.getOwner());\n                    beaconFireAlarmMsgInfo.setAlarm_msg(JsonUtil.formatJsonString(out));\n                    beaconFireAlarmMsgMapper.insertSelective(beaconFireAlarmMsgInfo);\n                }\n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }",
        "idx": "347"
    },
    {
        "target_file_name": "ZdhEtlController.java",
        "target_method": "src/main/java/com/zyc/zdh/controller/ZdhEtlController.java#etl_task_add_file",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "File",
            "FileCopyUtils.copy",
            "FileInputStream",
            "Files.newOutputStream",
            "InputStream",
            "SFTPUtil",
            "upload"
        ],
        "target_code": "@SentinelResource(value = \"etl_task_add_file\", blockHandler = \"handleReturn\")\n    @RequestMapping(value=\"/etl_task_add_file\", method = RequestMethod.POST, produces = \"application/json;charset=UTF-8\")\n    @ResponseBody\n    public ReturnInfo etl_task_add_file(MultipartFile up_file, HttpServletRequest request) {\n        try{\n            String json_str = JsonUtil.formatJsonString(request.getParameterMap());\n            String owner = getOwner();\n            System.out.println(json_str);\n            System.out.println(up_file);\n            if (up_file != null) {\n                String fileName = up_file.getOriginalFilename();\n                System.out.println(\"上传文件不为空\");\n                ZdhNginx zdhNginx = zdhNginxMapper.selectByOwner(owner);\n                File tempFile = new File(zdhNginx.getTmp_dir() + \"/\" + owner + \"/\" + fileName);\n                File fileDir = new File(zdhNginx.getTmp_dir() + \"/\" + owner);\n                if (!fileDir.exists()) {\n                    fileDir.mkdirs();\n                }\n                String nginx_dir = zdhNginx.getNginx_dir();\n\n                FileCopyUtils.copy(up_file.getInputStream(), Files.newOutputStream(tempFile.toPath()));\n                if (!zdhNginx.getHost().equals(\"\")) {\n                    System.out.println(\"通过sftp上传文件\");\n                    SFTPUtil sftp = new SFTPUtil(zdhNginx.getUsername(), zdhNginx.getPassword(),\n                            zdhNginx.getHost(), new Integer(zdhNginx.getPort()));\n                    sftp.login();\n                    InputStream is = new FileInputStream(tempFile);\n                    sftp.upload(nginx_dir + \"/\" + owner + \"/\", fileName, is);\n                    sftp.logout();\n                }\n            }\n            return ReturnInfo.build(RETURN_CODE.SUCCESS.getCode(),RETURN_CODE.SUCCESS.getDesc(), null);\n        }catch (Exception e){\n            LogUtil.error(this.getClass(), e);\n            return ReturnInfo.build(RETURN_CODE.FAIL.getCode(),e.getMessage(), null);\n        }\n    }",
        "idx": "348"
    },
    {
        "target_file_name": "SetUpJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/SetUpJob.java#run",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SSHUtil",
            "exec2"
        ],
        "target_code": "public static void run(ServerTaskInstance sti) {\n\n        //第一步：登陆构建服务器\n        //第二步：拉取git\n        //第三步：执行构建命令\n        //第四步：scp 远程服务器\n        SSHUtil sshUtil=null;\n        String system = System.getProperty(\"os.name\");\n        if(system.toLowerCase().startsWith(\"win\")){\n            sshUtil=new SSHUtil(sti.getBuild_username(),sti.getBuild_privatekey(),sti.getBuild_ip(),22);\n        }else{\n            sshUtil=new SSHUtil(sti.getBuild_username(),sti.getBuild_ip(),22,sti.getBuild_privatekey());\n        }\n\n        List<String> cmd_list=new ArrayList<>();\n        cmd_list.add(\"echo command start\");\n        if(!StringUtils.isEmpty(sti.getGit_url())){\n            String cmd=\"git clone -b \"+sti.getBuild_branch() + \" \"+sti.getGit_url() +\" \"+sti.getBuild_path();\n            cmd_list.add(\"echo command: \"+cmd);\n            cmd_list.add(cmd);\n        }\n        if(!StringUtils.isEmpty(sti.getBuild_path())){\n            String cmd2=\"cd \"+sti.getBuild_path();\n            cmd_list.add(\"echo command: \"+cmd2);\n            cmd_list.add(cmd2);\n        }\n        if(!StringUtils.isEmpty(sti.getBuild_command())){\n            String cmd3=sti.getBuild_command();\n            cmd_list.add(\"echo \"+cmd3);\n            cmd_list.add(cmd3);\n\n        }\n        if(!StringUtils.isEmpty(sti.getRemote_path())){\n            String cmd4=\"script -q -c \\\"scp -r \"+sti.getBuild_path()+\"/release/* \"+sti.getBuild_username()+\"@\"+sti.getRemote_ip()+\":\"+sti.getRemote_path() +\"\\\"\";\n            cmd_list.add(\"echo command: \"+cmd4);\n            cmd_list.add(cmd4);\n        }\n        cmd_list.add(\"echo command finish\");\n        String cmd=org.apache.commons.lang.StringUtils.join(cmd_list,\";\");\n        try {\n            sshUtil.login();\n            System.out.println(cmd);\n            String[] out=sshUtil.exec2(cmd,sti.getId(),sti.getTemplete_id());\n            System.out.println(out[0]+\"==\"+out[1]);\n            sshUtil.logout();\n        } catch (IOException e) {\n            LogUtil.error(SetUpJob.class, e);\n             JobCommon2.insertLog(sti.getTemplete_id(),sti.getId(),\"INFO\",e.getMessage());\n             setStatus(sti.getId(),\"2\");\n        } catch (JSchException e) {\n            LogUtil.error(SetUpJob.class, e);\n             JobCommon2.insertLog(sti.getTemplete_id(),sti.getId(),\"INFO\",e.getMessage());\n             setStatus(sti.getId(),\"2\");\n        }\n\n    }",
        "idx": "349"
    },
    {
        "target_file_name": "SystemCommandLineRunner.java",
        "target_method": "src/main/java/com/zyc/zdh/run/SystemCommandLineRunner.java#killJobGroup",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Future.cancel",
            "HttpUtil.getRequest",
            "HttpUtil.postJSON",
            "Process.destroyForcibly",
            "SSHUtil",
            "SshUtils.kill",
            "Thread.interrupt"
        ],
        "target_code": "public void killJobGroup(){\n        LogUtil.info(this.getClass(), \"初始化监控杀死任务\");\n        TaskGroupLogInstanceMapper taskGroupLogInstanceMapper = (TaskGroupLogInstanceMapper) SpringContext.getBean(\"taskGroupLogInstanceMapper\");\n        TaskLogInstanceMapper taskLogInstanceMapper = (TaskLogInstanceMapper) SpringContext.getBean(\"taskLogInstanceMapper\");\n        ZdhHaInfoMapper zdhHaInfoMapper = (ZdhHaInfoMapper) SpringContext.getBean(\"zdhHaInfoMapper\");\n        String myid = ConfigUtil.getValue(ConfigUtil.MYID, \"0\");\n\n        ZdhRunableTask zdhRunableTask=new ZdhRunableTask(\"schedule kill job task\", new Runnable() {\n            @Override\n            public void run() {\n                while(true){\n                    try {\n                        LogUtil.debug(this.getClass(), \"检查要杀死的任务组..\");\n                        List<TaskLogInstance> tlis=taskLogInstanceMapper.selectThreadByStatus(\"kill\");\n                        for(TaskLogInstance tl : tlis){\n\n                            if(tl.getThread_id()!=null && tl.getThread_id().startsWith(myid)){\n                                Future<?> future = JobCommon2.chm.get(tl.getId());\n                                if(future!=null){\n                                    String msg=\"杀死线程:线程id:\"+tl.getThread_id()+\",任务名:\"+tl.getJob_context()+\",任务实例id:\"+tl.getId();\n                                    LogUtil.info(this.getClass(), msg);\n                                    JobCommon2.insertLog(tl,\"INFO\",msg);\n                                    if(tl.getMore_task().equalsIgnoreCase(\"ssh\") || tl.getMore_task().equalsIgnoreCase(\"datax\") || tl.getJob_type().equalsIgnoreCase(\"flume\")){\n                                        SSHUtil sshUtil =JobCommon2.chm_ssh.get(tl.getId());\n                                        if(sshUtil!=null){\n                                            String[] connectUri= sshUtil.createUri();\n                                            sshUtil.logout();\n                                            JobCommon2.chm_ssh.get(tl.getId()).logout();\n                                            JobCommon2.chm_ssh.remove(tl.getId());\n                                            if(connectUri.length==2 && !StringUtils.isEmpty(connectUri[1])){\n                                                try{\n                                                    String kill_cmd=String.format(\"kill -9 `ps -ef |grep '%s' |awk -F \\\" \\\" '{print $2}'`\",connectUri[1]);\n                                                    JobCommon2.insertLog(tl,\"INFO\",kill_cmd);\n                                                    SshUtils.kill(connectUri[0],kill_cmd);\n                                                }catch (Exception e){\n                                                    LogUtil.error(this.getClass(), e);\n                                                }\n\n                                            }\n                                        }\n                                    }\n\n                                    try{\n                                        Process process = JobCommon2.chm_process.get(tl.getId());\n                                        if(process != null){\n                                            process.getInputStream().close();\n                                            process.destroyForcibly();\n                                        }\n                                        msg=\"杀死进程完成\";\n                                        LogUtil.info(this.getClass(), msg);\n                                    }catch (Exception e){\n                                        e.printStackTrace();\n                                        msg=\"杀死进程异常\";\n                                        LogUtil.error(this.getClass(), msg, e);\n                                        JobCommon2.insertLog(tl,\"ERROR\",msg);\n                                    }\n\n                                    try{\n                                        Thread thread = JobCommon2.chm_thread.get(tl.getId());\n                                        if(thread != null){\n                                            thread.interrupt();\n                                        }\n                                    }catch (Exception e){\n                                        e.printStackTrace();\n                                    }\n\n                                    try{\n                                        future.cancel(true);\n                                    }catch (Exception e){\n                                        LogUtil.error(this.getClass(), e);\n                                    }finally {\n                                        JobCommon2.chm.remove(tl.getId());\n                                        JobCommon2.chm_thread.remove(tl.getId());\n                                        JobCommon2.chm_process.remove(tl.getId());\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                        JobCommon2.insertLog(tl,\"INFO\",\"已杀死当前任务\");\n                                    }\n                                }else{\n                                    String msg=\"调度部分已经执行完成,ETL部分正在执行提交到后端的任务进行杀死\";\n                                    LogUtil.info(this.getClass(), msg);\n                                    JobCommon2.insertLog(tl,\"INFO\",msg);\n                                    List<NameValuePair> npl=new ArrayList<>();\n\n                                    //如果是flink任务,需要调用远程地址杀死\n                                    if(tl.getMore_task().equalsIgnoreCase(MoreTask.FLINK.getValue())){\n                                        //如果找不到flink_job_id,历史服务器,则跳过\n                                        if(StringUtils.isEmpty(tl.getApplication_id()) || StringUtils.isEmpty(tl.getHistory_server())){\n                                            if(System.currentTimeMillis()-tl.getUpdate_time().getTime() > 2*60*1000){\n                                                taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                            }\n                                            continue;\n                                        }\n\n                                        String cancel_url = tl.getHistory_server()+\"/jobs/\"+tl.getApplication_id()+\"/yarn-cancel\";\n                                        npl.add(new BasicNameValuePair(\"mode\",\"cancel\"));\n                                        JobCommon2.insertLog(tl,\"INFO\",\"杀死任务url: \"+cancel_url);\n                                        try{\n                                            String restul=HttpUtil.getRequest(cancel_url,npl);\n                                        }catch (Exception e){\n                                            JobCommon2.insertLog(tl,\"INFO\",\"杀死当前任务异常,判定服务已死亡,自动更新状态为killed\");\n                                            taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                            continue;\n                                        }\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                        JobCommon2.insertLog(tl,\"INFO\",\"已杀死当前任务\");\n                                        continue;\n                                    }else{\n\n                                    }\n\n                                    String executor=tl.getExecutor();//数据采集机器id\n                                    ZdhHaInfo zdhHaInfo=zdhHaInfoMapper.selectByPrimaryKey(executor);\n                                    String jobGroup=\"jobGroup\";\n                                    if(zdhHaInfo!=null){\n                                        String url=\"http://\"+zdhHaInfo.getZdh_host()+\":\"+zdhHaInfo.getWeb_port()+\"/api/v1/applications/\"+zdhHaInfo.getApplication_id()+\"/jobs\";\n                                        //获取杀死的任务名称\n                                        System.out.println(url);\n                                        //npl.add(new BasicNameValuePair(\"status\",\"running\"));\n                                        String restul=\"\";\n                                        try{\n                                            restul=HttpUtil.getRequest(url,npl);\n                                        }catch (Exception e){\n                                            taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                            continue;\n                                        }\n\n                                        List<Map<String, Object>> jsonArray= JsonUtil.toJavaListMap(restul);\n                                        List<String> killJobs=new ArrayList<>();\n                                        for(Map<String, Object> jo:jsonArray){\n                                            if(jo.getOrDefault(jobGroup, \"\").toString().startsWith(tl.getId())){\n                                                killJobs.add(jo.getOrDefault(jobGroup, \"\").toString());\n                                            }\n                                        }\n\n                                        Map<String, Object> js=JsonUtil.createEmptyMap();\n                                        js.put(\"task_logs_id\",tl.getId());//写日志使用\n                                        js.put(\"jobGroups\",killJobs);\n                                        js.put(\"job_id\",tl.getJob_id());\n                                        //发送杀死请求\n                                        String kill_url=\"http://\"+zdhHaInfo.getZdh_host()+\":\"+zdhHaInfo.getZdh_port()+\"/api/v1/kill\";\n                                        HttpUtil.postJSON(kill_url, JsonUtil.formatJsonString(js));\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                    }else{\n                                        String msg2=\"无法获取具体执行器,判断任务已杀死\";\n                                        taskLogInstanceMapper.updateStatusById(JobStatus.KILLED.getValue(),DateUtil.getCurrentTime(),tl.getId());\n                                        LogUtil.info(this.getClass(), msg2);\n                                        JobCommon2.insertLog(tl,\"INFO\",msg2);\n                                    }\n\n                                }\n                            }\n                        }\n                        // List<QuartzJobInfo> quartzJobInfos = quartzJobMapper.select(qj);\n                        Thread.sleep(1000*2);\n                    } catch (Exception e) {\n                        LogUtil.error(this.getClass(), e);\n                    }\n                }\n            }\n        });\n        threadPool.submit(zdhRunableTask);\n    }",
        "idx": "350"
    },
    {
        "target_file_name": "CheckBloodSourceJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/CheckBloodSourceJob.java#Check",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DateUtil.getCurrentTime",
            "JsonUtil.formatJsonString",
            "LogUtil.error",
            "SpringContext.getBean",
            "StringUtils.isEmpty",
            "System.out.println",
            "bloodSourceMapper.insertSelective",
            "check_etl_blood_source",
            "check_more_etl_blood_source",
            "check_spark_sql_blood_source",
            "check_sql_blood_source"
        ],
        "target_code": "public static void Check(String product_code) {\n        try {\n            BloodSourceMapper bloodSourceMapper = (BloodSourceMapper) SpringContext.getBean(\"bloodSourceMapper\");\n            String version = DateUtil.getCurrentTime();\n            List<BloodSourceInfo> bsis = check_etl_blood_source(version, product_code);\n            List<BloodSourceInfo> bsis2 = check_more_etl_blood_source(version, product_code);\n            List<BloodSourceInfo> bsis3 = check_sql_blood_source(version, product_code);\n            List<BloodSourceInfo> bsis4 = check_spark_sql_blood_source(version, product_code);\n\n            bsis.addAll(bsis2);\n            bsis.addAll(bsis3);\n            bsis.addAll(bsis4);\n\n            for (BloodSourceInfo bsi : bsis) {\n                if (!StringUtils.isEmpty(bsi.getInput())&& !StringUtils.isEmpty(bsi.getOutput_type())){\n                    System.out.println(\"Blood: \"+ JsonUtil.formatJsonString(bsi));\n                    bloodSourceMapper.insertSelective(bsi);\n                }\n\n            }\n        } catch (Exception e) {\n            LogUtil.error(CheckBloodSourceJob.class, e);\n        }\n    }",
        "idx": "351"
    },
    {
        "target_file_name": "CheckBloodSourceJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/CheckBloodSourceJob.java#check_sql_blood_source",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "Jinjava",
            "SQLUtils",
            "accept",
            "createSchemaStatVisitor",
            "getTables",
            "insertSelective",
            "parseStatements",
            "render"
        ],
        "target_code": "public static List<BloodSourceInfo> check_sql_blood_source(String version, String product_code) {\n        BloodSourceMapper bloodSourceMappeer = (BloodSourceMapper) SpringContext.getBean(\"bloodSourceMapper\");\n        EtlTaskJdbcMapper etlTaskJdbcMapper = (EtlTaskJdbcMapper) SpringContext.getBean(\"etlTaskJdbcMapper\");\n        DataSourcesMapper dataSourcesMapper = (DataSourcesMapper) SpringContext.getBean(\"dataSourcesMapper\");\n        List<EtlTaskJdbcInfo> etlTaskJdbcInfos = etlTaskJdbcMapper.selectAll();\n        List<BloodSourceInfo> bsis = new ArrayList<>();\n        for (EtlTaskJdbcInfo etlTaskJdbcInfo : etlTaskJdbcInfos) {\n            if(!etlTaskJdbcInfo.getProduct_code().equalsIgnoreCase(product_code)){\n                continue;\n            }\n            ArrayList input_tables = new ArrayList<String>();\n            ArrayList output_tables = new ArrayList<String>();\n            DataSourcesInfo ds = dataSourcesMapper.selectByPrimaryKey(etlTaskJdbcInfo.getData_sources_choose_input());\n            String dbType = JdbcUtils.getDbType(ds.getUrl(), ds.getDriver());\n            Map<String, Object> jinJavaParam = getJinJavaParam(new Timestamp(System.currentTimeMillis()));\n            Jinjava jj = new Jinjava();\n            String etl_sql = jj.render(etlTaskJdbcInfo.getEtl_sql(), jinJavaParam);\n            String[] sqls = etl_sql.split(\";\\r\\n|;\\n\");\n            for (String sql : sqls) {\n                System.out.println(sql);\n                System.out.println(\"======\");\n                try {\n                    List<SQLStatement> sqlStatementList = SQLUtils.parseStatements(sql, dbType);\n                    SQLStatement stmt = sqlStatementList.get(0);\n                    SchemaStatVisitor ssv = SQLUtils.createSchemaStatVisitor(dbType);\n                    stmt.accept(ssv);\n                    for (Map.Entry<TableStat.Name, TableStat> entry : ssv.getTables().entrySet()) {\n\n                        String table_name = entry.getKey().getName();\n                        if (entry.getValue().getInsertCount() > 0 || entry.getValue().getUpdateCount() > 0 || entry.getValue().getDeleteCount() > 0 || entry.getValue().getMergeCount() > 0) {\n                            output_tables.add(table_name);\n                        }\n                        if (entry.getValue().getSelectCount() > 0 || entry.getValue().getCreateCount() > 0) {\n                            input_tables.add(table_name);\n                        }\n\n                    }\n\n                    BloodSourceInfo bsi = new BloodSourceInfo();\n                    bsi.setProduct_code(etlTaskJdbcInfo.getProduct_code());\n                    bsi.setContext(etlTaskJdbcInfo.getEtl_context());\n                    bsi.setOwner(etlTaskJdbcInfo.getOwner());\n                    bsi.setCreate_time(new Date());\n                    bsi.setInput_type(etlTaskJdbcInfo.getData_source_type_input());\n                    DataSourcesInfo dsi_input = dataSourcesMapper.selectByPrimaryKey(etlTaskJdbcInfo.getData_sources_choose_input());\n                    String md5 = DigestUtils.md5DigestAsHex((dsi_input.getData_source_type() + dsi_input.getUrl()).getBytes());\n                    bsi.setInput_md5(md5);\n                    dsi_input.setPassword(\"\");\n                    bsi.setInput_json(JsonUtil.formatJsonString(dsi_input));\n                    bsi.setInput(StringUtils.join(input_tables, \",\"));\n\n                    bsi.setOutput_md5(md5);\n                    dsi_input.setPassword(\"\");\n                    bsi.setOutput_json(JsonUtil.formatJsonString(dsi_input));\n                    bsi.setOutput_type(etlTaskJdbcInfo.getData_source_type_input());\n                    bsi.setOutput(StringUtils.join(output_tables, \",\"));\n                    bsi.setVersion(version);\n                    bloodSourceMappeer.insertSelective(bsi);\n                    bsis.add(bsi);\n                } catch (Exception e) {\n                    LogUtil.error(CheckBloodSourceJob.class, e);\n                    continue;\n                }\n            }\n        }\n        return bsis;\n    }",
        "idx": "352"
    },
    {
        "target_file_name": "CheckBloodSourceJob.java",
        "target_method": "src/main/java/com/zyc/zdh/job/CheckBloodSourceJob.java#check_spark_sql_blood_source",
        "project_url": "https://github.com/zhaoyachao/zdh_web",
        "commit_id": "b2423378a8bf83f159f19ce4e14eac71c939793a^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-65897",
        "project_name": "zdh_web",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "DigestUtils.md5DigestAsHex",
            "JsonUtil.formatJsonString",
            "SQLUtils.createSchemaStatVisitor",
            "SQLUtils.parseStatements",
            "SchemaStatVisitor.getTables"
        ],
        "target_code": "public static List<BloodSourceInfo> check_spark_sql_blood_source(String version, String product_code) {\n        BloodSourceMapper bloodSourceMappeer = (BloodSourceMapper) SpringContext.getBean(\"bloodSourceMapper\");\n        SqlTaskMapper sqlTaskMapper = (SqlTaskMapper) SpringContext.getBean(\"sqlTaskMapper\");\n        DataSourcesMapper dataSourcesMapper = (DataSourcesMapper) SpringContext.getBean(\"dataSourcesMapper\");\n        List<SqlTaskInfo> sqlTaskInfos = sqlTaskMapper.selectAll();\n        List<BloodSourceInfo> bsis = new ArrayList<>();\n        for (SqlTaskInfo sqlTaskInfo : sqlTaskInfos) {\n            if(!sqlTaskInfo.getProduct_code().equalsIgnoreCase(product_code)){\n                continue;\n            }\n            ArrayList input_tables = new ArrayList<String>();\n            ArrayList output_tables = new ArrayList<String>();\n            DataSourcesInfo ds = new DataSourcesInfo();//dataSourcesMapper.selectByPrimaryKey(sqlTaskInfo.getData_sources_choose_input());\n            ds.setData_source_type(\"HIVE\");\n            ds.setData_source_context(\"默认HIVE数据源\");\n            ds.setUrl(\"\");\n\n            String dbType = \"hive\";//JdbcUtils.getDbType(ds.getUrl(), ds.getDriver());\n            String[] sqls = sqlTaskInfo.getEtl_sql().split(\";\\r\\n|;\\n\");\n            for (String sql : sqls) {\n                List<SQLStatement> sqlStatementList = SQLUtils.parseStatements(sql, dbType);\n                SQLStatement stmt = sqlStatementList.get(0);\n                SchemaStatVisitor ssv = SQLUtils.createSchemaStatVisitor(dbType);\n                stmt.accept(ssv);\n                for (Map.Entry<TableStat.Name, TableStat> entry : ssv.getTables().entrySet()) {\n\n                    String table_name = entry.getKey().getName();\n                    if (entry.getValue().getInsertCount() > 0 || entry.getValue().getUpdateCount() > 0 || entry.getValue().getDeleteCount() > 0 || entry.getValue().getMergeCount() > 0) {\n                        output_tables.add(table_name);\n                    }\n                    if (entry.getValue().getSelectCount() > 0 || entry.getValue().getCreateCount() > 0) {\n                        input_tables.add(table_name);\n                    }\n\n                }\n\n                BloodSourceInfo bsi = new BloodSourceInfo();\n                bsi.setProduct_code(sqlTaskInfo.getProduct_code());\n                bsi.setContext(sqlTaskInfo.getSql_context());\n                bsi.setOwner(sqlTaskInfo.getOwner());\n                bsi.setCreate_time(new Date());\n                bsi.setInput_type(ds.getData_source_type());\n                //DataSourcesInfo dsi_input = dataSourcesMapper.selectByPrimaryKey(sqlTaskInfo.getData_sources_choose_input());\n                String md5 = DigestUtils.md5DigestAsHex((ds.getData_source_type() + ds.getUrl()).getBytes());\n                bsi.setInput_json(JsonUtil.formatJsonString(ds));\n                bsi.setInput_md5(md5);\n                bsi.setInput(StringUtils.join(input_tables, \",\"));\n\n                DataSourcesInfo dsi_output = dataSourcesMapper.selectByPrimaryKey(sqlTaskInfo.getData_sources_choose_output());\n                if(dsi_output == null) {\n                    continue;\n                }\n                String md5_output = DigestUtils.md5DigestAsHex((dsi_output.getData_source_type() + dsi_output.getUrl()).getBytes());\n\n                bsi.setOutput_md5(md5_output);\n                bsi.setOutput_type(sqlTaskInfo.getData_source_type_output());\n                String out = dsi_output.getData_source_type().equalsIgnoreCase(\"jdbc\") ? sqlTaskInfo.getData_sources_table_name_output() : sqlTaskInfo.getData_sources_file_name_output();\n                dsi_output.setPassword(\"\");\n                bsi.setOutput_json(JsonUtil.formatJsonString(dsi_output));\n                if(!StringUtils.isEmpty(out)) {\n                    output_tables.add(out);\n                }\n                bsi.setOutput(StringUtils.join(output_tables, \",\"));\n                bsi.setVersion(version);\n                bloodSourceMappeer.insertSelective(bsi);\n                System.out.println(\"Spark: \"+JsonUtil.formatJsonString(bsi));\n                bsis.add(bsi);\n            }\n\n        }\n\n        return bsis;\n\n    }",
        "idx": "353"
    },
    {
        "target_file_name": "LDAPStorageProviderFactory.java",
        "target_method": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java#init",
        "project_url": "https://github.com/keycloak/keycloak",
        "commit_id": "754c070cf8ca187dcc71f0f72ff3130ff2195328",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-13467",
        "project_name": "keycloak",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "System.getProperty",
            "System.setProperty"
        ],
        "target_code": "@Override\n    public void init(Config.Scope config) {\n        if (config.getBoolean(SECURE_REFERRAL, SECURE_REFERRAL_DEFAULT)) {\n            setObjectFactoryBuilder();\n        } else {\n            logger.warnf(\"Insecure LDAP referrals are enabled. The option 'secure-referral' is deprecated and it will be removed in future releases.\");\n        }\n\n        // set connection pooling for plain and tls protocols by default\n        if (System.getProperty(LDAP_CONNECTION_POOL_PROTOCOL) == null) {\n            System.setProperty(LDAP_CONNECTION_POOL_PROTOCOL, \"plain ssl\");\n        }\n\n        this.ldapStoreRegistry = new LDAPIdentityStoreRegistry();\n    }",
        "idx": "354"
    },
    {
        "target_file_name": "LDAPStorageProviderFactory.java",
        "target_method": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java#init",
        "project_url": "https://github.com/keycloak/keycloak",
        "commit_id": "754c070cf8ca187dcc71f0f72ff3130ff2195328^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-13467",
        "project_name": "keycloak",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "System.getProperty",
            "System.setProperty"
        ],
        "target_code": "@Override\n    public void init(Config.Scope config) {\n        // set connection pooling for plain and tls protocols by default\n        if (System.getProperty(LDAP_CONNECTION_POOL_PROTOCOL) == null) {\n            System.setProperty(LDAP_CONNECTION_POOL_PROTOCOL, \"plain ssl\");\n        }\n        this.ldapStoreRegistry = new LDAPIdentityStoreRegistry();\n    }",
        "idx": "355"
    },
    {
        "target_file_name": "AppStoreController.java",
        "target_method": "src/com/fuse/actions/appstore/AppStoreController.java#authorization",
        "project_url": "https://github.com/factionsecurity/faction",
        "commit_id": "c6389f1c76175b7c1c68d1a87b389311b16c62c3",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-66022",
        "project_name": "faction",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "AuditLog.notAuthorized"
        ],
        "target_code": "@Before(priority=1)\n\tpublic String authorization() {\n\t\t if(!this.isAppStoreEnabled() || !this.isAcadmin()) { \n\t\t\t AuditLog.notAuthorized( this,\n\t\t\t\t \"Invalid Access to App Store\", true);\n\t\t\t return LOGIN; \n\t\t }else {\n\t\t\t return null;\n\t\t }\n\t}",
        "idx": "356"
    },
    {
        "target_file_name": "InstallExtensionController.java",
        "target_method": "src/com/fuse/actions/appstore/InstallExtensionController.java#authorization",
        "project_url": "https://github.com/factionsecurity/faction",
        "commit_id": "c6389f1c76175b7c1c68d1a87b389311b16c62c3",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-66022",
        "project_name": "faction",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "AuditLog.notAuthorized"
        ],
        "target_code": "@Before(priority=1)\n\tpublic String authorization() {\n\t\t if(!this.isAppStoreEnabled() || !this.isAcadmin()) { \n\t\t\t AuditLog.notAuthorized( this,\n\t\t\t\t \"Invalid Access to App Store\", true);\n\t\t\t return LOGIN; \n\t\t }else {\n\t\t\t return null;\n\t\t }\n\t}",
        "idx": "357"
    },
    {
        "target_file_name": "AppStoreController.java",
        "target_method": "src/com/fuse/actions/appstore/AppStoreController.java#authorization",
        "project_url": "https://github.com/factionsecurity/faction",
        "commit_id": "c6389f1c76175b7c1c68d1a87b389311b16c62c3^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-66022",
        "project_name": "faction",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "AuditLog.notAuthorized"
        ],
        "target_code": "@Before(priority=1)\n\tpublic String authorization() {\n\t\t if(this.isAppStoreEnabled() && !this.isAcadmin()) { \n\t\t\t AuditLog.notAuthorized( this,\n\t\t\t\t \"Invalid Access to App Store\", true);\n\t\t\t return LOGIN; \n\t\t }else {\n\t\t\t return null;\n\t\t }\n\t}",
        "idx": "358"
    },
    {
        "target_file_name": "InstallExtensionController.java",
        "target_method": "src/com/fuse/actions/appstore/InstallExtensionController.java#authorization",
        "project_url": "https://github.com/factionsecurity/faction",
        "commit_id": "c6389f1c76175b7c1c68d1a87b389311b16c62c3^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-66022",
        "project_name": "faction",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "AuditLog.notAuthorized"
        ],
        "target_code": "@Before(priority=1)\n\tpublic String authorization() {\n\t\t if(this.isAppStoreEnabled() && !this.isAcadmin()) { \n\t\t\t AuditLog.notAuthorized( this,\n\t\t\t\t \"Invalid Access to App Store\", true);\n\t\t\t return LOGIN; \n\t\t }else {\n\t\t\t return null;\n\t\t }\n\t}",
        "idx": "359"
    },
    {
        "target_file_name": "PaginationUtil.java",
        "target_method": "api/src/main/java/com/okta/sdk/helper/PaginationUtil.java#getAfter",
        "project_url": "https://github.com/okta/okta-sdk-java",
        "commit_id": "1daa9229a70fc38fb252aeaa637f82d0b0729b3f",
        "CWE_id": "CWE-401",
        "CVE_id": "CVE-2025-66033",
        "project_name": "okta-sdk-java",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getAfter",
            "getNextPage"
        ],
        "target_code": "@Deprecated(forRemoval = true, since = \"24.1.0\")\n    public static String getAfter(ApiClient apiClient) {\n        return getAfter(getNextPage(apiClient));\n    }",
        "idx": "360"
    },
    {
        "target_file_name": "PaginationUtil.java",
        "target_method": "api/src/main/java/com/okta/sdk/helper/PaginationUtil.java#getNextPage",
        "project_url": "https://github.com/okta/okta-sdk-java",
        "commit_id": "1daa9229a70fc38fb252aeaa637f82d0b0729b3f",
        "CWE_id": "CWE-401",
        "CVE_id": "CVE-2025-66033",
        "project_name": "okta-sdk-java",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "replaceAll",
            "split"
        ],
        "target_code": "@SuppressWarnings(\"removal\")\n    private static String getNextPage(ApiClient apiClient) {\n\n        Assert.notNull(apiClient, \"apiClient cannot be null\");\n        Assert.notNull(apiClient.getResponseHeaders(), \"apiClient is missing response headers\");\n        Assert.notNull(apiClient.getResponseHeaders().get(\"link\"), \"apiClient is missing 'link' response headers\");\n\n        List<String> linkHeaders = apiClient.getResponseHeaders().get(\"link\");\n\n        String nextPage = null;\n\n        for (String linkHeader : linkHeaders) {\n            String[] parts = linkHeader.split(\"; *\");\n            String url = parts[0]\n                .replaceAll(\"<\", \"\")\n                .replaceAll(\">\", \"\");\n            String rel = parts[1];\n            if (rel.equals(\"rel=\\\"next\\\"\")) {\n                nextPage = url;\n            }\n        }\n\n        log.debug(\"Next Page: {}\", nextPage);\n        return nextPage;\n    }",
        "idx": "361"
    },
    {
        "target_file_name": "PaginationUtil.java",
        "target_method": "api/src/main/java/com/okta/sdk/helper/PaginationUtil.java#getAfter",
        "project_url": "https://github.com/okta/okta-sdk-java",
        "commit_id": "1daa9229a70fc38fb252aeaa637f82d0b0729b3f^",
        "CWE_id": "CWE-401",
        "CVE_id": "CVE-2025-66033",
        "project_name": "okta-sdk-java",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getAfter",
            "getNextPage"
        ],
        "target_code": "public static String getAfter(ApiClient apiClient) {\n        return getAfter(getNextPage(apiClient));\n    }",
        "idx": "362"
    },
    {
        "target_file_name": "PaginationUtil.java",
        "target_method": "api/src/main/java/com/okta/sdk/helper/PaginationUtil.java#getNextPage",
        "project_url": "https://github.com/okta/okta-sdk-java",
        "commit_id": "1daa9229a70fc38fb252aeaa637f82d0b0729b3f^",
        "CWE_id": "CWE-401",
        "CVE_id": "CVE-2025-66033",
        "project_name": "okta-sdk-java",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "replaceAll",
            "split"
        ],
        "target_code": "private static String getNextPage(ApiClient apiClient) {\n\n        Assert.notNull(apiClient, \"apiClient cannot be null\");\n        Assert.notNull(apiClient.getResponseHeaders(), \"apiClient is missing response headers\");\n        Assert.notNull(apiClient.getResponseHeaders().get(\"link\"), \"apiClient is missing 'link' response headers\");\n\n        List<String> linkHeaders = apiClient.getResponseHeaders().get(\"link\");\n\n        String nextPage = null;\n\n        for (String linkHeader : linkHeaders) {\n            String[] parts = linkHeader.split(\"; *\");\n            String url = parts[0]\n                .replaceAll(\"<\", \"\")\n                .replaceAll(\">\", \"\");\n            String rel = parts[1];\n            if (rel.equals(\"rel=\\\"next\\\"\")) {\n                nextPage = url;\n            }\n        }\n\n        log.debug(\"Next Page: {}\", nextPage);\n        return nextPage;\n    }",
        "idx": "363"
    },
    {
        "target_file_name": "KafkaConnectCluster.java",
        "target_method": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaConnectCluster.java#generateRole",
        "project_url": "https://github.com/strimzi/strimzi-kafka-operator",
        "commit_id": "c8a14935e99c91eb0dd865431f46515da9f82ccc",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-66623",
        "project_name": "strimzi-kafka-operator",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PolicyRuleBuilder",
            "RbacUtils.createRole",
            "build",
            "withApiGroups",
            "withResourceNames",
            "withResources",
            "withVerbs"
        ],
        "target_code": "public Role generateRole() {\n        List<String> certSecretNames = secretsToAllowAccessTo();\n\n        if (certSecretNames.isEmpty()) {\n            return null;\n        } else {\n            List<PolicyRule> rules = List.of(new PolicyRuleBuilder()\n                    .withApiGroups(\"\")\n                    .withResources(\"secrets\")\n                    .withVerbs(\"get\")\n                    .withResourceNames(certSecretNames)\n                    .build());\n\n            return RbacUtils.createRole(componentName, namespace, rules, labels, ownerReference, null);\n        }\n    }",
        "idx": "364"
    },
    {
        "target_file_name": "KafkaConnectCluster.java",
        "target_method": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaConnectCluster.java#generateRoleBindingForRole",
        "project_url": "https://github.com/strimzi/strimzi-kafka-operator",
        "commit_id": "c8a14935e99c91eb0dd865431f46515da9f82ccc",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-66623",
        "project_name": "strimzi-kafka-operator",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "RbacUtils.createRoleBinding",
            "RoleRefBuilder",
            "SubjectBuilder"
        ],
        "target_code": "public RoleBinding generateRoleBindingForRole() {\n        if (secretsToAllowAccessTo().isEmpty()) {\n            return null;\n        } else {\n            Subject subject = new SubjectBuilder()\n                    .withKind(\"ServiceAccount\")\n                    .withName(componentName)\n                    .withNamespace(namespace)\n                    .build();\n\n            RoleRef roleRef = new RoleRefBuilder()\n                    .withName(componentName)\n                    .withApiGroup(\"rbac.authorization.k8s.io\")\n                    .withKind(\"Role\")\n                    .build();\n\n            return RbacUtils.createRoleBinding(getRoleBindingName(), namespace, roleRef, List.of(subject), labels, ownerReference, null);\n        }\n    }",
        "idx": "365"
    },
    {
        "target_file_name": "KafkaCluster.java",
        "target_method": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java#generateRole",
        "project_url": "https://github.com/strimzi/strimzi-kafka-operator",
        "commit_id": "c8a14935e99c91eb0dd865431f46515da9f82ccc",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-66623",
        "project_name": "strimzi-kafka-operator",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PolicyRuleBuilder",
            "RbacUtils.createRole",
            "build",
            "withApiGroups",
            "withResourceNames",
            "withResources",
            "withVerbs"
        ],
        "target_code": "public Role generateRole() {\n        Set<String> certSecretNames = new HashSet<>();\n        certSecretNames.add(KafkaResources.clusterCaCertificateSecretName(cluster));\n        certSecretNames.addAll(nodes().stream().map(NodeRef::podName).toList());\n\n        for (GenericKafkaListener listener : listeners) {\n            if (listener.isTls()) {\n                if (listener.getConfiguration() != null && listener.getConfiguration().getBrokerCertChainAndKey() != null) {\n                    certSecretNames.add(listener.getConfiguration().getBrokerCertChainAndKey().getSecretName());\n                }\n            }\n\n            if (listener.getAuth() instanceof KafkaListenerAuthenticationTls) {\n                certSecretNames.add(KafkaResources.clientsCaCertificateSecretName(cluster));\n            }\n        }\n\n        if (certSecretNames.isEmpty()) {\n            // This should never happen but just in case it does, we throw an error\n            throw new RuntimeException(\"No TLS certificate secrets found for the Kafka cluster.\");\n        } else {\n            List<PolicyRule> rules = List.of(new PolicyRuleBuilder()\n                    .withApiGroups(\"\")\n                    .withResources(\"secrets\")\n                    .withVerbs(\"get\")\n                    .withResourceNames(certSecretNames.stream().toList())\n                    .build());\n\n            return RbacUtils.createRole(componentName, namespace, rules, labels, ownerReference, null);\n        }\n    }",
        "idx": "366"
    },
    {
        "target_file_name": "KafkaConnectCluster.java",
        "target_method": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaConnectCluster.java#generateRole",
        "project_url": "https://github.com/strimzi/strimzi-kafka-operator",
        "commit_id": "c8a14935e99c91eb0dd865431f46515da9f82ccc^",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-66623",
        "project_name": "strimzi-kafka-operator",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "PolicyRuleBuilder",
            "RbacUtils.createRole",
            "build",
            "withApiGroups",
            "withResourceNames",
            "withResources",
            "withVerbs"
        ],
        "target_code": "@SuppressWarnings(\"deprecation\") // OAuth authentication is deprecated\n    public Role generateRole() {\n        List<String> certSecretNames = new ArrayList<>();\n        if (tls != null && tls.getTrustedCertificates() != null && !tls.getTrustedCertificates().isEmpty()) {\n            certSecretNames.add(KafkaConnectResources.internalTlsTrustedCertsSecretName(cluster));\n        }\n\n        if (authentication != null) {\n            if (authentication instanceof KafkaClientAuthenticationTls tlsAuth && tlsAuth.getCertificateAndKey() != null) {\n                certSecretNames.add(tlsAuth.getCertificateAndKey().getSecretName());\n            } else if (authentication instanceof KafkaClientAuthenticationOAuth oauth && oauth.getTlsTrustedCertificates() != null\n                    && !oauth.getTlsTrustedCertificates().isEmpty()) {\n                certSecretNames.add(KafkaConnectResources.internalOauthTrustedCertsSecretName(cluster));\n            }\n        }\n\n        List<PolicyRule> rules = List.of(new PolicyRuleBuilder()\n                .withApiGroups(\"\")\n                .withResources(\"secrets\")\n                .withVerbs(\"get\")\n                .withResourceNames(certSecretNames)\n                .build());\n\n        return RbacUtils.createRole(componentName, namespace, rules, labels, ownerReference, null);\n    }",
        "idx": "367"
    },
    {
        "target_file_name": "KafkaConnectCluster.java",
        "target_method": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaConnectCluster.java#generateRoleBindingForRole",
        "project_url": "https://github.com/strimzi/strimzi-kafka-operator",
        "commit_id": "c8a14935e99c91eb0dd865431f46515da9f82ccc^",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-66623",
        "project_name": "strimzi-kafka-operator",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "RbacUtils.createRoleBinding",
            "RoleRefBuilder",
            "SubjectBuilder"
        ],
        "target_code": "public RoleBinding generateRoleBindingForRole() {\n        Subject subject = new SubjectBuilder()\n                .withKind(\"ServiceAccount\")\n                .withName(componentName)\n                .withNamespace(namespace)\n                .build();\n\n        RoleRef roleRef = new RoleRefBuilder()\n                .withName(componentName)\n                .withApiGroup(\"rbac.authorization.k8s.io\")\n                .withKind(\"Role\")\n                .build();\n\n        return RbacUtils.createRoleBinding(getRoleBindingName(), namespace, roleRef, List.of(subject), labels, ownerReference, null);\n    }",
        "idx": "368"
    },
    {
        "target_file_name": "KafkaCluster.java",
        "target_method": "cluster-operator/src/main/java/io/strimzi/operator/cluster/model/KafkaCluster.java#generateRole",
        "project_url": "https://github.com/strimzi/strimzi-kafka-operator",
        "commit_id": "c8a14935e99c91eb0dd865431f46515da9f82ccc^",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-66623",
        "project_name": "strimzi-kafka-operator",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "PolicyRuleBuilder",
            "RbacUtils.createRole",
            "withApiGroups",
            "withResourceNames",
            "withResources",
            "withVerbs"
        ],
        "target_code": "public Role generateRole() {\n        Set<String> certSecretNames = new HashSet<>();\n        certSecretNames.add(KafkaResources.clusterCaCertificateSecretName(cluster));\n        certSecretNames.addAll(nodes().stream().map(NodeRef::podName).toList());\n\n        for (GenericKafkaListener listener : listeners) {\n            if (listener.isTls()) {\n                if (listener.getConfiguration() != null && listener.getConfiguration().getBrokerCertChainAndKey() != null) {\n                    certSecretNames.add(listener.getConfiguration().getBrokerCertChainAndKey().getSecretName());\n                }\n            }\n\n            if (listener.getAuth() instanceof KafkaListenerAuthenticationTls) {\n                certSecretNames.add(KafkaResources.clientsCaCertificateSecretName(cluster));\n            }\n        }\n\n        List<PolicyRule> rules = List.of(new PolicyRuleBuilder()\n                .withApiGroups(\"\")\n                .withResources(\"secrets\")\n                .withVerbs(\"get\")\n                .withResourceNames(certSecretNames.stream().toList())\n                .build());\n\n        return RbacUtils.createRole(componentName, namespace, rules, labels, ownerReference, null);\n    }",
        "idx": "369"
    },
    {
        "target_file_name": "SnappyRawDecompressor.java",
        "target_method": "src/main/java/io/airlift/compress/v3/snappy/SnappyRawDecompressor.java#uncompressAll",
        "project_url": "https://github.com/airlift/aircompressor",
        "commit_id": "ff12c4d5757c9d6d1de3d39a10402f1f84f9b765",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-67721",
        "project_name": "aircompressor",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "UNSAFE.copyMemory",
            "UNSAFE.getByte",
            "UNSAFE.getInt",
            "UNSAFE.getLong",
            "UNSAFE.putByte",
            "UNSAFE.putInt",
            "UNSAFE.putLong"
        ],
        "target_code": "private static int uncompressAll(\n            final Object inputBase,\n            final long inputAddress,\n            final long inputLimit,\n            final Object outputBase,\n            final long outputAddress,\n            final long outputLimit)\n    {\n        final long fastOutputLimit = outputLimit - SIZE_OF_LONG; // maximum offset in output buffer to which it's safe to write long-at-a-time\n\n        long output = outputAddress;\n        long input = inputAddress;\n\n        while (input < inputLimit) {\n            int opCode = UNSAFE.getByte(inputBase, input++) & 0xFF;\n            int entry = opLookupTable[opCode] & 0xFFFF;\n\n            int trailerBytes = entry >>> 11;\n            int trailer = 0;\n            if (input + SIZE_OF_INT < inputLimit) {\n                trailer = UNSAFE.getInt(inputBase, input) & wordmask[trailerBytes];\n            }\n            else {\n                if (input + trailerBytes > inputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                switch (trailerBytes) {\n                    case 4:\n                        trailer = (UNSAFE.getByte(inputBase, input + 3) & 0xff) << 24;\n                    case 3:\n                        trailer |= (UNSAFE.getByte(inputBase, input + 2) & 0xff) << 16;\n                    case 2:\n                        trailer |= (UNSAFE.getByte(inputBase, input + 1) & 0xff) << 8;\n                    case 1:\n                        trailer |= (UNSAFE.getByte(inputBase, input) & 0xff);\n                }\n            }\n            if (trailer < 0) {\n                throw new MalformedInputException(input - inputAddress);\n            }\n            input += trailerBytes;\n\n            int length = entry & 0xff;\n            if (length == 0) {\n                continue;\n            }\n\n            if ((opCode & 0x3) == LITERAL) {\n                int literalLength = length + trailer;\n                if (literalLength < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n\n                // copy literal\n                long literalOutputLimit = output + literalLength;\n                if (literalOutputLimit > fastOutputLimit || input + literalLength > inputLimit - SIZE_OF_LONG) {\n                    if (literalOutputLimit > outputLimit || input + literalLength > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n\n                    // slow, precise copy\n                    UNSAFE.copyMemory(inputBase, input, outputBase, output, literalLength);\n                    input += literalLength;\n                    output += literalLength;\n                }\n                else {\n                    // fast copy. We may over-copy but there's enough room in input and output to not overrun them\n                    do {\n                        UNSAFE.putLong(outputBase, output, UNSAFE.getLong(inputBase, input));\n                        input += SIZE_OF_LONG;\n                        output += SIZE_OF_LONG;\n                    }\n                    while (output < literalOutputLimit);\n                    input -= (output - literalOutputLimit); // adjust index if we over-copied\n                    output = literalOutputLimit;\n                }\n            }\n            else {\n                // matchOffset/256 is encoded in bits 8..10.  By just fetching\n                // those bits, we get matchOffset (since the bit-field starts at\n                // bit 8).\n                int matchOffset = entry & 0x700;\n                matchOffset += trailer;\n                if (matchOffset <= 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n\n                long matchAddress = output - matchOffset;\n                if (matchAddress < outputAddress || output + length > outputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                long matchOutputLimit = output + length;\n                if (matchOutputLimit > outputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n\n                if (output > fastOutputLimit) {\n                    // slow match copy\n                    while (output < matchOutputLimit) {\n                        UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                    }\n                }\n                else {\n                    // copy repeated sequence\n                    if (matchOffset < SIZE_OF_LONG) {\n                        // 8 bytes apart so that we can copy long-at-a-time below\n                        int increment32 = DEC_32_TABLE[matchOffset];\n                        int decrement64 = DEC_64_TABLE[matchOffset];\n\n                        UNSAFE.putByte(outputBase, output, UNSAFE.getByte(outputBase, matchAddress));\n                        UNSAFE.putByte(outputBase, output + 1, UNSAFE.getByte(outputBase, matchAddress + 1));\n                        UNSAFE.putByte(outputBase, output + 2, UNSAFE.getByte(outputBase, matchAddress + 2));\n                        UNSAFE.putByte(outputBase, output + 3, UNSAFE.getByte(outputBase, matchAddress + 3));\n                        output += SIZE_OF_INT;\n                        matchAddress += increment32;\n\n                        UNSAFE.putInt(outputBase, output, UNSAFE.getInt(outputBase, matchAddress));\n                        output += SIZE_OF_INT;\n                        matchAddress -= decrement64;\n                    }\n                    else {\n                        UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                        matchAddress += SIZE_OF_LONG;\n                        output += SIZE_OF_LONG;\n                    }\n\n                    if (matchOutputLimit > fastOutputLimit) {\n                        while (output < fastOutputLimit) {\n                            UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                            matchAddress += SIZE_OF_LONG;\n                            output += SIZE_OF_LONG;\n                        }\n\n                        while (output < matchOutputLimit) {\n                            UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                        }\n                    }\n                    else {\n                        while (output < matchOutputLimit) {\n                            UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                            matchAddress += SIZE_OF_LONG;\n                            output += SIZE_OF_LONG;\n                        }\n                    }\n                }\n                output = matchOutputLimit; // correction in case we over-copied\n            }\n        }\n\n        return (int) (output - outputAddress);\n    }",
        "idx": "370"
    },
    {
        "target_file_name": "SnappyRawDecompressor.java",
        "target_method": "src/main/java/io/airlift/compress/v3/snappy/SnappyRawDecompressor.java#uncompressAll",
        "project_url": "https://github.com/airlift/aircompressor",
        "commit_id": "ff12c4d5757c9d6d1de3d39a10402f1f84f9b765^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-67721",
        "project_name": "aircompressor",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "UNSAFE.copyMemory",
            "UNSAFE.getByte",
            "UNSAFE.getInt",
            "UNSAFE.getLong",
            "UNSAFE.putByte",
            "UNSAFE.putInt",
            "UNSAFE.putLong"
        ],
        "target_code": "private static int uncompressAll(\n            final Object inputBase,\n            final long inputAddress,\n            final long inputLimit,\n            final Object outputBase,\n            final long outputAddress,\n            final long outputLimit)\n    {\n        final long fastOutputLimit = outputLimit - SIZE_OF_LONG; // maximum offset in output buffer to which it's safe to write long-at-a-time\n\n        long output = outputAddress;\n        long input = inputAddress;\n\n        while (input < inputLimit) {\n            int opCode = UNSAFE.getByte(inputBase, input++) & 0xFF;\n            int entry = opLookupTable[opCode] & 0xFFFF;\n\n            int trailerBytes = entry >>> 11;\n            int trailer = 0;\n            if (input + SIZE_OF_INT < inputLimit) {\n                trailer = UNSAFE.getInt(inputBase, input) & wordmask[trailerBytes];\n            }\n            else {\n                if (input + trailerBytes > inputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                switch (trailerBytes) {\n                    case 4:\n                        trailer = (UNSAFE.getByte(inputBase, input + 3) & 0xff) << 24;\n                    case 3:\n                        trailer |= (UNSAFE.getByte(inputBase, input + 2) & 0xff) << 16;\n                    case 2:\n                        trailer |= (UNSAFE.getByte(inputBase, input + 1) & 0xff) << 8;\n                    case 1:\n                        trailer |= (UNSAFE.getByte(inputBase, input) & 0xff);\n                }\n            }\n            if (trailer < 0) {\n                throw new MalformedInputException(input - inputAddress);\n            }\n            input += trailerBytes;\n\n            int length = entry & 0xff;\n            if (length == 0) {\n                continue;\n            }\n\n            if ((opCode & 0x3) == LITERAL) {\n                int literalLength = length + trailer;\n                if (literalLength < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n\n                // copy literal\n                long literalOutputLimit = output + literalLength;\n                if (literalOutputLimit > fastOutputLimit || input + literalLength > inputLimit - SIZE_OF_LONG) {\n                    if (literalOutputLimit > outputLimit || input + literalLength > inputLimit) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n\n                    // slow, precise copy\n                    UNSAFE.copyMemory(inputBase, input, outputBase, output, literalLength);\n                    input += literalLength;\n                    output += literalLength;\n                }\n                else {\n                    // fast copy. We may over-copy but there's enough room in input and output to not overrun them\n                    do {\n                        UNSAFE.putLong(outputBase, output, UNSAFE.getLong(inputBase, input));\n                        input += SIZE_OF_LONG;\n                        output += SIZE_OF_LONG;\n                    }\n                    while (output < literalOutputLimit);\n                    input -= (output - literalOutputLimit); // adjust index if we over-copied\n                    output = literalOutputLimit;\n                }\n            }\n            else {\n                // matchOffset/256 is encoded in bits 8..10.  By just fetching\n                // those bits, we get matchOffset (since the bit-field starts at\n                // bit 8).\n                int matchOffset = entry & 0x700;\n                matchOffset += trailer;\n                if (matchOffset < 0) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n\n                long matchAddress = output - matchOffset;\n                if (matchAddress < outputAddress || output + length > outputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                long matchOutputLimit = output + length;\n                if (matchOutputLimit > outputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n\n                if (output > fastOutputLimit) {\n                    // slow match copy\n                    while (output < matchOutputLimit) {\n                        UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                    }\n                }\n                else {\n                    // copy repeated sequence\n                    if (matchOffset < SIZE_OF_LONG) {\n                        // 8 bytes apart so that we can copy long-at-a-time below\n                        int increment32 = DEC_32_TABLE[matchOffset];\n                        int decrement64 = DEC_64_TABLE[matchOffset];\n\n                        UNSAFE.putByte(outputBase, output, UNSAFE.getByte(outputBase, matchAddress));\n                        UNSAFE.putByte(outputBase, output + 1, UNSAFE.getByte(outputBase, matchAddress + 1));\n                        UNSAFE.putByte(outputBase, output + 2, UNSAFE.getByte(outputBase, matchAddress + 2));\n                        UNSAFE.putByte(outputBase, output + 3, UNSAFE.getByte(outputBase, matchAddress + 3));\n                        output += SIZE_OF_INT;\n                        matchAddress += increment32;\n\n                        UNSAFE.putInt(outputBase, output, UNSAFE.getInt(outputBase, matchAddress));\n                        output += SIZE_OF_INT;\n                        matchAddress -= decrement64;\n                    }\n                    else {\n                        UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                        matchAddress += SIZE_OF_LONG;\n                        output += SIZE_OF_LONG;\n                    }\n\n                    if (matchOutputLimit > fastOutputLimit) {\n                        while (output < fastOutputLimit) {\n                            UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                            matchAddress += SIZE_OF_LONG;\n                            output += SIZE_OF_LONG;\n                        }\n\n                        while (output < matchOutputLimit) {\n                            UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                        }\n                    }\n                    else {\n                        while (output < matchOutputLimit) {\n                            UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                            matchAddress += SIZE_OF_LONG;\n                            output += SIZE_OF_LONG;\n                        }\n                    }\n                }\n                output = matchOutputLimit; // correction in case we over-copied\n            }\n        }\n\n        return (int) (output - outputAddress);\n    }",
        "idx": "371"
    },
    {
        "target_file_name": "Lz4RawDecompressor.java",
        "target_method": "src/main/java/io/airlift/compress/v3/lz4/Lz4RawDecompressor.java#decompress",
        "project_url": "https://github.com/airlift/aircompressor",
        "commit_id": "f2b489b398779b40c1ee29ddb11d7edef54ddc15",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-67721",
        "project_name": "aircompressor",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "UNSAFE.copyMemory",
            "UNSAFE.getByte",
            "UNSAFE.getLong",
            "UNSAFE.getShort",
            "UNSAFE.putByte",
            "UNSAFE.putInt",
            "UNSAFE.putLong"
        ],
        "target_code": "public static int decompress(\n            final Object inputBase,\n            final long inputAddress,\n            final long inputLimit,\n            final Object outputBase,\n            final long outputAddress,\n            final long outputLimit)\n    {\n        final long fastOutputLimit = outputLimit - SIZE_OF_LONG; // maximum offset in output buffer to which it's safe to write long-at-a-time\n\n        long input = inputAddress;\n        long output = outputAddress;\n\n        if (inputAddress == inputLimit) {\n            throw new MalformedInputException(0, \"input is empty\");\n        }\n\n        if (outputAddress == outputLimit) {\n            if (inputLimit - inputAddress == 1 && UNSAFE.getByte(inputBase, inputAddress) == 0) {\n                return 0;\n            }\n            return -1;\n        }\n\n        while (input < inputLimit) {\n            final int token = UNSAFE.getByte(inputBase, input++) & 0xFF;\n\n            // decode literal length\n            int literalLength = token >>> 4; // top-most 4 bits of token\n            if (literalLength == 0xF) {\n                if (input >= inputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                int value;\n                do {\n                    value = UNSAFE.getByte(inputBase, input++) & 0xFF;\n                    literalLength += value;\n                }\n                while (value == 255 && input < inputLimit - 15);\n            }\n            if (literalLength < 0) {\n                throw new MalformedInputException(input - inputAddress);\n            }\n\n            // copy literal\n            long literalEnd = input + literalLength;\n            long literalOutputLimit = output + literalLength;\n            if (literalOutputLimit > (fastOutputLimit - MIN_MATCH) || literalEnd > inputLimit - (OFFSET_SIZE + TOKEN_SIZE + LAST_LITERAL_SIZE)) {\n                // copy the last literal and finish\n                if (literalOutputLimit > outputLimit) {\n                    throw new MalformedInputException(input - inputAddress, \"attempt to write last literal outside of destination buffer\");\n                }\n\n                if (literalEnd != inputLimit) {\n                    throw new MalformedInputException(input - inputAddress, \"all input must be consumed\");\n                }\n\n                // slow, precise copy\n                UNSAFE.copyMemory(inputBase, input, outputBase, output, literalLength);\n                output += literalLength;\n                break;\n            }\n\n            // fast copy. We may overcopy but there's enough room in input and output to not overrun them\n            int index = 0;\n            do {\n                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(inputBase, input));\n                output += SIZE_OF_LONG;\n                input += SIZE_OF_LONG;\n                index += SIZE_OF_LONG;\n            }\n            while (index < literalLength);\n            output = literalOutputLimit;\n\n            input = literalEnd;\n\n            // get offset\n            // we know we can read two bytes because of the bounds check performed before copying the literal above\n            int offset = UNSAFE.getShort(inputBase, input) & 0xFFFF;\n            input += SIZE_OF_SHORT;\n\n            long matchAddress = output - offset;\n            if (matchAddress < outputAddress || matchAddress >= output) {\n                throw new MalformedInputException(input - inputAddress, \"offset outside destination buffer\");\n            }\n\n            // compute match length\n            int matchLength = token & 0xF; // bottom-most 4 bits of token\n            if (matchLength == 0xF) {\n                int value;\n                do {\n                    if (input > inputLimit - LAST_LITERAL_SIZE) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n\n                    value = UNSAFE.getByte(inputBase, input++) & 0xFF;\n                    matchLength += value;\n                }\n                while (value == 255);\n            }\n            matchLength += MIN_MATCH; // implicit length from initial 4-byte match in encoder\n            if (matchLength < 0) {\n                throw new MalformedInputException(input - inputAddress);\n            }\n\n            long matchOutputLimit = output + matchLength;\n\n            // at this point we have at least 12 bytes of space in the output buffer\n            // due to the fastLimit check before copying a literal, so no need to check again\n\n            // copy repeated sequence\n            if (offset < SIZE_OF_LONG) {\n                // 8 bytes apart so that we can copy long-at-a-time below\n                int increment32 = DEC_32_TABLE[offset];\n                int decrement64 = DEC_64_TABLE[offset];\n\n                UNSAFE.putByte(outputBase, output, UNSAFE.getByte(outputBase, matchAddress));\n                UNSAFE.putByte(outputBase, output + 1, UNSAFE.getByte(outputBase, matchAddress + 1));\n                UNSAFE.putByte(outputBase, output + 2, UNSAFE.getByte(outputBase, matchAddress + 2));\n                UNSAFE.putByte(outputBase, output + 3, UNSAFE.getByte(outputBase, matchAddress + 3));\n                output += SIZE_OF_INT;\n                matchAddress += increment32;\n\n                UNSAFE.putInt(outputBase, output, UNSAFE.getInt(outputBase, matchAddress));\n                output += SIZE_OF_INT;\n                matchAddress -= decrement64;\n            }\n            else {\n                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                matchAddress += SIZE_OF_LONG;\n                output += SIZE_OF_LONG;\n            }\n\n            if (matchOutputLimit > fastOutputLimit - MIN_MATCH) {\n                if (matchOutputLimit > outputLimit - LAST_LITERAL_SIZE) {\n                    throw new MalformedInputException(input - inputAddress, String.format(\"last %s bytes must be literals\", LAST_LITERAL_SIZE));\n                }\n\n                while (output < fastOutputLimit) {\n                    UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                    matchAddress += SIZE_OF_LONG;\n                    output += SIZE_OF_LONG;\n                }\n\n                while (output < matchOutputLimit) {\n                    UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                }\n            }\n            else {\n                int i = 0;\n                do {\n                    UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                    output += SIZE_OF_LONG;\n                    matchAddress += SIZE_OF_LONG;\n                    i += SIZE_OF_LONG;\n                }\n                while (i < matchLength - SIZE_OF_LONG); // first long copied previously\n            }\n\n            output = matchOutputLimit; // correction in case we overcopied\n        }\n\n        return (int) (output - outputAddress);\n    }",
        "idx": "372"
    },
    {
        "target_file_name": "Lz4RawDecompressor.java",
        "target_method": "src/main/java/io/airlift/compress/v3/lz4/Lz4RawDecompressor.java#decompress",
        "project_url": "https://github.com/airlift/aircompressor",
        "commit_id": "f2b489b398779b40c1ee29ddb11d7edef54ddc15^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-67721",
        "project_name": "aircompressor",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "UNSAFE.copyMemory",
            "UNSAFE.getByte",
            "UNSAFE.getInt",
            "UNSAFE.getLong",
            "UNSAFE.getShort",
            "UNSAFE.putByte",
            "UNSAFE.putInt",
            "UNSAFE.putLong"
        ],
        "target_code": "public static int decompress(\n            final Object inputBase,\n            final long inputAddress,\n            final long inputLimit,\n            final Object outputBase,\n            final long outputAddress,\n            final long outputLimit)\n    {\n        final long fastOutputLimit = outputLimit - SIZE_OF_LONG; // maximum offset in output buffer to which it's safe to write long-at-a-time\n\n        long input = inputAddress;\n        long output = outputAddress;\n\n        if (inputAddress == inputLimit) {\n            throw new MalformedInputException(0, \"input is empty\");\n        }\n\n        if (outputAddress == outputLimit) {\n            if (inputLimit - inputAddress == 1 && UNSAFE.getByte(inputBase, inputAddress) == 0) {\n                return 0;\n            }\n            return -1;\n        }\n\n        while (input < inputLimit) {\n            final int token = UNSAFE.getByte(inputBase, input++) & 0xFF;\n\n            // decode literal length\n            int literalLength = token >>> 4; // top-most 4 bits of token\n            if (literalLength == 0xF) {\n                if (input >= inputLimit) {\n                    throw new MalformedInputException(input - inputAddress);\n                }\n                int value;\n                do {\n                    value = UNSAFE.getByte(inputBase, input++) & 0xFF;\n                    literalLength += value;\n                }\n                while (value == 255 && input < inputLimit - 15);\n            }\n            if (literalLength < 0) {\n                throw new MalformedInputException(input - inputAddress);\n            }\n\n            // copy literal\n            long literalEnd = input + literalLength;\n            long literalOutputLimit = output + literalLength;\n            if (literalOutputLimit > (fastOutputLimit - MIN_MATCH) || literalEnd > inputLimit - (OFFSET_SIZE + TOKEN_SIZE + LAST_LITERAL_SIZE)) {\n                // copy the last literal and finish\n                if (literalOutputLimit > outputLimit) {\n                    throw new MalformedInputException(input - inputAddress, \"attempt to write last literal outside of destination buffer\");\n                }\n\n                if (literalEnd != inputLimit) {\n                    throw new MalformedInputException(input - inputAddress, \"all input must be consumed\");\n                }\n\n                // slow, precise copy\n                UNSAFE.copyMemory(inputBase, input, outputBase, output, literalLength);\n                output += literalLength;\n                break;\n            }\n\n            // fast copy. We may overcopy but there's enough room in input and output to not overrun them\n            int index = 0;\n            do {\n                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(inputBase, input));\n                output += SIZE_OF_LONG;\n                input += SIZE_OF_LONG;\n                index += SIZE_OF_LONG;\n            }\n            while (index < literalLength);\n            output = literalOutputLimit;\n\n            input = literalEnd;\n\n            // get offset\n            // we know we can read two bytes because of the bounds check performed before copying the literal above\n            int offset = UNSAFE.getShort(inputBase, input) & 0xFFFF;\n            input += SIZE_OF_SHORT;\n\n            long matchAddress = output - offset;\n            if (matchAddress < outputAddress) {\n                throw new MalformedInputException(input - inputAddress, \"offset outside destination buffer\");\n            }\n\n            // compute match length\n            int matchLength = token & 0xF; // bottom-most 4 bits of token\n            if (matchLength == 0xF) {\n                int value;\n                do {\n                    if (input > inputLimit - LAST_LITERAL_SIZE) {\n                        throw new MalformedInputException(input - inputAddress);\n                    }\n\n                    value = UNSAFE.getByte(inputBase, input++) & 0xFF;\n                    matchLength += value;\n                }\n                while (value == 255);\n            }\n            matchLength += MIN_MATCH; // implicit length from initial 4-byte match in encoder\n            if (matchLength < 0) {\n                throw new MalformedInputException(input - inputAddress);\n            }\n\n            long matchOutputLimit = output + matchLength;\n\n            // at this point we have at least 12 bytes of space in the output buffer\n            // due to the fastLimit check before copying a literal, so no need to check again\n\n            // copy repeated sequence\n            if (offset < SIZE_OF_LONG) {\n                // 8 bytes apart so that we can copy long-at-a-time below\n                int increment32 = DEC_32_TABLE[offset];\n                int decrement64 = DEC_64_TABLE[offset];\n\n                UNSAFE.putByte(outputBase, output, UNSAFE.getByte(outputBase, matchAddress));\n                UNSAFE.putByte(outputBase, output + 1, UNSAFE.getByte(outputBase, matchAddress + 1));\n                UNSAFE.putByte(outputBase, output + 2, UNSAFE.getByte(outputBase, matchAddress + 2));\n                UNSAFE.putByte(outputBase, output + 3, UNSAFE.getByte(outputBase, matchAddress + 3));\n                output += SIZE_OF_INT;\n                matchAddress += increment32;\n\n                UNSAFE.putInt(outputBase, output, UNSAFE.getInt(outputBase, matchAddress));\n                output += SIZE_OF_INT;\n                matchAddress -= decrement64;\n            }\n            else {\n                UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                matchAddress += SIZE_OF_LONG;\n                output += SIZE_OF_LONG;\n            }\n\n            if (matchOutputLimit > fastOutputLimit - MIN_MATCH) {\n                if (matchOutputLimit > outputLimit - LAST_LITERAL_SIZE) {\n                    throw new MalformedInputException(input - inputAddress, String.format(\"last %s bytes must be literals\", LAST_LITERAL_SIZE));\n                }\n\n                while (output < fastOutputLimit) {\n                    UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                    matchAddress += SIZE_OF_LONG;\n                    output += SIZE_OF_LONG;\n                }\n\n                while (output < matchOutputLimit) {\n                    UNSAFE.putByte(outputBase, output++, UNSAFE.getByte(outputBase, matchAddress++));\n                }\n            }\n            else {\n                int i = 0;\n                do {\n                    UNSAFE.putLong(outputBase, output, UNSAFE.getLong(outputBase, matchAddress));\n                    output += SIZE_OF_LONG;\n                    matchAddress += SIZE_OF_LONG;\n                    i += SIZE_OF_LONG;\n                }\n                while (i < matchLength - SIZE_OF_LONG); // first long copied previously\n            }\n\n            output = matchOutputLimit; // correction in case we overcopied\n        }\n\n        return (int) (output - outputAddress);\n    }",
        "idx": "373"
    },
    {
        "target_file_name": "Altcha.java",
        "target_method": "src/main/java/org/altcha/altcha/Altcha.java#createChallenge",
        "project_url": "https://github.com/altcha-org/altcha-lib-java",
        "commit_id": "69277651fdd6418ae10bf3a088901506f9c62114",
        "CWE_id": "CWE-347",
        "CVE_id": "CVE-2025-68113",
        "project_name": "altcha-lib-java",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "hashHex",
            "hmacHex",
            "randomBytes"
        ],
        "target_code": "public static Challenge createChallenge(ChallengeOptions options) throws Exception {\n        Algorithm algorithm = options.algorithm != null ? options.algorithm : DEFAULT_ALGORITHM;\n        long maxNumber = options.maxNumber != null ? options.maxNumber : DEFAULT_MAX_NUMBER;\n        long saltLength = options.saltLength != null ? options.saltLength : DEFAULT_SALT_LENGTH;\n\n        Map<String, String> params = options.params;\n        if (options.expires != null) {\n            params.put(\"expires\", options.expires.toString());\n        }\n\n        String salt = options.salt != null ? options.salt : bytesToHex(randomBytes((int) saltLength));\n        if (!params.isEmpty()) {\n            salt += \"?\" + encodeParams(params);\n        }\n\n        // Add a delimiter to prevent parameter splicing\n        if (!salt.endsWith(\"&\")) {\n            salt += \"&\";\n        }\n\n        long number = options.number != null ? options.number\n                : (options.secureRandomNumber ? randomIntSecure(maxNumber) : randomInt(maxNumber));\n        String challengeStr = hashHex(algorithm, salt + number);\n\n        String signature = hmacHex(algorithm, challengeStr.getBytes(StandardCharsets.UTF_8), options.hmacKey);\n\n        Challenge challenge = new Challenge();\n        challenge.algorithm = algorithm.getName();\n        challenge.challenge = challengeStr;\n        challenge.maxnumber = maxNumber;\n        challenge.salt = salt;\n        challenge.signature = signature;\n\n        return challenge;\n    }",
        "idx": "374"
    },
    {
        "target_file_name": "Altcha.java",
        "target_method": "src/main/java/org/altcha/altcha/Altcha.java#createChallenge",
        "project_url": "https://github.com/altcha-org/altcha-lib-java",
        "commit_id": "69277651fdd6418ae10bf3a088901506f9c62114^",
        "CWE_id": "CWE-347",
        "CVE_id": "CVE-2025-68113",
        "project_name": "altcha-lib-java",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getBytes",
            "hashHex",
            "hmacHex",
            "randomBytes",
            "randomInt",
            "randomIntSecure"
        ],
        "target_code": "public static Challenge createChallenge(ChallengeOptions options) throws Exception {\n        Algorithm algorithm = options.algorithm != null ? options.algorithm : DEFAULT_ALGORITHM;\n        long maxNumber = options.maxNumber != null ? options.maxNumber : DEFAULT_MAX_NUMBER;\n        long saltLength = options.saltLength != null ? options.saltLength : DEFAULT_SALT_LENGTH;\n\n        Map<String, String> params = options.params;\n        if (options.expires != null) {\n            params.put(\"expires\", options.expires.toString());\n        }\n\n        String salt = options.salt != null ? options.salt : bytesToHex(randomBytes((int) saltLength));\n        if (!params.isEmpty()) {\n            salt += \"?\" + encodeParams(params);\n        }\n\n        long number = options.number != null ? options.number\n                : (options.secureRandomNumber ? randomIntSecure(maxNumber) : randomInt(maxNumber));\n        String challengeStr = hashHex(algorithm, salt + number);\n\n        String signature = hmacHex(algorithm, challengeStr.getBytes(StandardCharsets.UTF_8), options.hmacKey);\n\n        Challenge challenge = new Challenge();\n        challenge.algorithm = algorithm.getName();\n        challenge.challenge = challengeStr;\n        challenge.maxnumber = maxNumber;\n        challenge.salt = salt;\n        challenge.signature = signature;\n\n        return challenge;\n    }",
        "idx": "375"
    },
    {
        "target_file_name": "SysUserOnlineController.java",
        "target_method": "jeecg-boot/jeecg-module-system/jeecg-system-biz/src/main/java/org/jeecg/modules/system/controller/SysUserOnlineController.java#list",
        "project_url": "https://github.com/jeecgboot/JeecgBoot",
        "commit_id": "b686f9fbd1917edffe5922c6362c817a9361cfbd",
        "CWE_id": "CWE-1018",
        "CVE_id": "CVE-2025-14909",
        "project_name": "JeecgBoot",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "JwtUtil.getUsername",
            "redisUtil.get",
            "redisUtil.scan",
            "sysBaseApi.getUserByName"
        ],
        "target_code": "@RequiresPermissions(\"system:online:list\")\n    @RequestMapping(value = \"/list\", method = RequestMethod.GET)\n    public Result<Page<SysUserOnlineVO>> list(@RequestParam(name=\"username\", required=false) String username,\n                                              @RequestParam(name=\"pageNo\", defaultValue=\"1\") Integer pageNo,@RequestParam(name=\"pageSize\", defaultValue=\"10\") Integer pageSize) {\n        Collection<String> keys = redisUtil.scan(CommonConstant.PREFIX_USER_TOKEN + \"*\");\n        List<SysUserOnlineVO> onlineList = new ArrayList<SysUserOnlineVO>();\n        for (String key : keys) {\n            String token = (String)redisUtil.get(key);\n            if (StringUtils.isNotEmpty(token)) {\n                SysUserOnlineVO online = new SysUserOnlineVO();\n                online.setToken(token);\n                //TODO 改成一次性查询\n                LoginUser loginUser = sysBaseApi.getUserByName(JwtUtil.getUsername(token));\n                if (loginUser != null && !\"_reserve_user_external\".equals(loginUser.getUsername())) {\n                    //验证用户名是否与传过来的用户名相同\n                    boolean isMatchUsername=true;\n                    //判断用户名是否为空，并且当前循环的用户不包含传过来的用户名，那么就设成false\n                    if(oConvertUtils.isNotEmpty(username) && !loginUser.getUsername().contains(username)){\n                        isMatchUsername = false;\n                    }\n                    if(isMatchUsername){\n                        BeanUtils.copyProperties(loginUser, online);\n                        onlineList.add(online);\n                    }\n                }\n            }\n        }\n        Collections.reverse(onlineList);\n\n        Page<SysUserOnlineVO> page = new Page<SysUserOnlineVO>(pageNo, pageSize);\n        int count = onlineList.size();\n        List<SysUserOnlineVO> pages = new ArrayList<>();\n        // 计算当前页第一条数据的下标\n        int currId = pageNo > 1 ? (pageNo - 1) * pageSize : 0;\n        for (int i = 0; i < pageSize && i < count - currId; i++) {\n            pages.add(onlineList.get(currId + i));\n        }\n        page.setSize(pageSize);\n        page.setCurrent(pageNo);\n        page.setTotal(count);\n        // 计算分页总页数\n        page.setPages(count % 10 == 0 ? count / 10 : count / 10 + 1);\n        page.setRecords(pages);\n\n        Result<Page<SysUserOnlineVO>> result = new Result<Page<SysUserOnlineVO>>();\n        result.setSuccess(true);\n        result.setResult(page);\n        return result;\n    }",
        "idx": "376"
    },
    {
        "target_file_name": "SysUserOnlineController.java",
        "target_method": "jeecg-boot/jeecg-module-system/jeecg-system-biz/src/main/java/org/jeecg/modules/system/controller/SysUserOnlineController.java#forceLogout",
        "project_url": "https://github.com/jeecgboot/JeecgBoot",
        "commit_id": "b686f9fbd1917edffe5922c6362c817a9361cfbd",
        "CWE_id": "CWE-1018",
        "CVE_id": "CVE-2025-14909",
        "project_name": "JeecgBoot",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "SecurityUtils.getSubject.logout",
            "redisUtil.del"
        ],
        "target_code": "@RequiresPermissions(\"system:online:forceLogout\")\n    @RequestMapping(value = \"/forceLogout\",method = RequestMethod.POST)\n    public Result<Object> forceLogout(@RequestBody SysUserOnlineVO online) {\n        //用户退出逻辑\n        if(oConvertUtils.isEmpty(online.getToken())) {\n            return Result.error(\"退出登录失败！\");\n        }\n        String username = JwtUtil.getUsername(online.getToken());\n        LoginUser sysUser = sysBaseApi.getUserByName(username);\n        if(sysUser!=null) {\n            baseCommonService.addLog(\"强制: \"+sysUser.getRealname()+\"退出成功！\", CommonConstant.LOG_TYPE_1, null,sysUser);\n            log.info(\" 强制  \"+sysUser.getRealname()+\"退出成功！ \");\n            //清空用户登录Token缓存\n            redisUtil.del(CommonConstant.PREFIX_USER_TOKEN + online.getToken());\n            //清空用户登录Shiro权限缓存\n            redisUtil.del(CommonConstant.PREFIX_USER_SHIRO_CACHE + sysUser.getId());\n            //清空用户的缓存信息（包括部门信息），例如sys:cache:user::<username>\n            redisUtil.del(String.format(\"%s::%s\", CacheConstant.SYS_USERS_CACHE, sysUser.getUsername()));\n            //调用shiro的logout\n            SecurityUtils.getSubject().logout();\n            return Result.ok(\"退出登录成功！\");\n        }else {\n            return Result.error(\"Token无效!\");\n        }\n    }",
        "idx": "377"
    },
    {
        "target_file_name": "SysUserOnlineController.java",
        "target_method": "jeecg-boot/jeecg-module-system/jeecg-system-biz/src/main/java/org/jeecg/modules/system/controller/SysUserOnlineController.java#list",
        "project_url": "https://github.com/jeecgboot/JeecgBoot",
        "commit_id": "b686f9fbd1917edffe5922c6362c817a9361cfbd^",
        "CWE_id": "CWE-1018",
        "CVE_id": "CVE-2025-14909",
        "project_name": "JeecgBoot",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "JwtUtil.getUsername",
            "redisUtil.get",
            "redisUtil.scan"
        ],
        "target_code": "@RequestMapping(value = \"/list\", method = RequestMethod.GET)\n    public Result<Page<SysUserOnlineVO>> list(@RequestParam(name=\"username\", required=false) String username,\n                                              @RequestParam(name=\"pageNo\", defaultValue=\"1\") Integer pageNo,@RequestParam(name=\"pageSize\", defaultValue=\"10\") Integer pageSize) {\n        Collection<String> keys = redisUtil.scan(CommonConstant.PREFIX_USER_TOKEN + \"*\");\n        List<SysUserOnlineVO> onlineList = new ArrayList<SysUserOnlineVO>();\n        for (String key : keys) {\n            String token = (String)redisUtil.get(key);\n            if (StringUtils.isNotEmpty(token)) {\n                SysUserOnlineVO online = new SysUserOnlineVO();\n                online.setToken(token);\n                //TODO 改成一次性查询\n                LoginUser loginUser = sysBaseApi.getUserByName(JwtUtil.getUsername(token));\n                if (loginUser != null && !\"_reserve_user_external\".equals(loginUser.getUsername())) {\n                    //验证用户名是否与传过来的用户名相同\n                    boolean isMatchUsername=true;\n                    //判断用户名是否为空，并且当前循环的用户不包含传过来的用户名，那么就设成false\n                    if(oConvertUtils.isNotEmpty(username) && !loginUser.getUsername().contains(username)){\n                        isMatchUsername = false;\n                    }\n                    if(isMatchUsername){\n                        BeanUtils.copyProperties(loginUser, online);\n                        onlineList.add(online);\n                    }\n                }\n            }\n        }\n        Collections.reverse(onlineList);\n\n        Page<SysUserOnlineVO> page = new Page<SysUserOnlineVO>(pageNo, pageSize);\n        int count = onlineList.size();\n        List<SysUserOnlineVO> pages = new ArrayList<>();\n        // 计算当前页第一条数据的下标\n        int currId = pageNo > 1 ? (pageNo - 1) * pageSize : 0;\n        for (int i = 0; i < pageSize && i < count - currId; i++) {\n            pages.add(onlineList.get(currId + i));\n        }\n        page.setSize(pageSize);\n        page.setCurrent(pageNo);\n        page.setTotal(count);\n        // 计算分页总页数\n        page.setPages(count % 10 == 0 ? count / 10 : count / 10 + 1);\n        page.setRecords(pages);\n\n        Result<Page<SysUserOnlineVO>> result = new Result<Page<SysUserOnlineVO>>();\n        result.setSuccess(true);\n        result.setResult(page);\n        return result;\n    }",
        "idx": "378"
    },
    {
        "target_file_name": "SysUserOnlineController.java",
        "target_method": "jeecg-boot/jeecg-module-system/jeecg-system-biz/src/main/java/org/jeecg/modules/system/controller/SysUserOnlineController.java#forceLogout",
        "project_url": "https://github.com/jeecgboot/JeecgBoot",
        "commit_id": "b686f9fbd1917edffe5922c6362c817a9361cfbd^",
        "CWE_id": "CWE-1018",
        "CVE_id": "CVE-2025-14909",
        "project_name": "JeecgBoot",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "SecurityUtils.getSubject",
            "logout"
        ],
        "target_code": "@RequestMapping(value = \"/forceLogout\",method = RequestMethod.POST)\n    public Result<Object> forceLogout(@RequestBody SysUserOnlineVO online) {\n        //用户退出逻辑\n        if(oConvertUtils.isEmpty(online.getToken())) {\n            return Result.error(\"退出登录失败！\");\n        }\n        String username = JwtUtil.getUsername(online.getToken());\n        LoginUser sysUser = sysBaseApi.getUserByName(username);\n        if(sysUser!=null) {\n            baseCommonService.addLog(\"强制: \"+sysUser.getRealname()+\"退出成功！\", CommonConstant.LOG_TYPE_1, null,sysUser);\n            log.info(\" 强制  \"+sysUser.getRealname()+\"退出成功！ \");\n            //清空用户登录Token缓存\n            redisUtil.del(CommonConstant.PREFIX_USER_TOKEN + online.getToken());\n            //清空用户登录Shiro权限缓存\n            redisUtil.del(CommonConstant.PREFIX_USER_SHIRO_CACHE + sysUser.getId());\n            //清空用户的缓存信息（包括部门信息），例如sys:cache:user::<username>\n            redisUtil.del(String.format(\"%s::%s\", CacheConstant.SYS_USERS_CACHE, sysUser.getUsername()));\n            //调用shiro的logout\n            SecurityUtils.getSubject().logout();\n            return Result.ok(\"退出登录成功！\");\n        }else {\n            return Result.error(\"Token无效!\");\n        }\n    }",
        "idx": "379"
    },
    {
        "target_file_name": "SysTenantController.java",
        "target_method": "jeecg-boot/jeecg-module-system/jeecg-system-biz/src/main/java/org/jeecg/modules/system/controller/SysTenantController.java#invitationUser",
        "project_url": "https://github.com/jeecgboot/JeecgBoot",
        "commit_id": "e1c8f00bf2a2e0edddbaa8119afe1dc92d9dc1d2",
        "CWE_id": "CWE-287",
        "CVE_id": "CVE-2025-14908",
        "project_name": "JeecgBoot",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PostMapping",
            "RequestParam",
            "RequiresPermissions"
        ],
        "target_code": "@PostMapping(\"/invitationUser\")\n    @RequiresPermissions(\"system:tenant:invitation:user\")\n    public Result<String> invitationUser(@RequestParam(name=\"phone\") String phone,\n                                         @RequestParam(name=\"departId\",defaultValue = \"\") String departId){\n        return sysTenantService.invitationUser(phone,departId);\n    }",
        "idx": "380"
    },
    {
        "target_file_name": "SysTenantController.java",
        "target_method": "jeecg-boot/jeecg-module-system/jeecg-system-biz/src/main/java/org/jeecg/modules/system/controller/SysTenantController.java#invitationUser",
        "project_url": "https://github.com/jeecgboot/JeecgBoot",
        "commit_id": "e1c8f00bf2a2e0edddbaa8119afe1dc92d9dc1d2^",
        "CWE_id": "CWE-287",
        "CVE_id": "CVE-2025-14908",
        "project_name": "JeecgBoot",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "PostMapping",
            "RequestParam"
        ],
        "target_code": "@PostMapping(\"/invitationUser\")\n    public Result<String> invitationUser(@RequestParam(name=\"phone\") String phone,\n                                         @RequestParam(name=\"departId\",defaultValue = \"\") String departId){\n        return sysTenantService.invitationUser(phone,departId);\n    }",
        "idx": "381"
    }
]