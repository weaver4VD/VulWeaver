[
    {
        "target_file_name": "PgConfiguration.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "0db4872a52eccf6e83dd9359aa05db52dd580ec1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2024-55953",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "decode",
            "replace",
            "toLowerCase"
        ],
        "target_code": "public String getJdbc() {\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            if (StringUtils.isEmpty(getSchema())) {\n                jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE\"\n                        .replace(\"HOSTNAME\", getHost().trim())\n                        .replace(\"PORT\", getPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim());\n            } else {\n                jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?currentSchema=SCHEMA\"\n                        .replace(\"HOSTNAME\", getHost().trim())\n                        .replace(\"PORT\", getPort().toString().trim())\n                        .replace(\"DATABASE\", getDataBase().trim())\n                        .replace(\"SCHEMA\", getSchema().trim());\n            }\n        } else {\n            jdbcUrl = \"jdbc:postgresql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\"\n                    .replace(\"HOSTNAME\", getHost().trim())\n                    .replace(\"PORT\", getPort().toString().trim())\n                    .replace(\"DATABASE\", getDataBase().trim())\n                    .replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n\n        for (String illegalParameter : illegalParameters) {\n            if (jdbcUrl.toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }"
    },
    {
        "target_file_name": "RedshiftConfiguration.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "0db4872a52eccf6e83dd9359aa05db52dd580ec1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2024-55953",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "replace",
            "toLowerCase"
        ],
        "target_code": "public String getJdbc() {\n\n        String jdbcUrl = \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getHost().trim())\n                .replace(\"PORT\", getPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n        for (String illegalParameter : illegalParameters) {\n            if (jdbcUrl.toLowerCase().contains(illegalParameter.toLowerCase())) {\n                throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }"
    },
    {
        "target_file_name": "MysqlConfiguration.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "0db4872a52eccf6e83dd9359aa05db52dd580ec1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2024-55953",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "decode",
            "getDataBase",
            "getExtraParams",
            "getHost",
            "getIllegalParameters",
            "getPort",
            "replace",
            "toLowerCase",
            "toString",
            "trim"
        ],
        "target_code": "public String getJdbc() {\n        String jdbcUrl = \"\";\n        if (StringUtils.isEmpty(extraParams.trim())) {\n            jdbcUrl = \"jdbc:mysql://HOSTNAME:PORT/DATABASE\".replace(\"HOSTNAME\", getHost().trim()).replace(\"PORT\", getPort().toString().trim()).replace(\"DATABASE\", getDataBase().trim());\n        } else {\n            jdbcUrl = \"jdbc:mysql://HOSTNAME:PORT/DATABASE?EXTRA_PARAMS\".replace(\"HOSTNAME\", getHost().trim()).replace(\"PORT\", getPort().toString().trim()).replace(\"DATABASE\", getDataBase().trim()).replace(\"EXTRA_PARAMS\", getExtraParams().trim());\n        }\n        for (String illegalParameter : getIllegalParameters()) {\n            if (jdbcUrl.toLowerCase().contains(illegalParameter.toLowerCase()) || URLDecoder.decode(jdbcUrl).contains(illegalParameter.toLowerCase())) {\n                throw new RuntimeException(\"Illegal parameter: \" + illegalParameter);\n            }\n        }\n        return jdbcUrl;\n    }"
    },
    {
        "target_file_name": "MysqlConfiguration.java",
        "target_method": "getIllegalParameters",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "0db4872a52eccf6e83dd9359aa05db52dd580ec1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2024-55953",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public List<String> getIllegalParameters() {\n        List<String> newIllegalParameters = new ArrayList<>();\n        newIllegalParameters.addAll(illegalParameters);\n        newIllegalParameters.addAll(Arrays.asList(\"allowloadlocalinfile\", \"allowUrlInLocalInfile\", \"allowLoadLocalInfileInPath\"));\n        return newIllegalParameters;\n    }"
    },
    {
        "target_file_name": "MysqlConfiguration.java",
        "target_method": "getIllegalParameters",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "0db4872a52eccf6e83dd9359aa05db52dd580ec1^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2024-55953",
        "project_name": "dataease",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public List<String> getIllegalParameters(){\n        List<String> newIllegalParameters = new ArrayList<>();\n        newIllegalParameters.addAll(illegalParameters);\n        newIllegalParameters.addAll(Arrays.asList(\"allowloadlocalinfile\", \"allowUrlInLocalInfile\", \"allowLoadLocalInfileInPath\"));\n        return newIllegalParameters;\n    }"
    },
    {
        "target_file_name": "RedshiftConfiguration.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "0db4872a52eccf6e83dd9359aa05db52dd580ec1^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2024-55953",
        "project_name": "dataease",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "",
            ".rep",
            "lace(\"P"
        ],
        "target_code": "public String getJdbc() {\n        // 连接参数先写死，后边要把编码、时区等参数放到数据源的设置中\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getHost().trim())\n                .replace(\"PORT\", getPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "getAllExternalURLs",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "remoteInfo"
        ],
        "target_code": "@Override\n    public List<SvnExternal> getAllExternalURLs() {\n        CommandLine svnExternalCommand = svn(true)\n                .withArgs(\"propget\", \"--non-interactive\", \"svn:externals\", \"-R\")\n                .withArg(repositoryUrl);\n        ConsoleResult result = executeCommand(svnExternalCommand);\n        String svnExternalConsoleOut = result.outputAsString();\n        SvnInfo remoteInfo = remoteInfo(new SafeSaxBuilder());\n        String repoUrl = remoteInfo.getUrl();\n        String repoRoot = remoteInfo.getRoot();\n        List<SvnExternal> svnExternalList;\n        try {\n            svnExternalList = new SvnExternalParser().parse(svnExternalConsoleOut, repoUrl, repoRoot);\n        } catch (RuntimeException e) {\n            throw (RuntimeException) result.smudgedException(e);\n        }\n        return svnExternalList;\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "parseSvnLog",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getBuilder"
        ],
        "target_code": "private List<Modification> parseSvnLog(String output) {\n        SafeSaxBuilder builder = getBuilder();\n        SvnInfo svnInfo = remoteInfo(builder);\n        return svnLogXmlParser.parse(output, svnInfo.getPath(), builder);\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "getBuilder",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "get"
        ],
        "target_code": "private SafeSaxBuilder getBuilder() {\n        SafeSaxBuilder saxBuilder = saxBuilderThreadLocal.get();\n        if (saxBuilder == null) {\n            saxBuilder = new SafeSaxBuilder();\n            saxBuilderThreadLocal.set(saxBuilder);\n        }\n        return saxBuilder;\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "remoteInfo",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public SvnInfo remoteInfo(SafeSaxBuilder builder) {\n        SvnInfo svnInfo = new SvnInfo();\n        svnInfo.parse(executeCommand(svn(true)\n                .withArgs(\"info\", \"--xml\", \"--non-interactive\")\n                .withArg(repositoryUrl)).outputAsString(), builder);\n        return svnInfo;\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "parse",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public void parse(String xmlOutput, SafeSaxBuilder builder) {\n            try {\n                Document document = builder.build(new StringReader(xmlOutput));\n                parseDOMTree(document);\n            } catch (Exception e) {\n                bomb(\"Unable to parse svn info output: \" + xmlOutput, e);\n            }\n        }"
    },
    {
        "target_file_name": "XpathUtils.java",
        "target_method": "evaluate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "safeEvaluate"
        ],
        "target_code": "public static String evaluate(File file, String xpath) throws XPathExpressionException, IOException {\n        try (InputStream stream = new FileInputStream(file)) {\n            InputSource inputSource = new InputSource(stream);\n            return safeEvaluate(inputSource, xpath);\n        }\n    }"
    },
    {
        "target_file_name": "XpathUtils.java",
        "target_method": "nodeExists",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "nodeExists"
        ],
        "target_code": "public static boolean nodeExists(String xmlContent, String xpath) throws XPathExpressionException {\n        return nodeExists(new InputSource(new StringReader(xmlContent)), xpath);\n    }"
    },
    {
        "target_file_name": "ConfigCipherUpdater.java",
        "target_method": "migrate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument"
        ],
        "target_code": "public void migrate() {\n        File cipherFile = systemEnvironment.getDESCipherFile();\n        String timestamp = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\").format(timeProvider.currentTime());\n\n        File backupCipherFile = new File(systemEnvironment.getConfigDir(), \"cipher.original.\" + timestamp);\n        File configFile = new File(systemEnvironment.getCruiseConfigFile());\n        File backupConfigFile = new File(configFile.getParentFile(), configFile.getName() + \".original.\" + timestamp);\n        try {\n            if (!cipherFile.exists() || !FileUtils.readFileToString(cipherFile, UTF_8).equals(FLAWED_VALUE)) {\n                return;\n            }\n            LOGGER.info(\"Found unsafe cipher {} on server, Go will make an attempt to rekey\", FLAWED_VALUE);\n            FileUtils.copyFile(cipherFile, backupCipherFile);\n            LOGGER.info(\"Old cipher was successfully backed up to {}\", backupCipherFile.getAbsoluteFile());\n            FileUtils.copyFile(configFile, backupConfigFile);\n            LOGGER.info(\"Old config was successfully backed up to {}\", backupConfigFile.getAbsoluteFile());\n\n            String oldCipher = FileUtils.readFileToString(backupCipherFile, UTF_8);\n            new DESCipherProvider(systemEnvironment).resetCipher();\n\n            String newCipher = FileUtils.readFileToString(cipherFile, UTF_8);\n\n            if (newCipher.equals(oldCipher)) {\n                LOGGER.warn(\"Unable to generate a new safe cipher. Your cipher is unsafe.\");\n                FileUtils.deleteQuietly(backupCipherFile);\n                FileUtils.deleteQuietly(backupConfigFile);\n                return;\n            }\n            Document document = XmlUtils.buildXmlDocument(configFile);\n            List<String> encryptedAttributes = List.of(\"encryptedPassword\", \"encryptedManagerPassword\");\n            List<String> encryptedNodes = List.of(\"encryptedValue\");\n            XPathFactory xPathFactory = XPathFactory.instance();\n            for (String attributeName : encryptedAttributes) {\n                XPathExpression<Element> xpathExpression = xPathFactory.compile(String.format(\"//*[@%s]\", attributeName), Filters.element());\n                List<Element> encryptedPasswordElements = xpathExpression.evaluate(document);\n                for (Element element : encryptedPasswordElements) {\n                    Attribute encryptedPassword = element.getAttribute(attributeName);\n                    encryptedPassword.setValue(reEncryptUsingNewKey(decodeHex(oldCipher), decodeHex(newCipher), encryptedPassword.getValue()));\n                    LOGGER.debug(\"Replaced encrypted value at {}\", element.toString());\n                }\n            }\n            for (String nodeName : encryptedNodes) {\n                XPathExpression<Element> xpathExpression = xPathFactory.compile(String.format(\"//%s\", nodeName), Filters.element());\n                List<Element> encryptedNode = xpathExpression.evaluate(document);\n                for (Element element : encryptedNode) {\n                    element.setText(reEncryptUsingNewKey(decodeHex(oldCipher), decodeHex(newCipher), element.getValue()));\n                    LOGGER.debug(\"Replaced encrypted value at {}\", element.toString());\n                }\n            }\n            try (FileOutputStream fileOutputStream = new FileOutputStream(configFile)) {\n                XmlUtils.writeXml(document, fileOutputStream);\n            }\n            LOGGER.info(\"Successfully re-encrypted config\");\n        } catch (Exception e) {\n            LOGGER.error(\"Re-keying of cipher failed with error: [{}]\", e.getMessage(), e);\n            if (backupCipherFile.exists()) {\n                try {\n                    FileUtils.copyFile(backupCipherFile, cipherFile);\n                } catch (IOException e1) {\n                    LOGGER.error(\"Could not replace the cipher file [{}] with original one [{}], please do so manually. Error: [{}]\", cipherFile.getAbsolutePath(), backupCipherFile.getAbsolutePath(), e.getMessage(), e);\n                    bomb(e1);\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "MagicalGoConfigXmlLoader.java",
        "target_method": "parseInputStream",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildValidatedXmlDocument",
            "getCurrentSchema",
            "getRootElement"
        ],
        "target_code": "private Element parseInputStream(InputStream inputStream) throws Exception {\n        Element rootElement = XmlUtils.buildValidatedXmlDocument(inputStream, GoConfigSchema.getCurrentSchema()).getRootElement();\n        validateDom(rootElement, registry);\n        return rootElement;\n    }"
    },
    {
        "target_file_name": "MagicalGoConfigXmlLoader.java",
        "target_method": "fromXmlPartial",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument",
            "getRootElement",
            "parse"
        ],
        "target_code": "public <T> T fromXmlPartial(InputStream inputStream, Class<T> o) throws Exception {\n        return parse(o, XmlUtils.buildXmlDocument(inputStream).getRootElement());\n    }"
    },
    {
        "target_file_name": "GoPluginBundleDescriptorParser.java",
        "target_method": "parseXML",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "deserializeXML"
        ],
        "target_code": "static GoPluginBundleDescriptor parseXML(InputStream pluginXML,\n                                             String pluginJarFileLocation,\n                                             File pluginBundleLocation,\n                                             boolean isBundledPlugin) throws JAXBException, XMLStreamException, SAXException {\n\n        GoPluginBundleDescriptor bundle = GoPluginDescriptorParser.deserializeXML(pluginXML, GoPluginBundleDescriptor.class, \"/gocd-bundle-descriptor.xsd\", \"bundle.xml\");\n        bundle.pluginDescriptors().forEach(d -> {\n            d.setBundleDescriptor(bundle);\n            d.version(bundle.version());\n            d.pluginJarFileLocation(pluginJarFileLocation);\n            d.bundleLocation(pluginBundleLocation);\n            d.isBundledPlugin(isBundledPlugin);\n        });\n        return bundle;\n    }"
    },
    {
        "target_file_name": "XmlUtils.java",
        "target_method": "writeXml",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "output",
            "xmlOutputter"
        ],
        "target_code": "public static void writeXml(Element element, OutputStream outputStream) throws IOException {\n        xmlOutputter().output(element, outputStream);\n    }"
    },
    {
        "target_file_name": "XmlUtils.java",
        "target_method": "buildXmlDocument",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "build"
        ],
        "target_code": "public static Document buildXmlDocument(InputStream inputStream) throws IOException, JDOMException {\n        return new SafeSaxBuilder().build(inputStream);\n    }"
    },
    {
        "target_file_name": "GoPluginDescriptorParser.java",
        "target_method": "parseXML",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "deserializeXML"
        ],
        "target_code": "static GoPluginBundleDescriptor parseXML(InputStream pluginXML,\n                                             String pluginJarFileLocation,\n                                             File pluginBundleLocation,\n                                             boolean isBundledPlugin) throws JAXBException, XMLStreamException, SAXException {\n        GoPluginDescriptor plugin = deserializeXML(pluginXML, GoPluginDescriptor.class, \"/plugin-descriptor.xsd\", \"plugin.xml\");\n        plugin.pluginJarFileLocation(pluginJarFileLocation);\n        plugin.bundleLocation(pluginBundleLocation);\n        plugin.isBundledPlugin(isBundledPlugin);\n        return new GoPluginBundleDescriptor(plugin);\n    }"
    },
    {
        "target_file_name": "GoPluginDescriptorParser.java",
        "target_method": "deserializeXML",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createUnmarshaller",
            "getCause",
            "getValue",
            "newInstance",
            "schemaFor",
            "setSchema",
            "streamReaderFor",
            "unmarshal"
        ],
        "target_code": "static <T> T deserializeXML(InputStream pluginXML, Class<T> klass, String schemaResourcePath, String resourceType) throws JAXBException, XMLStreamException, SAXException {\n        XMLStreamReader data = streamReaderFor(pluginXML);\n        final Unmarshaller unmarshaller = JAXBContext.newInstance(klass).createUnmarshaller();\n        unmarshaller.setSchema(schemaFor(klass, schemaResourcePath));\n\n        try {\n            return unmarshaller.unmarshal(data, klass).getValue();\n        } catch (UnmarshalException e) {\n            // there is no non-frustrating way to customize error messages (without other pitfalls anyway),\n            // and `UnmarshalException` instances are rarely informative; assume a validation error.\n            if (null == e.getMessage()) {\n                throw new ValidationException(\"XML Schema validation of Plugin Descriptor(\" + resourceType + \") failed\", e.getCause());\n            }\n            throw e;\n        }\n    }"
    },
    {
        "target_file_name": "HgModificationSplitter.java",
        "target_method": "modifications",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument",
            "parseDOMTree"
        ],
        "target_code": "public List<Modification> modifications() {\n        try {\n            return parseDOMTree(XmlUtils.buildXmlDocument(output));\n        } catch (Exception e) {\n            throw ExceptionUtils.bomb(\"Unable to parse hg log output: \" + result.replaceSecretInfo(output), result.smudgedException(e));\n        }\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parse",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public List<Modification> parse(String svnLogOutput, String path, SafeSaxBuilder builder) {\n        try {\n            Document document = builder.build(new StringReader(svnLogOutput));\n            return parseDOMTree(document, path);\n        } catch (Exception e) {\n            throw bomb(\"Unable to parse svn log output: \" + svnLogOutput, e);\n        }\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parseDOMTree",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren"
        ],
        "target_code": "private List<Modification> parseDOMTree(Document document, String path) throws ParseException {\n        List<Modification> modifications = new ArrayList<>();\n\n        Element rootElement = document.getRootElement();\n        for (Element logEntry : rootElement.getChildren(\"logentry\")) {\n            Modification modification = parseLogEntry(logEntry, path);\n            if (modification != null) {\n                modifications.add(modification);\n            }\n        }\n\n        return modifications;\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parseLogEntry",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren"
        ],
        "target_code": "private Modification parseLogEntry(Element logEntry, String path) throws ParseException {\n        Element logEntryPaths = logEntry.getChild(\"paths\");\n        if (logEntryPaths == null) {\n            /* Path-based access control forbids us from learning\n             * details of this log entry, so skip it. */\n            return null;\n        }\n\n        Date modifiedTime = convertDate(logEntry.getChildText(\"date\"));\n        String author = logEntry.getChildText(\"author\");\n        String comment = logEntry.getChildText(\"msg\");\n        String revision = logEntry.getAttributeValue(\"revision\");\n\n        Modification modification = new Modification(author, comment, null, modifiedTime, revision);\n\n        for (Element node : logEntryPaths.getChildren(\"path\")) {\n            if (underPath(path, node.getText())) {\n                ModifiedAction action = convertAction(node.getAttributeValue(\"action\"));\n                modification.createModifiedFile(node.getText(), null, action);\n            }\n        }\n\n        return modification;\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "convertAction",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private ModifiedAction convertAction(String action) {\n        return switch (action) {\n            case \"A\" -> ModifiedAction.added;\n            case \"M\" -> ModifiedAction.modified;\n            case \"D\" -> ModifiedAction.deleted;\n            default -> ModifiedAction.unknown;\n        };\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parseInfoToGetUUID",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public Map<String, String> parseInfoToGetUUID(String output, String queryURL, SafeSaxBuilder builder) {\n        Map<String, String> uidToUrlMap = new HashMap<>();\n        try {\n            Document document = builder.build(new StringReader(output));\n            Element root = document.getRootElement();\n            List<Element> entries = root.getChildren(\"entry\");\n            for (Element entry : entries) {\n                uidToUrlMap.put(queryURL, entry.getChild(\"repository\").getChild(\"uuid\").getValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return uidToUrlMap;\n    }"
    },
    {
        "target_file_name": "MagicalGoConfigXmlWriter.java",
        "target_method": "verifyXsdValid",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildValidatedXmlDocument",
            "getCurrentSchema",
            "toInputStream"
        ],
        "target_code": "public void verifyXsdValid(Document document) throws Exception {\n        try (ByteArrayOutputStream buffer = new ByteArrayOutputStream(32 * 1024)) {\n            XmlUtils.writeXml(document, buffer);\n            XmlUtils.buildValidatedXmlDocument(buffer.toInputStream(), GoConfigSchema.getCurrentSchema());\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "validate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildValidatedXmlDocument",
            "getBytes",
            "getResource"
        ],
        "target_code": "private void validate(String content) {\n        int currentVersion = getCurrentSchemaVersion(content);\n        try {\n            XmlUtils.buildValidatedXmlDocument(new ByteArrayInputStream(content.getBytes()), GoConfigSchema.getResource(currentVersion));\n        } catch (Exception e) {\n            throw bomb(\"Cruise config file with version \" + currentVersion + \" is invalid. Unable to upgrade.\", e);\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "upgrade",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "length",
            "transform",
            "transformer"
        ],
        "target_code": "private String upgrade(String originalContent, URL upgradeScript) {\n        try {\n            ByteArrayOutputStream convertedConfig = new ByteArrayOutputStream(originalContent.length());\n            transformer(upgradeScript).transform(new StreamSource(new StringReader(originalContent)), new StreamResult(convertedConfig));\n            return convertedConfig.toString();\n        } catch (TransformerException e) {\n            throw bomb(\"Couldn't transform configuration file using upgrade script \" + upgradeScript.getPath(), e);\n        } catch (IOException e) {\n            throw bomb(\"Couldn't write converted config file\", e);\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "upgradeScripts",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private List<URL> upgradeScripts(int currentVersion, int targetVersion) {\n        List<URL> xsls = new ArrayList<>();\n        for (int i = currentVersion + 1; i <= targetVersion; i++) {\n            String scriptFile = i + \".xsl\";\n            URL xsl = getResource(\"/upgrades/\" + scriptFile);\n            bombIfNull(xsl, () -> \"Config File upgrade script named \" + scriptFile + \" is missing. Unable to perform upgrade.\");\n            xsls.add(xsl);\n        }\n        return xsls;\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "transformer",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bomb",
            "getPath",
            "openStream",
            "setAttribute"
        ],
        "target_code": "private Transformer transformer(URL upgradeScriptLocation) throws IOException {\n        try (InputStream xslt = upgradeScriptLocation.openStream()) {\n            TransformerFactory factory = TransformerFactory.newInstance();\n            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n            factory.setAttribute(\"jdk.xml.xpathExprOpLimit\", XPATH_EXPRESSION_OPERATION_LIMIT);\n            return factory.newTransformer(new StreamSource(xslt));\n        } catch (TransformerConfigurationException tce) {\n            throw bomb(\"Couldn't parse XSL template \" + upgradeScriptLocation.getPath(), tce);\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "getCurrentSchemaVersion",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument",
            "getRootElement"
        ],
        "target_code": "private int getCurrentSchemaVersion(String content) {\n        try {\n            Element root = XmlUtils.buildXmlDocument(content).getRootElement();\n\n            String schemaVersion = \"schemaVersion\";\n            String currentVersion = root.getAttributeValue(schemaVersion) == null ? \"0\" : root.getAttributeValue(schemaVersion);\n            return Integer.parseInt(currentVersion);\n        } catch (Exception e) {\n            throw bomb(e);\n        }\n    }"
    },
    {
        "target_file_name": "UniqueOnCancelValidator.java",
        "target_method": "validate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "compile",
            "element",
            "evaluate",
            "size"
        ],
        "target_code": "@Override\n    public void validate(Element element, ConfigElementImplementationRegistry registry) {\n        XPathFactory xPathFactory = XPathFactory.instance();\n        XPathExpression<Element> onCancelExpression = xPathFactory.compile(\"oncancel\", Filters.element());\n\n        List<String> tasks = ConfigUtil.allTasks(registry);\n        for (String task : tasks) {\n            List<Element> taskNodes = xPathFactory.compile(\"//\" + task, Filters.element()).evaluate(element);\n            for (Element taskNode : taskNodes) {\n                if (onCancelExpression.evaluate(taskNode).size() > 1) {\n                    throw new RuntimeException(\"Task [\" + task + \"] should not contain more than 1 oncancel task\");\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "getAllExternalURLs",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "remoteInfo"
        ],
        "target_code": "@Override\n    public List<SvnExternal> getAllExternalURLs() {\n        CommandLine svnExternalCommand = svn(true)\n                .withArgs(\"propget\", \"--non-interactive\", \"svn:externals\", \"-R\")\n                .withArg(repositoryUrl);\n        ConsoleResult result = executeCommand(svnExternalCommand);\n        String svnExternalConsoleOut = result.outputAsString();\n        SvnInfo remoteInfo = remoteInfo(new SAXBuilder());\n        String repoUrl = remoteInfo.getUrl();\n        String repoRoot = remoteInfo.getRoot();\n        List<SvnExternal> svnExternalList = null;\n        try {\n            svnExternalList = new SvnExternalParser().parse(svnExternalConsoleOut, repoUrl, repoRoot);\n        } catch (RuntimeException e) {\n            throw (RuntimeException) result.smudgedException(e);\n        }\n        return svnExternalList;\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "parseSvnLog",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getBuilder"
        ],
        "target_code": "private List<Modification> parseSvnLog(String output) {\n        SAXBuilder builder = getBuilder();\n        SvnInfo svnInfo = remoteInfo(builder);\n        return svnLogXmlParser.parse(output, svnInfo.getPath(), builder);\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "getBuilder",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "get"
        ],
        "target_code": "private SAXBuilder getBuilder() {\n        SAXBuilder saxBuilder = saxBuilderThreadLocal.get();\n        if (saxBuilder == null) {\n            saxBuilder = new SAXBuilder();\n            saxBuilderThreadLocal.set(saxBuilder);\n        }\n        return saxBuilder;\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "remoteInfo",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public SvnInfo remoteInfo(SAXBuilder builder) {\n        SvnInfo svnInfo = new SvnInfo();\n        svnInfo.parse(executeCommand(svn(true)\n                .withArgs(\"info\", \"--xml\", \"--non-interactive\")\n                .withArg(repositoryUrl)).outputAsString(), builder);\n        return svnInfo;\n    }"
    },
    {
        "target_file_name": "SvnCommand.java",
        "target_method": "parse",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public void parse(String xmlOutput, SAXBuilder builder) {\n            try {\n                Document document = builder.build(new StringReader(xmlOutput));\n                parseDOMTree(document);\n            } catch (Exception e) {\n                bomb(\"Unable to parse svn info output: \" + xmlOutput, e);\n            }\n        }"
    },
    {
        "target_file_name": "XpathUtils.java",
        "target_method": "evaluate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "compile",
            "evaluate",
            "newXPath",
            "trim"
        ],
        "target_code": "private static String evaluate(InputSource inputSource, String xpath)\n        throws XPathExpressionException {\n        XPathExpression expression = XpathUtils.XPATH.newXPath().compile(xpath);\n        return expression.evaluate(inputSource).trim();\n    }"
    },
    {
        "target_file_name": "XpathUtils.java",
        "target_method": "nodeExists",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "nodeExists"
        ],
        "target_code": "public static boolean nodeExists(File file, String xpath) throws XPathExpressionException, IOException {\n        try (FileInputStream stream = new FileInputStream(file)) {\n            return nodeExists(stream, xpath);\n        }\n    }"
    },
    {
        "target_file_name": "ConfigCipherUpdater.java",
        "target_method": "migrate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "build"
        ],
        "target_code": "public void migrate() {\n        File cipherFile = systemEnvironment.getDESCipherFile();\n        String timestamp = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\").format(timeProvider.currentTime());\n\n        File backupCipherFile = new File(systemEnvironment.getConfigDir(), \"cipher.original.\" + timestamp);\n        File configFile = new File(systemEnvironment.getCruiseConfigFile());\n        File backupConfigFile = new File(configFile.getParentFile(), configFile.getName() + \".original.\" + timestamp);\n        try {\n            if (!cipherFile.exists() || !FileUtils.readFileToString(cipherFile, UTF_8).equals(FLAWED_VALUE)) {\n                return;\n            }\n            LOGGER.info(\"Found unsafe cipher {} on server, Go will make an attempt to rekey\", FLAWED_VALUE);\n            FileUtils.copyFile(cipherFile, backupCipherFile);\n            LOGGER.info(\"Old cipher was successfully backed up to {}\", backupCipherFile.getAbsoluteFile());\n            FileUtils.copyFile(configFile, backupConfigFile);\n            LOGGER.info(\"Old config was successfully backed up to {}\", backupConfigFile.getAbsoluteFile());\n\n            String oldCipher = FileUtils.readFileToString(backupCipherFile, UTF_8);\n            new DESCipherProvider(systemEnvironment).resetCipher();\n\n            String newCipher = FileUtils.readFileToString(cipherFile, UTF_8);\n\n            if (newCipher.equals(oldCipher)) {\n                LOGGER.warn(\"Unable to generate a new safe cipher. Your cipher is unsafe.\");\n                FileUtils.deleteQuietly(backupCipherFile);\n                FileUtils.deleteQuietly(backupConfigFile);\n                return;\n            }\n            Document document = new SAXBuilder().build(configFile);\n            List<String> encryptedAttributes = List.of(\"encryptedPassword\", \"encryptedManagerPassword\");\n            List<String> encryptedNodes = List.of(\"encryptedValue\");\n            XPathFactory xPathFactory = XPathFactory.instance();\n            for (String attributeName : encryptedAttributes) {\n                XPathExpression<Element> xpathExpression = xPathFactory.compile(String.format(\"//*[@%s]\", attributeName), Filters.element());\n                List<Element> encryptedPasswordElements = xpathExpression.evaluate(document);\n                for (Element element : encryptedPasswordElements) {\n                    Attribute encryptedPassword = element.getAttribute(attributeName);\n                    encryptedPassword.setValue(reEncryptUsingNewKey(decodeHex(oldCipher), decodeHex(newCipher), encryptedPassword.getValue()));\n                    LOGGER.debug(\"Replaced encrypted value at {}\", element.toString());\n                }\n            }\n            for (String nodeName : encryptedNodes) {\n                XPathExpression<Element> xpathExpression = xPathFactory.compile(String.format(\"//%s\", nodeName), Filters.element());\n                List<Element> encryptedNode = xpathExpression.evaluate(document);\n                for (Element element : encryptedNode) {\n                    element.setText(reEncryptUsingNewKey(decodeHex(oldCipher), decodeHex(newCipher), element.getValue()));\n                    LOGGER.debug(\"Replaced encrypted value at {}\", element.toString());\n                }\n            }\n            try (FileOutputStream fileOutputStream = new FileOutputStream(configFile)) {\n                XmlUtils.writeXml(document, fileOutputStream);\n            }\n            LOGGER.info(\"Successfully re-encrypted config\");\n        } catch (Exception e) {\n            LOGGER.error(\"Re-keying of cipher failed with error: [{}]\", e.getMessage(), e);\n            if (backupCipherFile.exists()) {\n                try {\n                    FileUtils.copyFile(backupCipherFile, cipherFile);\n                } catch (IOException e1) {\n                    LOGGER.error(\"Could not replace the cipher file [{}] with original one [{}], please do so manually. Error: [{}]\", cipherFile.getAbsolutePath(), backupCipherFile.getAbsolutePath(), e.getMessage(), e);\n                    bomb(e1);\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "MagicalGoConfigXmlLoader.java",
        "target_method": "parseInputStream",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument",
            "getCurrentSchema",
            "getRootElement"
        ],
        "target_code": "private Element parseInputStream(InputStream inputStream) throws Exception {\n        Element rootElement = buildXmlDocument(inputStream, GoConfigSchema.getCurrentSchema()).getRootElement();\n        validateDom(rootElement, registry);\n        return rootElement;\n    }"
    },
    {
        "target_file_name": "MagicalGoConfigXmlLoader.java",
        "target_method": "fromXmlPartial",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "classParser",
            "getRootElement",
            "parse"
        ],
        "target_code": "public <T> T fromXmlPartial(InputStream inputStream, Class<T> o) throws Exception {\n        Document document = new SAXBuilder().build(inputStream);\n        Element element = document.getRootElement();\n        return classParser(element, o, configCache, new GoCipher(), registry, new ConfigReferenceElements()).parse();\n    }"
    },
    {
        "target_file_name": "GoPluginBundleDescriptorParser.java",
        "target_method": "parseXML",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "deserializeXML"
        ],
        "target_code": "static GoPluginBundleDescriptor parseXML(InputStream pluginXML,\n                                             String pluginJarFileLocation,\n                                             File pluginBundleLocation,\n                                             boolean isBundledPlugin) throws IOException, JAXBException, XMLStreamException, SAXException {\n\n        GoPluginBundleDescriptor bundle = deserializeXML(pluginXML, GoPluginBundleDescriptor.class);\n        bundle.pluginDescriptors().forEach(d -> {\n            d.setBundleDescriptor(bundle);\n            d.version(bundle.version());\n            d.pluginJarFileLocation(pluginJarFileLocation);\n            d.bundleLocation(pluginBundleLocation);\n            d.isBundledPlugin(isBundledPlugin);\n        });\n        return bundle;\n    }"
    },
    {
        "target_file_name": "XmlUtils.java",
        "target_method": "writeXml",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "output",
            "xmlOutputer"
        ],
        "target_code": "public static void writeXml(Element element, OutputStream outputStream) throws IOException {\n        xmlOutputer().output(element, outputStream);\n    }"
    },
    {
        "target_file_name": "XmlUtils.java",
        "target_method": "buildXmlDocument",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "hasValidationError",
            "setErrorHandler",
            "translate"
        ],
        "target_code": "private static Document buildXmlDocument(InputStream inputStream, SAXBuilder builder) throws JDOMException, IOException {\n        XsdErrorTranslator errorHandler = new XsdErrorTranslator();\n        builder.setErrorHandler(errorHandler);\n\n        Document cruiseRoot = builder.build(inputStream);\n        if (errorHandler.hasValidationError()) {\n            throw new XsdValidationException(errorHandler.translate());\n        }\n        return cruiseRoot;\n    }"
    },
    {
        "target_file_name": "GoPluginDescriptorParser.java",
        "target_method": "parseXML",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "deserializeXML"
        ],
        "target_code": "static GoPluginBundleDescriptor parseXML(InputStream pluginXML,\n                                             String pluginJarFileLocation,\n                                             File pluginBundleLocation,\n                                             boolean isBundledPlugin) throws IOException, JAXBException, XMLStreamException, SAXException {\n        GoPluginDescriptor plugin = deserializeXML(pluginXML, GoPluginDescriptor.class);\n        plugin.pluginJarFileLocation(pluginJarFileLocation);\n        plugin.bundleLocation(pluginBundleLocation);\n        plugin.isBundledPlugin(isBundledPlugin);\n        return new GoPluginBundleDescriptor(plugin);\n    }"
    },
    {
        "target_file_name": "GoPluginDescriptorParser.java",
        "target_method": "deserializeXML",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createUnmarshaller",
            "createXMLStreamReader",
            "getCause",
            "getResource",
            "getValue",
            "newInstance",
            "newSchema",
            "setSchema",
            "unmarshal"
        ],
        "target_code": "@SuppressWarnings(\"SameParameterValue\")\n    private static <T> T deserializeXML(InputStream pluginXML, Class<T> klass) throws JAXBException, XMLStreamException, SAXException {\n        JAXBContext ctx = JAXBContext.newInstance(klass);\n        XMLStreamReader data = XMLInputFactory.newInstance().createXMLStreamReader(pluginXML);\n        final Unmarshaller unmarshaller = ctx.createUnmarshaller();\n        unmarshaller.setSchema(SchemaFactory.\n                newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI).\n                newSchema(GoPluginDescriptorParser.class.getResource(\"/plugin-descriptor.xsd\")));\n\n        try {\n            final JAXBElement<T> result = unmarshaller.unmarshal(data, klass);\n            return result.getValue();\n        } catch (UnmarshalException e) {\n            // there is no non-frustrating way to customize error messages (without other pitfalls anyway),\n            // and `UnmarshalException` instances are rarely informative; assume a validation error.\n            if (null == e.getMessage()) {\n                throw new ValidationException(\"XML Schema validation of Plugin Descriptor(plugin.xml) failed\", e.getCause());\n            }\n            throw e;\n        }\n    }"
    },
    {
        "target_file_name": "HgModificationSplitter.java",
        "target_method": "modifications",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "parseDOMTree"
        ],
        "target_code": "public List<Modification> modifications() {\n        try {\n            SAXBuilder builder = new SAXBuilder();\n            Document document = builder.build(new StringReader(output));\n            return parseDOMTree(document);\n        } catch (Exception e) {\n            throw ExceptionUtils.bomb(\"Unable to parse hg log output: \" + result.replaceSecretInfo(output), result.smudgedException(e));\n        }\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parse",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public List<Modification> parse(String svnLogOutput, String path, SAXBuilder builder) {\n        try {\n            Document document = builder.build(new StringReader(svnLogOutput));\n            return parseDOMTree(document, path);\n        } catch (Exception e) {\n            throw bomb(\"Unable to parse svn log output: \" + svnLogOutput, e);\n        }\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parseDOMTree",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren",
            "hasNext",
            "iterator",
            "next"
        ],
        "target_code": "private List<Modification> parseDOMTree(Document document, String path) throws ParseException {\n        List<Modification> modifications = new ArrayList<>();\n\n        Element rootElement = document.getRootElement();\n        List logEntries = rootElement.getChildren(\"logentry\");\n        for (Iterator iterator = logEntries.iterator(); iterator.hasNext();) {\n            Element logEntry = (Element) iterator.next();\n\n            Modification modification = parseLogEntry(logEntry, path);\n            if (modification != null) {\n                modifications.add(modification);\n            }\n        }\n\n        return modifications;\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parseLogEntry",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getChildren",
            "hasNext",
            "iterator",
            "next"
        ],
        "target_code": "private Modification parseLogEntry(Element logEntry, String path) throws ParseException {\n        Element logEntryPaths = logEntry.getChild(\"paths\");\n        if (logEntryPaths == null) {\n            /* Path-based access control forbids us from learning\n             * details of this log entry, so skip it. */\n            return null;\n        }\n\n        Date modifiedTime = convertDate(logEntry.getChildText(\"date\"));\n        String author = logEntry.getChildText(\"author\");\n        String comment = logEntry.getChildText(\"msg\");\n        String revision = logEntry.getAttributeValue(\"revision\");\n\n        Modification modification = new Modification(author, comment, null, modifiedTime, revision);\n\n        List paths = logEntryPaths.getChildren(\"path\");\n        for (Iterator iterator = paths.iterator(); iterator.hasNext();) {\n            Element node = (Element) iterator.next();\n            if (underPath(path, node.getText())) {\n                ModifiedAction action = convertAction(node.getAttributeValue(\"action\"));\n                modification.createModifiedFile(node.getText(), null, action);\n            }\n        }\n\n        return modification;\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "convertAction",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "equals"
        ],
        "target_code": "private ModifiedAction convertAction(String action) {\n        if (action.equals(\"A\")) {\n            return ModifiedAction.added;\n        }\n        if (action.equals(\"M\")) {\n            return ModifiedAction.modified;\n        }\n        if (action.equals(\"D\")) {\n            return ModifiedAction.deleted;\n        }\n        return ModifiedAction.unknown;\n    }"
    },
    {
        "target_file_name": "SvnLogXmlParser.java",
        "target_method": "parseInfoToGetUUID",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public HashMap<String, String> parseInfoToGetUUID(String output, String queryURL, SAXBuilder builder) {\n        HashMap<String, String> uidToUrlMap = new HashMap<>();\n        try {\n            Document document = builder.build(new StringReader(output));\n            Element root = document.getRootElement();\n            List<Element> entries = root.getChildren(\"entry\");\n            for (Element entry : entries) {\n                uidToUrlMap.put(queryURL, entry.getChild(\"repository\").getChild(\"uuid\").getValue());\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return uidToUrlMap;\n    }"
    },
    {
        "target_file_name": "MagicalGoConfigXmlWriter.java",
        "target_method": "verifyXsdValid",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument",
            "getCurrentSchema",
            "toInputStream"
        ],
        "target_code": "public void verifyXsdValid(Document document) throws Exception {\n        try (ByteArrayOutputStream buffer = new ByteArrayOutputStream(32 * 1024)) {\n            XmlUtils.writeXml(document, buffer);\n            buildXmlDocument(buffer.toInputStream(), GoConfigSchema.getCurrentSchema());\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "validate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "buildXmlDocument",
            "getBytes",
            "getResource"
        ],
        "target_code": "private void validate(String content) {\n        int currentVersion = getCurrentSchemaVersion(content);\n        try {\n            buildXmlDocument(new ByteArrayInputStream(content.getBytes()), GoConfigSchema.getResource(currentVersion));\n        } catch (Exception e) {\n            throw bomb(\"Cruise config file with version \" + currentVersion + \" is invalid. Unable to upgrade.\", e);\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "upgrade",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getBytes",
            "getPath",
            "openStream",
            "transform",
            "transformer"
        ],
        "target_code": "private String upgrade(String originalContent, URL upgradeScript) {\n        try (InputStream xslt = upgradeScript.openStream()) {\n            ByteArrayOutputStream convertedConfig = new ByteArrayOutputStream();\n            transformer(upgradeScript.getPath(), xslt)\n                    .transform(new StreamSource(new ByteArrayInputStream(originalContent.getBytes())), new StreamResult(convertedConfig));\n            return convertedConfig.toString();\n        } catch (TransformerException e) {\n            throw bomb(\"Couldn't transform configuration file using upgrade script \" + upgradeScript.getPath(), e);\n        } catch (IOException e) {\n            throw bomb(\"Couldn't write converted config file\", e);\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "upgradeScripts",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private List<URL> upgradeScripts(int currentVersion, int targetVersion) {\n        ArrayList<URL> xsls = new ArrayList<>();\n        for (int i = currentVersion + 1; i <= targetVersion; i++) {\n            String scriptFile = i + \".xsl\";\n            URL xsl = getResource(\"/upgrades/\" + scriptFile);\n            bombIfNull(xsl, () -> \"Config File upgrade script named \" + scriptFile + \" is missing. Unable to perform upgrade.\");\n            xsls.add(xsl);\n        }\n        return xsls;\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "transformer",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "bomb",
            "tryIncreaseXpathExpressionOperationLimit"
        ],
        "target_code": "private Transformer transformer(String xsltName, InputStream xslt) {\n        try {\n            TransformerFactory factory = TransformerFactory.newInstance();\n            tryIncreaseXpathExpressionOperationLimit(factory);\n            return factory.newTransformer(new StreamSource(xslt));\n        } catch (TransformerConfigurationException tce) {\n            throw bomb(\"Couldn't parse XSL template \" + xsltName, tce);\n        }\n    }"
    },
    {
        "target_file_name": "GoConfigMigration.java",
        "target_method": "getCurrentSchemaVersion",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "getBytes",
            "getRootElement"
        ],
        "target_code": "private int getCurrentSchemaVersion(String content) {\n        try {\n            SAXBuilder builder = new SAXBuilder();\n            Document document = builder.build(new ByteArrayInputStream(content.getBytes()));\n            Element root = document.getRootElement();\n\n            String schemaVersion = \"schemaVersion\";\n            String currentVersion = root.getAttributeValue(schemaVersion) == null ? \"0\" : root.getAttributeValue(schemaVersion);\n            return Integer.parseInt(currentVersion);\n        } catch (Exception e) {\n            throw bomb(e);\n        }\n    }"
    },
    {
        "target_file_name": "UniqueOnCancelValidator.java",
        "target_method": "validate",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "410331a97eb2935e04c1372f50658e05c533f733^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2024-56322",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "compile",
            "element",
            "evaluate",
            "size"
        ],
        "target_code": "@Override\n    public void validate(Element element, ConfigElementImplementationRegistry registry) {\n        XPathFactory xPathFactory = XPathFactory.instance();\n        List<String> tasks = ConfigUtil.allTasks(registry);\n        for (String task : tasks) {\n            List<Element> taskNodes = xPathFactory.compile(\"//\" + task, Filters.element()).evaluate(element);\n            for (Element taskNode : taskNodes) {\n                List<Element> list = xPathFactory.compile(\"oncancel\", Filters.element()).evaluate(taskNode);\n                if (list.size() > 1) {\n                    throw new RuntimeException(\"Task [\" + task + \"] should not contain more than 1 oncancel task\");\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "BackupService.java",
        "target_method": "performBackup",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "631f315d17fcb73f310eee6c881974c9b55ca9f0",
        "CWE_id": "CWE-36",
        "CVE_id": "CVE-2024-56321",
        "project_name": "gocd",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "postBackupScriptFile",
            "validatePostBackupScript"
        ],
        "target_code": "private ServerBackup performBackup(ServerBackup backup, List<BackupUpdateListener> backupUpdateListeners, BackupInitiator initiatedBy) {\n        GoMailSender mailSender = goConfigService.getMailSender();\n        File destDir = new File(backup.getPath());\n        synchronized (BACKUP_MUTEX) {\n            try {\n                runningBackup = backup;\n                validator.validatePostBackupScript(postBackupScriptFile());\n                notifyUpdateToListeners(backupUpdateListeners, BackupProgressStatus.CREATING_DIR);\n                if (!destDir.mkdirs()) {\n                    notifyErrorToListeners(backupUpdateListeners, \"Failed to perform backup. Reason: Could not create the backup directory.\");\n                    return backup;\n                }\n                backupVersion(destDir, backupUpdateListeners);\n                backupConfig(destDir, backupUpdateListeners);\n                boolean backedUpWrapperConfig = backupWrapperConfig(destDir, backupUpdateListeners);\n                backupConfigRepo(backupUpdateListeners, destDir);\n                backupDb(destDir, backupUpdateListeners);\n                boolean passed = executePostBackupScript(backup.getUsername(), initiatedBy, backup, backupUpdateListeners);\n                if (passed) {\n                    sendBackupSuccessEmail(backup.getUsername(), mailSender, destDir);\n                    notifyCompletionToListeners(backupUpdateListeners, backedUpWrapperConfig);\n                    LOGGER.debug(\"Backup Completed Successfully\");\n                }\n            } catch (Exception e) {\n                FileUtils.deleteQuietly(destDir);\n                sendBackupFailedEmail(mailSender, e);\n                notifyErrorToListeners(backupUpdateListeners, String.format(\"Failed to perform backup. Reason: %s\", e.getMessage()));\n                LOGGER.error(\"[Backup] Failed to backup Go.\", e);\n            } finally {\n                runningBackup = null;\n            }\n        }\n        return backup;\n    }"
    },
    {
        "target_file_name": "BackupService.java",
        "target_method": "performBackup",
        "project_url": "https://github.com/gocd/gocd",
        "commit_id": "631f315d17fcb73f310eee6c881974c9b55ca9f0^",
        "CWE_id": "CWE-36",
        "CVE_id": "CVE-2024-56321",
        "project_name": "gocd",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private ServerBackup performBackup(ServerBackup backup, List<BackupUpdateListener> backupUpdateListeners, BackupInitiator initiatedBy) {\n        GoMailSender mailSender = goConfigService.getMailSender();\n        File destDir = new File(backup.getPath());\n        synchronized (BACKUP_MUTEX) {\n            try {\n                runningBackup = backup;\n                notifyUpdateToListeners(backupUpdateListeners, BackupProgressStatus.CREATING_DIR);\n                if (!destDir.mkdirs()) {\n                    notifyErrorToListeners(backupUpdateListeners, \"Failed to perform backup. Reason: Could not create the backup directory.\");\n                    return backup;\n                }\n                backupVersion(destDir, backupUpdateListeners);\n                backupConfig(destDir, backupUpdateListeners);\n                boolean backedUpWrapperConfig = backupWrapperConfig(destDir, backupUpdateListeners);\n                backupConfigRepo(backupUpdateListeners, destDir);\n                backupDb(destDir, backupUpdateListeners);\n                boolean passed = executePostBackupScript(backup.getUsername(), initiatedBy, backup, backupUpdateListeners);\n                if (passed) {\n                    sendBackupSuccessEmail(backup.getUsername(), mailSender, destDir);\n                    notifyCompletionToListeners(backupUpdateListeners, backedUpWrapperConfig);\n                    LOGGER.debug(\"Backup Completed Successfully\");\n                }\n            } catch (Exception e) {\n                FileUtils.deleteQuietly(destDir);\n                sendBackupFailedEmail(mailSender, e);\n                notifyErrorToListeners(backupUpdateListeners, String.format(\"Failed to perform backup. Reason: %s\", e.getMessage()));\n                LOGGER.error(\"[Backup] Failed to backup Go.\", e);\n            } finally {\n                runningBackup = null;\n            }\n        }\n        return backup;\n    }"
    },
    {
        "target_file_name": "XWikiDocumentRequiredRightAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "385bde985cdb61ebf315d30c0b144b6d2e2c2d45",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49585",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "analyze",
            "getXClass"
        ],
        "target_code": "@Override\n    public List<RequiredRightAnalysisResult> analyze(XWikiDocument document) throws RequiredRightsException\n    {\n        // Analyze the content\n        try {\n            // Push the document into the context such that we, e.g., get the correct context wiki with the correct\n            // wiki macros etc.\n            return this.documentContextExecutor.call(() ->\n            {\n                List<RequiredRightAnalysisResult> result = new ArrayList<>();\n\n                // Analyze the title\n                if (this.velocityDetector.containsVelocityScript(document.getTitle())) {\n                    result.add(new RequiredRightAnalysisResult(\n                        document.getDocumentReferenceWithLocale(),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title\"),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title.description\",\n                            document.getTitle()),\n                        List.of(RequiredRight.MAYBE_SCRIPT, RequiredRight.MAYBE_PROGRAM)\n                    ));\n                }\n\n                // Analyze the content\n                result.addAll(this.xdomRequiredRightAnalyzer.analyze(document.getXDOM()));\n\n                // Analyze XObjects and XClass on the Root locale version of the document\n                XWikiDocument rootLocaleDocument = document;\n                if (document.getLocale() != null && !document.getLocale().equals(Locale.ROOT)) {\n                    XWikiContext context = this.contextProvider.get();\n                    rootLocaleDocument = context.getWiki().getDocument(document.getDocumentReference(), context);\n                }\n\n                result.addAll(this.classRequiredRightAnalyzer.analyze(rootLocaleDocument.getXClass()));\n\n                for (List<BaseObject> baseObjects : rootLocaleDocument.getXObjects().values()) {\n                    for (BaseObject object : baseObjects) {\n                        result.addAll(this.objectRequiredRightAnalyzer.analyze(object));\n                    }\n                }\n\n                return result;\n            }, document);\n        } catch (Exception e) {\n            throw new RequiredRightsException(\"Error...\", e);\n        }\n    }"
    },
    {
        "target_file_name": "XWikiDocumentRequiredRightAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "385bde985cdb61ebf315d30c0b144b6d2e2c2d45^",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49585",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public List<RequiredRightAnalysisResult> analyze(XWikiDocument document) throws RequiredRightsException\n    {\n        // Analyze the content\n        try {\n            // Push the document into the context such that we, e.g., get the correct context wiki with the correct\n            // wiki macros etc.\n            return this.documentContextExecutor.call(() ->\n            {\n                List<RequiredRightAnalysisResult> result = new ArrayList<>();\n\n                // Analyze the title\n                if (this.velocityDetector.containsVelocityScript(document.getTitle())) {\n                    result.add(new RequiredRightAnalysisResult(\n                        document.getDocumentReferenceWithLocale(),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title\"),\n                        this.translationMessageSupplierProvider.get(\"security.requiredrights.title.description\",\n                            document.getTitle()),\n                        List.of(RequiredRight.MAYBE_SCRIPT, RequiredRight.MAYBE_PROGRAM)\n                    ));\n                }\n\n                // Analyze the content\n                result.addAll(this.xdomRequiredRightAnalyzer.analyze(document.getXDOM()));\n\n                // Analyze XObjects on the Root locale version of the document\n                XWikiDocument rootLocaleDocument = document;\n                if (document.getLocale() != null && !document.getLocale().equals(Locale.ROOT)) {\n                    XWikiContext context = this.contextProvider.get();\n                    rootLocaleDocument = context.getWiki().getDocument(document.getDocumentReference(), context);\n                }\n\n                for (List<BaseObject> baseObjects : rootLocaleDocument.getXObjects().values()) {\n                    for (BaseObject object : baseObjects) {\n                        result.addAll(this.objectRequiredRightAnalyzer.analyze(object));\n                    }\n                }\n\n                return result;\n            }, document);\n        } catch (Exception e) {\n            throw new RequiredRightsException(\"Error...\", e);\n        }\n    }"
    },
    {
        "target_file_name": "FileDownloadController.java",
        "target_method": "downloadFile",
        "project_url": "https://github.com/cuba-platform/restapi",
        "commit_id": "b3d599f6657d7e212fdb134a61ab5e0888669eb1",
        "CWE_id": "CWE-79",
        "CVE_id": "CVE-2025-32960",
        "project_name": "restapi",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "resolveAttachmentValue"
        ],
        "target_code": "@GetMapping(\"/{fileDescriptorId}\")\n    public void downloadFile(@PathVariable String fileDescriptorId,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkCanReadFileDescriptor();\n\n        UUID uuid;\n        try {\n            uuid = UUID.fromString(fileDescriptorId);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid entity ID\",\n                    String.format(\"Cannot convert %s into valid entity ID\", fileDescriptorId),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n        LoadContext<FileDescriptor> ctx = LoadContext.create(FileDescriptor.class).setId(uuid);\n        FileDescriptor fd = dataService.load(ctx);\n        if (fd == null) {\n            throw new RestAPIException(\"File not found\", \"File not found. Id: \" + fileDescriptorId, HttpStatus.NOT_FOUND);\n        }\n\n        attachment = resolveAttachmentValue(attachment, fd);\n\n        try {\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Content-Disposition\", (BooleanUtils.isTrue(attachment) ? \"attachment\" : \"inline\")\n                    + \"; filename=\\\"\" + URLEncodeUtils.encodeUtf8(fd.getName()) + \"\\\"\");\n\n            downloadFromMiddlewareAndWriteResponse(fd, response);\n        } catch (Exception e) {\n            log.error(\"Error on downloading the file {}\", fileDescriptorId, e);\n            throw new RestAPIException(\"Error on downloading the file\", \"\", HttpStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }"
    },
    {
        "target_file_name": "FileDownloadController.java",
        "target_method": "downloadFile",
        "project_url": "https://github.com/cuba-platform/restapi",
        "commit_id": "b3d599f6657d7e212fdb134a61ab5e0888669eb1^",
        "CWE_id": "CWE-79",
        "CVE_id": "CVE-2025-32960",
        "project_name": "restapi",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@GetMapping(\"/{fileDescriptorId}\")\n    public void downloadFile(@PathVariable String fileDescriptorId,\n                             @RequestParam(required = false) Boolean attachment,\n                             HttpServletResponse response) {\n\n        checkCanReadFileDescriptor();\n\n        UUID uuid;\n        try {\n            uuid = UUID.fromString(fileDescriptorId);\n        } catch (IllegalArgumentException e) {\n            throw new RestAPIException(\"Invalid entity ID\",\n                    String.format(\"Cannot convert %s into valid entity ID\", fileDescriptorId),\n                    HttpStatus.BAD_REQUEST,\n                    e);\n        }\n        LoadContext<FileDescriptor> ctx = LoadContext.create(FileDescriptor.class).setId(uuid);\n        FileDescriptor fd = dataService.load(ctx);\n        if (fd == null) {\n            throw new RestAPIException(\"File not found\", \"File not found. Id: \" + fileDescriptorId, HttpStatus.NOT_FOUND);\n        }\n\n        try {\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Content-Disposition\", (BooleanUtils.isTrue(attachment) ? \"attachment\" : \"inline\")\n                    + \"; filename=\\\"\" + URLEncodeUtils.encodeUtf8(fd.getName()) + \"\\\"\");\n\n            downloadFromMiddlewareAndWriteResponse(fd, response);\n        } catch (Exception e) {\n            log.error(\"Error on downloading the file {}\", fileDescriptorId, e);\n            throw new RestAPIException(\"Error on downloading the file\", \"\", HttpStatus.INTERNAL_SERVER_ERROR, e);\n        }\n    }"
    },
    {
        "target_file_name": "ConversationService.java",
        "target_method": "add",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setRemark"
        ],
        "target_code": "public ConvDto add(String title, String remark, String systemMessage) {\n        Conversation conversation = this.lambdaQuery()\n                .eq(Conversation::getUserId, ThreadContext.getCurrentUserId())\n                .eq(Conversation::getTitle, title)\n                .eq(Conversation::getIsDeleted, false)\n                .one();\n        if (null != conversation) {\n            throw new BaseException(A_CONVERSATION_TITLE_EXIST);\n        }\n        String uuid = UuidUtil.createShort();\n        Conversation one = new Conversation();\n        one.setUuid(uuid);\n        one.setTitle(title);\n        one.setAiSystemMessage(systemMessage);\n        one.setUserId(ThreadContext.getCurrentUserId());\n        one.setRemark(remark);\n        baseMapper.insert(one);\n\n        Conversation conv = this.lambdaQuery().eq(Conversation::getUuid, uuid).one();\n        return MPPageUtil.convertTo(conv, ConvDto.class);\n    }"
    },
    {
        "target_file_name": "ConversationService.java",
        "target_method": "addByPresetConv",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "getAiSystemMessage",
            "getRemark",
            "getTitle"
        ],
        "target_code": "public ConvDto addByPresetConv(String presetConvUuid) {\n        ConversationPreset presetConv = this.conversationPresetService.lambdaQuery()\n                .eq(ConversationPreset::getUuid, presetConvUuid)\n                .eq(ConversationPreset::getIsDeleted, false)\n                .oneOpt()\n                .orElseThrow(() -> new BaseException(A_PRESET_CONVERSATION_NOT_EXIST));\n        ConversationPresetRel presetRel = this.conversationPresetRelService.lambdaQuery()\n                .eq(ConversationPresetRel::getUserId, ThreadContext.getCurrentUserId())\n                .eq(ConversationPresetRel::getUserConvId, presetConv.getId())\n                .eq(ConversationPresetRel::getIsDeleted, false)\n                .oneOpt()\n                .orElse(null);\n        if (null != presetRel) {\n            Conversation conv = this.getById(presetRel.getUserConvId());\n            return MPPageUtil.convertTo(conv, ConvDto.class);\n        }\n        ConvDto convDto = self.add(presetConv.getTitle(), presetConv.getRemark(), presetConv.getAiSystemMessage());\n        conversationPresetRelService.save(\n                ConversationPresetRel.builder()\n                        .presetConvId(presetConv.getId())\n                        .userConvId(convDto.getId())\n                        .userId(ThreadContext.getCurrentUserId())\n                        .build()\n        );\n        return convDto;\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "writeToLocal",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "",
            ".lambdaUp",
            ".setPath(",
            "e.get",
            "eq",
            "sha256",
            "warn"
        ],
        "target_code": "public AdiFile writeToLocal(MultipartFile file, boolean image) {\n        String sha256 = HashUtil.sha256(file);\n        Optional<AdiFile> existFile = this.lambdaQuery()\n                .eq(AdiFile::getSha256, md5)\n                .eq(AdiFile::getIsDeleted, false)\n                .oneOpt();\n        if (existFile.isPresent()) {\n            AdiFile adiFile = existFile.get();\n            boolean exist = FileUtil.checkIfExist(adiFile.getPath());\n            if (exist) {\n                return adiFile;\n            } else {\n                log.warn(\"文件不存在,删除记录以便后续重新生成,fileId:{},uuid:{},sha256:{}\", adiFile.getId(), adiFile.getUuid(), adiFile.getSha256());\n                this.lambdaUpdate().eq(AdiFile::getId, adiFile.getId()).set(AdiFile::getIsDeleted, true).update();\n            }\n        }\n        String uuid = UuidUtil.createShort();\n        Pair<String, String> originalFile = FileUtil.saveToLocal(file, image ? imagePath : filePath, uuid);\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(file.getOriginalFilename());\n        adiFile.setUuid(uuid);\n        adiFile.setSha256(sha256);\n        adiFile.setPath(originalFile.getLeft());\n        adiFile.setExt(originalFile.getRight());\n        adiFile.setUserId(ThreadContext.getCurrentUserId());\n        this.getBaseMapper().insert(adiFile);\n        return adiFile;\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "saveImageToLocal",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setSha256",
            "sha256"
        ],
        "target_code": "public String saveImageToLocal(User user, String sourceImageUrl) {\n        String uuid = UuidUtil.createShort();\n        String localPath = imagePath + uuid + \".png\";\n        File target = new File(localPath);\n        try {\n            FileUtils.createParentDirectories(target);\n            FileUtils.copyURLToFile(new URL(sourceImageUrl), target);\n        } catch (IOException e) {\n            log.error(\"saveToLocal\", e);\n            throw new BaseException(B_SAVE_IMAGE_ERROR);\n        }\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(target.getName());\n        adiFile.setUuid(uuid);\n        adiFile.setSha256(HashUtil.sha256(localPath));\n        adiFile.setPath(localPath);\n        adiFile.setUserId(user.getId());\n        adiFile.setExt(\"png\");\n        this.getBaseMapper().insert(adiFile);\n        return uuid;\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "removeFileAndSoftDel",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "deleteIfExists",
            "get",
            "getPath",
            "warn"
        ],
        "target_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            try {\n                if (!Files.deleteIfExists(Paths.get(adiFile.getPath()))) {\n                    log.warn(\"Delete file fail,uuid:{}\", uuid);\n                }\n            } catch (IOException e) {\n                throw new BaseException(B_DELETE_FILE_ERROR);\n            }\n        }\n        this.softDel(uuid);\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "readImage",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private BufferedImage readImage(AdiFile adiFile, boolean thumbnail) {\n        try {\n            String currentFilePath = adiFile.getPath();\n            if (thumbnail) {\n                currentFilePath = thumbnailsPath + adiFile.getUuid() + \".\" + adiFile.getExt();\n                //不存在则创建\n                if (new File(adiFile.getPath()).exists() && !new File(currentFilePath).exists()) {\n                    ImgUtil.scale(\n                            cn.hutool.core.io.FileUtil.file(adiFile.getPath()),\n                            cn.hutool.core.io.FileUtil.file(currentFilePath),\n                            0.2f\n                    );\n                }\n            }\n            return ImageIO.read(new FileInputStream(currentFilePath));\n        } catch (IOException e) {\n            throw new BaseException(B_IO_EXCEPTION);\n        }\n    }"
    },
    {
        "target_file_name": "ConversationController.java",
        "target_method": "add",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "getAiSystemMessage",
            "getRemark",
            "getTitle"
        ],
        "target_code": "@PostMapping(\"/add\")\n    public ConvDto add(@RequestBody @Validated ConvAddReq convAddReq) {\n        return conversationService.add(convAddReq.getTitle(), convAddReq.getRemark(), convAddReq.getAiSystemMessage());\n    }"
    },
    {
        "target_file_name": "ConversationService.java",
        "target_method": "add",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public ConvDto add(String title, String systemMessage) {\n        Conversation conversation = this.lambdaQuery()\n                .eq(Conversation::getUserId, ThreadContext.getCurrentUserId())\n                .eq(Conversation::getTitle, title)\n                .eq(Conversation::getIsDeleted, false)\n                .one();\n        if (null != conversation) {\n            throw new BaseException(A_CONVERSATION_TITLE_EXIST);\n        }\n        String uuid = UuidUtil.createShort();\n        Conversation one = new Conversation();\n        one.setUuid(uuid);\n        one.setTitle(title);\n        one.setAiSystemMessage(systemMessage);\n        one.setUserId(ThreadContext.getCurrentUserId());\n        baseMapper.insert(one);\n\n        Conversation conv = this.lambdaQuery().eq(Conversation::getUuid, uuid).one();\n        return MPPageUtil.convertTo(conv, ConvDto.class);\n    }"
    },
    {
        "target_file_name": "ConversationService.java",
        "target_method": "addByPresetConv",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "getAiSystemMessage",
            "getTitle"
        ],
        "target_code": "public ConvDto addByPresetConv(String presetConvUuid) {\n        ConversationPreset presetConv = this.conversationPresetService.lambdaQuery()\n                .eq(ConversationPreset::getUuid, presetConvUuid)\n                .eq(ConversationPreset::getIsDeleted, false)\n                .oneOpt()\n                .orElseThrow(() -> new BaseException(A_PRESET_CONVERSATION_NOT_EXIST));\n        ConversationPresetRel presetRel = this.conversationPresetRelService.lambdaQuery()\n                .eq(ConversationPresetRel::getUserId, ThreadContext.getCurrentUserId())\n                .eq(ConversationPresetRel::getUserConvId, presetConv.getId())\n                .eq(ConversationPresetRel::getIsDeleted, false)\n                .oneOpt()\n                .orElse(null);\n        if (null != presetRel) {\n            Conversation conv = this.getById(presetRel.getUserConvId());\n            return MPPageUtil.convertTo(conv, ConvDto.class);\n        }\n        ConvDto convDto = self.add(presetConv.getTitle(), presetConv.getAiSystemMessage());\n        conversationPresetRelService.save(\n                ConversationPresetRel.builder()\n                        .presetConvId(presetConv.getId())\n                        .userConvId(convDto.getId())\n                        .userId(ThreadContext.getCurrentUserId())\n                        .build()\n        );\n        return convDto;\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "writeToLocal",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "",
            "e.get",
            "eq",
            "mbdaUp",
            "md5ByMultipartFile",
            "th(ori",
            "warn"
        ],
        "target_code": "public AdiFile writeToLocal(MultipartFile file, boolean image) {\n        String md5 = MD5Utils.md5ByMultipartFile(file);\n        Optional<AdiFile> existFile = this.lambdaQuery()\n                .eq(AdiFile::getMd5, md5)\n                .eq(AdiFile::getIsDeleted, false)\n                .oneOpt();\n        if (existFile.isPresent()) {\n            AdiFile adiFile = existFile.get();\n            boolean exist = FileUtil.checkIfExist(adiFile.getPath());\n            if (exist) {\n                return adiFile;\n            } else {\n                log.warn(\"文件不存在,删除记录以便后续重新生成,fileId:{},uuid:{},md5:{}\", adiFile.getId(), adiFile.getUuid(), adiFile.getMd5());\n                this.lambdaUpdate().eq(AdiFile::getId, adiFile.getId()).set(AdiFile::getIsDeleted, true).update();\n            }\n        }\n        String uuid = UuidUtil.createShort();\n        Pair<String, String> originalFile = FileUtil.saveToLocal(file, image ? imagePath : filePath, uuid);\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(file.getOriginalFilename());\n        adiFile.setUuid(uuid);\n        adiFile.setMd5(md5);\n        adiFile.setPath(originalFile.getLeft());\n        adiFile.setExt(originalFile.getRight());\n        adiFile.setUserId(ThreadContext.getCurrentUserId());\n        this.getBaseMapper().insert(adiFile);\n        return adiFile;\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "saveImageToLocal",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "calculateMD5",
            "setMd5"
        ],
        "target_code": "public String saveImageToLocal(User user, String sourceImageUrl) {\n        String uuid = UuidUtil.createShort();\n        String localPath = imagePath + uuid + \".png\";\n        File target = new File(localPath);\n        try {\n            FileUtils.createParentDirectories(target);\n            FileUtils.copyURLToFile(new URL(sourceImageUrl), target);\n        } catch (IOException e) {\n            log.error(\"saveToLocal\", e);\n            throw new BaseException(B_SAVE_IMAGE_ERROR);\n        }\n        AdiFile adiFile = new AdiFile();\n        adiFile.setName(target.getName());\n        adiFile.setUuid(uuid);\n        adiFile.setMd5(MD5Utils.calculateMD5(localPath));\n        adiFile.setPath(localPath);\n        adiFile.setUserId(user.getId());\n        adiFile.setExt(\"png\");\n        this.getBaseMapper().insert(adiFile);\n        return uuid;\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "removeFileAndSoftDel",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "delete",
            "getPath",
            "warn"
        ],
        "target_code": "public void removeFileAndSoftDel(String uuid) {\n        AdiFile adiFile = this.lambdaQuery()\n                .eq(AdiFile::getUserId, ThreadContext.getCurrentUserId())\n                .eq(AdiFile::getUuid, uuid)\n                .oneOpt()\n                .orElse(null);\n        if (null == adiFile) {\n            return;\n        }\n        if (StringUtils.isNotBlank(adiFile.getPath())) {\n            File file = new File(adiFile.getPath());\n            if (!file.delete()) {\n                log.warn(\"Delete file error,uuid:{}\", uuid);\n            }\n        }\n        this.softDel(uuid);\n    }"
    },
    {
        "target_file_name": "FileService.java",
        "target_method": "readImage",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private BufferedImage readImage(AdiFile adiFile, boolean thumbnail) {\n        try {\n            String currentFilePath = adiFile.getPath();\n            if (thumbnail) {\n                currentFilePath = thumbnailsPath + adiFile.getUuid() + \".\" + adiFile.getExt();\n                //不存在则创建\n                if (new File(adiFile.getPath()).exists() && !new File(currentFilePath).exists()) {\n                    ImgUtil.scale(\n                            cn.hutool.core.io.FileUtil.file(adiFile.getPath()),\n                            cn.hutool.core.io.FileUtil.file(currentFilePath),\n                            0.2f\n                    );\n                }\n            }\n            return ImageIO.read(new FileInputStream(currentFilePath));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }"
    },
    {
        "target_file_name": "ConversationController.java",
        "target_method": "add",
        "project_url": "https://github.com/moyangzhan/langchain4j-aideepin",
        "commit_id": "3cf625c5044a151a8cbcbdf98e10b4b46b8a975a^",
        "CWE_id": "CWE-328",
        "CVE_id": "CVE-2025-21604",
        "project_name": "langchain4j-aideepin",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "getAiSystemMessage",
            "getTitle"
        ],
        "target_code": "@PostMapping(\"/add\")\n    public ConvDto add(@RequestBody @Validated ConvAddReq convAddReq) {\n        return conversationService.add(convAddReq.getTitle(), convAddReq.getAiSystemMessage());\n    }"
    },
    {
        "target_file_name": "RouteLoader.java",
        "target_method": "load",
        "project_url": "https://github.com/TrueWinter/simofa",
        "commit_id": "1b04ba413a9c1d12a33dd50a32f67345c2fa6f2a",
        "CWE_id": "CWE-306",
        "CVE_id": "CVE-2024-56799",
        "project_name": "simofa",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "before",
            "contains",
            "url",
            "verifyLogin"
        ],
        "target_code": "public void load(Javalin server) throws Exception {\n        // Ignore RouteLoaderException which gets\n        // thrown if a request fails verification\n        server.exception(RouteLoaderException.class, (exception, context) -> {});\n\n        for (Class<? extends Route> route : getRoutes(ROUTES_LOCATION)) {\n            if (!route.isAnnotationPresent(RouteClass.class)) continue;\n            RouteClass routeClass = route.getAnnotation(RouteClass.class);\n            Route routeInstance = route.getDeclaredConstructor().newInstance();\n            Set<String> registeredBefore = new HashSet<>();\n\n            for (Method method : route.getMethods()) {\n                if (!method.isAnnotationPresent(RouteInfo.class)) continue;\n                if (method.getParameterCount() != 1) {\n                    throw new Exception(\"Failed to load route [\" + method.getName() + \"] \" + route.getSimpleName() + \". Method has too many parameters.\");\n                }\n\n                try {\n                    Class<?> firstParam = method.getParameterTypes()[0];\n                    firstParam.asSubclass(Context.class);\n\n                    RouteInfo routeInfo = method.getAnnotation(RouteInfo.class);\n\n                    if (!registeredBefore.contains(routeInfo.url()) && routeClass.verifyLogin()) {\n                        server.before(routeInfo.url(), ctx -> {\n                            if (!Route.verifyLogin(ctx)) {\n                                throw new RouteLoaderException();\n                            }\n                        });\n\n                        registeredBefore.add(routeInfo.url());\n                    }\n\n                    server.addHandler(routeInfo.method(), routeInfo.url(), ctx -> {\n                        try {\n                            method.invoke(routeInstance, ctx);\n                        } catch (InvocationTargetException e) {\n                            if (e.getTargetException() instanceof HttpResponseException) {\n                                throw (HttpResponseException) e.getTargetException();\n                            }\n\n                            throw e;\n                        }\n                    });\n\n                    Simofa.getLogger().info(\n                            String.format(\"Registered route %s %s\", routeInfo.method(), routeInfo.url())\n                    );\n                } catch (Exception e) {\n                    throw new Exception(\"Failed to load route \" + route.getSimpleName(), e);\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "RouteLoader.java",
        "target_method": "load",
        "project_url": "https://github.com/TrueWinter/simofa",
        "commit_id": "1b04ba413a9c1d12a33dd50a32f67345c2fa6f2a^",
        "CWE_id": "CWE-306",
        "CVE_id": "CVE-2024-56799",
        "project_name": "simofa",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "before",
            "url",
            "verifyLogin"
        ],
        "target_code": "public void load(Javalin server) throws Exception {\n        // Ignore RouteLoaderException which gets\n        // thrown if a request fails verification\n        server.exception(RouteLoaderException.class, (exception, context) -> {});\n\n        for (Class<? extends Route> route : getRoutes(ROUTES_LOCATION)) {\n            if (!route.isAnnotationPresent(RouteClass.class)) continue;\n            RouteClass routeClass = route.getAnnotation(RouteClass.class);\n            Route routeInstance = route.getDeclaredConstructor().newInstance();\n            boolean registeredBefore = false;\n\n            for (Method method : route.getMethods()) {\n                if (!method.isAnnotationPresent(RouteInfo.class)) continue;\n                if (method.getParameterCount() != 1) {\n                    throw new Exception(\"Failed to load route [\" + method.getName() + \"] \" + route.getSimpleName() + \". Method has too many parameters.\");\n                }\n\n                try {\n                    Class<?> firstParam = method.getParameterTypes()[0];\n                    firstParam.asSubclass(Context.class);\n\n                    RouteInfo routeInfo = method.getAnnotation(RouteInfo.class);\n\n                    if (!registeredBefore) {\n                        if (routeClass.verifyLogin()) {\n                            server.before(routeInfo.url(), ctx -> {\n                                if (routeClass.verifyLogin()) {\n                                    if (!Route.verifyLogin(ctx)) {\n                                        throw new RouteLoaderException();\n                                    }\n                                }\n                            });\n                        }\n\n                        registeredBefore = true;\n                    }\n\n                    server.addHandler(routeInfo.method(), routeInfo.url(), ctx -> {\n                        try {\n                            method.invoke(routeInstance, ctx);\n                        } catch (InvocationTargetException e) {\n                            if (e.getTargetException() instanceof HttpResponseException) {\n                                throw (HttpResponseException) e.getTargetException();\n                            }\n\n                            throw e;\n                        }\n                    });\n\n                    Simofa.getLogger().info(\n                            String.format(\"Registered route %s %s\", routeInfo.method(), routeInfo.url())\n                    );\n                } catch (Exception e) {\n                    throw new Exception(\"Failed to load route \" + route.getSimpleName(), e);\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "CosmosDbRepository.java",
        "target_method": "getDeployKeyByValue",
        "project_url": "https://github.com/PacoVK/tapir",
        "commit_id": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2024-56802",
        "project_name": "tapir",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "filter",
            "findFirst",
            "getKey",
            "isEmpty",
            "orElseThrow",
            "stream"
        ],
        "target_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n          Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n          if (deployKeys == null || deployKeys.isEmpty() {\n            throw new DeployKeyNotFoundException(\"Could not find matching key\");\n          }\n\n          return deployKeys\n            .stream()\n            .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure exact match\n            .findFirst()\n            .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }"
    },
    {
        "target_file_name": "DynamodbRepository.java",
        "target_method": "getDeployKeyByValue",
        "project_url": "https://github.com/PacoVK/tapir",
        "commit_id": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2024-56802",
        "project_name": "tapir",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "filter",
            "findFirst",
            "getKey",
            "isEmpty",
            "orElseThrow",
            "stream"
        ],
        "target_code": "public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n    if (deployKeys == null || deployKeys.isEmpty()) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n    return deployKeys\n      .stream()\n      .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure exact match\n      .findFirst()\n      .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n  }"
    },
    {
        "target_file_name": "ElasticSearchRepository.java",
        "target_method": "getDeployKeyByValue",
        "project_url": "https://github.com/PacoVK/tapir",
        "commit_id": "c36360b611fa0ba4f5e250fa43ecf8a294785a03",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2024-56802",
        "project_name": "tapir",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "filter",
            "findDeployKeys",
            "findFirst",
            "getEntities",
            "getKey",
            "isEmpty",
            "orElseThrow",
            "stream"
        ],
        "target_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    try {\n      Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n      if (deployKeys == null || deployKeys.isEmpty()) {\n        throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n      // Ensure we match the key exactly\n      return deployKeys.stream()\n          .filter(deployKey -> deployKey.getKey().equals(value)) // Ensure it's an exact match\n          .findFirst()\n          .orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n    } catch (Exception e) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n  }"
    },
    {
        "target_file_name": "CosmosDbRepository.java",
        "target_method": "getDeployKeyByValue",
        "project_url": "https://github.com/PacoVK/tapir",
        "commit_id": "c36360b611fa0ba4f5e250fa43ecf8a294785a03^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2024-56802",
        "project_name": "tapir",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "findFirst",
            "orElseThrow",
            "size",
            "stream"
        ],
        "target_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n          Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n          if (deployKeys == null || deployKeys.size() != 1) {\n            throw new DeployKeyNotFoundException(\"Could not find matching key\");\n          }\n          return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }"
    },
    {
        "target_file_name": "ElasticSearchRepository.java",
        "target_method": "getDeployKeyByValue",
        "project_url": "https://github.com/PacoVK/tapir",
        "commit_id": "c36360b611fa0ba4f5e250fa43ecf8a294785a03^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2024-56802",
        "project_name": "tapir",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "findDeployKeys",
            "findFirst",
            "getEntities",
            "orElseThrow",
            "size",
            "stream"
        ],
        "target_code": "@Override\n  public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n      try {\n        Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n        if (deployKeys == null || deployKeys.size() != 1) {\n          throw new DeployKeyNotFoundException(\"Could not find matching key\");\n        }\n        return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n      } catch (Exception e) {\n        throw new DeployKeyNotFoundException(\"Could not find matching key\");\n      }\n  }"
    },
    {
        "target_file_name": "DynamodbRepository.java",
        "target_method": "getDeployKeyByValue",
        "project_url": "https://github.com/PacoVK/tapir",
        "commit_id": "c36360b611fa0ba4f5e250fa43ecf8a294785a03^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2024-56802",
        "project_name": "tapir",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "findFirst",
            "orElseThrow",
            "size",
            "stream"
        ],
        "target_code": "public DeployKey getDeployKeyByValue(String value) throws DeployKeyNotFoundException {\n    Collection<DeployKey> deployKeys = (Collection<DeployKey>) findDeployKeys(\"\", 1, value).getEntities();\n    if (deployKeys == null || deployKeys.size() != 1) {\n      throw new DeployKeyNotFoundException(\"Could not find matching key\");\n    }\n    return deployKeys.stream().findFirst().orElseThrow(() -> new DeployKeyNotFoundException(\"Could not find matching key\"));\n  }"
    },
    {
        "target_file_name": "PropertyClass.java",
        "target_method": "displayCustom",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ef978315649cf83eae396021bb33603a1a5f7e42",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-49586",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getDocumentReference",
            "getObject",
            "getOwnerDocument",
            "isRestricted",
            "renderContentInContext"
        ],
        "target_code": "public void displayCustom(StringBuffer buffer, String fieldName, String prefix, String type, BaseObject object,\n        final XWikiContext context) throws XWikiException\n    {\n        String content = \"\";\n        try {\n            ScriptContext scontext = Utils.getComponent(ScriptContextManager.class).getCurrentScriptContext();\n            scontext.setAttribute(\"name\", fieldName, ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"prefix\", prefix, ScriptContext.ENGINE_SCOPE);\n            // The PropertyClass instance can be used to access meta properties in the custom displayer (e.g.\n            // dateFormat, multiSelect). It can be obtained from the XClass of the given object but only if the property\n            // has been added to the XClass. We need to have it in the Velocity context for the use case when an XClass\n            // property needs to be previewed before being added to the XClass.\n            scontext.setAttribute(\"field\", new com.xpn.xwiki.api.PropertyClass(this, context),\n                ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"object\", new com.xpn.xwiki.api.Object(object, context), ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"type\", type, ScriptContext.ENGINE_SCOPE);\n\n            BaseProperty prop = (BaseProperty) object.safeget(fieldName);\n            if (prop != null) {\n                scontext.setAttribute(\"value\", prop.getValue(), ScriptContext.ENGINE_SCOPE);\n            } else {\n                // The $value property can exist in the velocity context, we overwrite it to make sure we don't get a\n                // wrong value in the displayer when the property does not exist yet.\n                scontext.setAttribute(\"value\", null, ScriptContext.ENGINE_SCOPE);\n            }\n\n            String customDisplayer = getCachedDefaultCustomDisplayer(context);\n            if (StringUtils.isNotEmpty(customDisplayer)) {\n                if (customDisplayer.equals(CLASS_DISPLAYER_IDENTIFIER)) {\n                    final String rawContent = getCustomDisplay();\n                    XWikiDocument classDocument = getObject().getOwnerDocument();\n                    final String classSyntax = classDocument.getSyntax().toIdString();\n                    // Using author reference since the document content is not relevant in this case.\n                    DocumentReference authorReference = classDocument.getAuthorReference();\n                    if (authorReference == null && classDocument.isNew()) {\n                        // If the class document has not been saved yet (e.g. we could be previewing a class property in\n                        // the class editor) then use the context user as author (e.g. the user that is in the process\n                        // of creating the class).\n                        authorReference = context.getUserReference();\n                    }\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. class\n                    // document author).\n                    content = renderContentInContext(rawContent, classSyntax, authorReference,\n                        classDocument.getDocumentReference(), classDocument.isRestricted(), context);\n                } else if (customDisplayer.startsWith(DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    XWikiDocument displayerDoc = context.getWiki().getDocument(\n                        StringUtils.substringAfter(customDisplayer, DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX), context);\n                    final String rawContent = displayerDoc.getContent();\n                    final String displayerDocSyntax = displayerDoc.getSyntax().toIdString();\n                    DocumentReference authorReference = displayerDoc.getContentAuthorReference();\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. displayer\n                    // document content author).\n                    content = renderContentInContext(rawContent, displayerDocSyntax, authorReference,\n                        displayerDoc.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    content = context.getWiki().evaluateTemplate(\n                        StringUtils.substringAfter(customDisplayer, TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX), context);\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                XWikiException.ERROR_XWIKI_CLASSES_CANNOT_PREPARE_CUSTOM_DISPLAY,\n                \"Exception while preparing the custom display of \" + fieldName, e, null);\n\n        }\n        buffer.append(content);\n    }"
    },
    {
        "target_file_name": "PropertyClass.java",
        "target_method": "renderContentInContext",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ef978315649cf83eae396021bb33603a1a5f7e42",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-49586",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "call",
            "getComponent",
            "getDoc",
            "getRenderedContent"
        ],
        "target_code": "@Unstable\n    protected String renderContentInContext(final String content, final String syntax,\n        DocumentReference authorReference, DocumentReference secureDocument,\n        boolean restricted, final XWikiContext context)\n        throws Exception\n    {\n        return Utils.getComponent(AuthorExecutor.class)\n            .call(() -> context.getDoc().getRenderedContent(content, syntax, restricted, context), authorReference,\n                secureDocument);\n    }"
    },
    {
        "target_file_name": "PropertyClass.java",
        "target_method": "displayCustom",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ef978315649cf83eae396021bb33603a1a5f7e42^",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-49586",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getDocument",
            "getDocumentReference",
            "getObject",
            "getWiki",
            "renderContentInContext"
        ],
        "target_code": "public void displayCustom(StringBuffer buffer, String fieldName, String prefix, String type, BaseObject object,\n        final XWikiContext context) throws XWikiException\n    {\n        String content = \"\";\n        try {\n            ScriptContext scontext = Utils.getComponent(ScriptContextManager.class).getCurrentScriptContext();\n            scontext.setAttribute(\"name\", fieldName, ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"prefix\", prefix, ScriptContext.ENGINE_SCOPE);\n            // The PropertyClass instance can be used to access meta properties in the custom displayer (e.g.\n            // dateFormat, multiSelect). It can be obtained from the XClass of the given object but only if the property\n            // has been added to the XClass. We need to have it in the Velocity context for the use case when an XClass\n            // property needs to be previewed before being added to the XClass.\n            scontext.setAttribute(\"field\", new com.xpn.xwiki.api.PropertyClass(this, context),\n                ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"object\", new com.xpn.xwiki.api.Object(object, context), ScriptContext.ENGINE_SCOPE);\n            scontext.setAttribute(\"type\", type, ScriptContext.ENGINE_SCOPE);\n\n            BaseProperty prop = (BaseProperty) object.safeget(fieldName);\n            if (prop != null) {\n                scontext.setAttribute(\"value\", prop.getValue(), ScriptContext.ENGINE_SCOPE);\n            } else {\n                // The $value property can exist in the velocity context, we overwrite it to make sure we don't get a\n                // wrong value in the displayer when the property does not exist yet.\n                scontext.setAttribute(\"value\", null, ScriptContext.ENGINE_SCOPE);\n            }\n\n            String customDisplayer = getCachedDefaultCustomDisplayer(context);\n            if (StringUtils.isNotEmpty(customDisplayer)) {\n                if (customDisplayer.equals(CLASS_DISPLAYER_IDENTIFIER)) {\n                    final String rawContent = getCustomDisplay();\n                    XWikiDocument classDocument =\n                        context.getWiki().getDocument(getObject().getDocumentReference(), context);\n                    final String classSyntax = classDocument.getSyntax().toIdString();\n                    // Using author reference since the document content is not relevant in this case.\n                    DocumentReference authorReference = classDocument.getAuthorReference();\n                    if (authorReference == null && classDocument.isNew()) {\n                        // If the class document has not been saved yet (e.g. we could be previewing a class property in\n                        // the class editor) then use the context user as author (e.g. the user that is in the process\n                        // of creating the class).\n                        authorReference = context.getUserReference();\n                    }\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. class\n                    // document author).\n                    content = renderContentInContext(rawContent, classSyntax, authorReference,\n                        classDocument.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    XWikiDocument displayerDoc = context.getWiki().getDocument(\n                        StringUtils.substringAfter(customDisplayer, DOCUMENT_DISPLAYER_IDENTIFIER_PREFIX), context);\n                    final String rawContent = displayerDoc.getContent();\n                    final String displayerDocSyntax = displayerDoc.getSyntax().toIdString();\n                    DocumentReference authorReference = displayerDoc.getContentAuthorReference();\n\n                    // Make sure we render the custom displayer with the rights of the user who wrote it (i.e. displayer\n                    // document content author).\n                    content = renderContentInContext(rawContent, displayerDocSyntax, authorReference,\n                        displayerDoc.getDocumentReference(), context);\n                } else if (customDisplayer.startsWith(TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX)) {\n                    content = context.getWiki().evaluateTemplate(\n                        StringUtils.substringAfter(customDisplayer, TEMPLATE_DISPLAYER_IDENTIFIER_PREFIX), context);\n                }\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CLASSES,\n                XWikiException.ERROR_XWIKI_CLASSES_CANNOT_PREPARE_CUSTOM_DISPLAY,\n                \"Exception while preparing the custom display of \" + fieldName, e, null);\n\n        }\n        buffer.append(content);\n    }"
    },
    {
        "target_file_name": "PropertyClass.java",
        "target_method": "renderContentInContext",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ef978315649cf83eae396021bb33603a1a5f7e42^",
        "CWE_id": "CWE-863",
        "CVE_id": "CVE-2025-49586",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "renderContentInContext"
        ],
        "target_code": "@Deprecated\n    protected String renderContentInContext(final String content, final String syntax,\n        DocumentReference authorReference, final XWikiContext context) throws Exception\n    {\n        return renderContentInContext(content, syntax, authorReference, null, context);\n    }"
    },
    {
        "target_file_name": "DefaultMacroBlockRequiredRightAnalyzer.java",
        "target_method": "analyzeWithExceptions",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "abdcefc0db27035b67329add836fd683e0cf92b8",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addAll",
            "maybeAnalyzeMacroContent",
            "maybeAnalyzeParameters"
        ],
        "target_code": "private List<RequiredRightAnalysisResult> analyzeWithExceptions(MacroBlock macroBlock)\n        throws RequiredRightsException\n    {\n        List<RequiredRightAnalysisResult> result;\n\n        Optional<RequiredRightAnalyzer<MacroBlock>>\n            specificAnalyzer = getMacroBlockRequiredRightAnalyzer(macroBlock);\n\n        if (specificAnalyzer.isPresent()) {\n            result = specificAnalyzer.get().analyze(macroBlock);\n        } else {\n            // Check if there is a macro analyzer for this macro, if yes, use it.\n            Optional<MacroRequiredRightsAnalyzer> macroAnalyzer = getMacroAnalyzer(macroBlock.getId());\n\n            if (macroAnalyzer.isPresent()) {\n                DefaultMacroRequiredRightReporter reporter = this.macroRequiredRightReporterProvider.get();\n                macroAnalyzer.get().analyze(macroBlock, reporter);\n                result = reporter.getResults();\n            } else {\n                // No specific analyzer found, get more information about the macro.\n                Macro<?> macro = getMacro(macroBlock);\n\n                if (macro instanceof ScriptMacro) {\n                    result = this.scriptMacroAnalyzer.analyze(macroBlock);\n                } else if (macro != null) {\n                    result = new ArrayList<>(maybeAnalyzeMacroContent(macroBlock, macro));\n                    result.addAll(maybeAnalyzeParameters(macroBlock, macro));\n                } else {\n                    result = List.of();\n                }\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "DefaultMacroBlockRequiredRightAnalyzer.java",
        "target_method": "analyzeWithExceptions",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "abdcefc0db27035b67329add836fd683e0cf92b8^",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "analyzeMacroContent",
            "getContent",
            "shouldMacroContentBeParsed"
        ],
        "target_code": "private List<RequiredRightAnalysisResult> analyzeWithExceptions(MacroBlock macroBlock)\n        throws RequiredRightsException\n    {\n        List<RequiredRightAnalysisResult> result;\n\n        Optional<RequiredRightAnalyzer<MacroBlock>>\n            specificAnalyzer = getMacroBlockRequiredRightAnalyzer(macroBlock);\n\n        if (specificAnalyzer.isPresent()) {\n            result = specificAnalyzer.get().analyze(macroBlock);\n        } else {\n            // Check if there is a macro analyzer for this macro, if yes, use it.\n            Optional<MacroRequiredRightsAnalyzer> macroAnalyzer = getMacroAnalyzer(macroBlock.getId());\n\n            if (macroAnalyzer.isPresent()) {\n                DefaultMacroRequiredRightReporter reporter = this.macroRequiredRightReporterProvider.get();\n                macroAnalyzer.get().analyze(macroBlock, reporter);\n                result = reporter.getResults();\n            } else {\n                // No specific analyzer found, get more information about the macro.\n                Macro<?> macro = getMacro(macroBlock);\n\n                if (macro instanceof ScriptMacro) {\n                    result = this.scriptMacroAnalyzer.analyze(macroBlock);\n                } else if (macro != null && this.shouldMacroContentBeParsed(macro)) {\n                    result = analyzeMacroContent(macroBlock, macroBlock.getContent());\n                } else {\n                    result = List.of();\n                }\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "ObjectPropertyRequiredRightAnalyzer.java",
        "target_method": "analyzeWikiContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public List<RequiredRightAnalysisResult> analyzeWikiContent(BaseObject object, String value,\n        EntityReference reference)\n        throws RequiredRightsException\n    {\n        try {\n            XDOM parsedContent = this.contentParser.parse(value, object.getOwnerDocument().getSyntax(),\n                object.getDocumentReference());\n            parsedContent.getMetaData().addMetaData(XDOMRequiredRightAnalyzer.ENTITY_REFERENCE_METADATA, reference);\n            return this.xdomRequiredRightAnalyzer.analyze(parsedContent);\n        } catch (ParseException | MissingParserException e) {\n            throw new RequiredRightsException(\"Failed to parse content of object property\", e);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultWikiMacroRenderer.java",
        "target_method": "parseWiki",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "parse"
        ],
        "target_code": "private XDOM parseWiki(String macroContent, Syntax syntax, boolean transform, boolean inline)\n        throws RenderingException\n    {\n        try {\n            return this.contentParser.parse(macroContent, syntax, this.syncContext, transform, null, inline);\n        } catch (MacroExecutionException e) {\n            throw new RenderingException(\"Failed to parse the passed content\", e);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultWikiMacroRenderer.java",
        "target_method": "parseContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "parseWiki"
        ],
        "target_code": "private XDOM parseContent(String macroContent, boolean inline) throws RenderingException\n    {\n        ContentDescriptor contentDescriptor = this.wikimacro.getDescriptor().getContentDescriptor();\n        if (contentDescriptor == null || !contentDescriptor.getType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroContent));\n            } catch (ParseException e) {\n                throw new RenderingException(\"Error while parsing the macro content in plain text.\", e);\n            }\n        } else {\n            return parseWiki(macroContent, null, false, inline);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultWikiMacroRenderer.java",
        "target_method": "parseParameterValue",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "getDefaultValue",
            "getSourceSyntax",
            "parseWiki"
        ],
        "target_code": "private XDOM parseParameterValue(String macroParameterContent, String macroParameterName, boolean inline)\n        throws MacroExecutionException, RenderingException\n    {\n        MacroDescriptor macroDescriptor = this.wikimacro.getDescriptor();\n        ParameterDescriptor parameterDescriptor = null;\n        if (macroDescriptor != null) {\n            parameterDescriptor = macroDescriptor.getParameterDescriptorMap().get(macroParameterName);\n        }\n\n        if (parameterDescriptor == null || !parameterDescriptor.getParameterType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroParameterContent));\n            } catch (ParseException e) {\n                throw new MacroExecutionException(\"Error while parsing the macro parameter content in plain.\", e);\n            }\n        } else {\n            boolean executeWithMacroAuthor =\n                Objects.equals(macroParameterContent, parameterDescriptor.getDefaultValue());\n            if (executeWithMacroAuthor) {\n                return parseWiki(macroParameterContent, this.wikimacro.getSourceSyntax(), true, inline);\n            } else {\n                return parseWiki(macroParameterContent, null, false, inline);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "ObjectPropertyRequiredRightAnalyzer.java",
        "target_method": "analyzeWikiContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de^",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private List<RequiredRightAnalysisResult> analyzeWikiContent(BaseObject object, String value,\n        EntityReference reference)\n        throws RequiredRightsException\n    {\n        try {\n            XDOM parsedContent = this.contentParser.parse(value, object.getOwnerDocument().getSyntax(),\n                object.getDocumentReference());\n            parsedContent.getMetaData().addMetaData(XDOMRequiredRightAnalyzer.ENTITY_REFERENCE_METADATA, reference);\n            return this.xdomRequiredRightAnalyzer.analyze(parsedContent);\n        } catch (ParseException | MissingParserException e) {\n            throw new RequiredRightsException(\"Failed to parse content of object property\", e);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultWikiMacroRenderer.java",
        "target_method": "parseWiki",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de^",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "parse"
        ],
        "target_code": "private XDOM parseWiki(String macroContent, boolean inline) throws RenderingException\n    {\n        try {\n            return this.contentParser.parse(macroContent, this.syncContext, false, inline);\n        } catch (MacroExecutionException e) {\n            throw new RenderingException(\"Failed to parse the passed content\", e);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultWikiMacroRenderer.java",
        "target_method": "parseContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de^",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "parseWiki"
        ],
        "target_code": "private XDOM parseContent(String macroContent, boolean inline) throws RenderingException\n    {\n        ContentDescriptor contentDescriptor = this.wikimacro.getDescriptor().getContentDescriptor();\n        if (contentDescriptor == null || !contentDescriptor.getType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroContent));\n            } catch (ParseException e) {\n                throw new RenderingException(\"Error while parsing the macro content in plain text.\", e);\n            }\n        } else {\n            return parseWiki(macroContent, inline);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultWikiMacroRenderer.java",
        "target_method": "parseParameterValue",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "c99d501ed41cbee6a3c02ff927714531570789de^",
        "CWE_id": "CWE-270",
        "CVE_id": "CVE-2025-49581",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "parseWiki"
        ],
        "target_code": "private XDOM parseParameterValue(String macroParameterContent, String macroParameterName, boolean inline)\n        throws MacroExecutionException, RenderingException\n    {\n        MacroDescriptor macroDescriptor = this.wikimacro.getDescriptor();\n        ParameterDescriptor parameterDescriptor = null;\n        if (macroDescriptor != null) {\n            parameterDescriptor = macroDescriptor.getParameterDescriptorMap().get(macroParameterName);\n        }\n\n        if (parameterDescriptor == null || !parameterDescriptor.getParameterType().equals(Block.LIST_BLOCK_TYPE)) {\n            try {\n                return this.plainTextParser.parse(new StringReader(macroParameterContent));\n            } catch (ParseException e) {\n                throw new MacroExecutionException(\"Error while parsing the macro parameter content in plain.\", e);\n            }\n        } else {\n            return parseWiki(macroParameterContent, inline);\n        }\n    }"
    },
    {
        "target_file_name": "ContextMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "cc74dc802efe0e2d3fa2ba3355dbadc51c5fd8c7",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "analyzeContent",
            "getReference",
            "getSource",
            "getType",
            "isRestricted",
            "of",
            "report"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.beanManager.populate(parameters, macroBlock.getParameters());\n\n            // If the source parameter is set, the content is ignored, and we should analyze the source parameter\n            // instead.\n            if (parameters.getSource() != null) {\n                String sourceType = parameters.getSource().getType();\n\n                switch (sourceType) {\n                    case MacroContentSourceReference.TYPE_STRING:\n                        if (!parameters.isRestricted()) {\n                            reporter.analyzeContent(macroBlock, parameters.getSource().getReference());\n                        }\n                        break;\n\n                    case MacroContentSourceReference.TYPE_SCRIPT:\n                        if (parameters.isRestricted()) {\n                            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                                \"rendering.macro.context.requiredRights.restrictedScriptSource\");\n                        } else {\n                            // We don't know the actual content, but at least script right is needed and the content\n                            // could contain anything, so it might require programming right.\n                            reporter.report(macroBlock,\n                                List.of(MacroRequiredRight.SCRIPT, MacroRequiredRight.MAYBE_PROGRAM),\n                                \"rendering.macro.context.requiredRights.arbitraryScriptSource\");\n                        }\n                        break;\n\n                    default:\n                        // Do nothing.\n                }\n            } else if (!parameters.isRestricted()) {\n                reporter.analyzeContent(macroBlock, macroBlock.getContent());\n            }\n        } catch (PropertyException e) {\n            // Ignore, the macro won't be executed when populating the parameters fails.\n        }\n    }"
    },
    {
        "target_file_name": "ContextMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "cc74dc802efe0e2d3fa2ba3355dbadc51c5fd8c7^",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "isRestricted"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        ContextMacroParameters parameters = new ContextMacroParameters();\n\n        try {\n            this.beanManager.populate(parameters, macroBlock.getParameters());\n\n            // Analyze the content only when it isn't restricted.\n            if (!parameters.isRestricted()) {\n                reporter.analyzeContent(macroBlock, macroBlock.getContent());\n            }\n        } catch (PropertyException e) {\n            // Ignore, the macro won't be executed when populating the parameters fails.\n        }\n    }"
    },
    {
        "target_file_name": "HTMLMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "anyMatch",
            "getBooleanParameterValues",
            "noneMatch"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        boolean wiki = getBooleanParameterValues(macroBlock, \"wiki\").anyMatch(Boolean.TRUE::equals);\n\n        // Cleaning is enabled by default.\n        boolean clean = getBooleanParameterValues(macroBlock, \"clean\").noneMatch(Boolean.FALSE::equals);\n\n        if (wiki) {\n            reporter.analyzeContent(macroBlock, macroBlock.getContent());\n        }\n\n        if (!clean) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                TRANSLATION_PREFIX + \"noClean\");\n        } else if (wiki) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.MAYBE_SCRIPT),\n                TRANSLATION_PREFIX + \"wikiContent\");\n        } else {\n            HTMLCleanerConfiguration cleanerConfiguration = this.htmlCleaner.getDefaultConfiguration();\n            Map<String, String> parameters = new HashMap<>(cleanerConfiguration.getParameters());\n            // Assume HTML 5 as there is no real way to determine the target version of the rendering action. Also,\n            // the analysis shouldn't really be affected by the HTML version.\n            parameters.put(HTMLCleanerConfiguration.HTML_VERSION, \"5\");\n            cleanerConfiguration.setParameters(parameters);\n\n            // Add the filter for detecting content that would be filtered by restricted mode.\n            List<HTMLFilter> filters = new ArrayList<>(cleanerConfiguration.getFilters());\n            filters.add(this.restrictedFilterDetector);\n            cleanerConfiguration.setFilters(filters);\n\n            Document document = this.htmlCleaner.clean(new StringReader(macroBlock.getContent()), cleanerConfiguration);\n            if (Boolean.parseBoolean(document.getDocumentElement()\n                .getAttribute(SanitizerDetectorFilter.ATTRIBUTE_FILTERED)))\n            {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    TRANSLATION_PREFIX + \"dangerousContent\");\n            }\n        }\n    }"
    },
    {
        "target_file_name": "RawMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "anyMatch",
            "entrySet",
            "equalsIgnoreCase",
            "filter",
            "getKey",
            "getParameters",
            "getValue",
            "isHTMLSyntax",
            "of",
            "report",
            "stream"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        // Check if any parameter that is equal to \"syntax\" ignoring case is an HTML syntax.\n        boolean isHTML = macroBlock.getParameters().entrySet().stream()\n            .filter(entry -> \"syntax\".equalsIgnoreCase(entry.getKey()))\n            .anyMatch(entry -> isHTMLSyntax(entry.getValue()));\n\n        if (isHTML) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT), \"rendering.macro.rawMacroRequiredRights\");\n        }\n    }"
    },
    {
        "target_file_name": "CacheMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "3d451e957fe2b14459e9ac64172b4a0e4c46971c",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "analyzeContent",
            "entrySet",
            "equalsIgnoreCase",
            "filter",
            "forEach",
            "getKey",
            "getParameters",
            "getValue",
            "stream"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        macroBlock.getParameters().entrySet().stream()\n            .filter(entry -> \"id\".equalsIgnoreCase(entry.getKey()))\n            .forEach(entry -> reporter.analyzeContent(macroBlock, entry.getValue()));\n\n        reporter.analyzeContent(macroBlock, macroBlock.getContent());\n    }"
    },
    {
        "target_file_name": "HTMLMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "3d451e957fe2b14459e9ac64172b4a0e4c46971c^",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "convert",
            "equals",
            "getParameter"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        boolean wiki = Boolean.TRUE.equals(this.converter.convert(Boolean.class, macroBlock.getParameter(\"wiki\")));\n        String cleanParameter = macroBlock.getParameter(\"clean\");\n        // Cleaning is enabled by default.\n        boolean clean =\n            cleanParameter == null || Boolean.TRUE.equals(this.converter.convert(Boolean.class, cleanParameter));\n\n        if (wiki) {\n            reporter.analyzeContent(macroBlock, macroBlock.getContent());\n        }\n\n        if (!clean) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                TRANSLATION_PREFIX + \"noClean\");\n        } else if (wiki) {\n            reporter.report(macroBlock, List.of(MacroRequiredRight.MAYBE_SCRIPT),\n                TRANSLATION_PREFIX + \"wikiContent\");\n        } else {\n            HTMLCleanerConfiguration cleanerConfiguration = this.htmlCleaner.getDefaultConfiguration();\n            Map<String, String> parameters = new HashMap<>(cleanerConfiguration.getParameters());\n            // Assume HTML 5 as there is no real way to determine the target version of the rendering action. Also,\n            // the analysis shouldn't really be affected by the HTML version.\n            parameters.put(HTMLCleanerConfiguration.HTML_VERSION, \"5\");\n            cleanerConfiguration.setParameters(parameters);\n\n            // Add the filter for detecting content that would be filtered by restricted mode.\n            List<HTMLFilter> filters = new ArrayList<>(cleanerConfiguration.getFilters());\n            filters.add(this.restrictedFilterDetector);\n            cleanerConfiguration.setFilters(filters);\n\n            Document document = this.htmlCleaner.clean(new StringReader(macroBlock.getContent()), cleanerConfiguration);\n            if (Boolean.parseBoolean(document.getDocumentElement()\n                .getAttribute(SanitizerDetectorFilter.ATTRIBUTE_FILTERED)))\n            {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    TRANSLATION_PREFIX + \"dangerousContent\");\n            }\n        }\n    }"
    },
    {
        "target_file_name": "RawMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "3d451e957fe2b14459e9ac64172b4a0e4c46971c^",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "getParameter",
            "getType",
            "of",
            "report",
            "resolveSyntax"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        try {\n            SyntaxType syntax = this.syntaxRegistry.resolveSyntax(macroBlock.getParameter(\"syntax\")).getType();\n            if (SyntaxType.HTML_FAMILY_TYPES.contains(syntax)) {\n                reporter.report(macroBlock, List.of(MacroRequiredRight.SCRIPT),\n                    \"rendering.macro.rawMacroRequiredRights\");\n            }\n        } catch (ParseException e) {\n            // Ignore, this should fail the macro or at least won't produce HTML output.\n        }\n    }"
    },
    {
        "target_file_name": "CacheMacroRequiredRightsAnalyzer.java",
        "target_method": "analyze",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "3d451e957fe2b14459e9ac64172b4a0e4c46971c^",
        "CWE_id": "CWE-357",
        "CVE_id": "CVE-2025-49582",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "analyzeContent",
            "getParameter"
        ],
        "target_code": "@Override\n    public void analyze(MacroBlock macroBlock, MacroRequiredRightReporter reporter)\n    {\n        reporter.analyzeContent(macroBlock, macroBlock.getParameter(\"id\"));\n        reporter.analyzeContent(macroBlock, macroBlock.getContent());\n    }"
    },
    {
        "target_file_name": "AbstractDocumentListClassPropertyValuesProvider.java",
        "target_method": "getValue",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "exists",
            "hasAccess"
        ],
        "target_code": "@Override\n    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)\n        throws XWikiRestException\n    {\n\n        String reference = \"\";\n        if (rawValue != null) {\n            reference = rawValue.toString();\n        }\n        if (StringUtils.isEmpty(reference)) {\n            return null;\n        }\n\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(reference, propertyReference);\n\n        PropertyValue propertyValue = null;\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, documentReference) && exists(documentReference)) {\n            propertyValue = super.getValue(propertyReference, documentReference);\n        }\n\n        if (propertyValue == null) {\n            propertyValue = new PropertyValue();\n        }\n\n        propertyValue.setValue(reference);\n\n        return propertyValue;\n    }"
    },
    {
        "target_file_name": "UsersClassPropertyValuesProvider.java",
        "target_method": "getIcon",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "getAttachment",
            "getDocument",
            "getName",
            "getReference",
            "getRootCauseMessage",
            "getStringValue",
            "getURL",
            "getWiki",
            "hasAccess",
            "isImage",
            "name",
            "put",
            "warn"
        ],
        "target_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference userReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, userReference)) {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            try {\n                XWikiDocument userProfileDocument = xcontext.getWiki().getDocument(userReference, xcontext);\n                String avatar = userProfileDocument.getStringValue(\"avatar\");\n                XWikiAttachment avatarAttachment = userProfileDocument.getAttachment(avatar);\n                if (avatarAttachment != null && avatarAttachment.isImage(xcontext)) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of user [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    userReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }"
    },
    {
        "target_file_name": "GroupsClassPropertyValuesProvider.java",
        "target_method": "getIcon",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getDocument",
            "getFirstImageAttachment",
            "getName",
            "getReference",
            "getRootCauseMessage",
            "getURL",
            "getWiki",
            "hasAccess",
            "name",
            "put",
            "warn"
        ],
        "target_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n                XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n                if (avatarAttachment != null) {\n                    icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                        \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                    icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n                }\n            } catch (XWikiException e) {\n                this.logger.warn(\n                    \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                    groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }"
    },
    {
        "target_file_name": "GroupsClassPropertyValuesProvider.java",
        "target_method": "getLabel",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "getDocument",
            "getLabel",
            "getRenderedTitle",
            "getRootCauseMessage",
            "getWiki",
            "hasAccess",
            "serialize",
            "warn"
        ],
        "target_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, groupReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                    xcontext);\n            } catch (XWikiException e) {\n                this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                    this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            }\n        }\n\n        return super.getLabel(groupReference, currentLabel);\n    }"
    },
    {
        "target_file_name": "PageClassPropertyValuesProvider.java",
        "target_method": "getLabel",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "error",
            "get",
            "getDocument",
            "getLabel",
            "getRenderedTitle",
            "getRootCauseMessage",
            "getTranslatedDocument",
            "getWiki",
            "hasAccess"
        ],
        "target_code": "private String getLabel(EntityReference entityReference)\n    {\n        String label = null;\n\n        if (this.contextualAuthorizationManager.hasAccess(Right.VIEW, entityReference)) {\n            try {\n                XWikiContext xcontext = this.xcontextProvider.get();\n                XWikiDocument document;\n                document = xcontext.getWiki().getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);\n                label = document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while loading the document [{}]. Root cause is [{}]\", entityReference,\n                    ExceptionUtils.getRootCauseMessage(e), e);\n            }\n        }\n\n        if (label == null) {\n            if (entityReference instanceof DocumentReference documentReference) {\n                label = super.getLabel(documentReference, \"\");\n            } else {\n                label = entityReference.getName();\n            }\n        }\n        return label;\n    }"
    },
    {
        "target_file_name": "AbstractDocumentListClassPropertyValuesProvider.java",
        "target_method": "getValue",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "exists"
        ],
        "target_code": "@Override\n    public PropertyValue getValue(ClassPropertyReference propertyReference, Object rawValue)\n        throws XWikiRestException\n    {\n\n        String reference = \"\";\n        if (rawValue != null) {\n            reference = rawValue.toString();\n        }\n        if (StringUtils.isEmpty(reference)) {\n            return null;\n        }\n\n        DocumentReference documentReference = this.documentReferenceResolver.resolve(reference, propertyReference);\n\n        PropertyValue propertyValue = null;\n        if (exists(documentReference)) {\n            propertyValue = super.getValue(propertyReference, documentReference);\n        }\n\n        if (propertyValue == null) {\n            propertyValue = new PropertyValue();\n        }\n\n        propertyValue.setValue(reference);\n\n        return propertyValue;\n    }"
    },
    {
        "target_file_name": "UsersClassPropertyValuesProvider.java",
        "target_method": "getIcon",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "getAttachment",
            "getDocument",
            "getName",
            "getReference",
            "getRootCauseMessage",
            "getStringValue",
            "getURL",
            "getWiki",
            "isImage",
            "name",
            "put",
            "warn"
        ],
        "target_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference userReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument userProfileDocument = xcontext.getWiki().getDocument(userReference, xcontext);\n            String avatar = userProfileDocument.getStringValue(\"avatar\");\n            XWikiAttachment avatarAttachment = userProfileDocument.getAttachment(avatar);\n            if (avatarAttachment != null && avatarAttachment.isImage(xcontext)) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of user [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                userReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }"
    },
    {
        "target_file_name": "GroupsClassPropertyValuesProvider.java",
        "target_method": "getIcon",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getDocument",
            "getFirstImageAttachment",
            "getName",
            "getReference",
            "getRootCauseMessage",
            "getURL",
            "getWiki",
            "name",
            "put",
            "warn"
        ],
        "target_code": "@Override\n    protected Map<String, Object> getIcon(DocumentReference groupReference)\n    {\n        Map<String, Object> icon = new HashMap<>();\n        XWikiContext xcontext = this.xcontextProvider.get();\n        try {\n            XWikiDocument groupProfileDocument = xcontext.getWiki().getDocument(groupReference, xcontext);\n            XWikiAttachment avatarAttachment = getFirstImageAttachment(groupProfileDocument, xcontext);\n            if (avatarAttachment != null) {\n                icon.put(IconManager.META_DATA_URL, xcontext.getWiki().getURL(avatarAttachment.getReference(),\n                    \"download\", \"width=30&height=30&keepAspectRatio=true\", null, xcontext));\n                icon.put(IconManager.META_DATA_ICON_SET_TYPE, IconType.IMAGE.name());\n            }\n        } catch (XWikiException e) {\n            this.logger.warn(\n                \"Failed to read the avatar of group [{}]. Root cause is [{}]. Using the default avatar instead.\",\n                groupReference.getName(), ExceptionUtils.getRootCauseMessage(e));\n        }\n        if (!icon.containsKey(IconManager.META_DATA_URL)) {\n            try {\n                icon = this.iconManager.getMetaData(DEFAULT_ICON_NAME);\n            } catch (IconException e) {\n                this.logger.warn(\"Error getting the icon [{}]. Root cause is [{}].\", DEFAULT_ICON_NAME,\n                    ExceptionUtils.getRootCause(e));\n            }\n        }\n\n        return icon;\n    }"
    },
    {
        "target_file_name": "GroupsClassPropertyValuesProvider.java",
        "target_method": "getLabel",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "getDocument",
            "getLabel",
            "getRenderedTitle",
            "getRootCauseMessage",
            "getWiki",
            "serialize",
            "warn"
        ],
        "target_code": "@Override\n    protected String getLabel(DocumentReference groupReference, Object currentLabel)\n    {\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            return xcontext.getWiki().getDocument(groupReference, xcontext).getRenderedTitle(Syntax.PLAIN_1_0,\n                xcontext);\n        } catch (XWikiException e) {\n            this.logger.warn(\"Failed to get the title of group [{}]. Root cause is [{}].\",\n                this.entityReferenceSerializer.serialize(groupReference), ExceptionUtils.getRootCauseMessage(e));\n            return super.getLabel(groupReference, currentLabel);\n        }\n    }"
    },
    {
        "target_file_name": "PageClassPropertyValuesProvider.java",
        "target_method": "getLabel",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ee642f973a7c95d2d146fe03c81bcdee1871f4ec^",
        "CWE_id": "CWE-201",
        "CVE_id": "CVE-2025-49584",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "error",
            "get",
            "getDocument",
            "getLabel",
            "getRenderedTitle",
            "getRootCause",
            "getTranslatedDocument",
            "getWiki"
        ],
        "target_code": "private String getLabel(EntityReference entityReference)\n    {\n        String label;\n        try {\n            XWikiContext xcontext = this.xcontextProvider.get();\n            XWikiDocument document;\n            document = xcontext.getWiki().getDocument(entityReference, xcontext).getTranslatedDocument(xcontext);\n            label = document.getRenderedTitle(Syntax.PLAIN_1_0, xcontext);\n        } catch (XWikiException e) {\n            this.logger.error(\"Error while loading the document [{}]. Root cause is [{}]\", entityReference,\n                ExceptionUtils.getRootCause(e));\n            if (entityReference instanceof DocumentReference) {\n                label = super.getLabel((DocumentReference) entityReference, \"\");\n            } else {\n                label = entityReference.getName();\n            }\n        }\n        return label;\n    }"
    },
    {
        "target_file_name": "Publisher.java",
        "target_method": "generateDataFile",
        "project_url": "https://github.com/HL7/fhir-ig-publisher",
        "commit_id": "d968694b7dd041640efab5414d7077d5028569f7",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-24363",
        "project_name": "fhir-ig-publisher",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "asString",
            "genDate",
            "genTime",
            "getGitStatus",
            "getName",
            "getProperties",
            "getValue",
            "metadata"
        ],
        "target_code": "private void generateDataFile(DBBuilder db) throws IOException, FHIRException, SQLException {\n    JsonObject data = new JsonObject();\n    data.add(\"path\", checkAppendSlash(specPath));\n    data.add(\"canonical\", igpkp.getCanonical());\n    data.add(\"igId\", publishedIg.getId());\n    data.add(\"igName\", publishedIg.getName());\n    data.add(\"packageId\", npmName);\n    data.add(\"igVer\", workingVersion());\n    data.add(\"errorCount\", getErrorCount());\n    data.add(\"version\", version);\n    \n    StringType rl = findReleaseLabel();  \n    if (rl == null) {\n      data.add(\"releaseLabel\", \"n/a\");\n      for (String l : allLangs()) {\n        data.add(\"releaseLabel\"+l, rcLangs.get(l).formatPhrase(RenderingI18nContext._NA));\n      }\n    } else { \n      data.add(\"releaseLabel\", rl.getValue());\n      addTranslationsToJson(data, \"releaseLabel\", rl, false);\n    }\n    data.add(\"revision\", specMaps.get(0).getBuild());\n    data.add(\"versionFull\", version+\"-\"+specMaps.get(0).getBuild());\n    data.add(\"toolingVersion\", Constants.VERSION);\n    data.add(\"toolingRevision\", ToolsVersion.TOOLS_VERSION_STR);\n    data.add(\"toolingVersionFull\", Constants.VERSION+\" (\"+ToolsVersion.TOOLS_VERSION_STR+\")\");\n\n    data.add(\"genDate\", genTime());\n    data.add(\"genDay\", genDate());\n    if (db != null) {\n      for (JsonProperty p : data.getProperties()) {\n        db.metadata(p.getName(), p.getValue().asString());\n      }\n      db.metadata(\"gitstatus\", getGitStatus());\n    }\n\n    data.add(\"totalFiles\", fileList.size());\n    data.add(\"processedFiles\", changeList.size());\n\n    if (repoSource != null) {\n      data.add(\"repoSource\", gh());\n    } else {\n      String git= getGitSource();\n      if (git != null) {\n        data.add(\"repoSource\", git);\n      }\n    }\n\n    JsonArray rt = data.forceArray(\"resourceTypes\");\n    List<String> rtl = context.getResourceNames();\n    for (String s : rtl) {\n      rt.add(s);\n    }\n    rt = data.forceArray(\"dataTypes\");\n    ContextUtilities cu = new ContextUtilities(context);\n    for (String s : cu.getTypeNames()) {\n      if (!rtl.contains(s)) {\n        rt.add(s);\n      }\n    }\n\n    JsonObject ig = new JsonObject();\n    data.add(\"ig\", ig);\n    ig.add(\"id\", publishedIg.getId());\n    ig.add(\"name\", publishedIg.getName());\n    ig.add(\"title\", publishedIg.getTitle());\n    addTranslationsToJson(ig, \"title\", publishedIg.getTitleElement(), false);\n    ig.add(\"url\", publishedIg.getUrl());\n    ig.add(\"version\", workingVersion());\n    ig.add(\"status\", publishedIg.getStatusElement().asStringValue());\n    ig.add(\"experimental\", publishedIg.getExperimental());\n    ig.add(\"publisher\", publishedIg.getPublisher());    \n    addTranslationsToJson(ig, \"publisher\", publishedIg.getPublisherElement(), false);\n\n    if (previousVersionComparator != null && previousVersionComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(previousVersionComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(previousVersionComparator.getLastUrl()));\n    }    \n    if (ipaComparator != null && ipaComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipaComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipaComparator.getLastUrl()));\n    }\n    if (ipsComparator != null && ipsComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipsComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipsComparator.getLastUrl()));\n    }\n\n    if (publishedIg.hasContact()) {\n      JsonArray jc = new JsonArray();\n      ig.add(\"contact\", jc);\n      for (ContactDetail c : publishedIg.getContact()) {\n        JsonObject jco = new JsonObject();\n        jc.add(jco);\n        jco.add(\"name\", c.getName());\n        if (c.hasTelecom()) {\n          JsonArray jct = new JsonArray();\n          jco.add(\"telecom\", jct);\n          for (ContactPoint cc : c.getTelecom()) {\n            jct.add(new JsonString(cc.getValue()));\n          }\n        }\n      }\n      for (String l : allLangs()) {\n        jc = new JsonArray();\n        ig.add(\"contact\"+l, jc);\n        for (ContactDetail c : publishedIg.getContact()) {\n          JsonObject jco = new JsonObject();\n          jc.add(jco);\n          jco.add(\"name\", langUtils.getTranslationOrBase(c.getNameElement(), l));\n          if (c.hasTelecom()) {\n            JsonArray jct = new JsonArray();\n            jco.add(\"telecom\", jct);\n            for (ContactPoint cc : c.getTelecom()) {\n              jct.add(new JsonString(cc.getValue()));\n            }\n          }\n        }\n        \n      }\n    }\n    ig.add(\"date\", publishedIg.getDateElement().asStringValue());\n    ig.add(\"description\", ProfileUtilities.processRelativeUrls(publishedIg.getDescription(), \"\", igpkp.specPath(), context.getResourceNames(), specMaps.get(0).listTargets(), pageTargets(), false));\n    addTranslationsToJson(ig, \"description\", publishedIg.getDescriptionElement(), true);\n\n    if (context.getTxClientManager() != null && context.getTxClientManager().getMaster() != null) {\n      ig.add(\"tx-server\", context.getTxClientManager().getMaster().getAddress());\n    }\n    ig.add(\"copyright\", publishedIg.getCopyright());\n    addTranslationsToJson(ig, \"copyright\", publishedIg.getCopyrightElement(), true);\n\n    for (Enumeration<FHIRVersion> v : publishedIg.getFhirVersion()) {\n      ig.add(\"fhirVersion\", v.asStringValue());\n      break;\n    }\n\n    for (SpecMapManager sm : specMaps) {\n      if (sm.getName() != null) {\n        data.set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase() : Utilities.appendForwardSlash(sm.getBase()));\n        if (!data.has(\"ver\")) {\n          data.add(\"ver\", new JsonObject());\n        }\n        data.getJsonObject(\"ver\").set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase2() : Utilities.appendForwardSlash(sm.getBase2()));\n      }\n    }\n    String json = org.hl7.fhir.utilities.json.parser.JsonParser.compose(data, true);\n    TextFile.stringToFile(json, Utilities.path(tempDir, \"_data\", \"fhir.json\"));\n  }"
    },
    {
        "target_file_name": "Publisher.java",
        "target_method": "generateDataFile",
        "project_url": "https://github.com/HL7/fhir-ig-publisher",
        "commit_id": "d968694b7dd041640efab5414d7077d5028569f7^",
        "CWE_id": "CWE-200",
        "CVE_id": "CVE-2025-24363",
        "project_name": "fhir-ig-publisher",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "asString",
            "genDate",
            "genTime",
            "getGitStatus",
            "getName",
            "getProperties",
            "getValue",
            "metadata"
        ],
        "target_code": "private void generateDataFile(DBBuilder db) throws IOException, FHIRException, SQLException {\n    JsonObject data = new JsonObject();\n    data.add(\"path\", checkAppendSlash(specPath));\n    data.add(\"canonical\", igpkp.getCanonical());\n    data.add(\"igId\", publishedIg.getId());\n    data.add(\"igName\", publishedIg.getName());\n    data.add(\"packageId\", npmName);\n    data.add(\"igVer\", workingVersion());\n    data.add(\"errorCount\", getErrorCount());\n    data.add(\"version\", version);\n    \n    StringType rl = findReleaseLabel();  \n    if (rl == null) {\n      data.add(\"releaseLabel\", \"n/a\");\n      for (String l : allLangs()) {\n        data.add(\"releaseLabel\"+l, rcLangs.get(l).formatPhrase(RenderingI18nContext._NA));\n      }\n    } else { \n      data.add(\"releaseLabel\", rl.getValue());\n      addTranslationsToJson(data, \"releaseLabel\", rl, false);\n    }\n    data.add(\"revision\", specMaps.get(0).getBuild());\n    data.add(\"versionFull\", version+\"-\"+specMaps.get(0).getBuild());\n    data.add(\"toolingVersion\", Constants.VERSION);\n    data.add(\"toolingRevision\", ToolsVersion.TOOLS_VERSION_STR);\n    data.add(\"toolingVersionFull\", Constants.VERSION+\" (\"+ToolsVersion.TOOLS_VERSION_STR+\")\");\n    data.add(\"totalFiles\", fileList.size());\n    data.add(\"processedFiles\", changeList.size());\n    \n    if (repoSource != null) {\n      data.add(\"repoSource\", gh());\n    } else {\n      String git= getGitSource();\n      if (git != null) {\n        data.add(\"repoSource\", git);\n      }\n    }\n    data.add(\"genDate\", genTime());\n    data.add(\"genDay\", genDate());\n    if (db != null) {\n      for (JsonProperty p : data.getProperties()) {\n        db.metadata(p.getName(), p.getValue().asString());\n      }\n    }\n    JsonArray rt = data.forceArray(\"resourceTypes\");\n    List<String> rtl = context.getResourceNames();\n    for (String s : rtl) {\n      rt.add(s);\n    }\n    rt = data.forceArray(\"dataTypes\");\n    ContextUtilities cu = new ContextUtilities(context);\n    for (String s : cu.getTypeNames()) {\n      if (!rtl.contains(s)) {\n        rt.add(s);\n      }\n    }\n\n    JsonObject ig = new JsonObject();\n    data.add(\"ig\", ig);\n    ig.add(\"id\", publishedIg.getId());\n    ig.add(\"name\", publishedIg.getName());\n    ig.add(\"title\", publishedIg.getTitle());\n    addTranslationsToJson(ig, \"title\", publishedIg.getTitleElement(), false);\n    ig.add(\"url\", publishedIg.getUrl());\n    ig.add(\"version\", workingVersion());\n    ig.add(\"status\", publishedIg.getStatusElement().asStringValue());\n    ig.add(\"experimental\", publishedIg.getExperimental());\n    ig.add(\"publisher\", publishedIg.getPublisher());    \n    addTranslationsToJson(ig, \"publisher\", publishedIg.getPublisherElement(), false);\n    if (db != null) {\n      db.metadata(\"gitstatus\", getGitStatus());\n    }\n    if (previousVersionComparator != null && previousVersionComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(previousVersionComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(previousVersionComparator.getLastUrl()));\n    }    \n    if (ipaComparator != null && ipaComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipaComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipaComparator.getLastUrl()));\n    }\n    if (ipsComparator != null && ipsComparator.hasLast() && !targetUrl().startsWith(\"file:\")) {\n      JsonObject diff = new JsonObject();\n      data.add(\"iga-diff\", diff);\n      diff.add(\"name\", Utilities.encodeUri(ipsComparator.getLastName()));\n      diff.add(\"current\", Utilities.encodeUri(targetUrl()));\n      diff.add(\"previous\", Utilities.encodeUri(ipsComparator.getLastUrl()));\n    }\n\n    if (publishedIg.hasContact()) {\n      JsonArray jc = new JsonArray();\n      ig.add(\"contact\", jc);\n      for (ContactDetail c : publishedIg.getContact()) {\n        JsonObject jco = new JsonObject();\n        jc.add(jco);\n        jco.add(\"name\", c.getName());\n        if (c.hasTelecom()) {\n          JsonArray jct = new JsonArray();\n          jco.add(\"telecom\", jct);\n          for (ContactPoint cc : c.getTelecom()) {\n            jct.add(new JsonString(cc.getValue()));\n          }\n        }\n      }\n      for (String l : allLangs()) {\n        jc = new JsonArray();\n        ig.add(\"contact\"+l, jc);\n        for (ContactDetail c : publishedIg.getContact()) {\n          JsonObject jco = new JsonObject();\n          jc.add(jco);\n          jco.add(\"name\", langUtils.getTranslationOrBase(c.getNameElement(), l));\n          if (c.hasTelecom()) {\n            JsonArray jct = new JsonArray();\n            jco.add(\"telecom\", jct);\n            for (ContactPoint cc : c.getTelecom()) {\n              jct.add(new JsonString(cc.getValue()));\n            }\n          }\n        }\n        \n      }\n    }\n    ig.add(\"date\", publishedIg.getDateElement().asStringValue());\n    ig.add(\"description\", ProfileUtilities.processRelativeUrls(publishedIg.getDescription(), \"\", igpkp.specPath(), context.getResourceNames(), specMaps.get(0).listTargets(), pageTargets(), false));\n    addTranslationsToJson(ig, \"description\", publishedIg.getDescriptionElement(), true);\n\n    if (context.getTxClientManager() != null && context.getTxClientManager().getMaster() != null) {\n      ig.add(\"tx-server\", context.getTxClientManager().getMaster().getAddress());\n    }\n    ig.add(\"copyright\", publishedIg.getCopyright());\n    addTranslationsToJson(ig, \"copyright\", publishedIg.getCopyrightElement(), true);\n\n    for (Enumeration<FHIRVersion> v : publishedIg.getFhirVersion()) {\n      ig.add(\"fhirVersion\", v.asStringValue());\n      break;\n    }\n\n    for (SpecMapManager sm : specMaps) {\n      if (sm.getName() != null) {\n        data.set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase() : Utilities.appendForwardSlash(sm.getBase()));\n        if (!data.has(\"ver\")) {\n          data.add(\"ver\", new JsonObject());\n        }\n        data.getJsonObject(\"ver\").set(sm.getName(), appendTrailingSlashInDataFile ? sm.getBase2() : Utilities.appendForwardSlash(sm.getBase2()));\n      }\n    }\n    String json = org.hl7.fhir.utilities.json.parser.JsonParser.compose(data, true);\n    TextFile.stringToFile(json, Utilities.path(tempDir, \"_data\", \"fhir.json\"));\n  }"
    },
    {
        "target_file_name": "DefaultSFConnectionHandler.java",
        "target_method": "checkLogFolderPermissions",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "isWindows"
        ],
        "target_code": "private void checkLogFolderPermissions(Path path) throws SnowflakeSQLLoggedException {\n    if (!isWindows()) {\n      try {\n        Set<PosixFilePermission> folderPermissions = Files.getPosixFilePermissions(path);\n        if (folderPermissions.contains(PosixFilePermission.GROUP_WRITE)\n            || folderPermissions.contains(PosixFilePermission.GROUP_READ)\n            || folderPermissions.contains(PosixFilePermission.GROUP_EXECUTE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_WRITE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_READ)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_EXECUTE)) {\n          logger.warn(\n              \"Access permission for the logs directory '{}' is currently {} and is potentially \"\n                  + \"accessible to users other than the owner of the logs directory.\",\n              path.toString(),\n              folderPermissions.toString());\n        }\n      } catch (IOException ex) {\n        throw new SnowflakeSQLLoggedException(\n            sfSession,\n            ErrorCode.INTERNAL_ERROR,\n            String.format(\n                \"Unable to get permissions of log directory %s ,%s\",\n                path.toString(), ex.getMessage(), ex.getCause()));\n      }\n    }\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "overrideCacheFile",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "debug",
            "exists",
            "logFileUsage",
            "throwWhenPermiossionDifferentThanReadWriteForOwner"
        ],
        "target_code": "void overrideCacheFile(File newCacheFile) {\n    if (!newCacheFile.exists()) {\n      logger.debug(\"Cache file doesn't exists. File: {}\", newCacheFile);\n    }\n    if (onlyOwnerPermissions) {\n      FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(\n          newCacheFile, \"Override cache file\");\n    } else {\n      FileUtil.logFileUsage(cacheFile, \"Override cache file\", false);\n    }\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "build",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "asFileAttribute",
            "collect",
            "createFile",
            "debug",
            "exists",
            "getAbsoluteFile",
            "getMessage",
            "info",
            "isWindows",
            "of",
            "toPath",
            "toSet"
        ],
        "target_code": "FileCacheManager build() {\n    // try to get cacheDir from system property or environment variable\n    String cacheDirPath =\n        this.cacheDirectorySystemProperty != null\n            ? systemGetProperty(this.cacheDirectorySystemProperty)\n            : null;\n    if (cacheDirPath == null) {\n      try {\n        cacheDirPath =\n            this.cacheDirectoryEnvironmentVariable != null\n                ? systemGetEnv(this.cacheDirectoryEnvironmentVariable)\n                : null;\n      } catch (Throwable ex) {\n        logger.debug(\n            \"Cannot get environment variable for cache directory, skip using cache\", false);\n        // In Boomi cloud, System.getenv is not allowed due to policy,\n        // so we catch the exception and skip cache completely\n        return this;\n      }\n    }\n\n    if (cacheDirPath != null) {\n      this.cacheDir = new File(cacheDirPath);\n    } else {\n      // use user home directory to store the cache file\n      String homeDir = systemGetProperty(\"user.home\");\n      if (homeDir != null) {\n        // Checking if home directory is writable.\n        File homeFile = new File(homeDir);\n        if (!homeFile.canWrite()) {\n          logger.debug(\"Home directory not writeable, skip using cache\", false);\n          homeDir = null;\n        }\n      }\n      if (homeDir == null) {\n        // if still home directory is null, no cache dir is set.\n        return this;\n      }\n      if (Constants.getOS() == Constants.OS.WINDOWS) {\n        this.cacheDir =\n            new File(\n                new File(new File(new File(homeDir, \"AppData\"), \"Local\"), \"Snowflake\"), \"Caches\");\n      } else if (Constants.getOS() == Constants.OS.MAC) {\n        this.cacheDir = new File(new File(new File(homeDir, \"Library\"), \"Caches\"), \"Snowflake\");\n      } else {\n        this.cacheDir = new File(new File(homeDir, \".cache\"), \"snowflake\");\n      }\n    }\n\n    if (!this.cacheDir.mkdirs() && !this.cacheDir.exists()) {\n      logger.debug(\n          \"Cannot create the cache directory {}. Giving up.\", this.cacheDir.getAbsolutePath());\n      return this;\n    }\n    logger.debug(\"Verified Directory {}\", this.cacheDir.getAbsolutePath());\n\n    File cacheFileTmp = new File(this.cacheDir, this.baseCacheFileName).getAbsoluteFile();\n    try {\n      // create an empty file if not exists and return true.\n      // If exists. the method returns false.\n      // In this particular case, it doesn't matter as long as the file is\n      // writable.\n      if (!cacheFileTmp.exists()) {\n        if (!isWindows() && onlyOwnerPermissions) {\n          Files.createFile(\n              cacheFileTmp.toPath(),\n              PosixFilePermissions.asFileAttribute(\n                  Stream.of(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE)\n                      .collect(Collectors.toSet())));\n        } else {\n          Files.createFile(cacheFileTmp.toPath());\n        }\n        logger.debug(\"Successfully created a cache file {}\", cacheFileTmp);\n      } else {\n        logger.debug(\"Cache file already exists {}\", cacheFileTmp);\n      }\n      FileUtil.logFileUsage(cacheFileTmp, \"Cache file creation\", false);\n      this.cacheFile = cacheFileTmp.getCanonicalFile();\n      this.cacheLockFile =\n          new File(this.cacheFile.getParentFile(), this.baseCacheFileName + \".lck\");\n    } catch (IOException | SecurityException ex) {\n      logger.info(\n          \"Failed to touch the cache file: {}. Ignored. {}\",\n          ex.getMessage(),\n          cacheFileTmp.getAbsoluteFile());\n    }\n    return this;\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "readCacheFile",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "logFileUsage",
            "throwWhenOwnerDifferentThanCurrentUser",
            "throwWhenPermiossionDifferentThanReadWriteForOwner"
        ],
        "target_code": "JsonNode readCacheFile() {\n    if (cacheFile == null || !this.checkCacheLockFile()) {\n      // no cache or the cache is not valid.\n      return null;\n    }\n    try {\n      if (!cacheFile.exists()) {\n        logger.debug(\"Cache file doesn't exists. File: {}\", cacheFile);\n        return null;\n      }\n\n      try (Reader reader =\n          new InputStreamReader(new FileInputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n\n        if (onlyOwnerPermissions) {\n          FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(cacheFile, \"Read cache\");\n          FileUtil.throwWhenOwnerDifferentThanCurrentUser(cacheFile, \"Read cache\");\n        } else {\n          FileUtil.logFileUsage(cacheFile, \"Read cache\", false);\n        }\n        return OBJECT_MAPPER.readTree(reader);\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to read the cache file. No worry. File: {}, Err: {}\", cacheFile, ex);\n    }\n    return null;\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "writeCacheFile",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "logFileUsage",
            "throwWhenPermiossionDifferentThanReadWriteForOwner"
        ],
        "target_code": "void writeCacheFile(JsonNode input) {\n    logger.debug(\"Writing cache file. File: {}\", cacheFile);\n    if (cacheFile == null || !tryLockCacheFile()) {\n      // no cache file or it failed to lock file\n      logger.debug(\n          \"No cache file exists or failed to lock the file. Skipping writing the cache\", false);\n      return;\n    }\n    // NOTE: must unlock cache file\n    try {\n      if (input == null) {\n        return;\n      }\n      try (Writer writer =\n          new OutputStreamWriter(new FileOutputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        if (onlyOwnerPermissions) {\n          FileUtil.throwWhenPermiossionDifferentThanReadWriteForOwner(cacheFile, \"Write to cache\");\n        } else {\n          FileUtil.logFileUsage(cacheFile, \"Write to cache\", false);\n        }\n        writer.write(input.toString());\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to write the cache file. File: {}\", cacheFile);\n    } finally {\n      if (!unlockCacheFile()) {\n        logger.debug(\"Failed to unlock cache file\", false);\n      }\n    }\n  }"
    },
    {
        "target_file_name": "SFConnectionConfigParser.java",
        "target_method": "verifyFilePermissionSecure",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "isWindows"
        ],
        "target_code": "private static void verifyFilePermissionSecure(Path configFilePath)\n      throws IOException, SnowflakeSQLException {\n    if (!isWindows()) {\n      PosixFileAttributeView posixFileAttributeView =\n          Files.getFileAttributeView(configFilePath, PosixFileAttributeView.class);\n      if (!posixFileAttributeView.readAttributes().permissions().stream()\n          .allMatch(\n              o ->\n                  Arrays.asList(PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_READ)\n                      .contains(o))) {\n        logger.error(\n            \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n            configFilePath);\n        throw new SnowflakeSQLException(\n            String.format(\n                \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n                configFilePath));\n      }\n    }\n  }"
    },
    {
        "target_file_name": "FileUtil.java",
        "target_method": "logFileUsage",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public static void logFileUsage(Path filePath, String context, boolean logReadAccess) {\n    logWarnWhenAccessibleByOthers(filePath, context, logReadAccess);\n  }"
    },
    {
        "target_file_name": "FileUtil.java",
        "target_method": "logWarnWhenAccessibleByOthers",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "isPermPresent",
            "isWindows",
            "warn"
        ],
        "target_code": "private static void logWarnWhenAccessibleByOthers(\n      Path filePath, String context, boolean logReadAccess) {\n    // we do not check the permissions for Windows\n    if (isWindows()) {\n      return;\n    }\n\n    try {\n      Collection<PosixFilePermission> filePermissions = Files.getPosixFilePermissions(filePath);\n      logger.debug(\n          \"{}File {} access rights: {}\", getContextStr(context), filePath, filePermissions);\n\n      boolean isWritableByOthers = isPermPresent(filePermissions, WRITE_BY_OTHERS);\n      boolean isReadableByOthers = isPermPresent(filePermissions, READ_BY_OTHERS);\n      boolean isExecutable = isPermPresent(filePermissions, EXECUTABLE);\n\n      if (isWritableByOthers || (isReadableByOthers || isExecutable)) {\n        logger.warn(\n            \"{}File {} is accessible by others to:{}{}\",\n            getContextStr(context),\n            filePath,\n            isReadableByOthers && logReadAccess ? \" read\" : \"\",\n            isWritableByOthers ? \" write\" : \"\",\n            isExecutable ? \" executable\" : \"\");\n      }\n    } catch (IOException e) {\n      logger.warn(\n          \"{}Unable to access the file to check the permissions: {}. Error: {}\",\n          getContextStr(context),\n          filePath,\n          e);\n    }\n  }"
    },
    {
        "target_file_name": "DefaultSFConnectionHandler.java",
        "target_method": "checkLogFolderPermissions",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getOS"
        ],
        "target_code": "private void checkLogFolderPermissions(Path path) throws SnowflakeSQLLoggedException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      try {\n        Set<PosixFilePermission> folderPermissions = Files.getPosixFilePermissions(path);\n        if (folderPermissions.contains(PosixFilePermission.GROUP_WRITE)\n            || folderPermissions.contains(PosixFilePermission.GROUP_READ)\n            || folderPermissions.contains(PosixFilePermission.GROUP_EXECUTE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_WRITE)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_READ)\n            || folderPermissions.contains(PosixFilePermission.OTHERS_EXECUTE)) {\n          logger.warn(\n              \"Access permission for the logs directory '{}' is currently {} and is potentially \"\n                  + \"accessible to users other than the owner of the logs directory.\",\n              path.toString(),\n              folderPermissions.toString());\n        }\n      } catch (IOException ex) {\n        throw new SnowflakeSQLLoggedException(\n            sfSession,\n            ErrorCode.INTERNAL_ERROR,\n            String.format(\n                \"Unable to get permissions of log directory %s ,%s\",\n                path.toString(), ex.getMessage(), ex.getCause()));\n      }\n    }\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "overrideCacheFile",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "logFileUsage"
        ],
        "target_code": "void overrideCacheFile(File newCacheFile) {\n    this.cacheFile = newCacheFile;\n    this.cacheDir = newCacheFile.getParentFile();\n    this.baseCacheFileName = newCacheFile.getName();\n    FileUtil.logFileUsage(cacheFile, \"Override cache file\", true);\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "build",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createNewFile",
            "debug",
            "getAbsoluteFile",
            "systemGetProperty"
        ],
        "target_code": "FileCacheManager build() {\n    // try to get cacheDir from system property or environment variable\n    String cacheDirPath =\n        this.cacheDirectorySystemProperty != null\n            ? systemGetProperty(this.cacheDirectorySystemProperty)\n            : null;\n    if (cacheDirPath == null) {\n      try {\n        cacheDirPath =\n            this.cacheDirectoryEnvironmentVariable != null\n                ? systemGetEnv(this.cacheDirectoryEnvironmentVariable)\n                : null;\n      } catch (Throwable ex) {\n        logger.debug(\n            \"Cannot get environment variable for cache directory, skip using cache\", false);\n        // In Boomi cloud, System.getenv is not allowed due to policy,\n        // so we catch the exception and skip cache completely\n        return this;\n      }\n    }\n\n    if (cacheDirPath != null) {\n      this.cacheDir = new File(cacheDirPath);\n    } else {\n      // use user home directory to store the cache file\n      String homeDir = systemGetProperty(\"user.home\");\n      if (homeDir == null) {\n        // use tmp dir if not exists.\n        homeDir = systemGetProperty(\"java.io.tmpdir\");\n      } else {\n        // Checking if home directory is writable.\n        File homeFile = new File(homeDir);\n        if (!homeFile.canWrite()) {\n          logger.debug(\"Home directory not writeable, using tmpdir\", false);\n          homeDir = systemGetProperty(\"java.io.tmpdir\");\n        }\n      }\n      if (homeDir == null) {\n        // if still home directory is null, no cache dir is set.\n        return this;\n      }\n      if (Constants.getOS() == Constants.OS.WINDOWS) {\n        this.cacheDir =\n            new File(\n                new File(new File(new File(homeDir, \"AppData\"), \"Local\"), \"Snowflake\"), \"Caches\");\n      } else if (Constants.getOS() == Constants.OS.MAC) {\n        this.cacheDir = new File(new File(new File(homeDir, \"Library\"), \"Caches\"), \"Snowflake\");\n      } else {\n        this.cacheDir = new File(new File(homeDir, \".cache\"), \"snowflake\");\n      }\n    }\n\n    if (!this.cacheDir.mkdirs() && !this.cacheDir.exists()) {\n      logger.debug(\n          \"Cannot create the cache directory {}. Giving up.\", this.cacheDir.getAbsolutePath());\n      return this;\n    }\n    logger.debug(\"Verified Directory {}\", this.cacheDir.getAbsolutePath());\n\n    File cacheFileTmp = new File(this.cacheDir, this.baseCacheFileName).getAbsoluteFile();\n    try {\n      // create an empty file if not exists and return true.\n      // If exists. the method returns false.\n      // In this particular case, it doesn't matter as long as the file is\n      // writable.\n      if (cacheFileTmp.createNewFile()) {\n        logger.debug(\"Successfully created a cache file {}\", cacheFileTmp);\n      } else {\n        logger.debug(\"Cache file already exists {}\", cacheFileTmp);\n      }\n      FileUtil.logFileUsage(cacheFileTmp, \"Cache file creation\", false);\n      this.cacheFile = cacheFileTmp.getCanonicalFile();\n      this.cacheLockFile =\n          new File(this.cacheFile.getParentFile(), this.baseCacheFileName + \".lck\");\n    } catch (IOException | SecurityException ex) {\n      logger.debug(\"Failed to touch the cache file. Ignored. {}\", cacheFileTmp.getAbsoluteFile());\n    }\n    return this;\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "readCacheFile",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "logFileUsage"
        ],
        "target_code": "JsonNode readCacheFile() {\n    if (cacheFile == null || !this.checkCacheLockFile()) {\n      // no cache or the cache is not valid.\n      return null;\n    }\n    try {\n      if (!cacheFile.exists()) {\n        logger.debug(\"Cache file doesn't exists. File: {}\", cacheFile);\n        return null;\n      }\n\n      try (Reader reader =\n          new InputStreamReader(new FileInputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        FileUtil.logFileUsage(cacheFile, \"Read cache\", false);\n        return OBJECT_MAPPER.readTree(reader);\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to read the cache file. No worry. File: {}, Err: {}\", cacheFile, ex);\n    }\n    return null;\n  }"
    },
    {
        "target_file_name": "FileCacheManager.java",
        "target_method": "writeCacheFile",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "logFileUsage"
        ],
        "target_code": "void writeCacheFile(JsonNode input) {\n    logger.debug(\"Writing cache file. File: {}\", cacheFile);\n    if (cacheFile == null || !tryLockCacheFile()) {\n      // no cache file or it failed to lock file\n      logger.debug(\n          \"No cache file exists or failed to lock the file. Skipping writing the cache\", false);\n      return;\n    }\n    // NOTE: must unlock cache file\n    try {\n      if (input == null) {\n        return;\n      }\n      try (Writer writer =\n          new OutputStreamWriter(new FileOutputStream(cacheFile), DEFAULT_FILE_ENCODING)) {\n        FileUtil.logFileUsage(cacheFile, \"Write to cache\", false);\n        writer.write(input.toString());\n      }\n    } catch (IOException ex) {\n      logger.debug(\"Failed to write the cache file. File: {}\", cacheFile);\n    } finally {\n      if (!unlockCacheFile()) {\n        logger.debug(\"Failed to unlock cache file\", false);\n      }\n    }\n  }"
    },
    {
        "target_file_name": "SFConnectionConfigParser.java",
        "target_method": "verifyFilePermissionSecure",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getOS"
        ],
        "target_code": "private static void verifyFilePermissionSecure(Path configFilePath)\n      throws IOException, SnowflakeSQLException {\n    if (Constants.getOS() != Constants.OS.WINDOWS) {\n      PosixFileAttributeView posixFileAttributeView =\n          Files.getFileAttributeView(configFilePath, PosixFileAttributeView.class);\n      if (!posixFileAttributeView.readAttributes().permissions().stream()\n          .allMatch(\n              o ->\n                  Arrays.asList(PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_READ)\n                      .contains(o))) {\n        logger.error(\n            \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n            configFilePath);\n        throw new SnowflakeSQLException(\n            String.format(\n                \"Reading from file %s is not safe because file permissions are different than read/write for user\",\n                configFilePath));\n      }\n    }\n  }"
    },
    {
        "target_file_name": "FileUtil.java",
        "target_method": "logFileUsage",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getContextStr",
            "info"
        ],
        "target_code": "public static void logFileUsage(Path filePath, String context, boolean logReadAccess) {\n    logger.info(\"{}Accessing file: {}\", getContextStr(context), filePath);\n    logWarnWhenAccessibleByOthers(filePath, context, logReadAccess);\n  }"
    },
    {
        "target_file_name": "FileUtil.java",
        "target_method": "logWarnWhenAccessibleByOthers",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "9e1a5acf12406b16c4780ca013f4c4db48b74b59^",
        "CWE_id": "CWE-276",
        "CVE_id": "CVE-2025-24790",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getOS",
            "warn"
        ],
        "target_code": "private static void logWarnWhenAccessibleByOthers(\n      Path filePath, String context, boolean logReadAccess) {\n    // we do not check the permissions for Windows\n    if (Constants.getOS() == Constants.OS.WINDOWS) {\n      return;\n    }\n\n    try {\n      Collection<PosixFilePermission> filePermissions = Files.getPosixFilePermissions(filePath);\n      logger.debug(\n          \"{}File {} access rights: {}\", getContextStr(context), filePath, filePermissions);\n\n      boolean isWritableByOthers = isPermPresent(filePermissions, WRITE_BY_OTHERS);\n      boolean isReadableByOthers = isPermPresent(filePermissions, READ_BY_OTHERS);\n\n      if (isWritableByOthers || (isReadableByOthers && logReadAccess)) {\n        logger.warn(\n            \"{}File {} is accessible by others to:{}{}\",\n            getContextStr(context),\n            filePath,\n            isReadableByOthers && logReadAccess ? \" read\" : \"\",\n            isWritableByOthers ? \" write\" : \"\");\n      }\n    } catch (IOException e) {\n      logger.warn(\n          \"{}Unable to access the file to check the permissions: {}. Error: {}\",\n          getContextStr(context),\n          filePath,\n          e);\n    }\n  }"
    },
    {
        "target_file_name": "SessionUtilExternalBrowser.java",
        "target_method": "openBrowser",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "4f01bb8f9b708c71e7a2111c87371dbfc1d53dd6",
        "CWE_id": "CWE-426",
        "CVE_id": "CVE-2025-24789",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "browse",
            "exec",
            "getDesktop",
            "getMessage",
            "getOS",
            "getRuntime",
            "isDesktopSupported",
            "isSupported",
            "isValidURL"
        ],
        "target_code": "@Override\n    public void openBrowser(String ssoUrl) throws SFException {\n      if (!URLUtil.isValidURL(ssoUrl)) {\n        throw new SFException(ErrorCode.INVALID_CONNECTION_URL, \"Invalid SSOUrl found - \" + ssoUrl);\n      }\n      try {\n        // start web browser\n        Runtime runtime = Runtime.getRuntime();\n        Constants.OS os = Constants.getOS();\n        if (Desktop.isDesktopSupported()\n            && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {\n          Desktop.getDesktop().browse(new URI(ssoUrl));\n        } else if (os == Constants.OS.MAC) {\n          runtime.exec(\"open \" + ssoUrl);\n        } else if (os == Constants.OS.WINDOWS) {\n          runtime.exec(new String[] {\"rundll32\", \"url.dll,FileProtocolHandler\", ssoUrl});\n        } else {\n          runtime.exec(\"xdg-open \" + ssoUrl);\n        }\n      } catch (URISyntaxException | IOException ex) {\n        throw new SFException(ex, ErrorCode.NETWORK_ERROR, ex.getMessage());\n      }\n    }"
    },
    {
        "target_file_name": "SessionUtilExternalBrowser.java",
        "target_method": "openBrowser",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "4f01bb8f9b708c71e7a2111c87371dbfc1d53dd6^",
        "CWE_id": "CWE-426",
        "CVE_id": "CVE-2025-24789",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "void openBrowser(String ssoUrl) throws SFException;"
    },
    {
        "target_file_name": "DefaultReferenceUpdater.java",
        "target_method": "renameLinks",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ab209acd780da69a4c5ff77ff011efd698273cec",
        "CWE_id": "CWE-266",
        "CVE_id": "CVE-2025-49580",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "saveDocumentPreservingAuthors"
        ],
        "target_code": "private void renameLinks(XWikiDocument document, EntityReference oldTarget, EntityReference newTarget,\n        XWikiContext xcontext, boolean relative, RenameLambda renameLambda) throws XWikiException\n    {\n        DocumentReference currentDocumentReference = document.getDocumentReference();\n\n        ComponentManager componentManager = this.contextComponentManagerProvider.get();\n\n        // We support only the syntaxes for which there is an available renderer.\n        if (!componentManager.hasComponent(BlockRenderer.class, document.getSyntax().toIdString())) {\n            this.logger.warn(\n                \"We can't rename the links from [{}] because there is no renderer available for its syntax [{}].\",\n                currentDocumentReference, document.getSyntax());\n\n            return;\n        }\n\n        // Load the renderer\n        BlockRenderer renderer;\n        try {\n            renderer = componentManager.getInstance(BlockRenderer.class, document.getSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            this.logger.error(\n                \"We can't rename the links from [{}] because the renderer for syntax [{}] cannot be loaded.\",\n                currentDocumentReference, document.getSyntax(), e);\n\n            return;\n        }\n\n        // Document content\n        boolean modified = renameLinks(document, relative, renameLambda);\n\n        // XObjects properties\n        for (List<BaseObject> xobjects : document.getXObjects().values()) {\n            for (BaseObject xobject : xobjects) {\n                if (xobject != null) {\n                    modified |= renameLinks(xobject, document, renderer, xcontext, relative, renameLambda);\n                }\n            }\n        }\n\n        if (modified) {\n            if (relative) {\n                saveDocumentPreservingAuthors(document, \"refactoring.referenceUpdater.saveMessage.relativeLink\");\n\n                info(\"Updated the relative links from [{}].\", currentDocumentReference);\n            } else {\n                saveDocumentPreservingAuthors(document, \"refactoring.referenceUpdater.saveMessage.backlinks\");\n\n                info(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                    document.getDocumentReferenceWithLocale(), oldTarget, newTarget);\n            }\n        } else {\n            if (relative) {\n                info(\"No relative links to update in [{}].\", currentDocumentReference);\n            } else {\n                info(\"No back-links to update in [{}].\", currentDocumentReference);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "DefaultReferenceUpdater.java",
        "target_method": "renameLinks",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "ab209acd780da69a4c5ff77ff011efd698273cec^",
        "CWE_id": "CWE-266",
        "CVE_id": "CVE-2025-49580",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "saveDocumentPreservingContentAuthor"
        ],
        "target_code": "private void renameLinks(XWikiDocument document, EntityReference oldTarget, EntityReference newTarget,\n        XWikiContext xcontext, boolean relative, RenameLambda renameLambda) throws XWikiException\n    {\n        DocumentReference currentDocumentReference = document.getDocumentReference();\n\n        ComponentManager componentManager = this.contextComponentManagerProvider.get();\n\n        // We support only the syntaxes for which there is an available renderer.\n        if (!componentManager.hasComponent(BlockRenderer.class, document.getSyntax().toIdString())) {\n            this.logger.warn(\n                \"We can't rename the links from [{}] because there is no renderer available for its syntax [{}].\",\n                currentDocumentReference, document.getSyntax());\n\n            return;\n        }\n\n        // Load the renderer\n        BlockRenderer renderer;\n        try {\n            renderer = componentManager.getInstance(BlockRenderer.class, document.getSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            this.logger.error(\n                \"We can't rename the links from [{}] because the renderer for syntax [{}] cannot be loaded.\",\n                currentDocumentReference, document.getSyntax(), e);\n\n            return;\n        }\n\n        // Document content\n        boolean modified = renameLinks(document, relative, renameLambda);\n\n        // XObjects properties\n        for (List<BaseObject> xobjects : document.getXObjects().values()) {\n            for (BaseObject xobject : xobjects) {\n                if (xobject != null) {\n                    modified |= renameLinks(xobject, document, renderer, xcontext, relative, renameLambda);\n                }\n            }\n        }\n\n        if (modified) {\n            if (relative) {\n                saveDocumentPreservingContentAuthor(document, \"Updated the relative links.\", true);\n\n                info(\"Updated the relative links from [{}].\", currentDocumentReference);\n            } else {\n                saveDocumentPreservingContentAuthor(document, \"Renamed back-links.\", false);\n\n                info(\"The links from [{}] that were targeting [{}] have been updated to target [{}].\",\n                    document.getDocumentReferenceWithLocale(), oldTarget, newTarget);\n            }\n        } else {\n            if (relative) {\n                info(\"No relative links to update in [{}].\", currentDocumentReference);\n            } else {\n                info(\"No back-links to update in [{}].\", currentDocumentReference);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "list",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkValidPath",
            "debug",
            "normalize",
            "resolve"
        ],
        "target_code": "@Override\n    public final PageSet<? extends StorageMetadata> list(String container,\n            ListContainerOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var delimiter = options.getDelimiter();\n        if (\"\".equals(delimiter)) {\n            delimiter = null;\n        } else if (delimiter != null && !delimiter.equals(\"/\")) {\n            throw new IllegalArgumentException(\"Delimiters other than / not supported\");\n        }\n\n        var prefix = options.getPrefix();\n        var dirPrefix = root.resolve(container);\n        if (prefix != null) {\n            int idx = prefix.lastIndexOf('/');\n            if (idx != -1) {\n                dirPrefix = dirPrefix.resolve(prefix.substring(0, idx));\n            }\n        } else {\n            prefix = \"\";\n        }\n        var containerPath = root.resolve(container);\n        var pathPrefix = containerPath.resolve(prefix).normalize();\n        checkValidPath(containerPath, pathPrefix);\n        logger.debug(\"Listing blobs at: {}\", pathPrefix);\n        var set = ImmutableSortedSet.<StorageMetadata>naturalOrder();\n        try {\n            listHelper(set, container, dirPrefix, pathPrefix, delimiter);\n            var sorted = set.build();\n            if (options.getMarker() != null) {\n                var found = false;\n                for (var blob : sorted) {\n                    if (blob.getName().compareTo(options.getMarker()) > 0) {\n                        sorted = sorted.tailSet(blob);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    sorted = ImmutableSortedSet.of();\n                }\n            }\n            String marker = null;\n            if (options.getMaxResults() != null) {\n                // TODO: efficiency?\n                var temp = ImmutableSortedSet.copyOf(sorted.stream().limit(options.getMaxResults().intValue()).collect(Collectors.toSet()));\n                if (!temp.isEmpty()) {\n                    var next = sorted.higher(temp.last());\n                    if (next != null) {\n                        marker = temp.last().getName();\n                    }\n                }\n                sorted = temp;\n            }\n            return new PageSetImpl<StorageMetadata>(sorted, marker);\n        } catch (IOException ioe) {\n            logger.error(\"unexpected exception\", ioe);\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "getBlob",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkValidPath",
            "resolve"
        ],
        "target_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key);\n        checkValidPath(containerPath, path);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "putBlob",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkValidPath",
            "getMetadata",
            "getName",
            "resolve"
        ],
        "target_code": "@Override\n    public final String putBlob(String container, Blob blob, PutOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(blob.getMetadata().getName());\n        checkValidPath(containerPath, path);\n        // TODO: should we use a known suffix to filter these out during list?\n        var tmpPath = root.resolve(container).resolve(blob.getMetadata().getName() + \"-\" + UUID.randomUUID());\n        logger.debug(\"Creating blob at: {}\", path);\n\n        if (blob.getMetadata().getName().endsWith(\"/\")) {\n            try {\n                logger.debug(\"Creating directory blob: {}\", path);\n                Files.createDirectories(path);\n            } catch (FileAlreadyExistsException faee) {\n                logger.debug(\"Parent directories already exist: {}\", path.getParent());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            try {\n                writeCommonMetadataAttr(view, blob);\n                view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(DIRECTORY_MD5));\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            return BaseEncoding.base16().lowerCase().encode(DIRECTORY_MD5);\n        }\n\n        // Create parent directories.\n        try {\n            Files.createDirectories(path.getParent());\n        } catch (FileAlreadyExistsException faee) {\n            logger.debug(\"Parent directories already exist: {}\", path.getParent());\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n\n        var metadata = blob.getMetadata().getContentMetadata();\n        try (var is = new HashingInputStream(Hashing.md5(), blob.getPayload().openStream());\n             var os = Files.newOutputStream(tmpPath)) {\n            var count = is.transferTo(os);\n            var actualHashCode = is.hash();\n            var expectedHashCode = metadata.getContentMD5AsHashCode();\n            if (expectedHashCode != null && !actualHashCode.equals(expectedHashCode)) {\n                Files.delete(tmpPath);\n                throw returnResponseException(400);\n            }\n\n            var view = Files.getFileAttributeView(tmpPath, UserDefinedFileAttributeView.class);\n            if (view != null) {\n                try {\n                    var eTag = actualHashCode.asBytes();\n                    view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(eTag));\n                    writeStringAttributeIfPresent(view, XATTR_CACHE_CONTROL, metadata.getCacheControl());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_DISPOSITION, metadata.getContentDisposition());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_ENCODING, metadata.getContentEncoding());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_LANGUAGE, metadata.getContentLanguage());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_TYPE, metadata.getContentType());\n                    var expires = metadata.getExpires();\n                    if (expires != null) {\n                        ByteBuffer buf = ByteBuffer.allocate(Longs.BYTES).putLong(expires.getTime());\n                        buf.flip();\n                        view.write(XATTR_EXPIRES, buf);\n                    }\n                    writeStringAttributeIfPresent(view, XATTR_STORAGE_TIER, blob.getMetadata().getTier().toString());\n                    for (var entry : blob.getMetadata().getUserMetadata().entrySet()) {\n                        writeStringAttributeIfPresent(view, XATTR_USER_METADATA_PREFIX + entry.getKey(), entry.getValue());\n                    }\n                } catch (IOException e) {\n                    // TODO:\n                    //logger.debug(\"xattrs not supported on %s\", path);\n                }\n            }\n\n            Files.move(tmpPath, path, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n\n            setBlobAccess(container, blob.getMetadata().getName(), options.getBlobAccess());\n\n            return \"\\\"\" + actualHashCode + \"\\\"\";\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "removeBlob",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkValidPath",
            "debug",
            "normalize",
            "resolve"
        ],
        "target_code": "@Override\n    public final void removeBlob(String container, String key) {\n        try {\n            var containerPath = root.resolve(container);\n            var path = containerPath.resolve(key).normalize();\n            checkValidPath(containerPath, path);\n            logger.debug(\"Deleting blob at: {}\", path);\n            Files.delete(path);\n            removeEmptyParentDirectories(containerPath, path.getParent());\n        } catch (NoSuchFileException nsfe) {\n            return;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "getBlobAccess",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkValidPath",
            "normalize",
            "resolve"
        ],
        "target_code": "@Override\n    public final BlobAccess getBlobAccess(String container, String key) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key).normalize();\n        checkValidPath(containerPath, path);\n\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = Files.getPosixFilePermissions(path);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n        return permissions.contains(PosixFilePermission.OTHERS_READ) ?\n                BlobAccess.PUBLIC_READ : BlobAccess.PRIVATE;\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "setBlobAccess",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkValidPath",
            "normalize",
            "resolve"
        ],
        "target_code": "@Override\n    public final void setBlobAccess(String container, String key, BlobAccess access) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var containerPath = root.resolve(container);\n        var path = containerPath.resolve(key).normalize();\n        checkValidPath(containerPath, path);\n\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = new HashSet<>(Files.getPosixFilePermissions(path));\n            if (access == BlobAccess.PRIVATE) {\n                permissions.remove(PosixFilePermission.OTHERS_READ);\n            } else if (access == BlobAccess.PUBLIC_READ) {\n                permissions.add(PosixFilePermission.OTHERS_READ);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "list",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "resolve"
        ],
        "target_code": "@Override\n    public final PageSet<? extends StorageMetadata> list(String container,\n            ListContainerOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var delimiter = options.getDelimiter();\n        if (\"\".equals(delimiter)) {\n            delimiter = null;\n        } else if (delimiter != null && !delimiter.equals(\"/\")) {\n            throw new IllegalArgumentException(\"Delimiters other than / not supported\");\n        }\n\n        var prefix = options.getPrefix();\n        var dirPrefix = root.resolve(container);\n        if (prefix != null) {\n            int idx = prefix.lastIndexOf('/');\n            if (idx != -1) {\n                dirPrefix = dirPrefix.resolve(prefix.substring(0, idx));\n            }\n        } else {\n            prefix = \"\";\n        }\n        var pathPrefix = root.resolve(container).resolve(prefix);\n        var set = ImmutableSortedSet.<StorageMetadata>naturalOrder();\n        try {\n            listHelper(set, container, dirPrefix, pathPrefix, delimiter);\n            var sorted = set.build();\n            if (options.getMarker() != null) {\n                var found = false;\n                for (var blob : sorted) {\n                    if (blob.getName().compareTo(options.getMarker()) > 0) {\n                        sorted = sorted.tailSet(blob);\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    sorted = ImmutableSortedSet.of();\n                }\n            }\n            String marker = null;\n            if (options.getMaxResults() != null) {\n                // TODO: efficiency?\n                var temp = ImmutableSortedSet.copyOf(sorted.stream().limit(options.getMaxResults().intValue()).collect(Collectors.toSet()));\n                if (!temp.isEmpty()) {\n                    var next = sorted.higher(temp.last());\n                    if (next != null) {\n                        marker = temp.last().getName();\n                    }\n                }\n                sorted = temp;\n            }\n            return new PageSetImpl<StorageMetadata>(sorted, marker);\n        } catch (IOException ioe) {\n            logger.error(\"unexpected exception\", ioe);\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "getBlob",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "resolve"
        ],
        "target_code": "@Override\n    public final Blob getBlob(String container, String key, GetOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        logger.debug(\"Getting blob at: {}\", path);\n\n        try {\n            var isDirectory = Files.isDirectory(path);\n            var attr = Files.readAttributes(path, BasicFileAttributes.class);\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            var attributes = Set.copyOf(view.list());\n            var cacheControl = readStringAttributeIfPresent(view, attributes, XATTR_CACHE_CONTROL);\n            var contentDisposition = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_DISPOSITION);\n            var contentEncoding = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_ENCODING);\n            var contentLanguage = readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_LANGUAGE);\n            var contentType = isDirectory ? \"application/x-directory\" :\n                    readStringAttributeIfPresent(view, attributes, XATTR_CONTENT_TYPE);\n            Date expires = null;\n            HashCode hashCode = null;\n            String eTag = null;\n            var tier = Tier.STANDARD;\n            var userMetadata = ImmutableMap.<String, String>builder();\n            var lastModifiedTime = new Date(attr.lastModifiedTime().toMillis());\n            var creationTime = new Date(attr.creationTime().toMillis());\n\n            if (isDirectory) {\n                if (!attributes.contains(XATTR_CONTENT_MD5)) {\n                    // Lacks directory marker -- implicit directory.\n                    return null;\n                }\n            } else if (attributes.contains(XATTR_CONTENT_MD5)) {\n                var buf = ByteBuffer.allocate(view.size(XATTR_CONTENT_MD5));\n                view.read(XATTR_CONTENT_MD5, buf);\n                var etagBytes = buf.array();\n                if (etagBytes.length == 16) {\n                    // regular object\n                    hashCode = HashCode.fromBytes(buf.array());\n                    eTag = \"\\\"\" + hashCode + \"\\\"\";\n                } else {\n                    // multi-part object\n                    eTag = new String(etagBytes, StandardCharsets.US_ASCII);\n                }\n            }\n            if (attributes.contains(XATTR_EXPIRES)) {\n                ByteBuffer buf = ByteBuffer.allocate(view.size(XATTR_EXPIRES));\n                view.read(XATTR_EXPIRES, buf);\n                buf.flip();\n                expires = new Date(buf.asLongBuffer().get());\n            }\n            var tierString = readStringAttributeIfPresent(view, attributes, XATTR_STORAGE_TIER);\n            if (tierString != null) {\n                tier = Tier.valueOf(tierString);\n            }\n            for (String attribute : attributes) {\n                if (!attribute.startsWith(XATTR_USER_METADATA_PREFIX)) {\n                    continue;\n                }\n                var value = readStringAttributeIfPresent(view, attributes, attribute);\n                userMetadata.put(attribute.substring(XATTR_USER_METADATA_PREFIX.length()), value);\n            }\n\n            // Handle range.\n            String contentRange = null;\n            InputStream inputStream;\n            long size;\n            if (isDirectory) {\n                inputStream = ByteSource.empty().openStream();\n                size = 0;\n            } else {\n                inputStream = Files.newInputStream(path);  // TODO: leaky on exception\n                size = attr.size();\n                if (options.getRanges().size() > 0) {\n                    var range = options.getRanges().get(0);\n                    // HTTP uses a closed interval while Java array indexing uses a\n                    // half-open interval.\n                    long offset = 0;\n                    long last = size;\n                    if (range.startsWith(\"-\")) {\n                        offset = last - Long.parseLong(range.substring(1));\n                        if (offset < 0) {\n                            offset = 0;\n                        }\n                    } else if (range.endsWith(\"-\")) {\n                        offset = Long.parseLong(range.substring(0, range.length() - 1));\n                    } else if (range.contains(\"-\")) {\n                        String[] firstLast = range.split(\"\\\\-\", 2);\n                        offset = Long.parseLong(firstLast[0]);\n                        last = Long.parseLong(firstLast[1]);\n                    } else {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n\n                    if (offset >= size) {\n                        throw new HttpResponseException(\"illegal range: \" + range, null, HttpResponse.builder().statusCode(416).build());\n                    }\n                    if (last + 1 > size) {\n                        last = size - 1;\n                    }\n                    ByteStreams.skipFully(inputStream, offset);\n                    size = last - offset + 1;\n                    inputStream = ByteStreams.limit(inputStream, size);\n                    contentRange = \"bytes \" + offset + \"-\" + last + \"/\" + attr.size();\n                }\n            }\n\n            if (eTag != null) {\n                eTag = maybeQuoteETag(eTag);\n                if (options.getIfMatch() != null) {\n                    if (!eTag.equals(maybeQuoteETag(options.getIfMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n                if (options.getIfNoneMatch() != null) {\n                    if (eTag.equals(maybeQuoteETag(options.getIfNoneMatch()))) {\n                        HttpResponse response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode()).addHeader(HttpHeaders.ETAG, eTag).build();\n                        throw new HttpResponseException(new HttpCommand(HttpRequest.builder().method(\"GET\").endpoint(\"http://stub\").build()), response);\n                    }\n                }\n            }\n            if (options.getIfModifiedSince() != null) {\n                Date modifiedSince = options.getIfModifiedSince();\n                if (lastModifiedTime.before(modifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.NOT_MODIFIED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is before %2$s\", lastModifiedTime, modifiedSince), null, response.build());\n                }\n\n            }\n            if (options.getIfUnmodifiedSince() != null) {\n                Date unmodifiedSince = options.getIfUnmodifiedSince();\n                if (lastModifiedTime.after(unmodifiedSince)) {\n                    HttpResponse.Builder response = HttpResponse.builder().statusCode(Status.PRECONDITION_FAILED.getStatusCode());\n                    if (eTag != null) {\n                        response.addHeader(HttpHeaders.ETAG, eTag);\n                    }\n                    throw new HttpResponseException(String.format(\"%1$s is after %2$s\", lastModifiedTime, unmodifiedSince), null, response.build());\n                }\n            }\n\n            Blob blob = new BlobBuilderImpl()\n                    .type(isDirectory ? StorageType.FOLDER : StorageType.BLOB)\n                    .name(key)\n                    .userMetadata(userMetadata.build())\n                    .payload(inputStream)\n                    .cacheControl(cacheControl)\n                    .contentDisposition(contentDisposition)\n                    .contentEncoding(contentEncoding)\n                    .contentLanguage(contentLanguage)\n                    .contentLength(size)\n                    .contentMD5(hashCode)\n                    .contentType(contentType)\n                    .eTag(eTag)\n                    .expires(expires)\n                    .tier(tier)\n                    .build();\n            blob.getMetadata().setContainer(container);\n            blob.getMetadata().setCreationDate(creationTime);\n            blob.getMetadata().setLastModified(lastModifiedTime);\n            blob.getMetadata().setSize(size);\n            if (contentRange != null) {\n                blob.getAllHeaders().put(HttpHeaders.CONTENT_RANGE, contentRange);\n            }\n            if (hashCode != null) {\n                blob.getMetadata().setETag(BaseEncoding.base16().lowerCase().encode(hashCode.asBytes()));\n            }\n            return blob;\n        } catch (NoSuchFileException nsfe) {\n            return null;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "putBlob",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getMetadata",
            "getName",
            "resolve"
        ],
        "target_code": "@Override\n    public final String putBlob(String container, Blob blob, PutOptions options) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n\n        var path = root.resolve(container).resolve(blob.getMetadata().getName());\n        // TODO: should we use a known suffix to filter these out during list?\n        var tmpPath = root.resolve(container).resolve(blob.getMetadata().getName() + \"-\" + UUID.randomUUID());\n        logger.debug(\"Creating blob at: {}\", path);\n\n        if (blob.getMetadata().getName().endsWith(\"/\")) {\n            try {\n                logger.debug(\"Creating directory blob: {}\", path);\n                Files.createDirectories(path);\n            } catch (FileAlreadyExistsException faee) {\n                logger.debug(\"Parent directories already exist: {}\", path.getParent());\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            var view = Files.getFileAttributeView(path, UserDefinedFileAttributeView.class);\n            try {\n                writeCommonMetadataAttr(view, blob);\n                view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(DIRECTORY_MD5));\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n\n            return BaseEncoding.base16().lowerCase().encode(DIRECTORY_MD5);\n        }\n\n        // Create parent directories.\n        try {\n            Files.createDirectories(path.getParent());\n        } catch (FileAlreadyExistsException faee) {\n            logger.debug(\"Parent directories already exist: {}\", path.getParent());\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n\n        var metadata = blob.getMetadata().getContentMetadata();\n        try (var is = new HashingInputStream(Hashing.md5(), blob.getPayload().openStream());\n             var os = Files.newOutputStream(tmpPath)) {\n            var count = is.transferTo(os);\n            var actualHashCode = is.hash();\n            var expectedHashCode = metadata.getContentMD5AsHashCode();\n            if (expectedHashCode != null && !actualHashCode.equals(expectedHashCode)) {\n                Files.delete(tmpPath);\n                throw returnResponseException(400);\n            }\n\n            var view = Files.getFileAttributeView(tmpPath, UserDefinedFileAttributeView.class);\n            if (view != null) {\n                try {\n                    var eTag = actualHashCode.asBytes();\n                    view.write(XATTR_CONTENT_MD5, ByteBuffer.wrap(eTag));\n                    writeStringAttributeIfPresent(view, XATTR_CACHE_CONTROL, metadata.getCacheControl());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_DISPOSITION, metadata.getContentDisposition());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_ENCODING, metadata.getContentEncoding());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_LANGUAGE, metadata.getContentLanguage());\n                    writeStringAttributeIfPresent(view, XATTR_CONTENT_TYPE, metadata.getContentType());\n                    var expires = metadata.getExpires();\n                    if (expires != null) {\n                        ByteBuffer buf = ByteBuffer.allocate(Longs.BYTES).putLong(expires.getTime());\n                        buf.flip();\n                        view.write(XATTR_EXPIRES, buf);\n                    }\n                    writeStringAttributeIfPresent(view, XATTR_STORAGE_TIER, blob.getMetadata().getTier().toString());\n                    for (var entry : blob.getMetadata().getUserMetadata().entrySet()) {\n                        writeStringAttributeIfPresent(view, XATTR_USER_METADATA_PREFIX + entry.getKey(), entry.getValue());\n                    }\n                } catch (IOException e) {\n                    // TODO:\n                    //logger.debug(\"xattrs not supported on %s\", path);\n                }\n            }\n\n            Files.move(tmpPath, path, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);\n\n            setBlobAccess(container, blob.getMetadata().getName(), options.getBlobAccess());\n\n            return \"\\\"\" + actualHashCode + \"\\\"\";\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "removeBlob",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "resolve"
        ],
        "target_code": "@Override\n    public final void removeBlob(String container, String key) {\n        try {\n            var containerPath = root.resolve(container);\n            var path = containerPath.resolve(key);\n            Files.delete(path);\n            removeEmptyParentDirectories(containerPath, path.getParent());\n        } catch (NoSuchFileException nsfe) {\n            return;\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "getBlobAccess",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "resolve"
        ],
        "target_code": "@Override\n    public final BlobAccess getBlobAccess(String container, String key) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = Files.getPosixFilePermissions(path);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n        return permissions.contains(PosixFilePermission.OTHERS_READ) ?\n                BlobAccess.PUBLIC_READ : BlobAccess.PRIVATE;\n    }"
    },
    {
        "target_file_name": "AbstractNio2BlobStore.java",
        "target_method": "setBlobAccess",
        "project_url": "https://github.com/gaul/s3proxy",
        "commit_id": "86b6ee4749aa163a78e7898efc063617ed171980^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-24961",
        "project_name": "s3proxy",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "resolve"
        ],
        "target_code": "@Override\n    public final void setBlobAccess(String container, String key, BlobAccess access) {\n        if (!containerExists(container)) {\n            throw new ContainerNotFoundException(container, \"\");\n        }\n        if (!blobExists(container, key)) {\n            throw new KeyNotFoundException(container, key, \"\");\n        }\n\n        var path = root.resolve(container).resolve(key);\n        Set<PosixFilePermission> permissions;\n        try {\n            permissions = new HashSet<>(Files.getPosixFilePermissions(path));\n            if (access == BlobAccess.PRIVATE) {\n                permissions.remove(PosixFilePermission.OTHERS_READ);\n            } else if (access == BlobAccess.PUBLIC_READ) {\n                permissions.add(PosixFilePermission.OTHERS_READ);\n            }\n            Files.setPosixFilePermissions(path, permissions);\n        } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n        }\n    }"
    },
    {
        "target_file_name": "FilesResource.java",
        "target_method": "moveToFolder",
        "project_url": "https://github.com/obiba/opal",
        "commit_id": "fca7dc9c8348064741b2e8b2c31b66660a935743",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-27101",
        "project_name": "opal",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSourceIsNotParent"
        ],
        "target_code": "private Response moveToFolder(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      Response check = checkSourceFile(resolveFileInFileSystem(sourcePath));\n      if (check != null) return check;\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        checkSourceIsNotParent(sourceFile, destinationFolder);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        sourceFile.moveTo(destinationFile);\n      }\n    }\n\n    return Response.ok().build();\n  }"
    },
    {
        "target_file_name": "FilesResource.java",
        "target_method": "copyFrom",
        "project_url": "https://github.com/obiba/opal",
        "commit_id": "fca7dc9c8348064741b2e8b2c31b66660a935743",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-27101",
        "project_name": "opal",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSourceIsNotParent"
        ],
        "target_code": "private Response copyFrom(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n      if (!sourceFile.exists()) getPathNotExistResponse(sourcePath);\n      if (!sourceFile.isReadable()) {\n        return Response.status(Status.FORBIDDEN).entity(\"Source file is not readable: \" + sourcePath).build();\n      }\n      checkSourceIsNotParent(sourceFile, destinationFolder);\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        FileSelector selector = sourceFile.getType() == FileType.FOLDER ? Selectors.SELECT_ALL : Selectors.SELECT_SELF;\n        destinationFile.copyFrom(sourceFile, selector);\n      }\n    }\n\n    return Response.ok().build();\n  }"
    },
    {
        "target_file_name": "FilesResource.java",
        "target_method": "moveToFolder",
        "project_url": "https://github.com/obiba/opal",
        "commit_id": "fca7dc9c8348064741b2e8b2c31b66660a935743^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-27101",
        "project_name": "opal",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private Response moveToFolder(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      Response check = checkSourceFile(resolveFileInFileSystem(sourcePath));\n      if (check != null) return check;\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        sourceFile.moveTo(destinationFile);\n      }\n    }\n\n    return Response.ok().build();\n  }"
    },
    {
        "target_file_name": "FilesResource.java",
        "target_method": "copyFrom",
        "project_url": "https://github.com/obiba/opal",
        "commit_id": "fca7dc9c8348064741b2e8b2c31b66660a935743^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-27101",
        "project_name": "opal",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private Response copyFrom(FileObject destinationFolder, Iterable<String> sourcesPath) throws IOException {\n    // destination check\n    String destinationPath = destinationFolder.getName().getPath();\n    if (!destinationFolder.exists()) return getPathNotExistResponse(destinationPath);\n    if (destinationFolder.getType() != FileType.FOLDER)\n      return Response.status(Status.BAD_REQUEST).entity(\"Destination must be a folder: \" + destinationPath).build();\n\n    // sources check\n    for (String sourcePath : sourcesPath) {\n      FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n      if (!sourceFile.exists()) getPathNotExistResponse(sourcePath);\n      if (!sourceFile.isReadable()) {\n        return Response.status(Status.FORBIDDEN).entity(\"Source file is not readable: \" + sourcePath).build();\n      }\n    }\n\n    // do action\n    for (String sourcePath : sourcesPath) {\n      if (!sourcePath.equals(destinationPath)) {\n        FileObject sourceFile = resolveFileInFileSystem(sourcePath);\n        FileObject destinationFile = resolveFileInFileSystem(destinationPath + \"/\" + sourceFile.getName().getBaseName());\n        FileSelector selector = sourceFile.getType() == FileType.FOLDER ? Selectors.SELECT_ALL : Selectors.SELECT_SELF;\n        destinationFile.copyFrom(sourceFile, selector);\n      }\n    }\n\n    return Response.ok().build();\n  }"
    },
    {
        "target_file_name": "RightsFilterListener.java",
        "target_method": "checkModifiedRequiredRights",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "2557813aef3b863988d6cca58de996e207086898",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-48063",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "cancel",
            "formatted",
            "getName",
            "right",
            "scope"
        ],
        "target_code": "private void checkModifiedRequiredRights(DocumentReference user, XWikiDocument document,\n        CancelableEvent event)\n    {\n        XWikiDocument originalDocument = document.getOriginalDocument();\n        DocumentRequiredRights originalRequiredRights =\n            this.documentRequiredRightsReader.readRequiredRights(originalDocument);\n        DocumentRequiredRights requiredRights = this.documentRequiredRightsReader.readRequiredRights(document);\n\n        if (!originalRequiredRights.equals(requiredRights) && requiredRights.enforce()) {\n            // We can assume that the current user has all existing required rights as otherwise editing would be\n            // denied.\n            // Therefore, only check if the user has all rights specified in the updated document that could either\n            // have changed required rights or where enforcing has just been enabled.\n            for (DocumentRequiredRight requiredRight : requiredRights.rights()) {\n                try {\n                    this.authorization.checkAccess(requiredRight.right(), user,\n                        document.getDocumentReference().extractReference(requiredRight.scope()));\n                } catch (AccessDeniedException e) {\n                    event.cancel(\n                        \"The author doesn't have the right [%s] on the [%s] level that has been specified as required.\"\n                            .formatted(requiredRight.right().getName(), requiredRight.scope()));\n                    break;\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "RightsFilterListener.java",
        "target_method": "checkModifiedRequiredRights",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "2557813aef3b863988d6cca58de996e207086898^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-48063",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "cancel",
            "formatted",
            "getLowerCase",
            "getName",
            "right",
            "scope"
        ],
        "target_code": "private void checkModifiedRequiredRights(DocumentReference user, XWikiDocument document,\n        CancelableEvent event)\n    {\n        XWikiDocument originalDocument = document.getOriginalDocument();\n        DocumentRequiredRights originalRequiredRights =\n            this.documentRequiredRightsReader.readRequiredRights(originalDocument);\n        DocumentRequiredRights requiredRights = this.documentRequiredRightsReader.readRequiredRights(document);\n\n        if (!originalRequiredRights.equals(requiredRights) && requiredRights.enforce()) {\n            // We can assume that the current user has all existing required rights as otherwise editing would be\n            // denied.\n            // Therefore, only check if the user has all rights specified in the updated document that could either\n            // have changed required rights or where enforcing has just been enabled.\n            for (DocumentRequiredRight requiredRight : requiredRights.rights()) {\n                try {\n                    this.authorization.checkAccess(requiredRight.right(), user,\n                        document.getDocumentReference().extractReference(requiredRight.scope()));\n                } catch (AccessDeniedException e) {\n                    event.cancel(\n                        \"The author doesn't have the right [%s] on the [%s] level that has been specified as required.\"\n                            .formatted(requiredRight.right().getName(), requiredRight.scope().getLowerCase()));\n                    break;\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "BoundedInputStream.java",
        "target_method": "read",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386",
        "CWE_id": "CWE-400",
        "CVE_id": "CVE-2025-25193",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        checkMaxBytesRead();\n\n        // Calculate the maximum number of bytes that we should try to read.\n        int num = Math.min(len, maxBytesRead - numRead + 1);\n\n        int b = super.read(buf, off, num);\n\n        if (b != -1) {\n            numRead += b;\n        }\n        return b;\n    }"
    },
    {
        "target_file_name": "BoundedInputStream.java",
        "target_method": "read",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "d1fbda62d3a47835d3fb35db8bd42ecc205a5386^",
        "CWE_id": "CWE-400",
        "CVE_id": "CVE-2025-25193",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "checkMaxBytesRead"
        ],
        "target_code": "@Override\n    public int read(byte[] buf, int off, int len) throws IOException {\n        checkMaxBytesRead();\n\n        // Calculate the maximum number of bytes that we should try to read.\n        int num = Math.min(len, maxBytesRead - numRead + 1);\n\n        int b = super.read(buf, off, num);\n\n        if (b > 0) {\n            numRead += b;\n        }\n\n        checkMaxBytesRead();\n        return b;\n    }"
    },
    {
        "target_file_name": "SslUtils.java",
        "target_method": "getEncryptedPacketLength",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "87f40725155b2f89adfde68c7732f97c153676c4",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-24970",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "remaining"
        ],
        "target_code": "private static int getEncryptedPacketLength(ByteBuffer buffer) {\n        int remaining = buffer.remaining();\n        if (remaining < SSL_RECORD_HEADER_LENGTH) {\n            return NOT_ENOUGH_DATA;\n        }\n        int packetLength = 0;\n        int pos = buffer.position();\n\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (unsignedByte(buffer.get(pos))) {\n            case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n            case SSL_CONTENT_TYPE_ALERT:\n            case SSL_CONTENT_TYPE_HANDSHAKE:\n            case SSL_CONTENT_TYPE_APPLICATION_DATA:\n            case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1 - Check ProtocolVersion\n            int majorVersion = unsignedByte(buffer.get(pos + 1));\n            if (majorVersion == 3 || buffer.getShort(pos + 1) == GMSSL_PROTOCOL_VERSION) {\n                // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1\n                packetLength = unsignedShortBE(buffer, pos + 3) + SSL_RECORD_HEADER_LENGTH;\n                if (packetLength <= SSL_RECORD_HEADER_LENGTH) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                packetLength = headerLength == 2 ?\n                        (shortBE(buffer, pos) & 0x7FFF) + 2 : (shortBE(buffer, pos) & 0x3FFF) + 3;\n                if (packetLength <= headerLength) {\n                    // If there's no data then consider this package as not encrypted.\n                    return NOT_ENCRYPTED;\n                }\n            } else {\n                return NOT_ENCRYPTED;\n            }\n        }\n        return packetLength;\n    }"
    },
    {
        "target_file_name": "ReferenceCountedOpenSslEngine.java",
        "target_method": "unwrap",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "87f40725155b2f89adfde68c7732f97c153676c4",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-24970",
        "project_name": "netty",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public final SSLEngineResult unwrap(\n            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,\n            final ByteBuffer[] dsts, int dstsOffset, final int dstsLength) throws SSLException {\n\n        // Throw required runtime exceptions\n        checkNotNullWithIAE(srcs, \"srcs\");\n        if (srcsOffset >= srcs.length\n                || srcsOffset + srcsLength > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + srcsOffset + \", length: \" + srcsLength +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n        checkNotNullWithIAE(dsts, \"dsts\");\n        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + dstsOffset + \", length: \" + dstsLength +\n                            \" (expected: offset <= offset + length <= dsts.length (\" + dsts.length + \"))\");\n        }\n        long capacity = 0;\n        final int dstsEndOffset = dstsOffset + dstsLength;\n        for (int i = dstsOffset; i < dstsEndOffset; i ++) {\n            ByteBuffer dst = checkNotNullArrayParam(dsts[i], i, \"dsts\");\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        final int srcsEndOffset = srcsOffset + srcsLength;\n        long len = 0;\n        for (int i = srcsOffset; i < srcsEndOffset; i++) {\n            ByteBuffer src = checkNotNullArrayParam(srcs[i], i, \"srcs\");\n            len += src.remaining();\n        }\n\n        synchronized (this) {\n            if (isInboundDone()) {\n                return isOutboundDone() || isDestroyed() ? CLOSED_NOT_HANDSHAKING : NEED_WRAP_CLOSED;\n            }\n\n            SSLEngineResult.HandshakeStatus status = NOT_HANDSHAKING;\n            HandshakeState oldHandshakeState = handshakeState;\n            // Prepare OpenSSL to work in server mode and receive handshake\n            if (handshakeState != HandshakeState.FINISHED) {\n                if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                    // Update accepted so we know we triggered the handshake via wrap\n                    handshakeState = HandshakeState.STARTED_IMPLICITLY;\n                }\n\n                status = handshake();\n\n                if (status == NEED_TASK) {\n                    return newResult(status, 0, 0);\n                }\n\n                if (status == NEED_WRAP) {\n                    return NEED_WRAP_OK;\n                }\n                // Check if the inbound is considered to be closed if so let us try to wrap again.\n                if (isInboundDone) {\n                    return NEED_WRAP_CLOSED;\n                }\n            }\n\n            int sslPending = sslPending0();\n            int packetLength;\n            // The JDK implies that only a single SSL packet should be processed per unwrap call [1]. If we are in\n            // JDK compatibility mode then we should honor this, but if not we just wrap as much as possible. If there\n            // are multiple records or partial records this may reduce thrashing events through the pipeline.\n            // [1] https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html\n            if (jdkCompatibilityMode ||\n                    // If the handshake was not finished before we entered the method, we also ensure we only\n                    // unwrap one record. We do this to ensure we not produce any extra data before the caller\n                    // of the method is able to observe handshake completion and react on it.\n                    oldHandshakeState != HandshakeState.FINISHED) {\n                if (len < SSL_RECORD_HEADER_LENGTH) {\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n\n                packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);\n                if (packetLength == SslUtils.NOT_ENCRYPTED) {\n                    throw new NotSslRecordException(\"not an SSL/TLS record\");\n                }\n\n                assert packetLength >= 0;\n\n                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;\n                if (packetLengthDataOnly > capacity) {\n                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be\n                    // increased.\n                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {\n                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support\n                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max\n                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we\n                        // won't allocate a buffer large enough.\n                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1\n                        throw new SSLException(\"Illegal packet length: \" + packetLengthDataOnly + \" > \" +\n                                                session.getApplicationBufferSize());\n                    } else {\n                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);\n                    }\n                    return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n                }\n\n                if (len < packetLength) {\n                    // We either don't have enough data to read the packet length or not enough for reading the whole\n                    // packet.\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n            } else if (len == 0 && sslPending <= 0) {\n                return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n            } else if (capacity == 0) {\n                return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n            } else {\n                packetLength = (int) min(MAX_VALUE, len);\n            }\n\n            // This must always be the case when we reached here as if not we returned BUFFER_UNDERFLOW.\n            assert srcsOffset < srcsEndOffset;\n\n            // This must always be the case if we reached here.\n            assert capacity > 0;\n\n            // Number of produced bytes\n            int bytesProduced = 0;\n            int bytesConsumed = 0;\n            try {\n                srcLoop:\n                for (;;) {\n                    ByteBuffer src = srcs[srcsOffset];\n                    int remaining = src.remaining();\n                    final ByteBuf bioWriteCopyBuf;\n                    int pendingEncryptedBytes;\n                    if (remaining == 0) {\n                        if (sslPending <= 0) {\n                            // We must skip empty buffers as BIO_write will return 0 if asked to write something\n                            // with length 0.\n                            if (++srcsOffset >= srcsEndOffset) {\n                                break;\n                            }\n                            continue;\n                        } else {\n                            bioWriteCopyBuf = null;\n                            pendingEncryptedBytes = SSL.bioLengthByteBuffer(networkBIO);\n                        }\n                    } else {\n                        // Write more encrypted data into the BIO. Ensure we only read one packet at a time as\n                        // stated in the SSLEngine javadocs.\n                        pendingEncryptedBytes = min(packetLength, remaining);\n                        try {\n                            bioWriteCopyBuf = writeEncryptedData(src, pendingEncryptedBytes);\n                        } catch (SSLException e) {\n                            // Ensure we correctly handle the error stack.\n                            return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                        }\n                    }\n                    try {\n                        for (;;) {\n                            ByteBuffer dst = dsts[dstsOffset];\n                            if (!dst.hasRemaining()) {\n                                // No space left in the destination buffer, skip it.\n                                if (++dstsOffset >= dstsEndOffset) {\n                                    break srcLoop;\n                                }\n                                continue;\n                            }\n\n                            int bytesRead;\n                            try {\n                                bytesRead = readPlaintextData(dst);\n                            } catch (SSLException e) {\n                                // Ensure we correctly handle the error stack.\n                                return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                            }\n                            // We are directly using the ByteBuffer memory for the write, and so we only know what has\n                            // been consumed after we let SSL decrypt the data. At this point we should update the\n                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf.\n                            int localBytesConsumed = pendingEncryptedBytes - SSL.bioLengthByteBuffer(networkBIO);\n                            bytesConsumed += localBytesConsumed;\n                            packetLength -= localBytesConsumed;\n                            pendingEncryptedBytes -= localBytesConsumed;\n                            src.position(src.position() + localBytesConsumed);\n\n                            if (bytesRead > 0) {\n                                bytesProduced += bytesRead;\n\n                                if (!dst.hasRemaining()) {\n                                    sslPending = sslPending0();\n                                    // Move to the next dst buffer as this one is full.\n                                    if (++dstsOffset >= dstsEndOffset) {\n                                        return sslPending > 0 ?\n                                                newResult(BUFFER_OVERFLOW, status, bytesConsumed, bytesProduced) :\n                                                newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                                        bytesConsumed, bytesProduced);\n                                    }\n                                } else if (packetLength == 0 || jdkCompatibilityMode) {\n                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed\n                                    // a single TLS packet and should stop consuming until this method is called again.\n                                    break srcLoop;\n                                }\n                            } else {\n                                int sslError = SSL.getError(ssl, bytesRead);\n                                if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {\n                                    // break to the outer loop as we want to read more data which means we need to\n                                    // write more to the BIO.\n                                    break;\n                                } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {\n                                    // This means the connection was shutdown correctly, close inbound and outbound\n                                    if (!receivedShutdown) {\n                                        closeAll();\n                                    }\n                                    return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                            bytesConsumed, bytesProduced);\n                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||\n                                        sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY ||\n                                        sslError == SSL.SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {\n                                    return newResult(isInboundDone() ? CLOSED : OK,\n                                            NEED_TASK, bytesConsumed, bytesProduced);\n                                } else {\n                                    return sslReadErrorResult(sslError, SSL.getLastErrorNumber(), bytesConsumed,\n                                            bytesProduced);\n                                }\n                            }\n                        }\n\n                        if (++srcsOffset >= srcsEndOffset) {\n                            break;\n                        }\n                    } finally {\n                        if (bioWriteCopyBuf != null) {\n                            bioWriteCopyBuf.release();\n                        }\n                    }\n                }\n            } finally {\n                SSL.bioClearByteBuffer(networkBIO);\n                rejectRemoteInitiatedRenegotiation();\n            }\n\n            // Check to see if we received a close_notify message from the peer.\n            if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n                closeAll();\n            }\n\n            return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status, bytesConsumed, bytesProduced);\n        }\n    }"
    },
    {
        "target_file_name": "SslUtils.java",
        "target_method": "getEncryptedPacketLength",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "87f40725155b2f89adfde68c7732f97c153676c4^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-24970",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private static int getEncryptedPacketLength(ByteBuffer buffer) {\n        int packetLength = 0;\n        int pos = buffer.position();\n        // SSLv3 or TLS - Check ContentType\n        boolean tls;\n        switch (unsignedByte(buffer.get(pos))) {\n            case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:\n            case SSL_CONTENT_TYPE_ALERT:\n            case SSL_CONTENT_TYPE_HANDSHAKE:\n            case SSL_CONTENT_TYPE_APPLICATION_DATA:\n            case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:\n                tls = true;\n                break;\n            default:\n                // SSLv2 or bad data\n                tls = false;\n        }\n\n        if (tls) {\n            // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1 - Check ProtocolVersion\n            int majorVersion = unsignedByte(buffer.get(pos + 1));\n            if (majorVersion == 3 || buffer.getShort(pos + 1) == GMSSL_PROTOCOL_VERSION) {\n                // SSLv3 or TLS or GMSSLv1.0 or GMSSLv1.1\n                packetLength = unsignedShortBE(buffer, pos + 3) + SSL_RECORD_HEADER_LENGTH;\n                if (packetLength <= SSL_RECORD_HEADER_LENGTH) {\n                    // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                    tls = false;\n                }\n            } else {\n                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)\n                tls = false;\n            }\n        }\n\n        if (!tls) {\n            // SSLv2 or bad data - Check the version\n            int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;\n            int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));\n            if (majorVersion == 2 || majorVersion == 3) {\n                // SSLv2\n                packetLength = headerLength == 2 ?\n                        (shortBE(buffer, pos) & 0x7FFF) + 2 : (shortBE(buffer, pos) & 0x3FFF) + 3;\n                if (packetLength <= headerLength) {\n                    return NOT_ENOUGH_DATA;\n                }\n            } else {\n                return NOT_ENCRYPTED;\n            }\n        }\n        return packetLength;\n    }"
    },
    {
        "target_file_name": "ReferenceCountedOpenSslEngine.java",
        "target_method": "unwrap",
        "project_url": "https://github.com/netty/netty",
        "commit_id": "87f40725155b2f89adfde68c7732f97c153676c4^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-24970",
        "project_name": "netty",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public final SSLEngineResult unwrap(\n            final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,\n            final ByteBuffer[] dsts, int dstsOffset, final int dstsLength) throws SSLException {\n\n        // Throw required runtime exceptions\n        checkNotNullWithIAE(srcs, \"srcs\");\n        if (srcsOffset >= srcs.length\n                || srcsOffset + srcsLength > srcs.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + srcsOffset + \", length: \" + srcsLength +\n                            \" (expected: offset <= offset + length <= srcs.length (\" + srcs.length + \"))\");\n        }\n        checkNotNullWithIAE(dsts, \"dsts\");\n        if (dstsOffset >= dsts.length || dstsOffset + dstsLength > dsts.length) {\n            throw new IndexOutOfBoundsException(\n                    \"offset: \" + dstsOffset + \", length: \" + dstsLength +\n                            \" (expected: offset <= offset + length <= dsts.length (\" + dsts.length + \"))\");\n        }\n        long capacity = 0;\n        final int dstsEndOffset = dstsOffset + dstsLength;\n        for (int i = dstsOffset; i < dstsEndOffset; i ++) {\n            ByteBuffer dst = checkNotNullArrayParam(dsts[i], i, \"dsts\");\n            if (dst.isReadOnly()) {\n                throw new ReadOnlyBufferException();\n            }\n            capacity += dst.remaining();\n        }\n\n        final int srcsEndOffset = srcsOffset + srcsLength;\n        long len = 0;\n        for (int i = srcsOffset; i < srcsEndOffset; i++) {\n            ByteBuffer src = checkNotNullArrayParam(srcs[i], i, \"srcs\");\n            len += src.remaining();\n        }\n\n        synchronized (this) {\n            if (isInboundDone()) {\n                return isOutboundDone() || isDestroyed() ? CLOSED_NOT_HANDSHAKING : NEED_WRAP_CLOSED;\n            }\n\n            SSLEngineResult.HandshakeStatus status = NOT_HANDSHAKING;\n            HandshakeState oldHandshakeState = handshakeState;\n            // Prepare OpenSSL to work in server mode and receive handshake\n            if (handshakeState != HandshakeState.FINISHED) {\n                if (handshakeState != HandshakeState.STARTED_EXPLICITLY) {\n                    // Update accepted so we know we triggered the handshake via wrap\n                    handshakeState = HandshakeState.STARTED_IMPLICITLY;\n                }\n\n                status = handshake();\n\n                if (status == NEED_TASK) {\n                    return newResult(status, 0, 0);\n                }\n\n                if (status == NEED_WRAP) {\n                    return NEED_WRAP_OK;\n                }\n                // Check if the inbound is considered to be closed if so let us try to wrap again.\n                if (isInboundDone) {\n                    return NEED_WRAP_CLOSED;\n                }\n            }\n\n            int sslPending = sslPending0();\n            int packetLength;\n            // The JDK implies that only a single SSL packet should be processed per unwrap call [1]. If we are in\n            // JDK compatibility mode then we should honor this, but if not we just wrap as much as possible. If there\n            // are multiple records or partial records this may reduce thrashing events through the pipeline.\n            // [1] https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html\n            if (jdkCompatibilityMode ||\n                    // If the handshake was not finished before we entered the method, we also ensure we only\n                    // unwrap one record. We do this to ensure we not produce any extra data before the caller\n                    // of the method is able to observe handshake completion and react on it.\n                    oldHandshakeState != HandshakeState.FINISHED) {\n                if (len < SSL_RECORD_HEADER_LENGTH) {\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n\n                packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);\n                if (packetLength == SslUtils.NOT_ENCRYPTED) {\n                    throw new NotSslRecordException(\"not an SSL/TLS record\");\n                }\n\n                final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;\n                if (packetLengthDataOnly > capacity) {\n                    // Not enough space in the destination buffer so signal the caller that the buffer needs to be\n                    // increased.\n                    if (packetLengthDataOnly > MAX_RECORD_SIZE) {\n                        // The packet length MUST NOT exceed 2^14 [1]. However we do accommodate more data to support\n                        // legacy use cases which may violate this condition (e.g. OpenJDK's SslEngineImpl). If the max\n                        // length is exceeded we fail fast here to avoid an infinite loop due to the fact that we\n                        // won't allocate a buffer large enough.\n                        // [1] https://tools.ietf.org/html/rfc5246#section-6.2.1\n                        throw new SSLException(\"Illegal packet length: \" + packetLengthDataOnly + \" > \" +\n                                                session.getApplicationBufferSize());\n                    } else {\n                        session.tryExpandApplicationBufferSize(packetLengthDataOnly);\n                    }\n                    return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n                }\n\n                if (len < packetLength) {\n                    // We either don't have enough data to read the packet length or not enough for reading the whole\n                    // packet.\n                    return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n                }\n            } else if (len == 0 && sslPending <= 0) {\n                return newResultMayFinishHandshake(BUFFER_UNDERFLOW, status, 0, 0);\n            } else if (capacity == 0) {\n                return newResultMayFinishHandshake(BUFFER_OVERFLOW, status, 0, 0);\n            } else {\n                packetLength = (int) min(MAX_VALUE, len);\n            }\n\n            // This must always be the case when we reached here as if not we returned BUFFER_UNDERFLOW.\n            assert srcsOffset < srcsEndOffset;\n\n            // This must always be the case if we reached here.\n            assert capacity > 0;\n\n            // Number of produced bytes\n            int bytesProduced = 0;\n            int bytesConsumed = 0;\n            try {\n                srcLoop:\n                for (;;) {\n                    ByteBuffer src = srcs[srcsOffset];\n                    int remaining = src.remaining();\n                    final ByteBuf bioWriteCopyBuf;\n                    int pendingEncryptedBytes;\n                    if (remaining == 0) {\n                        if (sslPending <= 0) {\n                            // We must skip empty buffers as BIO_write will return 0 if asked to write something\n                            // with length 0.\n                            if (++srcsOffset >= srcsEndOffset) {\n                                break;\n                            }\n                            continue;\n                        } else {\n                            bioWriteCopyBuf = null;\n                            pendingEncryptedBytes = SSL.bioLengthByteBuffer(networkBIO);\n                        }\n                    } else {\n                        // Write more encrypted data into the BIO. Ensure we only read one packet at a time as\n                        // stated in the SSLEngine javadocs.\n                        pendingEncryptedBytes = min(packetLength, remaining);\n                        try {\n                            bioWriteCopyBuf = writeEncryptedData(src, pendingEncryptedBytes);\n                        } catch (SSLException e) {\n                            // Ensure we correctly handle the error stack.\n                            return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                        }\n                    }\n                    try {\n                        for (;;) {\n                            ByteBuffer dst = dsts[dstsOffset];\n                            if (!dst.hasRemaining()) {\n                                // No space left in the destination buffer, skip it.\n                                if (++dstsOffset >= dstsEndOffset) {\n                                    break srcLoop;\n                                }\n                                continue;\n                            }\n\n                            int bytesRead;\n                            try {\n                                bytesRead = readPlaintextData(dst);\n                            } catch (SSLException e) {\n                                // Ensure we correctly handle the error stack.\n                                return handleUnwrapException(bytesConsumed, bytesProduced, e);\n                            }\n                            // We are directly using the ByteBuffer memory for the write, and so we only know what has\n                            // been consumed after we let SSL decrypt the data. At this point we should update the\n                            // number of bytes consumed, update the ByteBuffer position, and release temp ByteBuf.\n                            int localBytesConsumed = pendingEncryptedBytes - SSL.bioLengthByteBuffer(networkBIO);\n                            bytesConsumed += localBytesConsumed;\n                            packetLength -= localBytesConsumed;\n                            pendingEncryptedBytes -= localBytesConsumed;\n                            src.position(src.position() + localBytesConsumed);\n\n                            if (bytesRead > 0) {\n                                bytesProduced += bytesRead;\n\n                                if (!dst.hasRemaining()) {\n                                    sslPending = sslPending0();\n                                    // Move to the next dst buffer as this one is full.\n                                    if (++dstsOffset >= dstsEndOffset) {\n                                        return sslPending > 0 ?\n                                                newResult(BUFFER_OVERFLOW, status, bytesConsumed, bytesProduced) :\n                                                newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                                        bytesConsumed, bytesProduced);\n                                    }\n                                } else if (packetLength == 0 || jdkCompatibilityMode) {\n                                    // We either consumed all data or we are in jdkCompatibilityMode and have consumed\n                                    // a single TLS packet and should stop consuming until this method is called again.\n                                    break srcLoop;\n                                }\n                            } else {\n                                int sslError = SSL.getError(ssl, bytesRead);\n                                if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {\n                                    // break to the outer loop as we want to read more data which means we need to\n                                    // write more to the BIO.\n                                    break;\n                                } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {\n                                    // This means the connection was shutdown correctly, close inbound and outbound\n                                    if (!receivedShutdown) {\n                                        closeAll();\n                                    }\n                                    return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status,\n                                            bytesConsumed, bytesProduced);\n                                } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP ||\n                                        sslError == SSL.SSL_ERROR_WANT_CERTIFICATE_VERIFY ||\n                                        sslError == SSL.SSL_ERROR_WANT_PRIVATE_KEY_OPERATION) {\n                                    return newResult(isInboundDone() ? CLOSED : OK,\n                                            NEED_TASK, bytesConsumed, bytesProduced);\n                                } else {\n                                    return sslReadErrorResult(sslError, SSL.getLastErrorNumber(), bytesConsumed,\n                                            bytesProduced);\n                                }\n                            }\n                        }\n\n                        if (++srcsOffset >= srcsEndOffset) {\n                            break;\n                        }\n                    } finally {\n                        if (bioWriteCopyBuf != null) {\n                            bioWriteCopyBuf.release();\n                        }\n                    }\n                }\n            } finally {\n                SSL.bioClearByteBuffer(networkBIO);\n                rejectRemoteInitiatedRenegotiation();\n            }\n\n            // Check to see if we received a close_notify message from the peer.\n            if (!receivedShutdown && (SSL.getShutdown(ssl) & SSL.SSL_RECEIVED_SHUTDOWN) == SSL.SSL_RECEIVED_SHUTDOWN) {\n                closeAll();\n            }\n\n            return newResultMayFinishHandshake(isInboundDone() ? CLOSED : OK, status, bytesConsumed, bytesProduced);\n        }\n    }"
    },
    {
        "target_file_name": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "target_method": "addFieldToQuery",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54124",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "checkSimpleFieldName",
            "format",
            "formatted",
            "get",
            "getWiki",
            "getXClass",
            "put",
            "resolve",
            "shouldObfuscate"
        ],
        "target_code": "private void addFieldToQuery(String fieldName, String fieldAlias, DBListQuerySpec spec, List<String> selectClause,\n        List<String> fromClause, List<String> whereClause, Map<String, Object> parameters) throws QueryException\n    {\n        if (fieldName.startsWith(DOC_PREFIX) || fieldName.startsWith(OBJ_PREFIX)) {\n            checkSimpleFieldName(fieldName);\n            selectClause.add(fieldName);\n        } else if (!spec.hasClassName) {\n            checkSimpleFieldName(fieldName);\n            selectClause.add(DOC_PREFIX + fieldName);\n        } else {\n            try {\n                // Only load the XClass when really needed.\n                if (spec.xClass == null) {\n                    // Resolve the reference relative to the specified wiki.\n                    DocumentReference classReference = this.documentReferenceResolver.resolve(spec.className,\n                        new WikiReference(spec.wiki));\n                    XWikiContext xWikiContext = this.contextProvider.get();\n                    spec.xClass = xWikiContext.getWiki().getXClass(classReference, xWikiContext);\n                }\n\n                PropertyInterface propertyInterface = spec.xClass.get(fieldName);\n                if (propertyInterface instanceof PasswordClass) {\n                    throw new QueryException(\"Queries for password field [%s] on class [%s] aren't allowed\"\n                        .formatted(fieldName, spec.className), null);\n                } else if (propertyInterface instanceof EmailClass && this.mailConfiguration.shouldObfuscate()) {\n                    throw new QueryException((\"Queries for email property [%s] on class [%s] aren't allowed as email \"\n                        + \"obfuscation is enabled.\").formatted(fieldName, spec.className), null);\n                }\n                selectClause.add(fieldAlias + \".value\");\n                fromClause.add(\"StringProperty as \" + fieldAlias);\n                whereClause.add(String.format(\"obj.id = %1$s.id.id and %1$s.id.name = :%1$s\", fieldAlias));\n                parameters.put(fieldAlias, fieldName);\n            } catch (XWikiException e) {\n                throw new QueryException(\"Failed to get the XClass definition\", null, e);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "target_method": "getStatementWhenIdOrValueFieldsAreSpecified",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54124",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private String getStatementWhenIdOrValueFieldsAreSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n        throws QueryException\n    {\n        // Make sure we always have an id field. Ignore the value field if it duplicates the id field and there's no\n        // parent field specified.\n        if (!spec.hasIdField || (spec.idField.equals(spec.valueField) && !spec.hasParentField)) {\n            // If the parent field is specified then we need to include the value field, even if it duplicates the id\n            // field, because otherwise we can't distinguish between the value and the parent.\n            spec.idField = spec.valueField;\n            spec.hasIdField = true;\n            spec.valueField = spec.hasParentField ? spec.valueField : \"\";\n            spec.hasValueField = spec.hasParentField;\n        } else if (!spec.hasValueField && spec.hasParentField) {\n            // Same as above, we need to include the value field when the parent field is specified.\n            spec.valueField = spec.idField;\n            spec.hasValueField = true;\n        }\n\n        return getStatementWhenIdFieldIsSpecified(spec, parameters);\n    }"
    },
    {
        "target_file_name": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "target_method": "getStatementWhenIdFieldIsSpecified",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f2ca8649cba2ed3765061660bf5c7f801afa0b24",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54124",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addFieldToQuery"
        ],
        "target_code": "private String getStatementWhenIdFieldIsSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n        throws QueryException\n    {\n        List<String> selectClause = new ArrayList<>();\n        List<String> fromClause = new ArrayList<>();\n        List<String> whereClause = new ArrayList<>();\n\n        // We need to select the document in order to be able to check access rights on the results. At the same time we\n        // want to skip this column when filtering the Database List property values.\n        selectClause.add(\"doc.fullName as unfilterable0\");\n        fromClause.add(\"XWikiDocument as doc\");\n\n        // We need to join the objects table if the class name is specified or if one of the selected columns is an\n        // object property.\n        if (spec.hasClassName || spec.idField.startsWith(OBJ_PREFIX) || spec.valueField.startsWith(OBJ_PREFIX)\n            || spec.parentField.startsWith(OBJ_PREFIX)) {\n            fromClause.add(\"BaseObject as obj\");\n            whereClause.add(\"doc.fullName = obj.name\");\n            if (spec.hasClassName) {\n                whereClause.add(\"obj.className = :className and doc.fullName <> :templateName\");\n                parameters.put(CLASS_NAME, spec.className);\n                parameters.put(TEMPLATE_NAME, getTemplateName(spec.className));\n            }\n        }\n\n        addFieldToQuery(spec.idField, \"idProp\", spec, selectClause, fromClause, whereClause, parameters);\n\n        if (spec.hasValueField) {\n            addFieldToQuery(spec.valueField, \"valueProp\", spec, selectClause, fromClause, whereClause,\n                parameters);\n\n            // We cannot include the parent field if there's no value field because we would confuse it with the value\n            // field (the second column in the result set is reserved for the value).\n            if (spec.hasParentField) {\n                addFieldToQuery(spec.parentField, \"parentProp\", spec, selectClause, fromClause,\n                    whereClause, parameters);\n            }\n        }\n\n        StringBuilder statementBuilder =\n            new StringBuilder(\"select distinct \").append(StringUtils.join(selectClause, COLUMN_SEPARATOR))\n                .append(\" from \").append(StringUtils.join(fromClause, COLUMN_SEPARATOR));\n        if (whereClause.size() > 0) {\n            statementBuilder.append(\" where \").append(StringUtils.join(whereClause, \" and \"));\n        }\n\n        return statementBuilder.toString();\n    }"
    },
    {
        "target_file_name": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "target_method": "addFieldToQuery",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f2ca8649cba2ed3765061660bf5c7f801afa0b24^",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54124",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "format",
            "put"
        ],
        "target_code": "private void addFieldToQuery(String fieldName, String fieldAlias, boolean hasClassName, List<String> selectClause,\n        List<String> fromClause, List<String> whereClause, Map<String, Object> parameters)\n    {\n        if (fieldName.startsWith(DOC_PREFIX) || fieldName.startsWith(OBJ_PREFIX)) {\n            selectClause.add(fieldName);\n        } else if (!hasClassName) {\n            selectClause.add(DOC_PREFIX + fieldName);\n        } else {\n            selectClause.add(fieldAlias + \".value\");\n            fromClause.add(\"StringProperty as \" + fieldAlias);\n            whereClause.add(String.format(\"obj.id = %1$s.id.id and %1$s.id.name = :%1$s\", fieldAlias));\n            parameters.put(fieldAlias, fieldName);\n        }\n    }"
    },
    {
        "target_file_name": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "target_method": "getStatementWhenIdOrValueFieldsAreSpecified",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f2ca8649cba2ed3765061660bf5c7f801afa0b24^",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54124",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private String getStatementWhenIdOrValueFieldsAreSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n    {\n        // Make sure we always have an id field. Ignore the value field if it duplicates the id field and there's no\n        // parent field specified.\n        if (!spec.hasIdField || (spec.idField.equals(spec.valueField) && !spec.hasParentField)) {\n            // If the parent field is specified then we need to include the value field, even if it duplicates the id\n            // field, because otherwise we can't distinguish between the value and the parent.\n            spec.idField = spec.valueField;\n            spec.hasIdField = true;\n            spec.valueField = spec.hasParentField ? spec.valueField : \"\";\n            spec.hasValueField = spec.hasParentField;\n        } else if (!spec.hasValueField && spec.hasParentField) {\n            // Same as above, we need to include the value field when the parent field is specified.\n            spec.valueField = spec.idField;\n            spec.hasValueField = true;\n        }\n\n        return getStatementWhenIdFieldIsSpecified(spec, parameters);\n    }"
    },
    {
        "target_file_name": "ImplicitlyAllowedValuesDBListQueryBuilder.java",
        "target_method": "getStatementWhenIdFieldIsSpecified",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f2ca8649cba2ed3765061660bf5c7f801afa0b24^",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54124",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addFieldToQuery"
        ],
        "target_code": "private String getStatementWhenIdFieldIsSpecified(DBListQuerySpec spec, Map<String, Object> parameters)\n    {\n        List<String> selectClause = new ArrayList<>();\n        List<String> fromClause = new ArrayList<>();\n        List<String> whereClause = new ArrayList<>();\n\n        // We need to select the document in order to be able to check access rights on the results. At the same time we\n        // want to skip this column when filtering the Database List property values.\n        selectClause.add(\"doc.fullName as unfilterable0\");\n        fromClause.add(\"XWikiDocument as doc\");\n\n        // We need to join the objects table if the class name is specified or if one of the selected columns is an\n        // object property.\n        if (spec.hasClassName || spec.idField.startsWith(OBJ_PREFIX) || spec.valueField.startsWith(OBJ_PREFIX)\n            || spec.parentField.startsWith(OBJ_PREFIX)) {\n            fromClause.add(\"BaseObject as obj\");\n            whereClause.add(\"doc.fullName = obj.name\");\n            if (spec.hasClassName) {\n                whereClause.add(\"obj.className = :className and doc.fullName <> :templateName\");\n                parameters.put(CLASS_NAME, spec.className);\n                parameters.put(TEMPLATE_NAME, getTemplateName(spec.className));\n            }\n        }\n\n        addFieldToQuery(spec.idField, \"idProp\", spec.hasClassName, selectClause, fromClause, whereClause, parameters);\n\n        if (spec.hasValueField) {\n            addFieldToQuery(spec.valueField, \"valueProp\", spec.hasClassName, selectClause, fromClause, whereClause,\n                parameters);\n\n            // We cannot include the parent field if there's no value field because we would confuse it with the value\n            // field (the second column in the result set is reserved for the value).\n            if (spec.hasParentField) {\n                addFieldToQuery(spec.parentField, \"parentProp\", spec.hasClassName, selectClause, fromClause,\n                    whereClause, parameters);\n            }\n        }\n\n        StringBuilder statementBuilder =\n            new StringBuilder(\"select distinct \").append(StringUtils.join(selectClause, COLUMN_SEPARATOR))\n                .append(\" from \").append(StringUtils.join(fromClause, COLUMN_SEPARATOR));\n        if (whereClause.size() > 0) {\n            statementBuilder.append(\" where \").append(StringUtils.join(whereClause, \" and \"));\n        }\n\n        return statementBuilder.toString();\n    }"
    },
    {
        "target_file_name": "StaticMappings.java",
        "target_method": "find",
        "project_url": "https://github.com/opensolon/solon",
        "commit_id": "f46e47fd1f8455b9467d7ead3cdb0509115b2ef1",
        "CWE_id": "CWE-24",
        "CVE_id": "CVE-2025-1584",
        "project_name": "solon",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "",
            "contains",
            "if (",
            "lse {",
            "tory.find(m",
            "{",
            "}"
        ],
        "target_code": "public static URL find(String path) throws Exception {\n        URL rst = null;\n\n        if (path.contains(\"/../\") == false) {\n            // '/../' 不安全，禁止进入静态资料库\n            for (StaticLocation m : locationMap.values()) {\n                if (path.startsWith(m.pathPrefix)) {\n                    if (m.repositoryIncPrefix) {\n                        //path = /demo/file.htm\n                        //relativePath = demo/file.htm （没有'/'开头）\n                        rst = m.repository.find(path.substring(1));\n                    } else {\n                        //path = /demo/file.htm\n                        //relativePath = demo/file.htm （没有'/'开头）\n                        if (m.pathPrefixAsFile) {\n                            //如果是文件\n                            int idx = m.pathPrefix.lastIndexOf(\"/\");\n                            rst = m.repository.find(m.pathPrefix.substring(idx + 1));\n                        } else {\n                            //如果是路段\n                            rst = m.repository.find(path.substring(m.pathPrefix.length()));\n                        }\n                    }\n\n                    if (rst != null) {\n                        return rst;\n                    }\n                }\n            }\n        }\n\n        return rst;\n    }"
    },
    {
        "target_file_name": "StaticMappings.java",
        "target_method": "find",
        "project_url": "https://github.com/opensolon/solon",
        "commit_id": "f46e47fd1f8455b9467d7ead3cdb0509115b2ef1^",
        "CWE_id": "CWE-24",
        "CVE_id": "CVE-2025-1584",
        "project_name": "solon",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "",
            ");",
            "1));",
            "bstr",
            "rst",
            "startsWith",
            "values",
            "}"
        ],
        "target_code": "public static URL find(String path) throws Exception {\n        URL rst = null;\n\n        for (StaticLocation m : locationMap.values()) {\n            if (path.startsWith(m.pathPrefix)) {\n                if (m.repositoryIncPrefix) {\n                    //path = /demo/file.htm\n                    //relativePath = demo/file.htm （没有'/'开头）\n                    rst = m.repository.find(path.substring(1));\n                } else {\n                    //path = /demo/file.htm\n                    //relativePath = demo/file.htm （没有'/'开头）\n                    if (m.pathPrefixAsFile) {\n                        //如果是文件\n                        int idx = m.pathPrefix.lastIndexOf(\"/\");\n                        rst = m.repository.find(m.pathPrefix.substring(idx + 1));\n                    } else {\n                        //如果是路段\n                        rst = m.repository.find(path.substring(m.pathPrefix.length()));\n                    }\n                }\n\n                if (rst != null) {\n                    return rst;\n                }\n            }\n        }\n\n        return rst;\n    }"
    },
    {
        "target_file_name": "LocalS3.java",
        "target_method": "createServiceFactory",
        "project_url": "https://github.com/Robothy/local-s3",
        "commit_id": "d6ed756ceb30c1eb9d4263321ac683d734f8836f",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-27136",
        "project_name": "local-s3",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setProperty"
        ],
        "target_code": "private ServiceFactory createServiceFactory() {\n\n    LocalS3Manager manager;\n    if (mode == LocalS3Mode.IN_MEMORY) {\n      log.info(\"Created in-memory LocalS3 manager.\");\n      manager = LocalS3Manager.createInMemoryS3Manager(dataPath, initialDataCacheEnabled);\n    } else {\n      log.info(\"Created file system LocalS3 manager.\");\n      manager = LocalS3Manager.createFileSystemS3Manager(dataPath);\n    }\n\n    ServiceFactory serviceFactory = new DefaultServiceFactory();\n    BucketService bucketService = manager.bucketService();\n    ObjectService objectService = manager.objectService();\n    serviceFactory.register(BucketService.class, () -> bucketService);\n    serviceFactory.register(ObjectService.class, () -> objectService);\n\n    XMLInputFactory input = new WstxInputFactory();\n    input.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);\n    input.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE); // Disable DTDs\n    input.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE); // Disable external entities\n\n    XmlMapper xmlMapper = new XmlMapper(new XmlFactory(input, new WstxOutputFactory()));\n    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    xmlMapper.registerModule(new Jdk8Module());\n    xmlMapper.registerModule(new JavaTimeModule());\n    serviceFactory.register(XmlMapper.class, () -> xmlMapper);\n    return serviceFactory;\n  }"
    },
    {
        "target_file_name": "LocalS3.java",
        "target_method": "createServiceFactory",
        "project_url": "https://github.com/Robothy/local-s3",
        "commit_id": "d6ed756ceb30c1eb9d4263321ac683d734f8836f^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-27136",
        "project_name": "local-s3",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private ServiceFactory createServiceFactory() {\n\n    LocalS3Manager manager;\n    if (mode == LocalS3Mode.IN_MEMORY) {\n      log.info(\"Created in-memory LocalS3 manager.\");\n      manager = LocalS3Manager.createInMemoryS3Manager(dataPath, initialDataCacheEnabled);\n    } else {\n      log.info(\"Created file system LocalS3 manager.\");\n      manager = LocalS3Manager.createFileSystemS3Manager(dataPath);\n    }\n\n    ServiceFactory serviceFactory = new DefaultServiceFactory();\n    BucketService bucketService = manager.bucketService();\n    ObjectService objectService = manager.objectService();\n    serviceFactory.register(BucketService.class, () -> bucketService);\n    serviceFactory.register(ObjectService.class, () -> objectService);\n\n    XMLInputFactory input = new WstxInputFactory();\n    input.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);\n    XmlMapper xmlMapper = new XmlMapper(new XmlFactory(input, new WstxOutputFactory()));\n    xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    xmlMapper.registerModule(new Jdk8Module());\n    xmlMapper.registerModule(new JavaTimeModule());\n    serviceFactory.register(XmlMapper.class, () -> xmlMapper);\n    return serviceFactory;\n  }"
    },
    {
        "target_file_name": "DefaultURLShortenerResource.java",
        "target_method": "createShortenedURL",
        "project_url": "https://github.com/xwikisas/application-urlshortener",
        "commit_id": "f121a9c973fd25948e82efcb6289d53fe00a9e7d",
        "CWE_id": "CWE-352",
        "CVE_id": "CVE-2025-48885",
        "project_name": "application-urlshortener",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "exists",
            "getWiki",
            "status",
            "type"
        ],
        "target_code": "@Override\n    public Response createShortenedURL(String currentDocRef) throws Exception\n    {\n\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference documentReference = documentReferenceResolver.resolve(currentDocRef);\n\n        if (!xcontext.getWiki().exists(documentReference, xcontext)) {\n            return Response.status(Response.Status.NOT_FOUND).type(MediaType.APPLICATION_JSON).build();\n        }\n\n        if (authorization.hasAccess(Right.VIEW, documentReference)) {\n            XWikiDocument currentDoc = xcontext.getWiki().getDocument(documentReference, xcontext);\n            String pageID = addURLShortenerXObject(currentDoc);\n            if (pageID == null || pageID.isEmpty()) {\n                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);\n            }\n\n            return Response.ok().entity(Map.of(PAGE_ID, pageID)).type(MediaType.APPLICATION_JSON).build();\n        } else {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n    }"
    },
    {
        "target_file_name": "DefaultURLShortenerResource.java",
        "target_method": "createShortenedURL",
        "project_url": "https://github.com/xwikisas/application-urlshortener",
        "commit_id": "f121a9c973fd25948e82efcb6289d53fe00a9e7d^",
        "CWE_id": "CWE-352",
        "CVE_id": "CVE-2025-48885",
        "project_name": "application-urlshortener",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public Response createShortenedURL(String currentDocRef) throws Exception\n    {\n\n        XWikiContext xcontext = xcontextProvider.get();\n        DocumentReference documentReference = documentReferenceResolver.resolve(currentDocRef);\n        if (authorization.hasAccess(Right.VIEW, documentReference)) {\n            XWikiDocument currentDoc = xcontext.getWiki().getDocument(documentReference, xcontext);\n            String pageID = addURLShortenerXObject(currentDoc);\n            if (pageID == null || pageID.isEmpty()) {\n                throw new WebApplicationException(Response.Status.INTERNAL_SERVER_ERROR);\n            }\n\n            return Response.ok().entity(Map.of(PAGE_ID, pageID)).type(MediaType.APPLICATION_JSON).build();\n        } else {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n    }"
    },
    {
        "target_file_name": "BaseObjectEventGenerator.java",
        "target_method": "write",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54125",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "get",
            "getClassType",
            "getExcludedPropertyTypes",
            "isNotBlank"
        ],
        "target_code": "@Override\n    public void write(BaseObject xobject, Object filter, BaseObjectFilter objectFilter,\n        DocumentInstanceInputProperties properties) throws FilterException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        // > WikiObject\n\n        FilterEventParameters objectParameters = new FilterEventParameters();\n\n        objectParameters.put(WikiObjectFilter.PARAMETER_NAME, xobject.getName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_CLASS_REFERENCE, xobject.getClassName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_GUID, xobject.getGuid());\n        objectParameters.put(WikiObjectFilter.PARAMETER_NUMBER, xobject.getNumber());\n\n        objectFilter.beginWikiObject(xobject.getReference() != null ? xobject.getReference().getName() : null,\n            objectParameters);\n\n        // Object class\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n        ((BaseClassEventGenerator) this.classEventGenerator).write(xclass, filter, objectFilter, properties);\n\n        // Properties\n\n        // Iterate over values/properties sorted by field name so that the values are\n        // exported to XML in a consistent order.\n        Iterator<BaseProperty<?>> it = xobject.getSortedIterator();\n        while (it.hasNext()) {\n            BaseProperty<?> xproperty = it.next();\n\n            String pname = xproperty.getName();\n            if (StringUtils.isNotBlank(pname)\n                && (!(xclass.get(pname) instanceof PropertyClass propertyClass)\n                || !properties.getExcludedPropertyTypes().contains(propertyClass.getClassType())))\n            {\n                ((BasePropertyEventGenerator) this.propertyEventGenerator).write(xproperty, filter,\n                    (Map<String, Object>) properties);\n            }\n        }\n\n        // < WikiObject\n\n        objectFilter.endWikiObject(xobject.getReference().getName(), objectParameters);\n    }"
    },
    {
        "target_file_name": "Document.java",
        "target_method": "getXMLContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54125",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "of",
            "setExcludedPropertyTypes",
            "setPreserveVersion",
            "setTarget",
            "setWithJRCSRevisions",
            "setWithRevisions",
            "setWithWikiAttachmentsContent",
            "setWithWikiDocumentContentHTML",
            "toString",
            "toXML"
        ],
        "target_code": "public String getXMLContent() throws XWikiException\n    {\n        StringWriter writer = new StringWriter();\n        OutputTarget outputTarget = new DefaultWriterOutputTarget(writer);\n\n        DocumentInstanceInputProperties documentProperties = new DocumentInstanceInputProperties();\n        documentProperties.setWithWikiDocumentContentHTML(true);\n        documentProperties.setWithWikiAttachmentsContent(false);\n        documentProperties.setWithJRCSRevisions(false);\n        documentProperties.setWithRevisions(false);\n        documentProperties.setExcludedPropertyTypes(Set.of(\"Email\", \"Password\"));\n\n        // Output\n        XAROutputProperties xarProperties = new XAROutputProperties();\n        xarProperties.setPreserveVersion(false);\n        xarProperties.setTarget(outputTarget);\n\n        this.doc.toXML(documentProperties, xarProperties);\n\n        return writer.toString();\n    }"
    },
    {
        "target_file_name": "BaseObjectEventGenerator.java",
        "target_method": "write",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59^",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54125",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "trim"
        ],
        "target_code": "@Override\n    public void write(BaseObject xobject, Object filter, BaseObjectFilter objectFilter,\n        DocumentInstanceInputProperties properties) throws FilterException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        // > WikiObject\n\n        FilterEventParameters objectParameters = new FilterEventParameters();\n\n        objectParameters.put(WikiObjectFilter.PARAMETER_NAME, xobject.getName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_CLASS_REFERENCE, xobject.getClassName());\n        objectParameters.put(WikiObjectFilter.PARAMETER_GUID, xobject.getGuid());\n        objectParameters.put(WikiObjectFilter.PARAMETER_NUMBER, xobject.getNumber());\n\n        objectFilter.beginWikiObject(xobject.getReference() != null ? xobject.getReference().getName() : null,\n            objectParameters);\n\n        // Object class\n\n        BaseClass xclass = xobject.getXClass(xcontext);\n        ((BaseClassEventGenerator) this.classEventGenerator).write(xclass, filter, objectFilter, properties);\n\n        // Properties\n\n        // Iterate over values/properties sorted by field name so that the values are\n        // exported to XML in a consistent order.\n        Iterator<BaseProperty<?>> it = xobject.getSortedIterator();\n        while (it.hasNext()) {\n            BaseProperty<?> xproperty = it.next();\n\n            String pname = xproperty.getName();\n            if (pname != null && !pname.trim().equals(\"\")) {\n                ((BasePropertyEventGenerator) this.propertyEventGenerator).write(xproperty, filter,\n                    (Map<String, Object>) properties);\n            }\n        }\n\n        // < WikiObject\n\n        objectFilter.endWikiObject(xobject.getReference().getName(), objectParameters);\n    }"
    },
    {
        "target_file_name": "Document.java",
        "target_method": "getXMLContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "742ee3482ef6c2bd4ad03d0de9cdd81d0e8f3d59^",
        "CWE_id": "CWE-359",
        "CVE_id": "CVE-2025-54125",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getUtil",
            "getXMLContent",
            "getXWikiContext",
            "substitute"
        ],
        "target_code": "public String getXMLContent() throws XWikiException\n    {\n        String xml = this.doc.getXMLContent(getXWikiContext());\n        return getXWikiContext().getUtil().substitute(\"s/<email>.*?<\\\\/email>/<email>********<\\\\/email>/goi\",\n            getXWikiContext().getUtil().substitute(\"s/<password>.*?<\\\\/password>/<password>********<\\\\/password>/goi\",\n                xml));\n    }"
    },
    {
        "target_file_name": "Login.java",
        "target_method": "execute",
        "project_url": "https://github.com/factionsecurity/faction",
        "commit_id": "0a6848d388d6dba1c81918cce2772b1e805cd3d6",
        "CWE_id": "CWE-287",
        "CVE_id": "CVE-2025-27422",
        "project_name": "faction",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals",
            "isNewInstance"
        ],
        "target_code": "@Action(value = \"index\", results = { @Result(name = \"createAccount\", location = \"/WEB-INF/jsp/newInstance.jsp\"),\n\t\t\t@Result(name = \"failedAuth\", location = \"/index.jsp\"),\n\t\t\t@Result(name = \"redirect_to_oauth\", location = \"/oauth\"),\n\t\t\t@Result(name = \"assessorQueue\", type = \"redirectAction\", location = \"portal/Dashboard\"),\n\t\t\t@Result(name = \"engagement\", type = \"redirectAction\", location = \"portal/Engagement\"),\n\t\t\t@Result(name = \"admin\", type = \"redirectAction\", location = \"portal/Users\"),\n\t\t\t@Result(name = \"calendar\", type = \"redirectAction\", location = \"portal/Calendar\"),\n\t\t\t@Result(name = \"remediation\", type = \"redirectAction\", location = \"portal/Remediation\") })\n\tpublic String execute() {\n\t\t\n\n\t\tif (AccessControl.isNewInstance(em) && action == null) {\n\t\t\treturn \"createAccount\";\n\t\t} else if (AccessControl.isAuthenticated(this.JSESSION)) {\n\t\t\treturn redirectIt(this.getSessionUser());\n\t\t}else if ( (username != null && !username.equals(\"\")) || (getProfiles() != null && getProfiles().size()>0) ) {\n\t\t\tAuthResult result = AccessControl.Authenticate(username, password, request, em, getProfiles());\n\t\t\tif (result == AuthResult.SUCCESS) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tHttpSession session = ServletActionContext.getRequest().getSession();\n\t\t\t\tAuditLog.audit(username, this, \"Successsfully logged in\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tUser user = (User) session.getAttribute(\"user\");\n\t\t\t\tSystemSettings ss = (SystemSettings) em.createQuery(\"from SystemSettings\").getResultList().stream()\n\t\t\t\t\t\t.findFirst().orElse(null);\n\t\t\t\tString tier = this.getTier();\n\t\t\t\tsession.setAttribute(\"tier\", tier);\n\t\t\t\tif (tier == \"consultant\") {\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", ss.getPeerreview());\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", ss.getEnablefeed());\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", true);\n\t\t\t\t}\n\t\t\t\tsession.setAttribute(\"title1\", ss.getBoldTitle() == null ? \"FACTION\" : ss.getBoldTitle());\n\t\t\t\tsession.setAttribute(\"title2\", ss.getOtherTitle() == null ? \"oss\" : ss.getOtherTitle());\n\n\t\t\t\treturn redirectIt(user);\n\t\t\t} else if (result == AuthResult.FAILED_AUTH) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, \" Failed Authentication\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.LOCKEDOUT) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account Lock Out\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.INACTIVITY) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account was Lock Out due to inactivity\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked due to inactivity. Please contact your administrator\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.REDIRECT_OAUTH) {\n\t\t\t\tMap<String,String[]> map = request.getParameterMap();\n\t\t\t\treturn \"redirect_to_oauth\";\n\t\t\t}else if (result == AuthResult.NOT_VALID_OAUTH_ACCOUNT) {\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Not a valid OAuth User. Try another account or contact the administrator.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.error(username, this, \"Access control result of \" + result, AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t}\n\n\t\t} else if (AccessControl.isNewInstance(em) && (action != null && action.equals(\"create\"))) {\n\t\t\tif (adminUsername == null || adminUsername.trim().equals(\"\")) {\n\t\t\t\tthis.message = \"Username is blank\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\tif (adminPassword == null || confirm == null || !adminPassword.equals(confirm)) {\n\t\t\t\tthis.message = \"Passwords do not match\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\t\t\tif (first == null || last == null || first.equals(\"\") || last.equals(\"\")) {\n\t\t\t\tthis.message = \"First and/or Last Name are missing\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (email == null || email.equals(\"\")) {\n\t\t\t\tthis.message = \"Email address is missing\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\t\n\t\t\tString errorMessage = AccessControl.checkPassword(adminPassword, confirm);\n\t\t\tif(!errorMessage.equals(\"\")) {\n\t\t\t\tthis.message = errorMessage;\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (adminPassword.equals(confirm)) {\n\t\t\t\tif (this.team.equals(\"\"))\n\t\t\t\t\tthis.team = \"Hacking Team\";\n\n\t\t\t\tUser testAdmin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tif (testAdmin != null) {\n\t\t\t\t\tthis.message = \"Username already taken\";\n\t\t\t\t\treturn \"createAccount\";\n\t\t\t\t}\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAccessControl.createAdmin(adminUsername.trim().toLowerCase(), adminPassword, first, last, email, em);\n\n\t\t\t\tSystemSettings settings = em.find(SystemSettings.class, 2l);\n\t\t\t\tTeams theTeam = em.createQuery(\"from Teams where TeamName = :team\", Teams.class)\n\t\t\t\t\t\t.setParameter(\"team\", team).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tList<AssessmentType> atype = em.createQuery(\"from AssessmentType\").getResultList();\n\t\t\t\tList<Campaign> campaigns = em.createQuery(\"from Campaign\").getResultList();\n\t\t\t\tList<RiskLevel> levels = em.createQuery(\"from RiskLevel\").getResultList();\n\t\t\t\tList<ReportTemplates> reportTemplates = em.createQuery(\"from ReportTemplates\").getResultList();\n\t\t\t\tCategory cat = new Category();\n\t\t\t\tcat.setName(\"Uncategorized\");\n\t\t\t\tDefaultVulnerability dv = new DefaultVulnerability();\n\t\t\t\tdv.setActive(true);\n\t\t\t\tdv.setCategory(cat);\n\t\t\t\tdv.setName(\"Generic Vulnerability\");\n\t\t\t\tdv.setLikelyhood(4);\n\t\t\t\tdv.setOverall(4);\n\t\t\t\tdv.setImpact(4);\n\t\t\t\tdv.setDescription(\"\");\n\t\t\t\tdv.setRecommendation(\"\");\n\t\t\t\tem.persist(cat);\n\t\t\t\tem.persist(dv);\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new SystemSettings();\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t\tList<String> status = new ArrayList<String>();\n\t\t\t\t\tstatus.add(\"Open\");\n\t\t\t\t\tstatus.add(\"In Progress\");\n\t\t\t\t\tstatus.add(\"On Hold\");\n\t\t\t\t\tstatus.add(\"Closed\");\n\t\t\t\t\tsettings.setStatus(status);\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t}\n\t\t\t\tif (theTeam == null)\n\t\t\t\t\ttheTeam = new Teams();\n\t\t\t\tif (levels == null || levels.size() == 0) {\n\t\t\t\t\tString[] risk = { \"Informational\", \"Recommended\", \"Low\", \"Medium\", \"High\", \"Critical\" };\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tRiskLevel level = new RiskLevel();\n\t\t\t\t\t\tlevel.setRiskId(i);\n\t\t\t\t\t\tif (i < risk.length)\n\t\t\t\t\t\t\tlevel.setRisk(risk[i]);\n\t\t\t\t\t\tem.persist(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (campaigns == null || campaigns.size() == 0) {\n\t\t\t\t\tCampaign camp = new Campaign();\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n\t\t\t\t\tcamp.setName(\"\" + sdf.format(now) + \" Assessments\");\n\t\t\t\t\tem.persist(camp);\n\n\t\t\t\t}\n\n\t\t\t\ttheTeam.setTeamName(this.team);\n\t\t\t\tem.persist(settings);\n\t\t\t\tem.persist(theTeam);\n\t\t\t\tUser admin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername.trim()).getSingleResult();\n\t\t\t\tadmin.getPermissions().setAssessor(true);\n\t\t\t\tadmin.getPermissions().setEngagement(true);\n\t\t\t\tadmin.getPermissions().setManager(true);\n\t\t\t\tadmin.getPermissions().setRemediation(true);\n\n\t\t\t\tadmin.setTeam(theTeam);\n\t\t\t\tem.persist(admin);\n\n\t\t\t\tif (atype == null || atype.isEmpty()) {\n\n\t\t\t\t\tAssessmentType newType = new AssessmentType();\n\t\t\t\t\tnewType.setType(\"Security Assessment\");\n\t\t\t\t\tem.persist(newType);\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (reportTemplates == null || reportTemplates.isEmpty()) {\n\t\t\t\t\t\t\tReportTemplates reportTemplate = new ReportTemplates();\n\t\t\t\t\t\t\treportTemplate.initDefaultTemplate(theTeam, newType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAuditLog.audit(adminUsername, this, \"Admin Account Created\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t}\n\t\t\treturn SUCCESS;\n\n\t\t}else {\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t}"
    },
    {
        "target_file_name": "Login.java",
        "target_method": "execute",
        "project_url": "https://github.com/factionsecurity/faction",
        "commit_id": "0a6848d388d6dba1c81918cce2772b1e805cd3d6^",
        "CWE_id": "CWE-287",
        "CVE_id": "CVE-2025-27422",
        "project_name": "faction",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "equals"
        ],
        "target_code": "@Action(value = \"index\", results = { @Result(name = \"createAccount\", location = \"/WEB-INF/jsp/newInstance.jsp\"),\n\t\t\t@Result(name = \"failedAuth\", location = \"/index.jsp\"),\n\t\t\t@Result(name = \"redirect_to_oauth\", location = \"/oauth\"),\n\t\t\t@Result(name = \"assessorQueue\", type = \"redirectAction\", location = \"portal/Dashboard\"),\n\t\t\t@Result(name = \"engagement\", type = \"redirectAction\", location = \"portal/Engagement\"),\n\t\t\t@Result(name = \"admin\", type = \"redirectAction\", location = \"portal/Users\"),\n\t\t\t@Result(name = \"calendar\", type = \"redirectAction\", location = \"portal/Calendar\"),\n\t\t\t@Result(name = \"remediation\", type = \"redirectAction\", location = \"portal/Remediation\") })\n\tpublic String execute() {\n\t\t\n\n\t\tif (AccessControl.isNewInstance(em) && action == null) {\n\t\t\treturn \"createAccount\";\n\t\t} else if (AccessControl.isAuthenticated(this.JSESSION)) {\n\t\t\treturn redirectIt(this.getSessionUser());\n\t\t}else if ( (username != null && !username.equals(\"\")) || (getProfiles() != null && getProfiles().size()>0) ) {\n\t\t\tAuthResult result = AccessControl.Authenticate(username, password, request, em, getProfiles());\n\t\t\tif (result == AuthResult.SUCCESS) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tHttpSession session = ServletActionContext.getRequest().getSession();\n\t\t\t\tAuditLog.audit(username, this, \"Successsfully logged in\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tUser user = (User) session.getAttribute(\"user\");\n\t\t\t\tSystemSettings ss = (SystemSettings) em.createQuery(\"from SystemSettings\").getResultList().stream()\n\t\t\t\t\t\t.findFirst().orElse(null);\n\t\t\t\tString tier = this.getTier();\n\t\t\t\tsession.setAttribute(\"tier\", tier);\n\t\t\t\tif (tier == \"consultant\") {\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", false);\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", false);\n\t\t\t\t} else {\n\t\t\t\t\tsession.setAttribute(\"prEnabled\", ss.getPeerreview());\n\t\t\t\t\tsession.setAttribute(\"feedEnabled\", ss.getEnablefeed());\n\t\t\t\t\tsession.setAttribute(\"retestsEnabled\", true);\n\t\t\t\t}\n\t\t\t\tsession.setAttribute(\"title1\", ss.getBoldTitle() == null ? \"FACTION\" : ss.getBoldTitle());\n\t\t\t\tsession.setAttribute(\"title2\", ss.getOtherTitle() == null ? \"oss\" : ss.getOtherTitle());\n\n\t\t\t\treturn redirectIt(user);\n\t\t\t} else if (result == AuthResult.FAILED_AUTH) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, \" Failed Authentication\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.LOCKEDOUT) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account Lock Out\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.INACTIVITY) {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.notAuthorized(username, this, username + \" Account was Lock Out due to inactivity\", false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Your account has been locked due to inactivity. Please contact your administrator\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else if (result == AuthResult.REDIRECT_OAUTH) {\n\t\t\t\tMap<String,String[]> map = request.getParameterMap();\n\t\t\t\treturn \"redirect_to_oauth\";\n\t\t\t}else if (result == AuthResult.NOT_VALID_OAUTH_ACCOUNT) {\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Not a valid OAuth User. Try another account or contact the administrator.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t} else {\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAuditLog.error(username, this, \"Access control result of \" + result, AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t\tfailed = true;\n\t\t\t\tmessage = \"Username and/or Password was incorrect.\";\n\t\t\t\treturn \"failedAuth\";\n\t\t\t}\n\n\t\t} else if (action != null && action.equals(\"create\")) {\n\t\t\tif (adminUsername == null || adminUsername.trim().equals(\"\")) {\n\t\t\t\tthis.message = \"Username is blank\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\tif (adminPassword == null || confirm == null || !adminPassword.equals(confirm)) {\n\t\t\t\tthis.message = \"Passwords do not match\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\t\t\tif (first == null || last == null || first.equals(\"\") || last.equals(\"\")) {\n\t\t\t\tthis.message = \"First and/or Last Name are missing\";\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (email == null || email.equals(\"\")) {\n\t\t\t\tthis.message = \"Email address is missing\";\n\t\t\t\treturn \"createAccount\";\n\n\t\t\t}\n\t\t\t\n\t\t\tString errorMessage = AccessControl.checkPassword(adminPassword, confirm);\n\t\t\tif(!errorMessage.equals(\"\")) {\n\t\t\t\tthis.message = errorMessage;\n\t\t\t\treturn \"createAccount\";\n\t\t\t}\n\n\t\t\tif (adminPassword.equals(confirm)) {\n\t\t\t\tif (this.team.equals(\"\"))\n\t\t\t\t\tthis.team = \"Hacking Team\";\n\n\t\t\t\tUser testAdmin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tif (testAdmin != null) {\n\t\t\t\t\tthis.message = \"Username already taken\";\n\t\t\t\t\treturn \"createAccount\";\n\t\t\t\t}\n\t\t\t\tHibHelper.getInstance().preJoin();\n\t\t\t\tem.joinTransaction();\n\t\t\t\tAccessControl.createAdmin(adminUsername.trim().toLowerCase(), adminPassword, first, last, email, em);\n\n\t\t\t\tSystemSettings settings = em.find(SystemSettings.class, 2l);\n\t\t\t\tTeams theTeam = em.createQuery(\"from Teams where TeamName = :team\", Teams.class)\n\t\t\t\t\t\t.setParameter(\"team\", team).getResultList().stream().findFirst().orElse(null);\n\t\t\t\tList<AssessmentType> atype = em.createQuery(\"from AssessmentType\").getResultList();\n\t\t\t\tList<Campaign> campaigns = em.createQuery(\"from Campaign\").getResultList();\n\t\t\t\tList<RiskLevel> levels = em.createQuery(\"from RiskLevel\").getResultList();\n\t\t\t\tList<ReportTemplates> reportTemplates = em.createQuery(\"from ReportTemplates\").getResultList();\n\t\t\t\tCategory cat = new Category();\n\t\t\t\tcat.setName(\"Uncategorized\");\n\t\t\t\tDefaultVulnerability dv = new DefaultVulnerability();\n\t\t\t\tdv.setActive(true);\n\t\t\t\tdv.setCategory(cat);\n\t\t\t\tdv.setName(\"Generic Vulnerability\");\n\t\t\t\tdv.setLikelyhood(4);\n\t\t\t\tdv.setOverall(4);\n\t\t\t\tdv.setImpact(4);\n\t\t\t\tdv.setDescription(\"\");\n\t\t\t\tdv.setRecommendation(\"\");\n\t\t\t\tem.persist(cat);\n\t\t\t\tem.persist(dv);\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new SystemSettings();\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t\tList<String> status = new ArrayList<String>();\n\t\t\t\t\tstatus.add(\"Open\");\n\t\t\t\t\tstatus.add(\"In Progress\");\n\t\t\t\t\tstatus.add(\"On Hold\");\n\t\t\t\t\tstatus.add(\"Closed\");\n\t\t\t\t\tsettings.setStatus(status);\n\t\t\t\t\tsettings.setDefaultStatus(\"Open\");\n\t\t\t\t}\n\t\t\t\tif (theTeam == null)\n\t\t\t\t\ttheTeam = new Teams();\n\t\t\t\tif (levels == null || levels.size() == 0) {\n\t\t\t\t\tString[] risk = { \"Informational\", \"Recommended\", \"Low\", \"Medium\", \"High\", \"Critical\" };\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tRiskLevel level = new RiskLevel();\n\t\t\t\t\t\tlevel.setRiskId(i);\n\t\t\t\t\t\tif (i < risk.length)\n\t\t\t\t\t\t\tlevel.setRisk(risk[i]);\n\t\t\t\t\t\tem.persist(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (campaigns == null || campaigns.size() == 0) {\n\t\t\t\t\tCampaign camp = new Campaign();\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy\");\n\t\t\t\t\tcamp.setName(\"\" + sdf.format(now) + \" Assessments\");\n\t\t\t\t\tem.persist(camp);\n\n\t\t\t\t}\n\n\t\t\t\ttheTeam.setTeamName(this.team);\n\t\t\t\tem.persist(settings);\n\t\t\t\tem.persist(theTeam);\n\t\t\t\tUser admin = em.createQuery(\"from User where username = :uname\", User.class)\n\t\t\t\t\t\t.setParameter(\"uname\", this.adminUsername.trim()).getSingleResult();\n\t\t\t\tadmin.getPermissions().setAssessor(true);\n\t\t\t\tadmin.getPermissions().setEngagement(true);\n\t\t\t\tadmin.getPermissions().setManager(true);\n\t\t\t\tadmin.getPermissions().setRemediation(true);\n\n\t\t\t\tadmin.setTeam(theTeam);\n\t\t\t\tem.persist(admin);\n\n\t\t\t\tif (atype == null || atype.isEmpty()) {\n\n\t\t\t\t\tAssessmentType newType = new AssessmentType();\n\t\t\t\t\tnewType.setType(\"Security Assessment\");\n\t\t\t\t\tem.persist(newType);\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (reportTemplates == null || reportTemplates.isEmpty()) {\n\t\t\t\t\t\t\tReportTemplates reportTemplate = new ReportTemplates();\n\t\t\t\t\t\t\treportTemplate.initDefaultTemplate(theTeam, newType);\n\t\t\t\t\t\t}\n\t\t\t\t\t}catch(Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAuditLog.audit(adminUsername, this, \"Admin Account Created\", AuditLog.Login, false);\n\t\t\t\tHibHelper.getInstance().commit();\n\n\t\t\t}\n\t\t\treturn SUCCESS;\n\n\t\t}else {\n\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t}"
    },
    {
        "target_file_name": "LocalBackendSearchOperation.java",
        "target_method": "processSearch",
        "project_url": "https://github.com/OpenIdentityPlatform/OpenDJ",
        "commit_id": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
        "CWE_id": "CWE-835",
        "CVE_id": "CVE-2025-27497",
        "project_name": "OpenDJ",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "contains",
            "getAliasedDN",
            "processSearch",
            "remove",
            "setBaseDN"
        ],
        "target_code": "private void processSearch(AtomicBoolean executePostOpPlugins) throws CanceledOperationException\n  {\n    // Process the search base and filter to convert them from their raw forms\n    // as provided by the client to the forms required for the rest of the\n    // search processing.\n    baseDN = getBaseDN();\n    filter = getFilter();\n\n    if (baseDN == null || filter == null)\n    {\n      return;\n    }\n\n    // Check to see if there are any controls in the request. If so, then\n    // see if there is any special processing required.\n    try\n    {\n      handleRequestControls();\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n\n      setResponseData(de);\n      return;\n    }\n\n\n    // Check to see if the client has permission to perform the search.\n\n    // FIXME: for now assume that this will check all permission\n    // pertinent to the operation. This includes proxy authorization\n    // and any other controls specified.\n    try\n    {\n      if (!getAccessControlHandler().isAllowed(this))\n      {\n        setResultCode(ResultCode.INSUFFICIENT_ACCESS_RIGHTS);\n        appendErrorMessage(ERR_SEARCH_AUTHZ_INSUFFICIENT_ACCESS_RIGHTS.get(baseDN));\n        return;\n      }\n    }\n    catch (DirectoryException e)\n    {\n      setResultCode(e.getResultCode());\n      appendErrorMessage(e.getMessageObject());\n      return;\n    }\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Invoke the pre-operation search plugins.\n    executePostOpPlugins.set(true);\n    if (!processOperationResult(this, getPluginConfigManager().invokePreOperationSearchPlugins(this)))\n    {\n      return;\n    }\n\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Get the backend that should hold the search base. If there is none,\n    // then fail.\n    if (backend == null)\n    {\n      setResultCode(ResultCode.NO_SUCH_OBJECT);\n      appendErrorMessage(ERR_SEARCH_BASE_DOESNT_EXIST.get(baseDN));\n      return;\n    }\n\n\n    // We'll set the result code to \"success\". If a problem occurs, then it\n    // will be overwritten.\n    setResultCode(ResultCode.SUCCESS);\n\n    try\n    {\n      //DereferenceAliasesPolicy\n      if (\n              DereferenceAliasesPolicy.ALWAYS.equals(getDerefPolicy())\n              || DereferenceAliasesPolicy.FINDING_BASE.equals(getDerefPolicy())\n              || (DereferenceAliasesPolicy.IN_SEARCHING.equals(getDerefPolicy()) && SearchScope.WHOLE_SUBTREE.equals(getScope()))\n      ) {\n        final Entry baseEntry=DirectoryServer.getEntry(baseDN);\n        if (baseEntry!=null && baseEntry.isAlias()) {\n          final DN aliasedDn = baseEntry.getAliasedDN();\n          if(!dereferencingDNs.contains(aliasedDn)) { //detect recursive search\n            dereferencingDNs.add(aliasedDn);\n            setBaseDN(aliasedDn);\n            try {\n              processSearch(executePostOpPlugins);\n            } catch (StackOverflowError error) {\n              throw new Exception(error);\n            }\n            dereferencingDNs.remove(aliasedDn);\n            return;\n          }\n        }\n      }\n\n      // If there's a persistent search, then register it with the server.\n      boolean processSearchNow = true;\n      if (persistentSearch != null)\n      {\n        // If we're only interested in changes, then we do not actually want\n        // to process the search now.\n        processSearchNow = !persistentSearch.isChangesOnly();\n\n        // The Core server maintains the count of concurrent persistent searches\n        // so that all the backends (Remote and Local) are aware of it. Verify\n        // with the core if we have already reached the threshold.\n        if (!DirectoryServer.allowNewPersistentSearch())\n        {\n          setResultCode(ResultCode.ADMIN_LIMIT_EXCEEDED);\n          appendErrorMessage(ERR_MAX_PSEARCH_LIMIT_EXCEEDED.get());\n          return;\n        }\n        backend.registerPersistentSearch(persistentSearch);\n        persistentSearch.enable();\n      }\n\n\n      if (processSearchNow)\n      {\n        // Process the search in the backend and all its subordinates.\n        backend.search(this);\n      }\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n      setResponseData(de);\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      return;\n    }\n    catch (CanceledOperationException coe)\n    {\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      throw coe;\n    }\n    catch (Exception e)\n    {\n      logger.traceException(e);\n\n      setResultCode(DirectoryServer.getCoreConfigManager().getServerErrorResultCode());\n      appendErrorMessage(ERR_SEARCH_BACKEND_EXCEPTION\n          .get(getExceptionMessage(e)));\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n    }\n  }"
    },
    {
        "target_file_name": "LocalBackendSearchOperation.java",
        "target_method": "processSearch",
        "project_url": "https://github.com/OpenIdentityPlatform/OpenDJ",
        "commit_id": "08aee4724608e4a32baa3c7d7499ec913a275aaf^",
        "CWE_id": "CWE-835",
        "CVE_id": "CVE-2025-27497",
        "project_name": "OpenDJ",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getAliasedDN",
            "processSearch",
            "setBaseDN"
        ],
        "target_code": "private void processSearch(AtomicBoolean executePostOpPlugins) throws CanceledOperationException\n  {\n    // Process the search base and filter to convert them from their raw forms\n    // as provided by the client to the forms required for the rest of the\n    // search processing.\n    baseDN = getBaseDN();\n    filter = getFilter();\n\n    if (baseDN == null || filter == null)\n    {\n      return;\n    }\n\n    // Check to see if there are any controls in the request. If so, then\n    // see if there is any special processing required.\n    try\n    {\n      handleRequestControls();\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n\n      setResponseData(de);\n      return;\n    }\n\n\n    // Check to see if the client has permission to perform the search.\n\n    // FIXME: for now assume that this will check all permission\n    // pertinent to the operation. This includes proxy authorization\n    // and any other controls specified.\n    try\n    {\n      if (!getAccessControlHandler().isAllowed(this))\n      {\n        setResultCode(ResultCode.INSUFFICIENT_ACCESS_RIGHTS);\n        appendErrorMessage(ERR_SEARCH_AUTHZ_INSUFFICIENT_ACCESS_RIGHTS.get(baseDN));\n        return;\n      }\n    }\n    catch (DirectoryException e)\n    {\n      setResultCode(e.getResultCode());\n      appendErrorMessage(e.getMessageObject());\n      return;\n    }\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Invoke the pre-operation search plugins.\n    executePostOpPlugins.set(true);\n    if (!processOperationResult(this, getPluginConfigManager().invokePreOperationSearchPlugins(this)))\n    {\n      return;\n    }\n\n\n    // Check for a request to cancel this operation.\n    checkIfCanceled(false);\n\n\n    // Get the backend that should hold the search base. If there is none,\n    // then fail.\n    if (backend == null)\n    {\n      setResultCode(ResultCode.NO_SUCH_OBJECT);\n      appendErrorMessage(ERR_SEARCH_BASE_DOESNT_EXIST.get(baseDN));\n      return;\n    }\n\n\n    // We'll set the result code to \"success\". If a problem occurs, then it\n    // will be overwritten.\n    setResultCode(ResultCode.SUCCESS);\n\n    try\n    {\n      //DereferenceAliasesPolicy\n      if (\n              DereferenceAliasesPolicy.ALWAYS.equals(getDerefPolicy())\n              || DereferenceAliasesPolicy.FINDING_BASE.equals(getDerefPolicy())\n              || (DereferenceAliasesPolicy.IN_SEARCHING.equals(getDerefPolicy()) && SearchScope.WHOLE_SUBTREE.equals(getScope()))\n      ) {\n        final Entry baseEntry=DirectoryServer.getEntry(baseDN);\n        if (baseEntry!=null && baseEntry.isAlias()) {\n          setBaseDN(baseEntry.getAliasedDN());\n          processSearch(executePostOpPlugins);\n          return;\n        }\n      }\n\n      // If there's a persistent search, then register it with the server.\n      boolean processSearchNow = true;\n      if (persistentSearch != null)\n      {\n        // If we're only interested in changes, then we do not actually want\n        // to process the search now.\n        processSearchNow = !persistentSearch.isChangesOnly();\n\n        // The Core server maintains the count of concurrent persistent searches\n        // so that all the backends (Remote and Local) are aware of it. Verify\n        // with the core if we have already reached the threshold.\n        if (!DirectoryServer.allowNewPersistentSearch())\n        {\n          setResultCode(ResultCode.ADMIN_LIMIT_EXCEEDED);\n          appendErrorMessage(ERR_MAX_PSEARCH_LIMIT_EXCEEDED.get());\n          return;\n        }\n        backend.registerPersistentSearch(persistentSearch);\n        persistentSearch.enable();\n      }\n\n\n      if (processSearchNow)\n      {\n        // Process the search in the backend and all its subordinates.\n        backend.search(this);\n      }\n    }\n    catch (DirectoryException de)\n    {\n      logger.traceException(de);\n      setResponseData(de);\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      return;\n    }\n    catch (CanceledOperationException coe)\n    {\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n\n      throw coe;\n    }\n    catch (Exception e)\n    {\n      logger.traceException(e);\n\n      setResultCode(DirectoryServer.getCoreConfigManager().getServerErrorResultCode());\n      appendErrorMessage(ERR_SEARCH_BACKEND_EXCEPTION\n          .get(getExceptionMessage(e)));\n\n      if (persistentSearch != null)\n      {\n        persistentSearch.cancel();\n        setSendResponse(true);\n      }\n    }\n  }"
    },
    {
        "target_file_name": "AliasTestCase.java",
        "target_method": "startServer",
        "project_url": "https://github.com/OpenIdentityPlatform/OpenDJ",
        "commit_id": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
        "CWE_id": "CWE-835",
        "CVE_id": "CVE-2025-27497",
        "project_name": "OpenDJ",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@BeforeClass\n    public void startServer() throws Exception {\n        TestCaseUtils.startServer();\n        TestCaseUtils.initializeTestBackend(true);\n\n        TestCaseUtils.addEntries(\n                 \"dn: o=MyCompany, o=test\",\n                        \"o: MyCompany\",\n                        \"objectclass:organization\",\n                        \"\",\n                        \"dn: ou=Area1, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"ou: Area1\",\n                        \"aliasedObjectName: o=MyCompany, o=test\",\n                        \"\",\n                        \"dn: cn=John Doe, o=MyCompany, o=test\",\n                        \"cn: John Doe\",\n                        \"sn: Doe\",\n                        \"objectclass: person\",\n                        \"\",\n                        \"dn: cn=President, o=MyCompany, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"cn: President\",\n                        \"aliasedobjectname: cn=John Doe, o=MyCompany, o=test\",\n                        \"\",\n\n                        \"dn: ou=employees,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: employees\",\n                        \"description: All employees\",\n                        \"\",\n                        \"dn: uid=jdoe,ou=employees,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=jdoe,ou=researchers,o=test\",\n                        \"uid: jdoe\",\n                        \"\",\n                        \"dn: ou=researchers,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: researchers\",\n                        \"description: All reasearchers\",\n                        \"\",\n                        \"dn: uid=jdoe,ou=researchers,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=jdoe,ou=employees,o=test\",\n                        \"uid: jdoe\",\n\n                        \"\",\n                        \"dn: ou=students,o=test\",\n                        \"objectClass: top\",\n                        \"objectClass: organizationalUnit\",\n                        \"ou: students\",\n                        \"description: All students\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=students,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=researchers,o=test\",\n                        \"uid: janedoe\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=researchers,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=employees,o=test\",\n                        \"uid: janedoe\",\n                        \"\",\n                        \"dn: uid=janedoe,ou=employees,o=test\",\n                        \"objectClass: alias\",\n                        \"objectClass: top\",\n                        \"objectClass: extensibleObject\",\n                        \"aliasedObjectName: uid=janedoe,ou=students,o=test\",\n                        \"uid: janedoe\",\n                        \"\"\n        );\n\n        final LDAPConnectionFactory factory =new LDAPConnectionFactory(\"localhost\", TestCaseUtils.getServerLdapPort());\n        connection = factory.getConnection();\n        connection.bind(\"cn=Directory Manager\", \"password\".toCharArray());\n        assertThat(connection.isValid()).isTrue();\n    }"
    },
    {
        "target_file_name": "AliasTestCase.java",
        "target_method": "search",
        "project_url": "https://github.com/OpenIdentityPlatform/OpenDJ",
        "commit_id": "08aee4724608e4a32baa3c7d7499ec913a275aaf",
        "CWE_id": "CWE-835",
        "CVE_id": "CVE-2025-27497",
        "project_name": "OpenDJ",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "newSearchRequest",
            "setDereferenceAliasesPolicy"
        ],
        "target_code": "public HashMap<String,SearchResultEntry> search(String dn, SearchScope scope,DereferenceAliasesPolicy policy) throws SearchResultReferenceIOException, LdapException {\n        final SearchRequest request =Requests.newSearchRequest(dn, scope,\"(objectclass=*)\")\n                .setDereferenceAliasesPolicy(policy);\n        System.out.println(\"---------------------------------------------------------------------------------------\");\n        System.out.println(request);\n\n        HashMap<String,SearchResultEntry> res=new HashMap<>();\n        final ConnectionEntryReader reader = connection.search(request);\n        while (reader.hasNext()) {\n            final SearchResultEntry srEntry = reader.readEntry();\n            System.out.println(srEntry);\n            assertThat(res.put(srEntry.getName().toString(),srEntry)).isNull();\n        }\n        return res;\n    }"
    },
    {
        "target_file_name": "AliasTestCase.java",
        "target_method": "startServer",
        "project_url": "https://github.com/OpenIdentityPlatform/OpenDJ",
        "commit_id": "08aee4724608e4a32baa3c7d7499ec913a275aaf^",
        "CWE_id": "CWE-835",
        "CVE_id": "CVE-2025-27497",
        "project_name": "OpenDJ",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@BeforeClass\n    public void startServer() throws Exception {\n        TestCaseUtils.startServer();\n        TestCaseUtils.initializeTestBackend(true);\n\n        TestCaseUtils.addEntries(\n                 \"dn: o=MyCompany, o=test\",\n                        \"o: MyCompany\",\n                        \"objectclass:organization\",\n                        \"\",\n                        \"dn: ou=Area1, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"ou: Area1\",\n                        \"aliasedObjectName: o=MyCompany, o=test\",\n                        \"\",\n                        \"dn: cn=John Doe, o=MyCompany, o=test\",\n                        \"cn: John Doe\",\n                        \"sn: Doe\",\n                        \"objectclass: person\",\n                        \"\",\n                        \"dn: cn=President, o=MyCompany, o=test\",\n                        \"objectclass: alias\",\n                        \"objectclass: extensibleobject\",\n                        \"cn: President\",\n                        \"aliasedobjectname: cn=John Doe, o=MyCompany, o=test\",\n                        \"\"\n        );\n\n        final LDAPConnectionFactory factory =new LDAPConnectionFactory(\"localhost\", TestCaseUtils.getServerLdapPort());\n        connection = factory.getConnection();\n        connection.bind(\"cn=Directory Manager\", \"password\".toCharArray());\n        assertThat(connection.isValid()).isTrue();\n    }"
    },
    {
        "target_file_name": "AliasTestCase.java",
        "target_method": "search",
        "project_url": "https://github.com/OpenIdentityPlatform/OpenDJ",
        "commit_id": "08aee4724608e4a32baa3c7d7499ec913a275aaf^",
        "CWE_id": "CWE-835",
        "CVE_id": "CVE-2025-27497",
        "project_name": "OpenDJ",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "newSearchRequest",
            "setDereferenceAliasesPolicy"
        ],
        "target_code": "public HashMap<String,SearchResultEntry> search(SearchScope scope,DereferenceAliasesPolicy policy) throws SearchResultReferenceIOException, LdapException {\n        final SearchRequest request =Requests.newSearchRequest(\"ou=Area1,o=test\", scope,\"(objectclass=*)\")\n                .setDereferenceAliasesPolicy(policy);\n        System.out.println(\"---------------------------------------------------------------------------------------\");\n        System.out.println(request);\n\n        HashMap<String,SearchResultEntry> res=new HashMap<>();\n        final ConnectionEntryReader reader = connection.search(request);\n        while (reader.hasNext()) {\n            final SearchResultEntry srEntry = reader.readEntry();\n            System.out.println(srEntry);\n            assertThat(res.put(srEntry.getName().toString(),srEntry)).isNull();\n        }\n        return res;\n    }"
    },
    {
        "target_file_name": "FileStorage.java",
        "target_method": "saveStream",
        "project_url": "https://github.com/cuba-platform/cuba",
        "commit_id": "42b6c00fd0572b8e52ae31afd1babc827a3161a1",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-32959",
        "project_name": "cuba",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "close",
            "copyLarge",
            "delete",
            "exists",
            "format",
            "getAbsolutePath",
            "getConfig",
            "getFileStorageMaxFileSize",
            "read",
            "toBytes",
            "toMegabytes",
            "warn"
        ],
        "target_code": "@Override\n    public long saveStream(final FileDescriptor fileDescr, final InputStream inputStream) throws FileStorageException {\n        checkFileDescriptor(fileDescr);\n\n        File[] roots = getStorageRoots();\n\n        // Store to primary storage\n\n        checkStorageDefined(roots, fileDescr);\n        checkPrimaryStorageAccessible(roots, fileDescr);\n\n        File dir = getStorageDir(roots[0], fileDescr);\n        dir.mkdirs();\n        checkDirectoryExists(dir);\n\n        final File file = new File(dir, getFileName(fileDescr));\n        checkFileExists(file);\n\n        ServerConfig serverConfig = configuration.getConfig(ServerConfig.class);\n        long maxAllowedSize = serverConfig.getFileStorageMaxFileSize().toBytes();\n        long size = 0;\n        OutputStream os = null;\n        try {\n            os = FileUtils.openOutputStream(file);\n            size = IOUtils.copyLarge(inputStream, os, 0, maxAllowedSize);\n\n            if (size >= maxAllowedSize) {\n                if (inputStream.read() != IOUtils.EOF) {\n                    os.close();\n                    if (file.exists()) {\n                        if (!file.delete()) {\n                            log.warn(\"Failed to delete an incorrectly uploaded file '{}'. \" +\n                                            \"File was to large and has been rejected but already loaded part was not deleted.\",\n                                    file.getAbsolutePath());\n                        }\n                    }\n                    throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION,\n                            String.format(\"File is too large: '%s'. Max file size = %s MB is exceeded but there are unread bytes left.\",\n                                    file.getAbsolutePath(),\n                                    serverConfig.getFileStorageMaxFileSize().toMegabytes()));\n                }\n            }\n            os.flush();\n            writeLog(file, false);\n        } catch (IOException e) {\n            IOUtils.closeQuietly(os);\n            FileUtils.deleteQuietly(file);\n\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, file.getAbsolutePath(), e);\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n\n        // Copy file to secondary storages asynchronously\n\n        final SecurityContext securityContext = AppContext.getSecurityContext();\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileDescr, roots[i]);\n                continue;\n            }\n\n            File copyDir = getStorageDir(roots[i], fileDescr);\n            final File fileCopy = new File(copyDir, getFileName(fileDescr));\n\n            writeExecutor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        AppContext.setSecurityContext(securityContext);\n                        FileUtils.copyFile(file, fileCopy, true);\n                        writeLog(fileCopy, false);\n                    } catch (Exception e) {\n                        log.error(\"Error saving {} into {} : {}\", fileDescr, fileCopy.getAbsolutePath(), e.getMessage());\n                    } finally {\n                        AppContext.setSecurityContext(null);\n                    }\n                }\n            });\n        }\n\n        return size;\n    }"
    },
    {
        "target_file_name": "FileStorage.java",
        "target_method": "saveStream",
        "project_url": "https://github.com/cuba-platform/cuba",
        "commit_id": "42b6c00fd0572b8e52ae31afd1babc827a3161a1^",
        "CWE_id": "CWE-770",
        "CVE_id": "CVE-2025-32959",
        "project_name": "cuba",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "copyLarge"
        ],
        "target_code": "@Override\n    public long saveStream(final FileDescriptor fileDescr, final InputStream inputStream) throws FileStorageException {\n        checkFileDescriptor(fileDescr);\n\n        File[] roots = getStorageRoots();\n\n        // Store to primary storage\n\n        checkStorageDefined(roots, fileDescr);\n        checkPrimaryStorageAccessible(roots, fileDescr);\n\n        File dir = getStorageDir(roots[0], fileDescr);\n        dir.mkdirs();\n        checkDirectoryExists(dir);\n\n        final File file = new File(dir, getFileName(fileDescr));\n        checkFileExists(file);\n\n        long size = 0;\n        OutputStream os = null;\n        try {\n            os = FileUtils.openOutputStream(file);\n            size = IOUtils.copyLarge(inputStream, os);\n            os.flush();\n            writeLog(file, false);\n        } catch (IOException e) {\n            IOUtils.closeQuietly(os);\n            FileUtils.deleteQuietly(file);\n\n            throw new FileStorageException(FileStorageException.Type.IO_EXCEPTION, file.getAbsolutePath(), e);\n        } finally {\n            IOUtils.closeQuietly(os);\n        }\n\n        // Copy file to secondary storages asynchronously\n\n        final SecurityContext securityContext = AppContext.getSecurityContext();\n        for (int i = 1; i < roots.length; i++) {\n            if (!roots[i].exists()) {\n                log.error(\"Error saving {} into {} : directory doesn't exist\", fileDescr, roots[i]);\n                continue;\n            }\n\n            File copyDir = getStorageDir(roots[i], fileDescr);\n            final File fileCopy = new File(copyDir, getFileName(fileDescr));\n\n            writeExecutor.submit(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        AppContext.setSecurityContext(securityContext);\n                        FileUtils.copyFile(file, fileCopy, true);\n                        writeLog(fileCopy, false);\n                    } catch (Exception e) {\n                        log.error(\"Error saving {} into {} : {}\", fileDescr, fileCopy.getAbsolutePath(), e.getMessage());\n                    } finally {\n                        AppContext.setSecurityContext(null);\n                    }\n                }\n            });\n        }\n\n        return size;\n    }"
    },
    {
        "target_file_name": "SnowflakeFileTransferAgent.java",
        "target_method": "parseCommandInGS",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-27496",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "debug",
            "maskSecrets",
            "toString"
        ],
        "target_code": "private static JsonNode parseCommandInGS(SFStatement statement, String command)\n      throws SnowflakeSQLException {\n    Object result = null;\n    // send the command to GS\n    try {\n      result =\n          statement.executeHelper(\n              command,\n              \"application/json\",\n              null, // bindValues\n              false, // describeOnly\n              false, // internal\n              false, // async\n              new ExecTimeTelemetryData()); // OOB telemetry timing queries\n    } catch (SFException ex) {\n      throw new SnowflakeSQLException(\n          ex.getQueryId(), ex, ex.getSqlState(), ex.getVendorCode(), ex.getParams());\n    }\n\n    JsonNode jsonNode = (JsonNode) result;\n\n    logger.debug(\"Response: {}\", SecretDetector.maskSecrets(jsonNode.toString()));\n\n    SnowflakeUtil.checkErrorAndThrowException(jsonNode);\n    return jsonNode;\n  }"
    },
    {
        "target_file_name": "SecretDetector.java",
        "target_method": "maskSecrets",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-27496",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "filterAWSKeys",
            "filterAccessTokens",
            "filterConnectionTokens",
            "filterEncryptionMaterial",
            "filterOAuthTokens",
            "filterPassword",
            "filterSASTokens"
        ],
        "target_code": "public static String maskSecrets(String text) {\n    return filterAccessTokens(\n        filterConnectionTokens(\n            filterPassword(\n                filterSASTokens(\n                    filterAWSKeys(filterOAuthTokens(filterEncryptionMaterial(text)))))));\n  }"
    },
    {
        "target_file_name": "SecretDetector.java",
        "target_method": "filterAccessTokens",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-27496",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public static String filterAccessTokens(String message) {\n    Matcher awsMatcher = AWS_TOKEN_PATTERN.matcher(message);\n\n    // aws\n    if (awsMatcher.find()) {\n      message = awsMatcher.replaceAll(\"$1\\\":\\\"XXXX\\\"\");\n    }\n\n    // azure\n    Matcher azureMatcher = SAS_TOKEN_PATTERN.matcher(message);\n\n    if (azureMatcher.find()) {\n      message = azureMatcher.replaceAll(\"$1=XXXX\");\n    }\n\n    // GCS\n    Matcher gcsMatcher = PRIVATE_KEY_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message =\n          gcsMatcher.replaceAll(\n              \"-----BEGIN PRIVATE KEY-----\" // #pragma: allowlist secret\n                  + \"\\\\\\\\nXXXX\\\\\\\\n\"\n                  + \"-----END PRIVATE KEY-----\");\n    }\n\n    gcsMatcher = PRIVATE_KEY_DATA_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message = gcsMatcher.replaceAll(\"\\\"privateKeyData\\\": \\\"XXXX\\\"\");\n    }\n\n    return message;\n  }"
    },
    {
        "target_file_name": "SecretDetector.java",
        "target_method": "filterAccessTokens",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507^",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-27496",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public static String filterAccessTokens(String message) {\n    Matcher awsMatcher = AWS_TOKEN_PATTERN.matcher(message);\n\n    // aws\n    if (awsMatcher.find()) {\n      message = awsMatcher.replaceAll(\"$1\\\":\\\"XXXX\\\"\");\n    }\n\n    // azure\n    Matcher azureMatcher = SAS_TOKEN_PATTERN.matcher(message);\n\n    if (azureMatcher.find()) {\n      message = azureMatcher.replaceAll(\"$1=XXXX\");\n    }\n\n    // GCS\n    Matcher gcsMatcher = PRIVATE_KEY_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message =\n          gcsMatcher.replaceAll(\n              \"-----BEGIN PRIVATE KEY-----\" // #pragma: allowlist secret\n                  + \"\\\\\\\\nXXXX\\\\\\\\n\"\n                  + \"-----END PRIVATE KEY-----\");\n    }\n\n    gcsMatcher = PRIVATE_KEY_DATA_PATTERN.matcher(message);\n    if (gcsMatcher.find()) {\n      message = gcsMatcher.replaceAll(\"\\\"privateKeyData\\\": \\\"XXXX\\\"\");\n    }\n\n    return message;\n  }"
    },
    {
        "target_file_name": "SnowflakeFileTransferAgent.java",
        "target_method": "parseCommandInGS",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507^",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-27496",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "debug",
            "toString"
        ],
        "target_code": "private static JsonNode parseCommandInGS(SFStatement statement, String command)\n      throws SnowflakeSQLException {\n    Object result = null;\n    // send the command to GS\n    try {\n      result =\n          statement.executeHelper(\n              command,\n              \"application/json\",\n              null, // bindValues\n              false, // describeOnly\n              false, // internal\n              false, // async\n              new ExecTimeTelemetryData()); // OOB telemetry timing queries\n    } catch (SFException ex) {\n      throw new SnowflakeSQLException(\n          ex.getQueryId(), ex, ex.getSqlState(), ex.getVendorCode(), ex.getParams());\n    }\n\n    JsonNode jsonNode = (JsonNode) result;\n    logger.debug(\"Response: {}\", jsonNode.toString());\n\n    SnowflakeUtil.checkErrorAndThrowException(jsonNode);\n    return jsonNode;\n  }"
    },
    {
        "target_file_name": "SecretDetector.java",
        "target_method": "maskSecrets",
        "project_url": "https://github.com/snowflakedb/snowflake-jdbc",
        "commit_id": "ef81582ce2f1dbc3c8794a696c94f4fe65fad507^",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-27496",
        "project_name": "snowflake-jdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "filterAWSKeys",
            "filterAccessTokens",
            "filterConnectionTokens",
            "filterOAuthTokens",
            "filterPassword",
            "filterSASTokens"
        ],
        "target_code": "public static String maskSecrets(String text) {\n    return filterAccessTokens(\n        filterConnectionTokens(\n            filterPassword(filterSASTokens(filterAWSKeys(filterOAuthTokens(text))))));\n  }"
    },
    {
        "target_file_name": "RestFileDownloadController.java",
        "target_method": "download",
        "project_url": "https://github.com/cuba-platform/jpawebapi",
        "commit_id": "78b837d7e2b12d0df69cef1bc6042ebf3bdaf22c",
        "CWE_id": "CWE-79",
        "CVE_id": "CVE-2025-32961",
        "project_name": "jpawebapi",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "resolveAttachmentValue"
        ],
        "target_code": "@RequestMapping(value = \"/download\", method = RequestMethod.GET)\n    public ModelAndView download(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        UserSession userSession = getSession(request, response);\n        if (userSession == null) {\n            error(response);\n            return null;\n        }\n\n        AppContext.setSecurityContext(new SecurityContext(userSession));\n        try {\n            UUID fileId;\n            try {\n                fileId = UUID.fromString(request.getParameter(\"f\"));\n            } catch (Exception e) {\n                log.error(e.toString());\n                error(response);\n                return null;\n            }\n\n            FileDescriptor fd = dataService.load(new LoadContext<>(FileDescriptor.class).setId(fileId));\n            if (fd == null) {\n                log.warn(\"Unable to find file with id \" + fileId);\n                error(response);\n                return null;\n            }\n\n            String fileName = URLEncodeUtils.encodeUtf8(fd.getName());\n\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Pragma\", \"no-cache\");\n\n            boolean attach = Boolean.valueOf(request.getParameter(\"a\"));\n\n            attach = resolveAttachmentValue(attach, fd);\n\n            response.setHeader(\"Content-Disposition\", (attach ? \"attachment\" : \"inline\")\n                    + \"; filename=\" + fileName);\n\n            writeResponse(response, userSession, fd);\n\n        } finally {\n            AppContext.setSecurityContext(null);\n        }\n        return null;\n    }"
    },
    {
        "target_file_name": "RestFileDownloadController.java",
        "target_method": "download",
        "project_url": "https://github.com/cuba-platform/jpawebapi",
        "commit_id": "78b837d7e2b12d0df69cef1bc6042ebf3bdaf22c^",
        "CWE_id": "CWE-79",
        "CVE_id": "CVE-2025-32961",
        "project_name": "jpawebapi",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@RequestMapping(value = \"/download\", method = RequestMethod.GET)\n    public ModelAndView download(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        UserSession userSession = getSession(request, response);\n        if (userSession == null) {\n            error(response);\n            return null;\n        }\n\n        AppContext.setSecurityContext(new SecurityContext(userSession));\n        try {\n            UUID fileId;\n            try {\n                fileId = UUID.fromString(request.getParameter(\"f\"));\n            } catch (Exception e) {\n                log.error(e.toString());\n                error(response);\n                return null;\n            }\n\n            FileDescriptor fd = dataService.load(new LoadContext<>(FileDescriptor.class).setId(fileId));\n            if (fd == null) {\n                log.warn(\"Unable to find file with id \" + fileId);\n                error(response);\n                return null;\n            }\n\n            String fileName = URLEncodeUtils.encodeUtf8(fd.getName());\n\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setHeader(\"Pragma\", \"no-cache\");\n            response.setDateHeader(\"Expires\", 0);\n            response.setHeader(\"Content-Type\", getContentType(fd));\n            response.setHeader(\"Pragma\", \"no-cache\");\n\n            boolean attach = Boolean.valueOf(request.getParameter(\"a\"));\n            response.setHeader(\"Content-Disposition\", (attach ? \"attachment\" : \"inline\")\n                    + \"; filename=\" + fileName);\n\n            writeResponse(response, userSession, fd);\n\n        } finally {\n            AppContext.setSecurityContext(null);\n        }\n        return null;\n    }"
    },
    {
        "target_file_name": "SseServiceImpl.java",
        "target_method": "speechToTextTranscriptionsV2",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "4e93ac86d4891c59ecfcd27c051de9b3c5379315",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-6466",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "ention(file, MimeTyp"
        ],
        "target_code": "@Override\n    public WhisperResponse speechToTextTranscriptionsV2(MultipartFile file) {\n        // 确保文件不为空\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot convert an empty MultipartFile\");\n        }\n        if (!FileUtils.isValidFileExtention(file, MimeTypeUtils.AUDIO__EXTENSION)) {\n            throw new IllegalStateException(\"File Extention not supported\");\n        }\n        // 创建一个文件对象\n        File fileA = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + file.getOriginalFilename());\n        try {\n            // 将 MultipartFile 的内容写入文件\n            file.transferTo(fileA);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to convert MultipartFile to File\", e);\n        }\n        return openAiStreamClient.speechToTextTranscriptions(fileA);\n    }"
    },
    {
        "target_file_name": "SseServiceImpl.java",
        "target_method": "upload",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "4e93ac86d4891c59ecfcd27c051de9b3c5379315",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-6466",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "isEmpty",
            "isValidFileExtention"
        ],
        "target_code": "@Override\n    public UploadFileResponse upload(MultipartFile file) {\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot upload an empty MultipartFile\");\n        }\n        if (!FileUtils.isValidFileExtention(file, MimeTypeUtils.DEFAULT_ALLOWED_EXTENSION)) {\n            throw new IllegalStateException(\"File Extention not supported\");\n        }\n        openAiStreamClient = chatConfig.getOpenAiStreamClient();\n        return openAiStreamClient.uploadFile(\"fine-tune\", convertMultiPartToFile(file));\n    }"
    },
    {
        "target_file_name": "SseServiceImpl.java",
        "target_method": "speechToTextTranscriptionsV2",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "4e93ac86d4891c59ecfcd27c051de9b3c5379315^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-6466",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public WhisperResponse speechToTextTranscriptionsV2(MultipartFile file) {\n        // 确保文件不为空\n        if (file.isEmpty()) {\n            throw new IllegalStateException(\"Cannot convert an empty MultipartFile\");\n        }\n        // 创建一个文件对象\n        File fileA = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + file.getOriginalFilename());\n        try {\n            // 将 MultipartFile 的内容写入文件\n            file.transferTo(fileA);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to convert MultipartFile to File\", e);\n        }\n        return openAiStreamClient.speechToTextTranscriptions(fileA);\n    }"
    },
    {
        "target_file_name": "SseServiceImpl.java",
        "target_method": "upload",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "4e93ac86d4891c59ecfcd27c051de9b3c5379315^",
        "CWE_id": "CWE-434",
        "CVE_id": "CVE-2025-6466",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public UploadFileResponse upload(MultipartFile file) {\n        openAiStreamClient = chatConfig.getOpenAiStreamClient();\n        return openAiStreamClient.uploadFile(\"fine-tune\", convertMultiPartToFile(file));\n    }"
    },
    {
        "target_file_name": "ConfigureModule.java",
        "target_method": "configure",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "annotatedWith",
            "bindConstant",
            "equals",
            "equalsIgnoreCase",
            "getInitParameter",
            "named",
            "to"
        ],
        "target_code": "protected void configure() {\n        this.bindConstant().annotatedWith(Names.named(filesDirectoryParameter)).to(this.context.getInitParameter(filesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(baseUrlParameter)).to(this.context.getInitParameter(baseUrlParameter));\n        this.bindConstant().annotatedWith(Names.named(pluginFilesDirectoryParameter)).to(this.context.getInitParameter(pluginFilesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(usageScenarioParameter)).to(this.context.getInitParameter(usageScenarioParameter));\n        String secureEnrollment = this.context.getInitParameter(secureEnrollmentParameter);\n        this.bindConstant().annotatedWith(Names.named(secureEnrollmentParameter)).to(\n                secureEnrollment != null && (secureEnrollment.equals(\"1\") || secureEnrollment.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(hashSecretParameter)).to(this.context.getInitParameter(hashSecretParameter));\n        String hsts = this.context.getInitParameter(hstsParameter);\n        this.bindConstant().annotatedWith(Names.named(hstsParameter)).to(\n                hsts != null && (hsts.equals(\"1\") || hsts.equalsIgnoreCase(\"true\"))\n        );\n        String preventDuplicate = this.context.getInitParameter(preventDuplicateParameter);\n        this.bindConstant().annotatedWith(Names.named(preventDuplicateParameter)).to(\n                preventDuplicate != null && (preventDuplicate.equals(\"1\") || preventDuplicate.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(aaptCommandParameter)).to(this.context.getInitParameter(aaptCommandParameter));\n        this.bindConstant().annotatedWith(Names.named(roleOrgadminIdParameter)).to(\n                Integer.parseInt(this.context.getInitParameter(roleOrgadminIdParameter))\n        );\n        String launcherPackage = this.context.getInitParameter(launcherPackageParameter);\n        if (launcherPackage == null) {\n            launcherPackage = Application.DEFAULT_LAUNCHER_PACKAGE;\n        }\n        this.bindConstant().annotatedWith(Names.named(launcherPackageParameter)).to(launcherPackage);\n\n        // Optional parameters (Guice doesn't allow to bind string to null)\n        String opt;\n\n        opt = this.context.getInitParameter(baseDirectoryParameter);\n        this.bindConstant().annotatedWith(Names.named(baseDirectoryParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(transmitPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(transmitPasswordParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(authClassParameter);\n        try {\n            Class authImpl = opt != null ? Class.forName(\"com.hmdm.auth.\" + opt + \"Auth\") : LocalAuth.class;\n            this.bind(HmdmAuthInterface.class).annotatedWith(Names.named(authClassParameter))\n                    .to(authImpl);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Rebranding\n        opt = this.context.getInitParameter(rebrandingNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingLogoParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingLogoParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingMobileNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingMobileNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingSignupLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingSignupLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingTermsLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingTermsLinkParameter)).to(opt != null ? opt : \"\");\n\n        // SMTP\n        opt = this.context.getInitParameter(smtpHostParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpHostParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPortParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPortParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 25);\n        opt = this.context.getInitParameter(smtpSslParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpStartTlsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpStartTlsParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpSslProtocolsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslProtocolsParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpSslTrustParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslTrustParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpUsernameParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpUsernameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPasswordParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpFromParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpFromParameter)).to(opt != null ? opt : \"\");\n\n        // Other\n        opt = this.context.getInitParameter(deviceFastSearchCharsParameter);\n        this.bindConstant().annotatedWith(Names.named(deviceFastSearchCharsParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 5);\n        opt = this.context.getInitParameter(sqlInitScriptPath);\n        this.bindConstant().annotatedWith(Names.named(sqlInitScriptPath)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyAddresses);\n        this.bindConstant().annotatedWith(Names.named(proxyAddresses)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyIpHeader);\n        this.bindConstant().annotatedWith(Names.named(proxyIpHeader)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerAutoStatus);\n        this.bindConstant().annotatedWith(Names.named(customerAutoStatus)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(adminEmail);\n        this.bindConstant().annotatedWith(Names.named(adminEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpUrl);\n        this.bindConstant().annotatedWith(Names.named(mailchimpUrl)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpKey);\n        this.bindConstant().annotatedWith(Names.named(mailchimpKey)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignup);\n        this.bindConstant().annotatedWith(Names.named(customerSignup)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupCopySettings);\n        this.bindConstant().annotatedWith(Names.named(customerSignupCopySettings)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupConfigurations);\n        this.bindConstant().annotatedWith(Names.named(customerSignupConfigurations)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSupportEmail);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSupportEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceLimit);\n        // I have absolutely no idea why int can't be bound here but it can't!!!\n        // Let's proceed as an Indian and send String to SignupResource instead of int :-/\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSizeLimit);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSizeLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupExpiryDays);\n        this.bindConstant().annotatedWith(Names.named(customerSignupExpiryDays)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceConfig);\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceConfig)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(emailRecoverySubj);\n        this.bindConstant().annotatedWith(Names.named(emailRecoverySubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailRecoveryBody);\n        this.bindConstant().annotatedWith(Names.named(emailRecoveryBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteBody)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(ldapAdminBind);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminBind)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(ldapHost);\n        this.bindConstant().annotatedWith(Names.named(ldapHost)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapPort);\n        this.bindConstant().annotatedWith(Names.named(ldapPort)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 389);\n        opt = this.context.getInitParameter(ldapBaseDn);\n        this.bindConstant().annotatedWith(Names.named(ldapBaseDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminDn);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminPassword);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminPassword)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUsernameAttribute);\n        this.bindConstant().annotatedWith(Names.named(ldapUsernameAttribute)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUserDn);\n        this.bindConstant().annotatedWith(Names.named(ldapUserDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapDefaultRole);\n        this.bindConstant().annotatedWith(Names.named(ldapDefaultRole)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapCustomerId);\n        this.bindConstant().annotatedWith(Names.named(ldapCustomerId)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 1);\n        opt = this.context.getInitParameter(deviceAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(deviceAllowedAddress)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(uiAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(uiAllowedAddress)).to(opt != null ? opt : \"\");\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "getAllConfigurations",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PERMISSION_DENIED",
            "error",
            "get",
            "hasPermission"
        ],
        "target_code": "@ApiOperation(\n            value = \"Get configurations\",\n            notes = \"Gets the list of available configurations\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getAllConfigurations() {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configurations\");\n            return Response.PERMISSION_DENIED();\n        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurations();\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "searchConfigurations",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PERMISSION_DENIED",
            "error",
            "get",
            "hasPermission"
        ],
        "target_code": "@ApiOperation(\n            value = \"Search configurations\",\n            notes = \"Searches configurations meeting the specified filter value\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search/{value}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response searchConfigurations(@PathParam(\"value\") String value) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configurations\");\n            return Response.PERMISSION_DENIED();\n        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurationsByValue(value);\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "getConfigurationApplications",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PERMISSION_DENIED",
            "error",
            "get",
            "hasPermission"
        ],
        "target_code": "@ApiOperation(\n            value = \"Get configuration applications\",\n            notes = \"Gets the list of all applications in context of usage by the requested configuration\",\n            response = Application.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/applications/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationApplications(@PathParam(\"id\") @ApiParam(\"Configuration ID\") Integer id) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access configuration applications\");\n            return Response.PERMISSION_DENIED();\n        }\n        return Response.OK(this.configurationDAO.getConfigurationApplications(id));\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "getConfigurationById",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "PERMISSION_DENIED",
            "error",
            "get",
            "hasPermission"
        ],
        "target_code": "@ApiOperation(\n            value = \"Get configuration\",\n            notes = \"Gets the details for configuration referenced by the specified ID\",\n            response = Configuration.class\n    )\n    @GET\n    @Path(\"/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationById(@PathParam(\"id\") Integer id) {\n        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n            log.error(\"Unauthorized attempt to access the configuration \" + id);\n            return Response.PERMISSION_DENIED();\n        }\n\n        Configuration configurationById = getConfiguration(id);\n\n        return Response.OK(configurationById);\n    }"
    },
    {
        "target_file_name": "SyncResource.java",
        "target_method": "getDeviceSetting",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getNumber",
            "info"
        ],
        "target_code": "@ApiOperation(\n            value = \"Get device settings\",\n            notes = \"Gets the device info and settings from the MDM server.\",\n            response = SyncResponse.class\n    )\n    @GET\n    @Path(\"/configuration/{deviceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getDeviceSetting(@PathParam(\"deviceId\")\n                                     @ApiParam(\"An identifier of device within MDM server\")\n                                     String number,\n                                     @Context HttpServletRequest request,\n                                     @Context HttpServletResponse response) {\n        logger.debug(\"/public/sync/configuration/{}\", number);\n\n        if (secureEnrollment) {\n            if (!CryptoUtil.checkRequestSignature(request.getHeader(HEADER_ENROLLMENT_SIGNATURE), hashSecret + number)) {\n                logger.warn(\"Failed to setup device {}: signature mismatch\", number);\n                return Response.PERMISSION_DENIED();\n            }\n        }\n\n        try {\n            Device dbDevice = this.unsecureDAO.getDeviceByNumber(number);\n            boolean migration = false;\n            boolean foundByImeiOrSerial = false;\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByOldNumber(number);\n                migration = dbDevice != null;\n            }\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByImeiOrSerial(number);\n                foundByImeiOrSerial = dbDevice != null;\n                if (foundByImeiOrSerial) {\n                    logger.info(\"IMEI/Serial {}: assigned existing number: {}\", number, dbDevice.getNumber());\n                }\n            }\n\n            // Device creation on demand\n            if (dbDevice == null) {\n                if (unsecureDAO.isSingleCustomer()) {\n                    dbDevice = unsecureDAO.createNewDeviceOnDemand(number);\n                } else {\n                    logger.warn(\"Not allowed to create devices in the multi-tenant setup\");\n                }\n            }\n\n            if (dbDevice != null) {\n                return getDeviceSettingInternal(dbDevice, migration, foundByImeiOrSerial, request, response);\n            } else {\n                logger.warn(\"Requested device {} was not found\", number);\n                return Response.DEVICE_NOT_FOUND_ERROR();\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error when getting device settings\", e);\n            e.printStackTrace();\n            return Response.INTERNAL_ERROR();\n        }\n    }"
    },
    {
        "target_file_name": "ConfigureModule.java",
        "target_method": "configure",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "protected void configure() {\n        this.bindConstant().annotatedWith(Names.named(filesDirectoryParameter)).to(this.context.getInitParameter(filesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(baseUrlParameter)).to(this.context.getInitParameter(baseUrlParameter));\n        this.bindConstant().annotatedWith(Names.named(pluginFilesDirectoryParameter)).to(this.context.getInitParameter(pluginFilesDirectoryParameter));\n        this.bindConstant().annotatedWith(Names.named(usageScenarioParameter)).to(this.context.getInitParameter(usageScenarioParameter));\n        String secureEnrollment = this.context.getInitParameter(secureEnrollmentParameter);\n        this.bindConstant().annotatedWith(Names.named(secureEnrollmentParameter)).to(\n                secureEnrollment != null && (secureEnrollment.equals(\"1\") || secureEnrollment.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(hashSecretParameter)).to(this.context.getInitParameter(hashSecretParameter));\n        String hsts = this.context.getInitParameter(hstsParameter);\n        this.bindConstant().annotatedWith(Names.named(hstsParameter)).to(\n                hsts != null && (hsts.equals(\"1\") || hsts.equalsIgnoreCase(\"true\"))\n        );\n        this.bindConstant().annotatedWith(Names.named(aaptCommandParameter)).to(this.context.getInitParameter(aaptCommandParameter));\n        this.bindConstant().annotatedWith(Names.named(roleOrgadminIdParameter)).to(\n                Integer.parseInt(this.context.getInitParameter(roleOrgadminIdParameter))\n        );\n        String launcherPackage = this.context.getInitParameter(launcherPackageParameter);\n        if (launcherPackage == null) {\n            launcherPackage = Application.DEFAULT_LAUNCHER_PACKAGE;\n        }\n        this.bindConstant().annotatedWith(Names.named(launcherPackageParameter)).to(launcherPackage);\n\n        // Optional parameters (Guice doesn't allow to bind string to null)\n        String opt;\n\n        opt = this.context.getInitParameter(baseDirectoryParameter);\n        this.bindConstant().annotatedWith(Names.named(baseDirectoryParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(transmitPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(transmitPasswordParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(authClassParameter);\n        try {\n            Class authImpl = opt != null ? Class.forName(\"com.hmdm.auth.\" + opt + \"Auth\") : LocalAuth.class;\n            this.bind(HmdmAuthInterface.class).annotatedWith(Names.named(authClassParameter))\n                    .to(authImpl);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Rebranding\n        opt = this.context.getInitParameter(rebrandingNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingVendorLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingVendorLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingLogoParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingLogoParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingMobileNameParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingMobileNameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingSignupLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingSignupLinkParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(rebrandingTermsLinkParameter);\n        this.bindConstant().annotatedWith(Names.named(rebrandingTermsLinkParameter)).to(opt != null ? opt : \"\");\n\n        // SMTP\n        opt = this.context.getInitParameter(smtpHostParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpHostParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPortParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPortParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 25);\n        opt = this.context.getInitParameter(smtpSslParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpStartTlsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpStartTlsParameter)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(smtpSslProtocolsParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslProtocolsParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpSslTrustParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpSslTrustParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpUsernameParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpUsernameParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpPasswordParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpPasswordParameter)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(smtpFromParameter);\n        this.bindConstant().annotatedWith(Names.named(smtpFromParameter)).to(opt != null ? opt : \"\");\n\n        // Other\n        opt = this.context.getInitParameter(deviceFastSearchCharsParameter);\n        this.bindConstant().annotatedWith(Names.named(deviceFastSearchCharsParameter)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 5);\n        opt = this.context.getInitParameter(sqlInitScriptPath);\n        this.bindConstant().annotatedWith(Names.named(sqlInitScriptPath)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyAddresses);\n        this.bindConstant().annotatedWith(Names.named(proxyAddresses)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(proxyIpHeader);\n        this.bindConstant().annotatedWith(Names.named(proxyIpHeader)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerAutoStatus);\n        this.bindConstant().annotatedWith(Names.named(customerAutoStatus)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(adminEmail);\n        this.bindConstant().annotatedWith(Names.named(adminEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpUrl);\n        this.bindConstant().annotatedWith(Names.named(mailchimpUrl)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(mailchimpKey);\n        this.bindConstant().annotatedWith(Names.named(mailchimpKey)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignup);\n        this.bindConstant().annotatedWith(Names.named(customerSignup)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupCopySettings);\n        this.bindConstant().annotatedWith(Names.named(customerSignupCopySettings)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(customerSignupConfigurations);\n        this.bindConstant().annotatedWith(Names.named(customerSignupConfigurations)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSupportEmail);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSupportEmail)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceLimit);\n        // I have absolutely no idea why int can't be bound here but it can't!!!\n        // Let's proceed as an Indian and send String to SignupResource instead of int :-/\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupSizeLimit);\n        this.bindConstant().annotatedWith(Names.named(customerSignupSizeLimit)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupExpiryDays);\n        this.bindConstant().annotatedWith(Names.named(customerSignupExpiryDays)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(customerSignupDeviceConfig);\n        this.bindConstant().annotatedWith(Names.named(customerSignupDeviceConfig)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(emailRecoverySubj);\n        this.bindConstant().annotatedWith(Names.named(emailRecoverySubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailRecoveryBody);\n        this.bindConstant().annotatedWith(Names.named(emailRecoveryBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupBody)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteSubj);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteSubj)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(emailSignupCompleteBody);\n        this.bindConstant().annotatedWith(Names.named(emailSignupCompleteBody)).to(opt != null ? opt : \"\");\n\n        opt = this.context.getInitParameter(ldapAdminBind);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminBind)).to(\n                opt != null && (opt.equals(\"1\") || opt.equalsIgnoreCase(\"true\")));\n        opt = this.context.getInitParameter(ldapHost);\n        this.bindConstant().annotatedWith(Names.named(ldapHost)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapPort);\n        this.bindConstant().annotatedWith(Names.named(ldapPort)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 389);\n        opt = this.context.getInitParameter(ldapBaseDn);\n        this.bindConstant().annotatedWith(Names.named(ldapBaseDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminDn);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapAdminPassword);\n        this.bindConstant().annotatedWith(Names.named(ldapAdminPassword)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUsernameAttribute);\n        this.bindConstant().annotatedWith(Names.named(ldapUsernameAttribute)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapUserDn);\n        this.bindConstant().annotatedWith(Names.named(ldapUserDn)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapDefaultRole);\n        this.bindConstant().annotatedWith(Names.named(ldapDefaultRole)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(ldapCustomerId);\n        this.bindConstant().annotatedWith(Names.named(ldapCustomerId)).to(opt != null && !opt.equals(\"\") ? Integer.parseInt(opt): 1);\n        opt = this.context.getInitParameter(deviceAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(deviceAllowedAddress)).to(opt != null ? opt : \"\");\n        opt = this.context.getInitParameter(uiAllowedAddress);\n        this.bindConstant().annotatedWith(Names.named(uiAllowedAddress)).to(opt != null ? opt : \"\");\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "getAllConfigurations",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@ApiOperation(\n            value = \"Get configurations\",\n            notes = \"Gets the list of available configurations\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getAllConfigurations() {\n        // There should be different permissions to view and edit configurations\n        // By now, let's just remove this check to avoid issues with getting config lists\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configurations\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurations();\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "searchConfigurations",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@ApiOperation(\n            value = \"Search configurations\",\n            notes = \"Searches configurations meeting the specified filter value\",\n            response = Configuration.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/search/{value}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response searchConfigurations(@PathParam(\"value\") String value) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configurations\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        List<Configuration> configurations = this.configurationDAO.getAllConfigurationsByValue(value);\n        configurations.forEach(c -> c.setBaseUrl(this.configurationDAO.getBaseUrl()));\n        return Response.OK(configurations);\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "getConfigurationApplications",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@ApiOperation(\n            value = \"Get configuration applications\",\n            notes = \"Gets the list of all applications in context of usage by the requested configuration\",\n            response = Application.class,\n            responseContainer = \"List\"\n    )\n    @GET\n    @Path(\"/applications/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationApplications(@PathParam(\"id\") @ApiParam(\"Configuration ID\") Integer id) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access configuration applications\");\n//            return Response.PERMISSION_DENIED();\n//        }\n        return Response.OK(this.configurationDAO.getConfigurationApplications(id));\n    }"
    },
    {
        "target_file_name": "ConfigurationResource.java",
        "target_method": "getConfigurationById",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@ApiOperation(\n            value = \"Get configuration\",\n            notes = \"Gets the details for configuration referenced by the specified ID\",\n            response = Configuration.class\n    )\n    @GET\n    @Path(\"/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getConfigurationById(@PathParam(\"id\") Integer id) {\n//        if (!SecurityContext.get().hasPermission(\"configurations\")) {\n//            log.error(\"Unauthorized attempt to access the configuration \" + id);\n//            return Response.PERMISSION_DENIED();\n//        }\n\n        Configuration configurationById = getConfiguration(id);\n\n        return Response.OK(configurationById);\n    }"
    },
    {
        "target_file_name": "SyncResource.java",
        "target_method": "getDeviceSetting",
        "project_url": "https://github.com/h-mdm/hmdm-server",
        "commit_id": "19e4a63f732c99064444df7e8c61b4f01df362e8^",
        "CWE_id": "CWE-862",
        "CVE_id": "CVE-2025-43720",
        "project_name": "hmdm-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@ApiOperation(\n            value = \"Get device settings\",\n            notes = \"Gets the device info and settings from the MDM server.\",\n            response = SyncResponse.class\n    )\n    @GET\n    @Path(\"/configuration/{deviceId}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response getDeviceSetting(@PathParam(\"deviceId\")\n                                     @ApiParam(\"An identifier of device within MDM server\")\n                                     String number,\n                                     @Context HttpServletRequest request,\n                                     @Context HttpServletResponse response) {\n        logger.debug(\"/public/sync/configuration/{}\", number);\n\n        if (secureEnrollment) {\n            if (!CryptoUtil.checkRequestSignature(request.getHeader(HEADER_ENROLLMENT_SIGNATURE), hashSecret + number)) {\n                logger.warn(\"Failed to setup device {}: signature mismatch\", number);\n                return Response.PERMISSION_DENIED();\n            }\n        }\n\n        try {\n            Device dbDevice = this.unsecureDAO.getDeviceByNumber(number);\n            boolean migration = false;\n            boolean foundByImeiOrSerial = false;\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByOldNumber(number);\n                migration = dbDevice != null;\n            }\n\n            if (dbDevice == null) {\n                dbDevice = this.unsecureDAO.getDeviceByImeiOrSerial(number);\n                foundByImeiOrSerial = dbDevice != null;\n            }\n\n            // Device creation on demand\n            if (dbDevice == null) {\n                if (unsecureDAO.isSingleCustomer()) {\n                    dbDevice = unsecureDAO.createNewDeviceOnDemand(number);\n                } else {\n                    logger.warn(\"Not allowed to create devices in the multi-tenant setup\");\n                }\n            }\n\n            if (dbDevice != null) {\n                return getDeviceSettingInternal(dbDevice, migration, foundByImeiOrSerial, request, response);\n            } else {\n                logger.warn(\"Requested device {} was not found\", number);\n                return Response.DEVICE_NOT_FOUND_ERROR();\n            }\n        } catch (Exception e) {\n            logger.error(\"Unexpected error when getting device settings\", e);\n            e.printStackTrace();\n            return Response.INTERNAL_ERROR();\n        }\n    }"
    },
    {
        "target_file_name": "HqlQueryUtils.java",
        "target_method": "isShortFormStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "startsWithAny",
            "toLowerCase",
            "trim"
        ],
        "target_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), COMMA, WHERE, ORDER_BY);\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "createSQLQuery",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createLegacySQLQuery"
        ],
        "target_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        return HqlQueryUtils.createLegacySQLQuery(queryPrefix, whereSQL);\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "getColumnsForSelectStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getColumnsForSelectStatement"
        ],
        "target_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        return HqlQueryUtils.getColumnsForSelectStatement(whereSQL);\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "getMetaclass",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "getMetaclass",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocuments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed"
        ],
        "target_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedWhereClause);\n\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocumentsNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed"
        ],
        "target_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            checkSearchQueryAllowed(parameterizedWhereClause);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchSpacesNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed",
            "getStore",
            "search"
        ],
        "target_code": "public List<String> searchSpacesNames(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parameterizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed",
            "convertAttachments",
            "searchAttachments"
        ],
        "target_code": "public List<Attachment> searchAttachments(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return convertAttachments(\n            this.xwiki.searchAttachments(parameterizedSqlClause, true, nb, start, parameterValues, this.context));\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "countAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed",
            "countAttachments"
        ],
        "target_code": "public int countAttachments(String parameterizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.countAttachments(parameterizedSqlClause, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "HqlQueryUtils.java",
        "target_method": "isShortFormStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "startsWithAny",
            "toLowerCase",
            "trim"
        ],
        "target_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), \",\", \"where \", \"order by\");\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "createSQLQuery",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "append",
            "equals",
            "getColumnsForSelectStatement",
            "isBlank",
            "startsWith",
            "toString",
            "trim"
        ],
        "target_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "getColumnsForSelectStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "append",
            "hasMoreTokens",
            "indexOf",
            "length",
            "nextToken",
            "removeEndIgnoreCase",
            "substring",
            "toLowerCase",
            "toString",
            "trim"
        ],
        "target_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocuments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocumentsNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchSpacesNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getStore",
            "search"
        ],
        "target_code": "public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "convertAttachments",
            "searchAttachments"
        ],
        "target_code": "public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "countAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7313dc9b533c70f14b7672379c8b3b63d1fd8f51^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "countAttachments"
        ],
        "target_code": "public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "HqlQueryUtils.java",
        "target_method": "isShortFormStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "startsWithAny",
            "toLowerCase",
            "trim"
        ],
        "target_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), COMMA, WHERE, ORDER_BY);\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "createSQLQuery",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createLegacySQLQuery"
        ],
        "target_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        return HqlQueryUtils.createLegacySQLQuery(queryPrefix, whereSQL);\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "getColumnsForSelectStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getColumnsForSelectStatement"
        ],
        "target_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        return HqlQueryUtils.getColumnsForSelectStatement(whereSQL);\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "getMetaclass",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "getMetaclass",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocuments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed"
        ],
        "target_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedWhereClause);\n\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocumentsNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed"
        ],
        "target_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            checkSearchQueryAllowed(parameterizedWhereClause);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchSpacesNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed",
            "getStore",
            "search"
        ],
        "target_code": "public List<String> searchSpacesNames(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parameterizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed",
            "convertAttachments",
            "searchAttachments"
        ],
        "target_code": "public List<Attachment> searchAttachments(String parameterizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return convertAttachments(\n            this.xwiki.searchAttachments(parameterizedSqlClause, true, nb, start, parameterValues, this.context));\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "countAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "checkSearchQueryAllowed",
            "countAttachments"
        ],
        "target_code": "public int countAttachments(String parameterizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        checkSearchQueryAllowed(parameterizedSqlClause);\n\n        return this.xwiki.countAttachments(parameterizedSqlClause, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "HqlQueryUtils.java",
        "target_method": "isShortFormStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "startsWithAny",
            "toLowerCase",
            "trim"
        ],
        "target_code": "public static boolean isShortFormStatement(String statement)\n    {\n        return StringUtils.startsWithAny(statement.trim().toLowerCase(), \",\", \"where \", \"order by\");\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "createSQLQuery",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "append",
            "equals",
            "getColumnsForSelectStatement",
            "isBlank",
            "startsWith",
            "toString",
            "trim"
        ],
        "target_code": "protected String createSQLQuery(String queryPrefix, String whereSQL)\n    {\n        StringBuilder sql = new StringBuilder(queryPrefix);\n\n        String normalizedWhereSQL;\n        if (StringUtils.isBlank(whereSQL)) {\n            normalizedWhereSQL = \"\";\n        } else {\n            normalizedWhereSQL = whereSQL.trim();\n        }\n\n        sql.append(getColumnsForSelectStatement(normalizedWhereSQL));\n        sql.append(\" from XWikiDocument as doc\");\n\n        if (!normalizedWhereSQL.equals(\"\")) {\n            if ((!normalizedWhereSQL.startsWith(\"where\")) && (!normalizedWhereSQL.startsWith(\",\"))) {\n                sql.append(\" where \");\n            } else {\n                sql.append(\" \");\n            }\n            sql.append(normalizedWhereSQL);\n        }\n\n        return sql.toString();\n    }"
    },
    {
        "target_file_name": "XWikiHibernateStore.java",
        "target_method": "getColumnsForSelectStatement",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "append",
            "hasMoreTokens",
            "indexOf",
            "length",
            "nextToken",
            "removeEndIgnoreCase",
            "substring",
            "toLowerCase",
            "toString",
            "trim"
        ],
        "target_code": "protected String getColumnsForSelectStatement(String whereSQL)\n    {\n        StringBuilder columns = new StringBuilder();\n\n        int orderByPos = whereSQL.toLowerCase().indexOf(\"order by\");\n        if (orderByPos >= 0) {\n            String orderByStatement = whereSQL.substring(orderByPos + \"order by\".length() + 1);\n            StringTokenizer tokenizer = new StringTokenizer(orderByStatement, \",\");\n            while (tokenizer.hasMoreTokens()) {\n                String column = tokenizer.nextToken().trim();\n                // Remove \"desc\" or \"asc\" from the column found\n                column = StringUtils.removeEndIgnoreCase(column, \" desc\");\n                column = StringUtils.removeEndIgnoreCase(column, \" asc\");\n                columns.append(\", \").append(column.trim());\n            }\n        }\n\n        return columns.toString();\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocuments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchDocumentsNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchSpacesNames",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getStore",
            "search"
        ],
        "target_code": "public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "searchAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "convertAttachments",
            "searchAttachments"
        ],
        "target_code": "public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }"
    },
    {
        "target_file_name": "XWiki.java",
        "target_method": "countAttachments",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "7c4087d44ac550610b2fa413dd4f5375409265a5^",
        "CWE_id": "CWE-20",
        "CVE_id": "CVE-2025-54385",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "countAttachments"
        ],
        "target_code": "public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }"
    },
    {
        "target_file_name": "SysModelController.java",
        "target_method": "export",
        "project_url": "https://github.com/gwozai/ruoyi-ai",
        "commit_id": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3199",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SaCheckPermission(\"system:model:export\")\n    @Log(title = \"系统模型\", businessType = BusinessType.EXPORT)\n    @PostMapping(\"/export\")\n    public void export(SysModelBo bo, HttpServletResponse response) {\n        List<SysModelVo> list = sysModelService.queryList(bo);\n        ExcelUtil.exportExcel(list, \"系统模型\", SysModelVo.class, response);\n    }"
    },
    {
        "target_file_name": "SysModelController.java",
        "target_method": "add",
        "project_url": "https://github.com/gwozai/ruoyi-ai",
        "commit_id": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3199",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SaCheckPermission(\"system:model:add\")\n    @Log(title = \"系统模型\", businessType = BusinessType.INSERT)\n    @PostMapping()\n    public R<Void> add(@Validated(AddGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.insertByBo(bo));\n    }"
    },
    {
        "target_file_name": "SysModelController.java",
        "target_method": "edit",
        "project_url": "https://github.com/gwozai/ruoyi-ai",
        "commit_id": "c0daf641fb25b244591b7a6c3affa35c69d321fe",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3199",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SaCheckPermission(\"system:model:edit\")\n    @Log(title = \"系统模型\", businessType = BusinessType.UPDATE)\n    @RepeatSubmit()\n    @PutMapping()\n    public R<Void> edit(@Validated(EditGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.updateByBo(bo));\n    }"
    },
    {
        "target_file_name": "SysModelController.java",
        "target_method": "export",
        "project_url": "https://github.com/gwozai/ruoyi-ai",
        "commit_id": "c0daf641fb25b244591b7a6c3affa35c69d321fe^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3199",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Log(title = \"系统模型\", businessType = BusinessType.EXPORT)\n    @PostMapping(\"/export\")\n    public void export(SysModelBo bo, HttpServletResponse response) {\n        List<SysModelVo> list = sysModelService.queryList(bo);\n        ExcelUtil.exportExcel(list, \"系统模型\", SysModelVo.class, response);\n    }"
    },
    {
        "target_file_name": "SysModelController.java",
        "target_method": "add",
        "project_url": "https://github.com/gwozai/ruoyi-ai",
        "commit_id": "c0daf641fb25b244591b7a6c3affa35c69d321fe^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3199",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Log(title = \"系统模型\", businessType = BusinessType.INSERT)\n    @PostMapping()\n    public R<Void> add(@Validated(AddGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.insertByBo(bo));\n    }"
    },
    {
        "target_file_name": "SysModelController.java",
        "target_method": "edit",
        "project_url": "https://github.com/gwozai/ruoyi-ai",
        "commit_id": "c0daf641fb25b244591b7a6c3affa35c69d321fe^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3199",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Log(title = \"系统模型\", businessType = BusinessType.UPDATE)\n    @RepeatSubmit()\n    @PutMapping()\n    public R<Void> edit(@Validated(EditGroup.class) @RequestBody SysModelBo bo) {\n        return toAjax(sysModelService.updateByBo(bo));\n    }"
    },
    {
        "target_file_name": "SysNoticeController.java",
        "target_method": "list",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "6382e177bf90cc56ff70521842409e35c50df32d",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3202",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SaCheckPermission(\"system:notice:list\")\n    @GetMapping(\"/list\")\n    public TableDataInfo<SysNoticeVo> list(SysNoticeBo notice, PageQuery pageQuery) {\n        //公告类型（1通知 2公告）\n        notice.setNoticeType(\"2\");\n        return noticeService.selectPageNoticeList(notice, pageQuery);\n    }"
    },
    {
        "target_file_name": "SysNoticeController.java",
        "target_method": "edit",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "6382e177bf90cc56ff70521842409e35c50df32d",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3202",
        "project_name": "ruoyi-ai",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SaCheckPermission(\"system:notice:edit\")\n    @Log(title = \"通知公告\", businessType = BusinessType.UPDATE)\n    @PutMapping\n    public R<Void> edit(@Validated @RequestBody SysNoticeBo notice) {\n        return toAjax(noticeService.updateNotice(notice));\n    }"
    },
    {
        "target_file_name": "SysNoticeController.java",
        "target_method": "list",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "6382e177bf90cc56ff70521842409e35c50df32d^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3202",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@GetMapping(\"/list\")\n    public TableDataInfo<SysNoticeVo> list(SysNoticeBo notice, PageQuery pageQuery) {\n        //公告类型（1通知 2公告）\n        notice.setNoticeType(\"2\");\n        return noticeService.selectPageNoticeList(notice, pageQuery);\n    }"
    },
    {
        "target_file_name": "SysNoticeController.java",
        "target_method": "edit",
        "project_url": "https://github.com/ageerle/ruoyi-ai",
        "commit_id": "6382e177bf90cc56ff70521842409e35c50df32d^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-3202",
        "project_name": "ruoyi-ai",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Log(title = \"通知公告\", businessType = BusinessType.UPDATE)\n    @PutMapping\n    public R<Void> edit(@Validated @RequestBody SysNoticeBo notice) {\n        return toAjax(noticeService.updateNotice(notice));\n    }"
    },
    {
        "target_file_name": "SamlValidator.java",
        "target_method": "validateCreateProvider",
        "project_url": "https://github.com/telstra/open-kilda",
        "commit_id": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-54992",
        "project_name": "open-kilda",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "equals"
        ],
        "target_code": "public void validateCreateProvider(MultipartFile file, String name, String entityId, String url,\n            boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = samlRepository.findByEntityIdOrNameEqualsIgnoreCase(entityId, name);\n        if (samlConfigEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file == null && url == null) {\n            throw new RequestValidationException(messageUtil.getAttributeNotNull(\"Metadata file or url\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        String metadataEntityId = validateEntityId(file, url);\n        if (!metadataEntityId.equals(entityId)) {\n            throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n    }"
    },
    {
        "target_file_name": "SamlValidator.java",
        "target_method": "validateCreateProvider",
        "project_url": "https://github.com/telstra/open-kilda",
        "commit_id": "1eddb4983a6287d083e3e99a56dc4c291abd347e^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-54992",
        "project_name": "open-kilda",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "equals"
        ],
        "target_code": "public void validateCreateProvider(MultipartFile file, String name, String entityId, String url, \n            boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = samlRepository.findByEntityIdOrNameEqualsIgnoreCase(entityId, name);\n        if (samlConfigEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file == null && url == null) {\n            throw new RequestValidationException(messageUtil.getAttributeNotNull(\"Metadata file or url\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        String metadataEntityId = validateEntityId(file, url);\n        if (!metadataEntityId.equals(entityId)) { \n            throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n    }"
    },
    {
        "target_file_name": "SamlValidator.java",
        "target_method": "validateUpdateProvider",
        "project_url": "https://github.com/telstra/open-kilda",
        "commit_id": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-54992",
        "project_name": "open-kilda",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public SamlConfigEntity validateUpdateProvider(String uuid, MultipartFile file, String name,\n            String entityId, String url, boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = getEntityByUuid(uuid);\n        SamlConfigEntity configEntity = samlRepository.findByUuidNotAndEntityIdOrUuidNotAndNameEqualsIgnoreCase(\n                uuid, entityId, uuid, name);\n        if (configEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        if (file == null && url == null) {\n            if (!samlConfigEntity.getEntityId().equals(entityId)) {\n                throw new RequestValidationException(messageUtil.getAttributeInvalid(\"Entity Id\", entityId));\n            }\n        } else {\n            String metadataEntityId = validateEntityId(file, url);\n            if (!metadataEntityId.equals(entityId)) {\n                throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n            }\n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n        return samlConfigEntity;\n    }"
    },
    {
        "target_file_name": "SamlValidator.java",
        "target_method": "validateUpdateProvider",
        "project_url": "https://github.com/telstra/open-kilda",
        "commit_id": "1eddb4983a6287d083e3e99a56dc4c291abd347e^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-54992",
        "project_name": "open-kilda",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public SamlConfigEntity validateUpdateProvider(String uuid, MultipartFile file, String name, \n            String entityId, String url, boolean userCreation, List<Long> roleIds) {\n        SamlConfigEntity samlConfigEntity = getEntityByUuid(uuid);\n        SamlConfigEntity configEntity = samlRepository.findByUuidNotAndEntityIdOrUuidNotAndNameEqualsIgnoreCase(\n                uuid, entityId, uuid, name);\n        if (configEntity != null) {\n            throw new RequestValidationException(messageUtil.getAttributeUnique(\"Provider name or Entity Id\"));\n        }\n        if (file != null) {\n            if (!FilenameUtils.getExtension(file.getOriginalFilename()).equals(\"xml\")) {\n                throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"file\"));\n            }\n        }\n        if (file == null && url == null) {\n            if (!samlConfigEntity.getEntityId().equals(entityId)) {\n                throw new RequestValidationException(messageUtil.getAttributeInvalid(\"Entity Id\", entityId));\n            }\n        } else {\n            String metadataEntityId = validateEntityId(file, url);\n            if (!metadataEntityId.equals(entityId)) {\n                throw new RequestValidationException(\"Entity Id must be same as Metadata Entity Id\");\n            } \n        }\n        if (userCreation) {\n            if (roleIds.isEmpty() || roleIds == null) {\n                throw new RequestValidationException(messageUtil.getAttributeNotNull(\"role\"));\n            }\n        }\n        return samlConfigEntity;\n    }"
    },
    {
        "target_file_name": "SamlValidator.java",
        "target_method": "validateEntityId",
        "project_url": "https://github.com/telstra/open-kilda",
        "commit_id": "1eddb4983a6287d083e3e99a56dc4c291abd347e",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-54992",
        "project_name": "open-kilda",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setFeature"
        ],
        "target_code": "private String validateEntityId(MultipartFile file, String url) {\n        String entityId = null;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            dbFactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            dbFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();\n            Document doc = null;\n            if (file != null) {\n                doc = docBuilder.parse(file.getInputStream());\n            } else if (url != null) {\n                doc = docBuilder.parse(new URL(url).openStream());\n            }\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(doc.getDocumentElement().getNodeName());\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node node = nodeList.item(temp);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    entityId = element.getAttribute(\"entityID\");\n                }\n            }\n            return entityId;\n        } catch (Exception e) {\n            LOGGER.error(\"Error occurred while validating entity ID\" + e);\n            throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"url\"));\n        }\n    }"
    },
    {
        "target_file_name": "SamlValidator.java",
        "target_method": "validateEntityId",
        "project_url": "https://github.com/telstra/open-kilda",
        "commit_id": "1eddb4983a6287d083e3e99a56dc4c291abd347e^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-54992",
        "project_name": "open-kilda",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private String validateEntityId(MultipartFile file, String url) {\n        String entityId = null;\n        try {\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = dbFactory.newDocumentBuilder();\n            Document doc = null; \n            if (file != null) {\n                doc = docBuilder.parse(file.getInputStream());\n            } else if (url != null) {\n                doc = docBuilder.parse(new URL(url).openStream());\n            }\n            doc.getDocumentElement().normalize();\n            NodeList nodeList = doc.getElementsByTagName(doc.getDocumentElement().getNodeName());\n            for (int temp = 0; temp < nodeList.getLength(); temp++) {\n                Node node = nodeList.item(temp);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    Element element = (Element) node;\n                    entityId = element.getAttribute(\"entityID\");\n                }\n            }\n            return entityId;\n        } catch (Exception e) {\n            LOGGER.error(\"Error occurred while validating entity ID\" + e);\n            throw new RequestValidationException(messageUtil.getAttributeMetadataInvalid(\"url\"));\n        }\n    }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "get",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "context",
            "flatMap",
            "get",
            "getSessionOrEmpty",
            "map",
            "require",
            "strToObject"
        ],
        "target_code": "@Override\n  public Optional<Object> get(WebContext context, String key) {\n    return getSessionOrEmpty(context)\n        .map(session -> session.get(key))\n        .flatMap(value -> strToObject(context(context).require(Serializer.class), value));\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "set",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "context",
            "isEmpty",
            "objToStr",
            "require",
            "toString"
        ],
        "target_code": "@Override\n  public void set(WebContext context, String key, Object value) {\n    if (value == null || value.toString().isEmpty()) {\n      getSessionOrEmpty(context).ifPresent(session -> session.remove(key));\n    } else {\n      String encoded = objToStr(context(context).require(Serializer.class), value);\n      getSession(context).put(key, encoded);\n    }\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "renewSession",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getSessionOrEmpty",
            "ifPresent",
            "isPresent"
        ],
        "target_code": "@Override\n  public boolean renewSession(WebContext context) {\n    var session = getSessionOrEmpty(context);\n    session.ifPresent(Session::renewId);\n    return session.isPresent();\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "strToObject",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "deserializeFromString",
            "length",
            "of",
            "substring"
        ],
        "target_code": "static Optional<Object> strToObject(Serializer serializer, Value node) {\n    if (node.isMissing()) {\n      return Optional.empty();\n    }\n    String value = node.value();\n    if (value.startsWith(BIN)) {\n      return Optional.of(serializer.deserializeFromString(value.substring(BIN.length())));\n    } else if (value.startsWith(PAC4J)) {\n      return Optional.of(strToAction(value.substring(PAC4J.length())));\n    }\n    return Optional.of(value);\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "objToStr",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "serializeToString"
        ],
        "target_code": "static String objToStr(Serializer serializer, Object value) {\n    if (value instanceof CharSequence || value instanceof Number || value instanceof Boolean) {\n      return value.toString();\n    } else if (value instanceof HttpAction) {\n      return actionToStr((HttpAction) value);\n    } else {\n      return BIN + serializer.serializeToString(value);\n    }\n  }"
    },
    {
        "target_file_name": "Pac4jOptions.java",
        "target_method": "setLogoutUrlPattern",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public @NonNull Pac4jOptions setLogoutUrlPattern(String logoutUrlPattern) {\n    this.logoutUrlPattern = logoutUrlPattern;\n    return this;\n  }"
    },
    {
        "target_file_name": "Pac4jModule.java",
        "target_method": "install",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getSerializer",
            "getServices",
            "putIfAbsent",
            "use"
        ],
        "target_code": "@Override\n  public void install(@NonNull Jooby app) throws Exception {\n    var services = app.getServices();\n    services.putIfAbsent(Pac4jOptions.class, options);\n    // Set defaults:\n    services.putIfAbsent(Serializer.class, options.getSerializer());\n\n    var clients =\n        ofNullable(options.getClients())\n            /* No client? set a default one: */\n            .orElseGet(Clients::new);\n\n    /* No client instance added from DSL, init them from pac4j config. */\n    if (clientMap == null) {\n      clientMap = initializeClients(options);\n    }\n\n    var contextPath = app.getContextPath().equals(\"/\") ? \"\" : app.getContextPath();\n\n    Map<String, List<ClientReference>> allClients = new LinkedHashMap<>();\n\n    /* Should add simple login form? */\n    var devLogin = false;\n    if (clientMap.isEmpty()) {\n      devLogin = true;\n      client(\n          conf ->\n              new FormClient(\n                  contextPath + \"/login\", new SimpleTestUsernamePasswordAuthenticator()));\n    }\n    var conf = app.getConfig();\n    /* Initialize clients from DSL: */\n    for (var routing : clientMap.entrySet()) {\n      var localClients = allClients.computeIfAbsent(routing.getKey(), k -> new ArrayList<>());\n      var path = routing.getValue();\n      for (var candidate : path.clients) {\n        if (candidate instanceof Class) {\n          localClients.add(new ClientReference((Class<Client>) candidate));\n        } else if (candidate instanceof Client) {\n          localClients.add(new ClientReference((Client) candidate));\n        } else {\n          Function<com.typesafe.config.Config, Client> clientProvider =\n              (Function<com.typesafe.config.Config, Client>) candidate;\n          localClients.add(new ClientReference(clientProvider.apply(conf)));\n        }\n      }\n      allClients.put(routing.getKey(), localClients);\n\n      // check for forwarding authorizers\n      for (var authorizerName : path.authorizers) {\n        Authorizer authorizer = options.getAuthorizers().get(authorizerName);\n        if (authorizer instanceof ForwardingAuthorizer) {\n          ((ForwardingAuthorizer) authorizer).setRegistry(app);\n        }\n      }\n    }\n\n    options.getAuthorizers().put(NoopAuthorizer.NAME, new NoopAuthorizer());\n\n    /* Default callback URL if none was set at client level: */\n    clients.setCallbackUrl(\n        ofNullable(clients.getCallbackUrl()).orElse(contextPath + options.getCallbackPath()));\n    /* Default URL resolver if none was set at client level: */\n    clients.setUrlResolver(\n        ofNullable(clients.getUrlResolver()).orElseGet(Pac4jModule::newUrlResolver));\n\n    /* Set resolved clients: */\n    clients.setClients(\n        allClients.values().stream()\n            .flatMap(List::stream)\n            .filter(ClientReference::isResolved)\n            .map(ClientReference::getClient)\n            .collect(Collectors.toList()));\n    options.setClients(clients);\n\n    /* Delay setting unresolved clients: */\n    var unresolved =\n        allClients.values().stream().flatMap(List::stream).filter(r -> !r.isResolved()).toList();\n\n    if (!unresolved.isEmpty()) {\n      app.onStarting(\n          () -> {\n            List<Client> clientList = new ArrayList<>(clients.getClients());\n            unresolved.stream()\n                .peek(r -> r.resolve(app::require))\n                .map(ClientReference::getClient)\n                .forEachOrdered(clientList::add);\n            clients.setClients(clientList);\n\n            /** If the global client was unresolved at initialization, try to set it now: */\n            List<ClientReference> defaultSecurityFilter = allClients.get(\"*\");\n            if (defaultSecurityFilter != null && options.getDefaultClient() == null) {\n              options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n            }\n          });\n    }\n\n    /* Set default http action adapter: */\n    options.setHttpActionAdapter(\n        ofNullable(options.getHttpActionAdapter()).orElseGet(Pac4jModule::newActionAdapter));\n\n    /* WebContextFactory: */\n    options.setWebContextFactory(\n        ofNullable(options.getWebContextFactory()).orElseGet(ContextFactoryImpl::new));\n    options.setSessionStoreFactory(\n        ofNullable(options.getSessionStoreFactory()).orElseGet(SessionStoreFactoryImpl::new));\n    options.setProfileManagerFactory(\n        ofNullable(options.getProfileManagerFactory()).orElse(ProfileManagerFactory.DEFAULT));\n\n    if (devLogin) {\n      app.get(\"/login\", new DevLoginForm(options, contextPath + options.getCallbackPath()));\n    }\n\n    /*\n     * If we have multiple clients on specific paths, we collect those path and configure pac4j to\n     * ignore them. So after login they are redirected to the requested url and not to one of this\n     * sign-in endpoints.\n     *\n     * <pre>\n     *   install(new Pac4jModule()\n     *     .client(\"/google\", ...)\n     *     .client(\"/twitter\", ....);\n     *   );\n     * </pre>\n     *\n     * So <code>google</code> and <code>twitter</code> paths are never saved as requested urls.\n     */\n    var excludes =\n        allClients.keySet().stream()\n            .filter(it -> !it.equals(\"*\"))\n            .map(it -> contextPath + it)\n            .collect(Collectors.toSet());\n\n    var callbackLogic = options.getCallbackLogic();\n    if (callbackLogic == null) {\n      options.setCallbackLogic(newCallbackLogic(excludes));\n    }\n    var direct = clients.getClients().stream().allMatch(it -> it instanceof DirectClient);\n    if (!direct || options.isForceCallbackRoutes()) {\n      CallbackFilterImpl callbackFilter = new CallbackFilterImpl(options, options);\n      app.get(options.getCallbackPath(), callbackFilter);\n      app.post(options.getCallbackPath(), callbackFilter);\n    }\n\n    var securityLogic = options.getSecurityLogic();\n    if (securityLogic == null) {\n      options.setSecurityLogic(newSecurityLogic(excludes));\n    }\n    app.use(new UntrustedSessionDataDetector());\n\n    /** For each client to a specific path, add a security handler. */\n    for (var entry : allClients.entrySet()) {\n      String pattern = entry.getKey();\n      if (!pattern.equals(\"*\")) {\n        List<String> keys = Router.pathKeys(pattern);\n        if (keys.isEmpty()) {\n          SecurityFilterImpl securityFilter =\n              new SecurityFilterImpl(\n                  null,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers);\n          app.get(pattern, securityFilter);\n          // POST for direct authentication\n          app.post(pattern, securityFilter);\n        } else {\n          app.use(\n              new SecurityFilterImpl(\n                  pattern,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers));\n        }\n      }\n    }\n\n    /* Is there is a global client, use it as decorator/filter (default client): */\n    var defaultSecurityFilter = allClients.get(\"*\");\n    if (defaultSecurityFilter != null) {\n      if (options.getDefaultClient() == null && defaultSecurityFilter.get(0).isResolved()) {\n        options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n      }\n      app.use(\n          new SecurityFilterImpl(\n              null,\n              options,\n              options,\n              lazyClientNameList(defaultSecurityFilter),\n              clientMap.get(\"*\").authorizers));\n    }\n\n    /* Logout configuration: */\n    var logoutLogic = options.getLogoutLogic();\n    if (logoutLogic == null) {\n      options.setLogoutLogic(newLogoutLogic());\n    }\n    if (!direct || options.isForceLogoutRoutes()) {\n      app.get(options.getLogoutPath(), new LogoutImpl(options, options));\n    }\n\n    /* Better response code for some errors. */\n    app.errorCode(UnauthorizedAction.class, StatusCode.UNAUTHORIZED);\n    app.errorCode(ForbiddenAction.class, StatusCode.FORBIDDEN);\n\n    /* Compute default url as next available route. We only select static path patterns. */\n    if (options.getDefaultUrl() == null) {\n      int index = app.getRoutes().size();\n      app.onStarting(\n          () -> {\n            List<Route> routes = app.getRoutes();\n            String defaultUrl = app.getContextPath();\n            if (index < routes.size()) {\n              Route route = routes.get(index);\n              if (route.getPathKeys().isEmpty()) {\n                defaultUrl = contextPath + route.getPattern();\n              }\n            }\n            options.setDefaultUrl(defaultUrl);\n          });\n    }\n\n    app.getServices().put(Config.class, options);\n\n    /* Set current user provider */\n    app.setCurrentUser(new Pac4jCurrentUser(options));\n    // cleanup\n    clientMap.clear();\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "get",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "getSessionOrEmpty",
            "map",
            "orElseGet"
        ],
        "target_code": "@Override\n  public Optional<Object> get(WebContext context, String key) {\n    Optional sessionValue =\n        getSessionOrEmpty(context)\n            .map(session -> session.get(key))\n            .map(SessionStoreImpl::strToObject)\n            .orElseGet(Optional::empty);\n    return sessionValue;\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "set",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "length",
            "objToStr",
            "toString"
        ],
        "target_code": "@Override\n  public void set(WebContext context, String key, Object value) {\n    if (value == null || value.toString().length() == 0) {\n      getSessionOrEmpty(context).ifPresent(session -> session.remove(key));\n    } else {\n      String encoded = objToStr(value);\n      getSession(context).put(key, encoded);\n    }\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "renewSession",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getSessionOrEmpty",
            "ifPresent",
            "renewId"
        ],
        "target_code": "@Override\n  public boolean renewSession(WebContext context) {\n    getSessionOrEmpty(context).ifPresent(session -> session.renewId());\n    return true;\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "strToObject",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "decode",
            "getDecoder",
            "length",
            "of",
            "propagate",
            "readObject",
            "substring"
        ],
        "target_code": "static Optional<Object> strToObject(final Value node) {\n    if (node.isMissing()) {\n      return Optional.empty();\n    }\n    String value = node.value();\n    if (value.startsWith(BIN)) {\n      try {\n        byte[] bytes = Base64.getDecoder().decode(value.substring(BIN.length()));\n        return Optional.of(new ObjectInputStream(new ByteArrayInputStream(bytes)).readObject());\n      } catch (Exception x) {\n        throw SneakyThrows.propagate(x);\n      }\n    } else if (value.startsWith(PAC4J)) {\n      return Optional.of(strToAction(value.substring(PAC4J.length())));\n    }\n    return Optional.of(value);\n  }"
    },
    {
        "target_file_name": "SessionStoreImpl.java",
        "target_method": "objToStr",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "encodeToString",
            "flush",
            "getEncoder",
            "propagate",
            "toByteArray",
            "writeObject"
        ],
        "target_code": "static String objToStr(final Object value) {\n    if (value instanceof CharSequence || value instanceof Number || value instanceof Boolean) {\n      return value.toString();\n    } else if (value instanceof HttpAction) {\n      return actionToStr((HttpAction) value);\n    }\n    try {\n      ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n      ObjectOutputStream stream = new ObjectOutputStream(bytes);\n      stream.writeObject(value);\n      stream.flush();\n      return BIN + Base64.getEncoder().encodeToString(bytes.toByteArray());\n    } catch (IOException x) {\n      throw SneakyThrows.propagate(x);\n    }\n  }"
    },
    {
        "target_file_name": "Pac4jOptions.java",
        "target_method": "setLogoutUrlPattern",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public void setLogoutUrlPattern(String logoutUrlPattern) {\n    this.logoutUrlPattern = logoutUrlPattern;\n  }"
    },
    {
        "target_file_name": "Pac4jModule.java",
        "target_method": "install",
        "project_url": "https://github.com/jooby-project/jooby",
        "commit_id": "3e13562cf36d7407813eae464e0f4b598de15692^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-31129",
        "project_name": "jooby",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getServices",
            "putIfAbsent"
        ],
        "target_code": "@Override\n  public void install(@NonNull Jooby app) throws Exception {\n    app.getServices().putIfAbsent(Pac4jOptions.class, options);\n\n    var clients =\n        ofNullable(options.getClients())\n            /* No client? set a default one: */\n            .orElseGet(Clients::new);\n\n    /* No client instance added from DSL, init them from pac4j config. */\n    if (clientMap == null) {\n      clientMap = initializeClients(options);\n    }\n\n    var contextPath = app.getContextPath().equals(\"/\") ? \"\" : app.getContextPath();\n\n    Map<String, List<ClientReference>> allClients = new LinkedHashMap<>();\n\n    /* Should add simple login form? */\n    var devLogin = false;\n    if (clientMap.isEmpty()) {\n      devLogin = true;\n      client(\n          conf ->\n              new FormClient(\n                  contextPath + \"/login\", new SimpleTestUsernamePasswordAuthenticator()));\n    }\n    var conf = app.getConfig();\n    /* Initialize clients from DSL: */\n    for (var routing : clientMap.entrySet()) {\n      var localClients = allClients.computeIfAbsent(routing.getKey(), k -> new ArrayList<>());\n      var path = routing.getValue();\n      for (var candidate : path.clients) {\n        if (candidate instanceof Class) {\n          localClients.add(new ClientReference((Class<Client>) candidate));\n        } else if (candidate instanceof Client) {\n          localClients.add(new ClientReference((Client) candidate));\n        } else {\n          Function<com.typesafe.config.Config, Client> clientProvider =\n              (Function<com.typesafe.config.Config, Client>) candidate;\n          localClients.add(new ClientReference(clientProvider.apply(conf)));\n        }\n      }\n      allClients.put(routing.getKey(), localClients);\n\n      // check for forwarding authorizers\n      for (var authorizerName : path.authorizers) {\n        Authorizer authorizer = options.getAuthorizers().get(authorizerName);\n        if (authorizer instanceof ForwardingAuthorizer) {\n          ((ForwardingAuthorizer) authorizer).setRegistry(app);\n        }\n      }\n    }\n\n    options.getAuthorizers().put(NoopAuthorizer.NAME, new NoopAuthorizer());\n\n    /* Default callback URL if none was set at client level: */\n    clients.setCallbackUrl(\n        ofNullable(clients.getCallbackUrl()).orElse(contextPath + options.getCallbackPath()));\n    /* Default URL resolver if none was set at client level: */\n    clients.setUrlResolver(\n        ofNullable(clients.getUrlResolver()).orElseGet(Pac4jModule::newUrlResolver));\n\n    /* Set resolved clients: */\n    clients.setClients(\n        allClients.values().stream()\n            .flatMap(List::stream)\n            .filter(ClientReference::isResolved)\n            .map(ClientReference::getClient)\n            .collect(Collectors.toList()));\n    options.setClients(clients);\n\n    /* Delay setting unresolved clients: */\n    var unresolved =\n        allClients.values().stream().flatMap(List::stream).filter(r -> !r.isResolved()).toList();\n\n    if (!unresolved.isEmpty()) {\n      app.onStarting(\n          () -> {\n            List<Client> clientList = new ArrayList<>(clients.getClients());\n            unresolved.stream()\n                .peek(r -> r.resolve(app::require))\n                .map(ClientReference::getClient)\n                .forEachOrdered(clientList::add);\n            clients.setClients(clientList);\n\n            /** If the global client was unresolved at initialization, try to set it now: */\n            List<ClientReference> defaultSecurityFilter = allClients.get(\"*\");\n            if (defaultSecurityFilter != null && options.getDefaultClient() == null) {\n              options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n            }\n          });\n    }\n\n    /* Set default http action adapter: */\n    options.setHttpActionAdapter(\n        ofNullable(options.getHttpActionAdapter()).orElseGet(Pac4jModule::newActionAdapter));\n\n    /* WebContextFactory: */\n    options.setWebContextFactory(\n        ofNullable(options.getWebContextFactory()).orElseGet(ContextFactoryImpl::new));\n    options.setSessionStoreFactory(\n        ofNullable(options.getSessionStoreFactory()).orElseGet(SessionStoreFactoryImpl::new));\n    options.setProfileManagerFactory(\n        ofNullable(options.getProfileManagerFactory()).orElse(ProfileManagerFactory.DEFAULT));\n\n    if (devLogin) {\n      app.get(\"/login\", new DevLoginForm(options, contextPath + options.getCallbackPath()));\n    }\n\n    /*\n     * If we have multiple clients on specific paths, we collect those path and configure pac4j to\n     * ignore them. So after login they are redirected to the requested url and not to one of this\n     * sign-in endpoints.\n     *\n     * <pre>\n     *   install(new Pac4jModule()\n     *     .client(\"/google\", ...)\n     *     .client(\"/twitter\", ....);\n     *   );\n     * </pre>\n     *\n     * So <code>google</code> and <code>twitter</code> paths are never saved as requested urls.\n     */\n    var excludes =\n        allClients.keySet().stream()\n            .filter(it -> !it.equals(\"*\"))\n            .map(it -> contextPath + it)\n            .collect(Collectors.toSet());\n\n    var callbackLogic = options.getCallbackLogic();\n    if (callbackLogic == null) {\n      options.setCallbackLogic(newCallbackLogic(excludes));\n    }\n    var direct = clients.getClients().stream().allMatch(it -> it instanceof DirectClient);\n    if (!direct || options.isForceCallbackRoutes()) {\n      CallbackFilterImpl callbackFilter = new CallbackFilterImpl(options, options);\n      app.get(options.getCallbackPath(), callbackFilter);\n      app.post(options.getCallbackPath(), callbackFilter);\n    }\n\n    var securityLogic = options.getSecurityLogic();\n    if (securityLogic == null) {\n      options.setSecurityLogic(newSecurityLogic(excludes));\n    }\n\n    /** For each client to a specific path, add a security handler. */\n    for (var entry : allClients.entrySet()) {\n      String pattern = entry.getKey();\n      if (!pattern.equals(\"*\")) {\n        List<String> keys = Router.pathKeys(pattern);\n        if (keys.isEmpty()) {\n          SecurityFilterImpl securityFilter =\n              new SecurityFilterImpl(\n                  null,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers);\n          app.get(pattern, securityFilter);\n          // POST for direct authentication\n          app.post(pattern, securityFilter);\n        } else {\n          app.use(\n              new SecurityFilterImpl(\n                  pattern,\n                  options,\n                  options,\n                  lazyClientNameList(entry.getValue()),\n                  clientMap.get(pattern).authorizers));\n        }\n      }\n    }\n\n    /* Is there is a global client, use it as decorator/filter (default client): */\n    var defaultSecurityFilter = allClients.get(\"*\");\n    if (defaultSecurityFilter != null) {\n      if (options.getDefaultClient() == null && defaultSecurityFilter.get(0).isResolved()) {\n        options.setDefaultClient(defaultSecurityFilter.get(0).getClient().getName());\n      }\n      app.use(\n          new SecurityFilterImpl(\n              null,\n              options,\n              options,\n              lazyClientNameList(defaultSecurityFilter),\n              clientMap.get(\"*\").authorizers));\n    }\n\n    /* Logout configuration: */\n    var logoutLogic = options.getLogoutLogic();\n    if (logoutLogic == null) {\n      options.setLogoutLogic(newLogoutLogic());\n    }\n    if (!direct || options.isForceLogoutRoutes()) {\n      app.get(options.getLogoutPath(), new LogoutImpl(options, options));\n    }\n\n    /* Better response code for some errors. */\n    app.errorCode(UnauthorizedAction.class, StatusCode.UNAUTHORIZED);\n    app.errorCode(ForbiddenAction.class, StatusCode.FORBIDDEN);\n\n    /* Compute default url as next available route. We only select static path patterns. */\n    if (options.getDefaultUrl() == null) {\n      int index = app.getRoutes().size();\n      app.onStarting(\n          () -> {\n            List<Route> routes = app.getRoutes();\n            String defaultUrl = app.getContextPath();\n            if (index < routes.size()) {\n              Route route = routes.get(index);\n              if (route.getPathKeys().isEmpty()) {\n                defaultUrl = contextPath + route.getPattern();\n              }\n            }\n            options.setDefaultUrl(defaultUrl);\n          });\n    }\n\n    app.getServices().put(Config.class, options);\n\n    /* Set current user provider */\n    app.setCurrentUser(new Pac4jCurrentUser(options));\n    // cleanup\n    clientMap.clear();\n  }"
    },
    {
        "target_file_name": "HttpHandler.java",
        "target_method": "channelRead0",
        "project_url": "https://github.com/Graylog2/graylog2-server",
        "commit_id": "31bc13d3cd6f550ec83473d0f8666cd3ebf50f10",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-30373",
        "project_name": "graylog2-server",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n        final Channel channel = ctx.channel();\n        final boolean keepAlive = HttpUtil.isKeepAlive(request);\n        final HttpVersion httpRequestVersion = request.protocolVersion();\n        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);\n\n        if (isNotBlank(authorizationHeader)) {\n            // Authentication is required.\n            final String suppliedAuthHeaderValue = request.headers().get(authorizationHeader);\n            if (isBlank(suppliedAuthHeaderValue) || !suppliedAuthHeaderValue.equals(authorizationHeaderValue)) {\n                writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.UNAUTHORIZED, origin);\n                return;\n            }\n        }\n\n        // to allow for future changes, let's be at least a little strict in what we accept here.\n        if (HttpMethod.OPTIONS.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.OK, origin);\n            return;\n        } else if (!HttpMethod.POST.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.METHOD_NOT_ALLOWED, origin);\n            return;\n        }\n\n        final boolean correctPath = path.equals(request.uri());\n        if (correctPath && request instanceof FullHttpRequest) {\n            final FullHttpRequest fullHttpRequest = (FullHttpRequest) request;\n            final ByteBuf buffer = fullHttpRequest.content();\n\n            // send on to raw message handler\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.ACCEPTED, origin);\n            ctx.fireChannelRead(buffer.retain());\n        } else {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.NOT_FOUND, origin);\n        }\n    }"
    },
    {
        "target_file_name": "HttpHandler.java",
        "target_method": "channelRead0",
        "project_url": "https://github.com/Graylog2/graylog2-server",
        "commit_id": "31bc13d3cd6f550ec83473d0f8666cd3ebf50f10^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-30373",
        "project_name": "graylog2-server",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) throws Exception {\n        final Channel channel = ctx.channel();\n        final boolean keepAlive = HttpUtil.isKeepAlive(request);\n        final HttpVersion httpRequestVersion = request.protocolVersion();\n        final String origin = request.headers().get(HttpHeaderNames.ORIGIN);\n\n        if (isNotBlank(authorizationHeader)) {\n            // Authentication is required.\n            final String suppliedAuthHeaderValue = request.headers().get(authorizationHeader);\n            if (isBlank(suppliedAuthHeaderValue) || !suppliedAuthHeaderValue.equals(authorizationHeaderValue)) {\n                writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.UNAUTHORIZED, origin);\n            }\n        }\n\n        // to allow for future changes, let's be at least a little strict in what we accept here.\n        if (HttpMethod.OPTIONS.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.OK, origin);\n            return;\n        } else if (!HttpMethod.POST.equals(request.method())) {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.METHOD_NOT_ALLOWED, origin);\n            return;\n        }\n\n        final boolean correctPath = path.equals(request.uri());\n        if (correctPath && request instanceof FullHttpRequest) {\n            final FullHttpRequest fullHttpRequest = (FullHttpRequest) request;\n            final ByteBuf buffer = fullHttpRequest.content();\n\n            // send on to raw message handler\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.ACCEPTED, origin);\n            ctx.fireChannelRead(buffer.retain());\n        } else {\n            writeResponse(channel, keepAlive, httpRequestVersion, HttpResponseStatus.NOT_FOUND, origin);\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "importBot",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "resume"
        ],
        "target_code": "@Override\n    public void importBot(InputStream zippedBotConfigFiles, AsyncResponse response) {\n        try {\n            if (response != null) response.setTimeout(60, TimeUnit.SECONDS);\n            File targetDir = new File(FileUtilities.buildPath(tmpPath.toString(), UUID.randomUUID().toString()));\n            importBotZipFile(zippedBotConfigFiles, targetDir, response);\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            if (response != null) {\n                response.resume(new InternalServerErrorException());\n            }\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "importBotZipFile",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "buildOldBotUri",
            "createNewBot",
            "deserialize",
            "endsWith",
            "error",
            "forEach",
            "get",
            "getLocalizedMessage",
            "getPackages",
            "getPath",
            "location",
            "newDirectoryStream",
            "ok",
            "parsePackage",
            "readFile",
            "resume",
            "toString",
            "updateDocumentDescriptor"
        ],
        "target_code": "private void importBotZipFile(InputStream zippedBotConfigFiles, File targetDir, AsyncResponse response)\n            throws IOException {\n\n        this.zipArchive.unzip(zippedBotConfigFiles, targetDir);\n        var targetDirPath = targetDir.getPath();\n        try (var directoryStream = Files.newDirectoryStream(Paths.get(targetDirPath),\n                path -> path.toString().endsWith(BOT_FILE_ENDING))) {\n            directoryStream.forEach(botFilePath -> {\n                try {\n                    String botFileString = readFile(botFilePath);\n                    BotConfiguration botConfiguration =\n                            jsonSerialization.deserialize(botFileString, BotConfiguration.class);\n                    botConfiguration.getPackages().forEach(packageUri ->\n                            parsePackage(targetDirPath, packageUri, botConfiguration, response));\n\n                    URI newBotUri = createNewBot(botConfiguration);\n                    updateDocumentDescriptor(Paths.get(targetDirPath), buildOldBotUri(botFilePath), newBotUri);\n                    response.resume(Response.ok().location(newBotUri).build());\n                } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException e) {\n                    log.error(e.getLocalizedMessage(), e);\n                    response.resume(new InternalServerErrorException());\n                }\n            });\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "parsePackage",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "buildPath",
            "collect",
            "createNewBehaviors",
            "createNewDictionaries",
            "createNewHttpCalls",
            "createNewLangchain",
            "createNewOutputs",
            "createNewPackage",
            "createNewProperties",
            "endsWith",
            "equals",
            "error",
            "extractResourcesUris",
            "forEach",
            "get",
            "getLocalizedMessage",
            "getPackages",
            "getParent",
            "map",
            "newDirectoryStream",
            "readFile",
            "readResources",
            "replaceURIs",
            "resume",
            "setPackages",
            "stream",
            "toList",
            "toString",
            "updateDocumentDescriptor"
        ],
        "target_code": "private void parsePackage(String targetDirPath, URI packageUri, BotConfiguration\n            botConfiguration, AsyncResponse response) {\n        try {\n            IResourceId packageResourceId = RestUtilities.extractResourceId(packageUri);\n            if (packageResourceId == null) {\n                return;\n            }\n            String packageId = packageResourceId.getId();\n            String packageVersion = String.valueOf(packageResourceId.getVersion());\n\n            var dir = Paths.get(FileUtilities.buildPath(targetDirPath, packageId, packageVersion));\n            try(var directoryStream = Files.newDirectoryStream(dir,\n                    packageFilePath -> packageFilePath.toString().endsWith(\".package.json\"))) {\n                directoryStream.\n                        forEach(packageFilePath -> {\n                            try {\n                                Path packagePath = packageFilePath.getParent();\n                                String packageFileString = readFile(packageFilePath);\n\n                                // loading old resources, creating them in the new system,\n                                // updating document descriptor and replacing references in package config\n\n                                // ... for dictionaries\n                                List<URI> dictionaryUris = extractResourcesUris(packageFileString, DICTIONARY_URI_PATTERN);\n                                List<URI> newDictionaryUris = createNewDictionaries(\n                                        readResources(dictionaryUris, packagePath,\n                                                DICTIONARY_EXT, RegularDictionaryConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, dictionaryUris, newDictionaryUris);\n                                packageFileString = replaceURIs(packageFileString, dictionaryUris, newDictionaryUris);\n\n                                // ... for behavior\n                                List<URI> behaviorUris = extractResourcesUris(packageFileString, BEHAVIOR_URI_PATTERN);\n                                List<URI> newBehaviorUris = createNewBehaviors(\n                                        readResources(behaviorUris, packagePath,\n                                                BEHAVIOR_EXT, BehaviorConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, behaviorUris, newBehaviorUris);\n                                packageFileString = replaceURIs(packageFileString, behaviorUris, newBehaviorUris);\n\n                                // ... for http calls\n                                List<URI> httpCallsUris = extractResourcesUris(packageFileString, HTTPCALLS_URI_PATTERN);\n                                List<URI> newHttpCallsUris = createNewHttpCalls(\n                                        readResources(httpCallsUris, packagePath,\n                                                HTTPCALLS_EXT, HttpCallsConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, httpCallsUris, newHttpCallsUris);\n                                packageFileString = replaceURIs(packageFileString, httpCallsUris, newHttpCallsUris);\n\n                                // ... for langchain\n                                List<URI> langchainUris = extractResourcesUris(packageFileString, LANGCHAIN_URI_PATTERN);\n                                List<URI> newLangchainUris = createNewLangchain(\n                                        readResources(langchainUris, packagePath,\n                                                LANGCHAIN_EXT, LangChainConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, langchainUris, newLangchainUris);\n                                packageFileString = replaceURIs(packageFileString, langchainUris, newLangchainUris);\n\n                                // ... for property\n                                List<URI> propertyUris = extractResourcesUris(packageFileString, PROPERTY_URI_PATTERN);\n                                List<URI> newPropertyUris = createNewProperties(\n                                        readResources(propertyUris, packagePath,\n                                                PROPERTY_EXT, PropertySetterConfiguration.class));\n\n                                updateDocumentDescriptor(packagePath, propertyUris, newPropertyUris);\n                                packageFileString = replaceURIs(packageFileString, propertyUris, newPropertyUris);\n\n                                // ... for output\n                                List<URI> outputUris = extractResourcesUris(packageFileString, OUTPUT_URI_PATTERN);\n                                List<URI> newOutputUris = createNewOutputs(\n                                        readResources(outputUris, packagePath,\n                                                OUTPUT_EXT, OutputConfigurationSet.class));\n\n                                updateDocumentDescriptor(packagePath, outputUris, newOutputUris);\n                                packageFileString = replaceURIs(packageFileString, outputUris, newOutputUris);\n\n                                // creating updated package and replacing references in bot config\n                                URI newPackageUri = createNewPackage(packageFileString);\n                                updateDocumentDescriptor(packagePath, packageUri, newPackageUri);\n                                botConfiguration.setPackages(botConfiguration.getPackages().stream().\n                                        map(uri -> uri.equals(packageUri) ? newPackageUri : uri).\n                                        collect(Collectors.toList()));\n\n                            } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException |\n                                     CallbackMatcher.CallbackMatcherException e) {\n                                log.error(e.getLocalizedMessage(), e);\n                                response.resume(new InternalServerErrorException());\n                            }\n                        });\n\n            }\n\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "updateDocumentDescriptor",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "extractResourceId",
            "get",
            "getId",
            "getVersion",
            "patchDescriptor",
            "readDocumentDescriptorFromFile",
            "setDocument",
            "setOperation"
        ],
        "target_code": "private void updateDocumentDescriptor(Path directoryPath, List<URI> oldUris, List<URI> newUris)\n            throws RestInterfaceFactory.RestInterfaceFactoryException {\n\n        IRestDocumentDescriptorStore restDocumentDescriptorStore = getRestResourceStore(IRestDocumentDescriptorStore.class);\n        IntStream.range(0, oldUris.size()).forEach(idx -> {\n            try {\n                URI oldUri = oldUris.get(idx);\n                IResourceId oldResourceId = RestUtilities.extractResourceId(oldUri);\n                if (oldResourceId != null) {\n                    var oldDocumentDescriptor = readDocumentDescriptorFromFile(directoryPath, oldResourceId);\n\n                    URI newUri = newUris.get(idx);\n                    IResourceId newResourceId = RestUtilities.extractResourceId(newUri);\n\n                    if (newResourceId != null) {\n                        PatchInstruction<DocumentDescriptor> patchInstruction = new PatchInstruction<>();\n                        patchInstruction.setOperation(PatchInstruction.PatchOperation.SET);\n                        patchInstruction.setDocument(oldDocumentDescriptor);\n\n                        restDocumentDescriptorStore.patchDescriptor(newResourceId.getId(),\n                                newResourceId.getVersion(), patchInstruction);\n                    }\n                }\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n            }\n        });\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "readResources",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SuppressWarnings(\"unchecked\")\n    private <T> List<T> readResources(List<URI> uris, Path packagePath, String extension, Class<T> clazz) {\n        return uris.stream().map(uri -> {\n            Path resourcePath = null;\n            String resourceContent = null;\n            try {\n                IResourceId resourceId = RestUtilities.extractResourceId(uri);\n                if (resourceId == null) {\n                    throw new IOException(\"resourceId was null\");\n                }\n                resourcePath = createResourcePath(packagePath, resourceId.getId(), extension);\n                resourceContent = readFile(resourcePath);\n                if (uri.toString().startsWith(IRestPropertySetterStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedPropertySetterDocument =\n                            migrationManager.migratePropertySetter().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedPropertySetterDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedPropertySetterDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestHttpCallsStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedHttpCallsDocument =\n                            migrationManager.migrateHttpCalls().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedHttpCallsDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedHttpCallsDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestOutputStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedOutputDocument =\n                            migrationManager.migrateOutput().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedOutputDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedOutputDocument);\n                    }\n                }\n                return jsonSerialization.deserialize(resourceContent, clazz);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n                log.error(String.format(\"uri is: %s\", uri));\n                log.error(String.format(\"packagePath is: %s\", packagePath));\n                log.error(String.format(\"resourcePath is: %s\", resourcePath));\n                log.error(String.format(\"resourceContent is:\\n%s\", resourceContent));\n                return null;\n            }\n        }).collect(Collectors.toList());\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "writeZipFile",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addToZip",
            "isDirectory"
        ],
        "target_code": "private static void writeZipFile(String targetZipFile, File directoryToZip, List<File> fileList) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(targetZipFile);\n             ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos))) {\n\n            for (File file : fileList) {\n                if (!file.isDirectory()) {\n                    addToZip(directoryToZip, file, zos);\n                }\n            }\n        }\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "addToZip",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "closeEntry",
            "getZipEntry",
            "putNextEntry",
            "read",
            "write"
        ],
        "target_code": "private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws IOException {\n        // Use try-with-resources for automatic stream closing\n        try (FileInputStream fis = new FileInputStream(file)) {\n            // Ensure consistent path separators and protect against traversal in entry name creation itself\n            var zipEntry = getZipEntry(directoryToZip, file);\n            zos.putNextEntry(zipEntry);\n\n            byte[] bytes = new byte[BUFFER_SIZE];\n            int length;\n            while ((length = fis.read(bytes)) >= 0) {\n                zos.write(bytes, 0, length);\n            }\n            zos.closeEntry();\n        }\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "unzip",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "closeEntry",
            "extractFile",
            "getCanonicalPath",
            "getName",
            "getNextEntry",
            "getParentFile",
            "isDirectory",
            "mkdirs",
            "startsWith"
        ],
        "target_code": "@Override\n    public void unzip(InputStream zipFile, File targetDir) throws IOException {\n        if (!targetDir.exists()) {\n            if (!targetDir.mkdirs()) {\n                throw new IOException(\"Could not create target directory: \" + targetDir);\n            }\n        }\n\n        String targetDirPath = targetDir.getCanonicalPath();\n        try (ZipInputStream zipIn = new ZipInputStream(new BufferedInputStream(zipFile))) {\n            ZipEntry entry;\n            while ((entry = zipIn.getNextEntry()) != null) {\n                File destFile = new File(targetDir, entry.getName());\n                String destFilePath = destFile.getCanonicalPath();\n\n                // Ensure the resolved destination path starts with the target directory path\n                if (!destFilePath.startsWith(targetDirPath + File.separator)) {\n                    throw new IOException(\"Entry is outside of the target dir: \" + entry.getName());\n                }\n\n                if (entry.isDirectory()) {\n                    if (!destFile.mkdirs() && !destFile.isDirectory()) {\n                        throw new IOException(\"Could not create directory: \" + destFilePath);\n                    }\n                } else {\n                    File parentDir = destFile.getParentFile();\n                    if (!parentDir.mkdirs() && !parentDir.isDirectory()) {\n                        throw new IOException(\"Could not create parent directories for: \" + destFilePath);\n                    }\n                    extractFile(zipIn, destFile);\n                }\n                zipIn.closeEntry();\n            }\n        }\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "extractFile",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "read",
            "write"
        ],
        "target_code": "private void extractFile(ZipInputStream zipIn, File destFile) throws IOException {\n        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile))) {\n            byte[] bytesIn = new byte[BUFFER_SIZE];\n            int read;\n            while ((read = zipIn.read(bytesIn)) != -1) {\n                bos.write(bytesIn, 0, read);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "importBot",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "resume"
        ],
        "target_code": "@Override\n    public void importBot(InputStream zippedBotConfigFiles, AsyncResponse response) {\n        try {\n            if (response != null) response.setTimeout(60, TimeUnit.SECONDS);\n            File targetDir = new File(FileUtilities.buildPath(tmpPath.toString(), UUID.randomUUID().toString()));\n            importBotZipFile(zippedBotConfigFiles, targetDir, response);\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "importBotZipFile",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "build",
            "buildOldBotUri",
            "createNewBot",
            "deserialize",
            "endsWith",
            "error",
            "forEach",
            "get",
            "getLocalizedMessage",
            "getPackages",
            "getPath",
            "location",
            "newDirectoryStream",
            "ok",
            "parsePackage",
            "readFile",
            "resume",
            "toString",
            "updateDocumentDescriptor"
        ],
        "target_code": "private void importBotZipFile(InputStream zippedBotConfigFiles, File targetDir, AsyncResponse response) throws\n            IOException {\n        this.zipArchive.unzip(zippedBotConfigFiles, targetDir);\n\n        String targetDirPath = targetDir.getPath();\n        Files.newDirectoryStream(Paths.get(targetDirPath),\n                        path -> path.toString().endsWith(BOT_FILE_ENDING))\n                .forEach(botFilePath -> {\n                    try {\n                        String botFileString = readFile(botFilePath);\n                        BotConfiguration botConfiguration =\n                                jsonSerialization.deserialize(botFileString, BotConfiguration.class);\n                        botConfiguration.getPackages().forEach(packageUri ->\n                                parsePackage(targetDirPath, packageUri, botConfiguration, response));\n\n                        URI newBotUri = createNewBot(botConfiguration);\n                        updateDocumentDescriptor(Paths.get(targetDirPath), buildOldBotUri(botFilePath), newBotUri);\n                        response.resume(Response.ok().location(newBotUri).build());\n                    } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException e) {\n                        log.error(e.getLocalizedMessage(), e);\n                        response.resume(new InternalServerErrorException());\n                    }\n                });\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "parsePackage",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "buildPath",
            "collect",
            "createNewBehaviors",
            "createNewDictionaries",
            "createNewHttpCalls",
            "createNewLangchain",
            "createNewOutputs",
            "createNewPackage",
            "createNewProperties",
            "endsWith",
            "equals",
            "error",
            "extractResourcesUris",
            "forEach",
            "get",
            "getLocalizedMessage",
            "getPackages",
            "getParent",
            "map",
            "newDirectoryStream",
            "readFile",
            "readResources",
            "replaceURIs",
            "resume",
            "setPackages",
            "stream",
            "toList",
            "toString",
            "updateDocumentDescriptor"
        ],
        "target_code": "private void parsePackage(String targetDirPath, URI packageUri, BotConfiguration\n            botConfiguration, AsyncResponse response) {\n        try {\n            IResourceId packageResourceId = RestUtilities.extractResourceId(packageUri);\n            String packageId = packageResourceId.getId();\n            String packageVersion = String.valueOf(packageResourceId.getVersion());\n\n            Files.newDirectoryStream(Paths.get(FileUtilities.buildPath(targetDirPath, packageId, packageVersion)),\n                            packageFilePath -> packageFilePath.toString().endsWith(\".package.json\")).\n                    forEach(packageFilePath -> {\n                        try {\n                            Path packagePath = packageFilePath.getParent();\n                            String packageFileString = readFile(packageFilePath);\n\n                            // loading old resources, creating them in the new system,\n                            // updating document descriptor and replacing references in package config\n\n                            // ... for dictionaries\n                            List<URI> dictionaryUris = extractResourcesUris(packageFileString, DICTIONARY_URI_PATTERN);\n                            List<URI> newDictionaryUris = createNewDictionaries(\n                                    readResources(dictionaryUris, packagePath,\n                                            DICTIONARY_EXT, RegularDictionaryConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, dictionaryUris, newDictionaryUris);\n                            packageFileString = replaceURIs(packageFileString, dictionaryUris, newDictionaryUris);\n\n                            // ... for behavior\n                            List<URI> behaviorUris = extractResourcesUris(packageFileString, BEHAVIOR_URI_PATTERN);\n                            List<URI> newBehaviorUris = createNewBehaviors(\n                                    readResources(behaviorUris, packagePath,\n                                            BEHAVIOR_EXT, BehaviorConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, behaviorUris, newBehaviorUris);\n                            packageFileString = replaceURIs(packageFileString, behaviorUris, newBehaviorUris);\n\n                            // ... for http calls\n                            List<URI> httpCallsUris = extractResourcesUris(packageFileString, HTTPCALLS_URI_PATTERN);\n                            List<URI> newHttpCallsUris = createNewHttpCalls(\n                                    readResources(httpCallsUris, packagePath,\n                                            HTTPCALLS_EXT, HttpCallsConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, httpCallsUris, newHttpCallsUris);\n                            packageFileString = replaceURIs(packageFileString, httpCallsUris, newHttpCallsUris);\n\n                            // ... for langchain\n                            List<URI> langchainUris = extractResourcesUris(packageFileString, LANGCHAIN_URI_PATTERN);\n                            List<URI> newLangchainUris = createNewLangchain(\n                                    readResources(langchainUris, packagePath,\n                                            LANGCHAIN_EXT, LangChainConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, langchainUris, newLangchainUris);\n                            packageFileString = replaceURIs(packageFileString, langchainUris, newLangchainUris);\n\n                            // ... for property\n                            List<URI> propertyUris = extractResourcesUris(packageFileString, PROPERTY_URI_PATTERN);\n                            List<URI> newPropertyUris = createNewProperties(\n                                    readResources(propertyUris, packagePath,\n                                            PROPERTY_EXT, PropertySetterConfiguration.class));\n\n                            updateDocumentDescriptor(packagePath, propertyUris, newPropertyUris);\n                            packageFileString = replaceURIs(packageFileString, propertyUris, newPropertyUris);\n\n                            // ... for output\n                            List<URI> outputUris = extractResourcesUris(packageFileString, OUTPUT_URI_PATTERN);\n                            List<URI> newOutputUris = createNewOutputs(\n                                    readResources(outputUris, packagePath,\n                                            OUTPUT_EXT, OutputConfigurationSet.class));\n\n                            updateDocumentDescriptor(packagePath, outputUris, newOutputUris);\n                            packageFileString = replaceURIs(packageFileString, outputUris, newOutputUris);\n\n                            // creating updated package and replacing references in bot config\n                            URI newPackageUri = createNewPackage(packageFileString);\n                            updateDocumentDescriptor(packagePath, packageUri, newPackageUri);\n                            botConfiguration.setPackages(botConfiguration.getPackages().stream().\n                                    map(uri -> uri.equals(packageUri) ? newPackageUri : uri).\n                                    collect(Collectors.toList()));\n\n                        } catch (IOException | RestInterfaceFactory.RestInterfaceFactoryException |\n                                 CallbackMatcher.CallbackMatcherException e) {\n                            log.error(e.getLocalizedMessage(), e);\n                            response.resume(new InternalServerErrorException());\n                        }\n                    });\n        } catch (IOException e) {\n            log.error(e.getLocalizedMessage(), e);\n            response.resume(new InternalServerErrorException());\n        }\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "updateDocumentDescriptor",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "extractResourceId",
            "get",
            "getId",
            "getVersion",
            "patchDescriptor",
            "readDocumentDescriptorFromFile",
            "setDocument",
            "setOperation"
        ],
        "target_code": "private void updateDocumentDescriptor(Path directoryPath, List<URI> oldUris, List<URI> newUris)\n            throws RestInterfaceFactory.RestInterfaceFactoryException {\n\n        IRestDocumentDescriptorStore restDocumentDescriptorStore = getRestResourceStore(IRestDocumentDescriptorStore.class);\n        IntStream.range(0, oldUris.size()).forEach(idx -> {\n            try {\n                URI oldUri = oldUris.get(idx);\n                IResourceId oldResourceId = RestUtilities.extractResourceId(oldUri);\n                DocumentDescriptor oldDocumentDescriptor = readDocumentDescriptorFromFile(directoryPath, oldResourceId);\n\n                URI newUri = newUris.get(idx);\n                IResourceId newResourceId = RestUtilities.extractResourceId(newUri);\n\n                PatchInstruction<DocumentDescriptor> patchInstruction = new PatchInstruction<>();\n                patchInstruction.setOperation(PatchInstruction.PatchOperation.SET);\n                patchInstruction.setDocument(oldDocumentDescriptor);\n\n                restDocumentDescriptorStore.patchDescriptor(newResourceId.getId(), newResourceId.getVersion(), patchInstruction);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n            }\n        });\n    }"
    },
    {
        "target_file_name": "RestImportService.java",
        "target_method": "readResources",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@SuppressWarnings(\"unchecked\")\n    private <T> List<T> readResources(List<URI> uris, Path packagePath, String extension, Class<T> clazz) {\n        return uris.stream().map(uri -> {\n            Path resourcePath = null;\n            String resourceContent = null;\n            try {\n                IResourceId resourceId = RestUtilities.extractResourceId(uri);\n                resourcePath = createResourcePath(packagePath, resourceId.getId(), extension);\n                resourceContent = readFile(resourcePath);\n                if (uri.toString().startsWith(IRestPropertySetterStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedPropertySetterDocument =\n                            migrationManager.migratePropertySetter().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedPropertySetterDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedPropertySetterDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestHttpCallsStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedHttpCallsDocument =\n                            migrationManager.migrateHttpCalls().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedHttpCallsDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedHttpCallsDocument);\n                    }\n                } else if (uri.toString().startsWith(IRestOutputStore.resourceBaseType)) {\n                    var resourceAsMap = jsonSerialization.deserialize(resourceContent, Map.class);\n                    var migratedOutputDocument =\n                            migrationManager.migrateOutput().\n                                    migrate(new Document(resourceAsMap));\n\n                    if (migratedOutputDocument != null) {\n                        resourceContent = jsonSerialization.serialize(migratedOutputDocument);\n                    }\n                }\n                return jsonSerialization.deserialize(resourceContent, clazz);\n            } catch (IOException e) {\n                log.error(e.getLocalizedMessage(), e);\n                log.error(String.format(\"uri is: %s\", uri));\n                log.error(String.format(\"packagePath is: %s\", packagePath));\n                log.error(String.format(\"resourcePath is: %s\", resourcePath));\n                log.error(String.format(\"resourceContent is:\\n%s\", resourceContent));\n                return null;\n            }\n        }).collect(Collectors.toList());\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "writeZipFile",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addToZip",
            "close",
            "isDirectory"
        ],
        "target_code": "private static void writeZipFile(String targetZipFile, File directoryToZip, List<File> fileList) throws IOException {\n        FileOutputStream fos = new FileOutputStream(targetZipFile);\n        ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(fos));\n\n        for (File file : fileList) {\n            if (!file.isDirectory()) { // we only zip files, not directories\n                addToZip(directoryToZip, file, zos);\n            }\n        }\n\n        zos.close();\n        fos.close();\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "addToZip",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "close",
            "closeEntry",
            "getCanonicalPath",
            "length",
            "putNextEntry",
            "read",
            "replace",
            "substring",
            "write"
        ],
        "target_code": "private static void addToZip(File directoryToZip, File file, ZipOutputStream zos) throws IOException {\n        FileInputStream fis = new FileInputStream(file);\n\n        String zipFilePath = file.getCanonicalPath().\n                substring(directoryToZip.getCanonicalPath().length() + 1).replace('\\\\', '/');\n        ZipEntry zipEntry = new ZipEntry(zipFilePath);\n        zos.putNextEntry(zipEntry);\n\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zos.write(bytes, 0, length);\n        }\n\n        zos.closeEntry();\n        fis.close();\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "unzip",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "close",
            "closeEntry",
            "extractFile",
            "getName",
            "getNextEntry",
            "getParentFile",
            "getPath",
            "isDirectory",
            "mkdir",
            "mkdirs"
        ],
        "target_code": "@Override\n    public void unzip(InputStream zipFile, File targetDir) throws IOException {\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n        ZipInputStream zipIn = new ZipInputStream(zipFile);\n\n        ZipEntry entry = zipIn.getNextEntry();\n        // iterates over entries in the zip file\n        while (entry != null) {\n            String filePath = targetDir.getPath() + File.separator + entry.getName();\n            if (!entry.isDirectory()) {\n                // if the entry is a file, extracts it\n                new File(filePath).getParentFile().mkdirs();\n                extractFile(zipIn, filePath);\n            } else {\n                // if the entry is a directory, make the directory\n                File dir = new File(filePath);\n                dir.mkdirs();\n            }\n            zipIn.closeEntry();\n            entry = zipIn.getNextEntry();\n        }\n        zipIn.close();\n    }"
    },
    {
        "target_file_name": "ZipArchive.java",
        "target_method": "extractFile",
        "project_url": "https://github.com/labsai/EDDI",
        "commit_id": "1e207d0e4f72a5a93920bc0f76cad53ffd8e7065^",
        "CWE_id": "CWE-22",
        "CVE_id": "CVE-2025-32779",
        "project_name": "EDDI",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "close",
            "read",
            "write"
        ],
        "target_code": "private void extractFile(ZipInputStream zipIn, String filePath) throws IOException {\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath));\n        byte[] bytesIn = new byte[BUFFER_SIZE];\n        int read;\n        while ((read = zipIn.read(bytesIn)) != -1) {\n            bos.write(bytesIn, 0, read);\n        }\n        bos.close();\n    }"
    },
    {
        "target_file_name": "DefaultHQLStatementValidator.java",
        "target_method": "checkOrderBySafe",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "dfd0744e9c18d24ac66a0d261dc6cafd1c209101",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-32429",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Unsafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "DefaultHQLStatementValidator.java",
        "target_method": "checkOrderBySafe",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "dfd0744e9c18d24ac66a0d261dc6cafd1c209101^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-32429",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Usafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "DefaultHQLStatementValidator.java",
        "target_method": "checkOrderBySafe",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f502b5d5fd36284a50890ad26d168b7d8dc80bd3",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-32429",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Unsafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "DefaultHQLStatementValidator.java",
        "target_method": "checkOrderBySafe",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "f502b5d5fd36284a50890ad26d168b7d8dc80bd3^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-32429",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public void checkOrderBySafe(List<String> allowedPrefixes, String orderByValue) throws QueryException\n    {\n        if (StringUtils.isBlank(orderByValue)) {\n            return;\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(orderByValue, \",\");\n        while (tokenizer.hasMoreTokens()) {\n            String orderByColumn = tokenizer.nextToken().trim();\n\n            boolean valid = false;\n            if (SAFE_ORDERBY_ELEMENT.matcher(orderByColumn).matches()) {\n                valid = isValidOrderBy(allowedPrefixes, orderByColumn);\n            }\n\n            if (!valid) {\n                throw new QueryException(\"Usafe ORDER BY value [\" + orderByValue + \"].\", null);\n            }\n        }\n    }"
    },
    {
        "target_file_name": "Redshift.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "03b18db8a0fb7e9dc2c44f6d26d8c6221b7748c4",
        "CWE_id": "CWE-923",
        "CVE_id": "CVE-2025-48999",
        "project_name": "dataease",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "decode",
            "getJdbcUrl",
            "throwException"
        ],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            for (String illegalParameter : illegalParameters) {\n                if (URLDecoder.decode(getJdbcUrl()).contains(illegalParameter)) {\n                    DEException.throwException(\"Illegal parameter: \" + illegalParameter);\n                }\n            }\n            return getJdbcUrl();\n        }\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }"
    },
    {
        "target_file_name": "Redshift.java",
        "target_method": "getJdbc",
        "project_url": "https://github.com/dataease/dataease",
        "commit_id": "03b18db8a0fb7e9dc2c44f6d26d8c6221b7748c4^",
        "CWE_id": "CWE-923",
        "CVE_id": "CVE-2025-48999",
        "project_name": "dataease",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public String getJdbc() {\n        if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase(\"hostName\")){\n            return getJdbcUrl();\n        }\n        return \"jdbc:redshift://HOSTNAME:PORT/DATABASE\"\n                .replace(\"HOSTNAME\", getLHost().trim())\n                .replace(\"PORT\", getLPort().toString().trim())\n                .replace(\"DATABASE\", getDataBase().trim());\n    }"
    },
    {
        "target_file_name": "PDFExportJob.java",
        "target_method": "runInternal",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "60982ad0057b1701ed8297f28cad35d170686539",
        "CWE_id": "CWE-257",
        "CVE_id": "CVE-2025-58049",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "cleanup",
            "exportAsPDF"
        ],
        "target_code": "@Override\n    protected void runInternal() throws Exception\n    {\n        try {\n            exportAsPDF();\n        } finally {\n            cleanup();\n        }\n    }"
    },
    {
        "target_file_name": "PDFExportJob.java",
        "target_method": "runInternal",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "60982ad0057b1701ed8297f28cad35d170686539^",
        "CWE_id": "CWE-257",
        "CVE_id": "CVE-2025-58049",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "clear",
            "getDocumentRenderingResults",
            "getDocuments",
            "isCanceled",
            "isEmpty",
            "isServerSide",
            "render",
            "saveAsPDF",
            "setRequiredSkinExtensions",
            "start",
            "stop"
        ],
        "target_code": "@Override\n    protected void runInternal() throws Exception\n    {\n        if (!this.request.getDocuments().isEmpty()) {\n            this.requiredSkinExtensionsRecorder.start();\n            render(this.request.getDocuments());\n            if (!this.status.isCanceled()) {\n                this.status.setRequiredSkinExtensions(this.requiredSkinExtensionsRecorder.stop());\n            }\n\n            if (this.request.isServerSide() && !this.status.isCanceled()) {\n                saveAsPDF();\n                this.status.getDocumentRenderingResults().clear();\n            }\n        }\n    }"
    },
    {
        "target_file_name": "BlogScriptService.java",
        "target_method": "renderRSSDescription",
        "project_url": "https://github.com/xwiki-contrib/application-blog",
        "commit_id": "b98ab6f17da3029576f42d12b4442cd555c7e0b4",
        "CWE_id": "CWE-95",
        "CVE_id": "CVE-2025-58365",
        "project_name": "application-blog",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Deprecated\n    public String renderRSSDescription(String contentToRender, Document blogDocument) throws XWikiException\n    {\n        XWikiContext context = this.xwikiContextProvider.get();\n        XWikiURLFactory currentURLFactory = context.getURLFactory();\n        try {\n            context.setURLFactory(new ExternalServletURLFactory(context));\n            return blogDocument.getRenderedContent(contentToRender, blogDocument.getSyntax().toIdString());\n        } finally {\n            context.setURLFactory(currentURLFactory);\n        }\n    }"
    },
    {
        "target_file_name": "BlogScriptService.java",
        "target_method": "renderRSSDescription",
        "project_url": "https://github.com/xwiki-contrib/application-blog",
        "commit_id": "b98ab6f17da3029576f42d12b4442cd555c7e0b4^",
        "CWE_id": "CWE-95",
        "CVE_id": "CVE-2025-58365",
        "project_name": "application-blog",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public String renderRSSDescription(String contentToRender, Document blogDocument) throws XWikiException\n    {\n        XWikiContext context = this.xwikiContextProvider.get();\n        XWikiURLFactory currentURLFactory = context.getURLFactory();\n        try {\n            context.setURLFactory(new ExternalServletURLFactory(context));\n            return blogDocument.getRenderedContent(contentToRender, blogDocument.getSyntax().toIdString());\n        } finally {\n            context.setURLFactory(currentURLFactory);\n        }\n    }"
    },
    {
        "target_file_name": "AbstractServletResourceReferenceHandler.java",
        "target_method": "handle",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        @SuppressWarnings(\"unchecked\")\n        R typedResourceReference = (R) resourceReference;\n\n        if (!isResourceAccessible(typedResourceReference)) {\n            sendError(HttpStatus.SC_FORBIDDEN, \"You are not allowed to view [%s].\",\n                getResourceName(typedResourceReference));\n        } else if (!shouldBrowserUseCachedContent(typedResourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            try (InputStream resourceStream = getResourceStream(typedResourceReference)) {\n                if (resourceStream != null) {\n                    try (InputStream filteredSteam = filterResource(typedResourceReference, resourceStream)) {\n                        serveResource(typedResourceReference, filteredSteam);\n                    }\n                } else {\n                    sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\",\n                        getResourceName(typedResourceReference));\n                }\n            } catch (Exception e) {\n                this.logger.error(e.getMessage(), e);\n                sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority handler has something to do for this\n        // resource reference.\n        chain.handleNext(resourceReference);\n    }"
    },
    {
        "target_file_name": "InternalTemplateManager.java",
        "target_method": "getClassloaderTemplate",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getResource",
            "warn"
        ],
        "target_code": "private Template getClassloaderTemplate(ClassLoader classloader, String prefixPath, String templateName)\n    {\n        URL url;\n        try {\n            url = ClassLoaderUtils.getResource(classloader, prefixPath, templateName);\n        } catch (IllegalArgumentException e) {\n            this.logger.warn(\"The template name [{}] is trying to execute a path traversal attack!\", templateName);\n\n            return null;\n        }\n\n        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;\n    }"
    },
    {
        "target_file_name": "WebJarsResourceReferenceHandler.java",
        "target_method": "getResourceStream",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getClassLoader",
            "getNamespace",
            "getResourceAsStream",
            "getResourceName"
        ],
        "target_code": "@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        return ClassLoaderUtils.getResourceAsStream(getClassLoader(resourceReference.getNamespace()),\n            WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n    }"
    },
    {
        "target_file_name": "SxResourceSource.java",
        "target_method": "getContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getResourceAsStream"
        ],
        "target_code": "@Override\n    public String getContent()\n    {\n        try {\n            // Load from the current context class loader to allow extensions to contribute skin extensions.\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            try (InputStream in = ClassLoaderUtils.getResourceAsStream(contextClassLoader, this.resourceName)) {\n                return IOUtils.toString(in, StandardCharsets.UTF_8);\n            }\n        } catch (NullPointerException e) {\n            // This happens when the file was not found. Forward an IAE so that the sx action returns 404\n            throw new IllegalArgumentException(e);\n        } catch (IOException e) {\n            return \"\";\n        }\n    }"
    },
    {
        "target_file_name": "AbstractServletResourceReferenceHandler.java",
        "target_method": "handle",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81^",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        @SuppressWarnings(\"unchecked\")\n        R typedResourceReference = (R) resourceReference;\n\n        if (!isResourceAccessible(typedResourceReference)) {\n            sendError(HttpStatus.SC_FORBIDDEN, \"You are not allowed to view [%s].\",\n                getResourceName(typedResourceReference));\n        } else if (!shouldBrowserUseCachedContent(typedResourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            try (InputStream resourceStream = getResourceStream(typedResourceReference)) {\n                if (resourceStream != null) {\n                    try (InputStream filteredSteam = filterResource(typedResourceReference, resourceStream)) {\n                        serveResource(typedResourceReference, filteredSteam);\n                    }\n                } else {\n                    sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\",\n                        getResourceName(typedResourceReference));\n                }\n            } catch (IOException | ResourceReferenceHandlerException e) {\n                this.logger.error(e.getMessage(), e);\n                sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority handler has something to do for this\n        // resource reference.\n        chain.handleNext(resourceReference);\n    }"
    },
    {
        "target_file_name": "WebJarsResourceReferenceHandler.java",
        "target_method": "getResourceStream",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81^",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "format",
            "getClassLoader",
            "getNamespace",
            "getResourceAsStream",
            "getResourceName"
        ],
        "target_code": "@Override\n    protected InputStream getResourceStream(WebJarsResourceReference resourceReference)\n    {\n        String resourcePath = String.format(\"%s%s\", WEBJARS_RESOURCE_PREFIX, getResourceName(resourceReference));\n        return getClassLoader(resourceReference.getNamespace()).getResourceAsStream(resourcePath);\n    }"
    },
    {
        "target_file_name": "SxResourceSource.java",
        "target_method": "getContent",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "9e7b4c03f2143978d891109a17159f73d4cdd318#diff-45ea9c87d5fb68cd5db0da7f78cf25e76f1325f5fe56e21618b21786fc706236R80-R81^",
        "CWE_id": "CWE-23",
        "CVE_id": "CVE-2025-55747",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "getResourceAsStream"
        ],
        "target_code": "@Override\n    public String getContent()\n    {\n        try {\n            // Load from the current context class loader to allow extensions to contribute skin extensions.\n            ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n            try (InputStream in = contextClassLoader.getResourceAsStream(this.resourceName)) {\n                return IOUtils.toString(in, StandardCharsets.UTF_8);\n            }\n        } catch (NullPointerException e) {\n            // This happens when the file was not found. Forward an IAE so that the sx action returns 404\n            throw new IllegalArgumentException(e);\n        } catch (IOException e) {\n            return \"\";\n        }\n    }"
    },
    {
        "target_file_name": "FileSystemStorageService.java",
        "target_method": "store",
        "project_url": "https://github.com/OsamaTaher/Java-springboot-codebase",
        "commit_id": "c835c6f7799eacada4c0fc77e0816f250af01ad2",
        "CWE_id": "CWE-36",
        "CVE_id": "CVE-2025-46822",
        "project_name": "Java-springboot-codebase",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "contains",
            "matcher",
            "matches"
        ],
        "target_code": "@Override\n    public int store(MultipartFile file, String nameAndExt) {\n        Path location = Paths.get(rootLocation+\"/\");\n\n        try {\n            Files.createDirectories(location);\n            if (file.isEmpty()) {\n                return OP_STATUS_FILE_EMPTY;\n            }\n            if (nameAndExt.contains(\"..\") || !fileNamePattern.matcher(nameAndExt).matches()) {\n                // This is a security check\n               return OP_STATUS_INVALID_FILE_NAME;\n            }\n\n            if(!isAllowedFileType(file)) return OP_STATUS_FILE_TYPE_NOT_ALLOWED;\n\n            try (InputStream inputStream = file.getInputStream()) {\n\n                Files.copy(inputStream, location.resolve(nameAndExt),\n                        StandardCopyOption.REPLACE_EXISTING);\n\n                if(isImage(FilenameUtils.getExtension(file.getOriginalFilename()))){\n                    createThumbnail(file,thumbWidth,nameAndExt);\n                }\n            }\n            return OP_STATUS_SUCCESS;\n        }\n        catch (IOException e) {\n            log.error(\"[EXCEPTION] store : {},{}\",e.getMessage(),e.getCause());\n            return OP_STATUS_FAILED;\n        }\n    }"
    },
    {
        "target_file_name": "FileSystemStorageService.java",
        "target_method": "loadAsResource",
        "project_url": "https://github.com/OsamaTaher/Java-springboot-codebase",
        "commit_id": "c835c6f7799eacada4c0fc77e0816f250af01ad2",
        "CWE_id": "CWE-36",
        "CVE_id": "CVE-2025-46822",
        "project_name": "Java-springboot-codebase",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "error",
            "matcher",
            "matches"
        ],
        "target_code": "@Override\n    public Resource loadAsResource(String filename) {\n        try {\n            if(!fileNamePattern.matcher(filename).matches()){\n                log.error(\"[ERROR] loadAsResource: invalid file name\");\n                return null;\n            }\n            Path location = Paths.get(rootLocation+\"/\");\n            Path file = load(filename,location);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n              return null;\n            }\n        } catch (MalformedURLException e) {\n           log.error(\"[EXCEPTION] loadAsResource: {},{}\",e.getMessage(),e.getCause());\n           return null;\n        }\n    }"
    },
    {
        "target_file_name": "FileSystemStorageService.java",
        "target_method": "loadAsResource",
        "project_url": "https://github.com/OsamaTaher/Java-springboot-codebase",
        "commit_id": "c835c6f7799eacada4c0fc77e0816f250af01ad2^",
        "CWE_id": "CWE-36",
        "CVE_id": "CVE-2025-46822",
        "project_name": "Java-springboot-codebase",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "@Override\n    public Resource loadAsResource(String filename) {\n        try {\n            Path location = Paths.get(rootLocation+\"/\");\n            Path file = load(filename,location);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            }\n            else {\n              return null;\n            }\n        } catch (MalformedURLException e) {\n           log.error(\"[EXCEPTION] loadAsResource: {},{}\",e.getMessage(),e.getCause());\n           return null;\n        }\n    }"
    },
    {
        "target_file_name": "SystemHelper.java",
        "target_method": "createTempFile",
        "project_url": "https://github.com/codelibs/fess",
        "commit_id": "25b2009fea2a0f6ccd5aa8154aa54b536c08f6c4",
        "CWE_id": "CWE-732",
        "CVE_id": "CVE-2025-48382",
        "project_name": "fess",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setReadable",
            "setWritable"
        ],
        "target_code": "public File createTempFile(final String prefix, final String suffix) {\n        try {\n            final File file = File.createTempFile(prefix, suffix);\n            file.setReadable(false, false);\n            file.setReadable(true, true);\n            file.setWritable(false, false);\n            file.setWritable(true, true);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Create {} as a temp file.\", file.getAbsolutePath());\n            }\n            return file;\n        } catch (final IOException e) {\n            throw new IORuntimeException(e);\n        }\n    }"
    },
    {
        "target_file_name": "SystemHelper.java",
        "target_method": "createTempFile",
        "project_url": "https://github.com/codelibs/fess",
        "commit_id": "25b2009fea2a0f6ccd5aa8154aa54b536c08f6c4^",
        "CWE_id": "CWE-732",
        "CVE_id": "CVE-2025-48382",
        "project_name": "fess",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public File createTempFile(final String prefix, final String suffix) {\n        try {\n            final File file = File.createTempFile(prefix, suffix);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Create {} as a temp file.\", file.getAbsolutePath());\n            }\n            return file;\n        } catch (final IOException e) {\n            throw new IORuntimeException(e);\n        }\n    }"
    },
    {
        "target_file_name": "HealthUtils.java",
        "target_method": "saveConfigFile",
        "project_url": "https://github.com/Erudika/para",
        "commit_id": "1e8a89558542854bb0683ab234c4429ad93b0835",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-48955",
        "project_name": "para",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "info"
        ],
        "target_code": "private void saveConfigFile(String confFile, Map<String, String> rootAppCredentials) {\n\t\t\tif (rootAppCredentials.containsKey(\"secretKey\")) {\n\t\t\t\tString confString = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tconfString = loadConfigFile(confFile);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogger.info(\"Initialized root app with access key '{}', \"\n\t\t\t\t\t\t\t+ \"but could not write to {}.\", rootAppCredentials.get(\"accessKey\"), confFile);\n\t\t\t\t}\n\t\t\t\tString accessKey = \"para.root_access_key = \\\"\" + rootAppCredentials.get(\"accessKey\") + \"\\\"\";\n\t\t\t\tString secretKey = \"para.root_secret_key = \\\"\" + rootAppCredentials.get(\"secretKey\") + \"\\\"\";\n\t\t\t\tif (confString.contains(\"para.root_access_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_access_key\\\\s*=\\\\s*\\\".*?\\\"\", accessKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + accessKey;\n\t\t\t\t}\n\t\t\t\tif (confString.contains(\"para.root_secret_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_secret_key\\\\s*=\\\\s*\\\".*?\\\"\", secretKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + secretKey;\n\t\t\t\t}\n\t\t\t\tPara.getFileStore().store(confFile, new ByteArrayInputStream(confString.\n\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\n\t\t\t\tlogger.info(\"Saved root app credentials to {}.\", confFile);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Server is unhealthy - failed to initialize root app. Open http://localhost:\" +\n\t\t\t\t\t\tPara.getConfig().serverPort() + \"/v1/_setup in the browser to initialize Para manually.\");\n\t\t\t}\n\t\t}"
    },
    {
        "target_file_name": "HealthUtils.java",
        "target_method": "saveConfigFile",
        "project_url": "https://github.com/Erudika/para",
        "commit_id": "1e8a89558542854bb0683ab234c4429ad93b0835^",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-48955",
        "project_name": "para",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "get",
            "info"
        ],
        "target_code": "private void saveConfigFile(String confFile, Map<String, String> rootAppCredentials) {\n\t\t\tif (rootAppCredentials.containsKey(\"secretKey\")) {\n\t\t\t\tString confString = \"\";\n\t\t\t\ttry {\n\t\t\t\t\tconfString = loadConfigFile(confFile);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlogger.info(\"Initialized root app with access key '{}' and secret '{}', \"\n\t\t\t\t\t\t\t+ \"but could not write these to {}.\",\n\t\t\t\t\t\t\trootAppCredentials.get(\"accessKey\"), rootAppCredentials.get(\"secretKey\"), confFile);\n\t\t\t\t}\n\t\t\t\tString accessKey = \"para.root_access_key = \\\"\" + rootAppCredentials.get(\"accessKey\") + \"\\\"\";\n\t\t\t\tString secretKey = \"para.root_secret_key = \\\"\" + rootAppCredentials.get(\"secretKey\") + \"\\\"\";\n\t\t\t\tif (confString.contains(\"para.root_access_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_access_key\\\\s*=\\\\s*\\\".*?\\\"\", accessKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + accessKey;\n\t\t\t\t}\n\t\t\t\tif (confString.contains(\"para.root_secret_key\")) {\n\t\t\t\t\tconfString = confString.replaceAll(\"para\\\\.root_secret_key\\\\s*=\\\\s*\\\".*?\\\"\", secretKey);\n\t\t\t\t} else {\n\t\t\t\t\tconfString += \"\\n\" + secretKey;\n\t\t\t\t}\n\t\t\t\tPara.getFileStore().store(confFile, new ByteArrayInputStream(confString.\n\t\t\t\t\t\tgetBytes(StandardCharsets.UTF_8)));\n\t\t\t\tlogger.info(\"Saved root app credentials to {}.\", confFile);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Server is unhealthy - failed to initialize root app. Open http://localhost:\" +\n\t\t\t\t\t\tPara.getConfig().serverPort() + \"/v1/_setup in the browser to initialize Para manually.\");\n\t\t\t}\n\t\t}"
    },
    {
        "target_file_name": "FacebookAuthFilter.java",
        "target_method": "getOrCreateUser",
        "project_url": "https://github.com/Erudika/para",
        "commit_id": "46a908d887da02037384193f70a69345f04887cf",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-49009",
        "project_name": "para",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "warn"
        ],
        "target_code": "@SuppressWarnings(\"unchecked\")\n\tpublic UserAuthentication getOrCreateUser(App app, String accessToken) throws IOException {\n\t\tif (accessToken == null) {\n\t\t\treturn SecurityUtils.checkIfActive(null, null, false);\n\t\t}\n\t\tHttpGet profileGet = new HttpGet(PROFILE_URL + accessToken);\n\t\treturn httpclient.execute(profileGet, (resp2) -> {\n\t\t\tUserAuthentication userAuth = null;\n\t\t\tUser user = new User();\n\t\t\ttry {\n\t\t\t\tHttpEntity respEntity = resp2.getEntity();\n\t\t\t\tif (respEntity != null) {\n\t\t\t\t\tMap<String, Object> profile = jreader.readValue(respEntity.getContent());\n\n\t\t\t\t\tif (profile != null && profile.containsKey(\"id\")) {\n\t\t\t\t\t\tString fbId = (String) profile.get(\"id\");\n\t\t\t\t\t\tString email = (String) profile.get(\"email\");\n\t\t\t\t\t\tString name = (String) profile.get(\"name\");\n\n\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\tuser.setEmail(email);\n\t\t\t\t\t\tuser = User.readUserForIdentifier(user);\n\t\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\t\t//user is new\n\t\t\t\t\t\t\tuser = new User();\n\t\t\t\t\t\t\tuser.setActive(true);\n\t\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\t\tuser.setEmail(StringUtils.isBlank(email) ? Utils.getNewId() + \"@facebook.com\" : email);\n\t\t\t\t\t\t\tuser.setName(StringUtils.isBlank(name) ? \"No Name\" : name);\n\t\t\t\t\t\t\tuser.setPassword(Utils.generateSecurityToken());\n\t\t\t\t\t\t\tuser.setPicture(getPicture(fbId));\n\t\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\t\tString id = user.create();\n\t\t\t\t\t\t\tif (id == null) {\n\t\t\t\t\t\t\t\tthrow new AuthenticationServiceException(\"Authentication failed: cannot create new user.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (updateUserInfo(user, fbId, email, name)) {\n\t\t\t\t\t\t\t\tuser.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuserAuth = new UserAuthentication(new AuthenticatedUserDetails(user));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(\"Authentication request failed because user profile doesn't contain the expected attributes\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Authentication request failed because response was missing or contained invalid JSON.\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Facebook auth request failed: GET \" + PROFILE_URL + \"{access_token}\", e);\n\t\t\t}\n\t\t\treturn SecurityUtils.checkIfActive(userAuth, user, false);\n\t\t});\n\t}"
    },
    {
        "target_file_name": "FacebookAuthFilter.java",
        "target_method": "getOrCreateUser",
        "project_url": "https://github.com/Erudika/para",
        "commit_id": "46a908d887da02037384193f70a69345f04887cf^",
        "CWE_id": "CWE-532",
        "CVE_id": "CVE-2025-49009",
        "project_name": "para",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "warn"
        ],
        "target_code": "@SuppressWarnings(\"unchecked\")\n\tpublic UserAuthentication getOrCreateUser(App app, String accessToken) throws IOException {\n\t\tif (accessToken == null) {\n\t\t\treturn SecurityUtils.checkIfActive(null, null, false);\n\t\t}\n\t\tHttpGet profileGet = new HttpGet(PROFILE_URL + accessToken);\n\t\treturn httpclient.execute(profileGet, (resp2) -> {\n\t\t\tUserAuthentication userAuth = null;\n\t\t\tUser user = new User();\n\t\t\ttry {\n\t\t\t\tHttpEntity respEntity = resp2.getEntity();\n\t\t\t\tif (respEntity != null) {\n\t\t\t\t\tMap<String, Object> profile = jreader.readValue(respEntity.getContent());\n\n\t\t\t\t\tif (profile != null && profile.containsKey(\"id\")) {\n\t\t\t\t\t\tString fbId = (String) profile.get(\"id\");\n\t\t\t\t\t\tString email = (String) profile.get(\"email\");\n\t\t\t\t\t\tString name = (String) profile.get(\"name\");\n\n\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\tuser.setEmail(email);\n\t\t\t\t\t\tuser = User.readUserForIdentifier(user);\n\t\t\t\t\t\tif (user == null) {\n\t\t\t\t\t\t\t//user is new\n\t\t\t\t\t\t\tuser = new User();\n\t\t\t\t\t\t\tuser.setActive(true);\n\t\t\t\t\t\t\tuser.setAppid(getAppid(app));\n\t\t\t\t\t\t\tuser.setEmail(StringUtils.isBlank(email) ? Utils.getNewId() + \"@facebook.com\" : email);\n\t\t\t\t\t\t\tuser.setName(StringUtils.isBlank(name) ? \"No Name\" : name);\n\t\t\t\t\t\t\tuser.setPassword(Utils.generateSecurityToken());\n\t\t\t\t\t\t\tuser.setPicture(getPicture(fbId));\n\t\t\t\t\t\t\tuser.setIdentifier(Config.FB_PREFIX.concat(fbId));\n\t\t\t\t\t\t\tString id = user.create();\n\t\t\t\t\t\t\tif (id == null) {\n\t\t\t\t\t\t\t\tthrow new AuthenticationServiceException(\"Authentication failed: cannot create new user.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (updateUserInfo(user, fbId, email, name)) {\n\t\t\t\t\t\t\t\tuser.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tuserAuth = new UserAuthentication(new AuthenticatedUserDetails(user));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.info(\"Authentication request failed because user profile doesn't contain the expected attributes\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Authentication request failed because response was missing or contained invalid JSON.\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.warn(\"Facebook auth request failed: GET \" + PROFILE_URL + accessToken, e);\n\t\t\t}\n\t\t\treturn SecurityUtils.checkIfActive(userAuth, user, false);\n\t\t});\n\t}"
    },
    {
        "target_file_name": "AuthUtil.java",
        "target_method": "findMissingElements",
        "project_url": "https://github.com/JanssenProject/jans",
        "commit_id": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1",
        "CWE_id": "CWE-284",
        "CVE_id": "CVE-2025-53003",
        "project_name": "jans",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "isEmpty"
        ],
        "target_code": "public List<String> findMissingElements(List<String> list1, List<String> list2) {\n        if (list1 == null || list1.isEmpty()) {\n            return Collections.emptyList();\n        }\n        if(list2==null || list2.isEmpty()) {\n            return list1;\n        }\n        return list1.stream().filter(e -> !list2.contains(e)).collect(Collectors.toList());\n    }"
    },
    {
        "target_file_name": "OpenIdAuthorizationService.java",
        "target_method": "validateScope",
        "project_url": "https://github.com/JanssenProject/jans",
        "commit_id": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1",
        "CWE_id": "CWE-284",
        "CVE_id": "CVE-2025-53003",
        "project_name": "jans",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "info",
            "isEmpty"
        ],
        "target_code": "private String validateScope(String accessToken, List<String> tokenScopes, ResourceInfo resourceInfo, String issuer)\n            throws WebApplicationException {\n        logger.info(\"Validate scope, accessToken:{}, tokenScopes:{}, resourceInfo: {}, issuer: {}\", accessToken,\n                tokenScopes, resourceInfo, issuer);\n        try {\n            // Get resource scope\n            Map<ProtectionScopeType, List<String>> resourceScopesByType = getRequestedScopes(resourceInfo);\n            List<String> resourceScopes = getAllScopeList(resourceScopesByType);\n            logger.debug(\"Validate scope, resourceScopesByType: {}, resourceScopes: {}\", resourceScopesByType,\n                    resourceScopes);\n          \n            //If no scope required\n            if (resourceScopes == null || resourceScopes.isEmpty()) {\n                logger.info(\" If no resource scopes required return original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n            \n            // find missing scopes\n            List<String> missingScopes = findMissingScopes(resourceScopesByType, tokenScopes);\n            logger.info(\"missingScopes:{}\", missingScopes);\n\n            // Check if resource requires auth server specific scope\n            List<String> authSpecificScope = getAuthSpecificScopeRequired(resourceInfo);\n            logger.info(\" resourceScopes:{}, authSpecificScope:{} \", resourceScopes, authSpecificScope);\n\n            // If No auth scope required OR if token contains the authSpecificScope\n            if ((authSpecificScope == null || authSpecificScope.isEmpty())) {\n                logger.info(\"Validating token scopes as no authSpecificScope required\");\n                if ((missingScopes != null && !missingScopes.isEmpty())) {\n                    logger.error(\"Insufficient scopes! Required scope:{} -  however token scopes:{}\", resourceScopes,\n                            tokenScopes);\n                    throw new WebApplicationException(\"Insufficient scopes! , Required scope: \" + resourceScopes\n                            + \", however token scopes: \" + tokenScopes,\n                            Response.status(Response.Status.UNAUTHORIZED).build());\n                }\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            // If only authSpecificScope missing then proceed with token creation else throw\n            // error\n            if (missingScopes != null && !missingScopes.isEmpty()\n                    && !isEqualCollection(missingScopes, authSpecificScope)) {\n                logger.error(\"Insufficient scopes!! Required scope:{}, , however token scopes:{} \", resourceScopes,\n                        tokenScopes);\n                throw new WebApplicationException(\"Insufficient scopes!! , Required scope: \" + resourceScopes\n                        + \", however token scopes: \" + tokenScopes,\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n            \n            //If no scope is missing\n            if (missingScopes == null || missingScopes.isEmpty()) {\n                logger.info(\" No missing scopes and hence returning original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            logger.info(\"Generating new token with authSpecificScope\");\n            // Generate token with required resourceScopes\n            resourceScopes.addAll(authSpecificScope);\n            accessToken = openIdService.requestAccessToken(authUtil.getClientId(), resourceScopes);\n            logger.debug(\"Introspecting new accessToken:{}\", accessToken);\n\n            // Introspect\n            IntrospectionResponse introspectionResponse = openIdService\n                    .getIntrospectionResponse(AUTHENTICATION_SCHEME + accessToken, accessToken, authUtil.getIssuer());\n\n            // Validate Token Scope\n            if (!validateScope(introspectionResponse.getScope(), resourceScopes)) {\n                logger.error(\"Insufficient scopes!!! for new token as well - Required scope:{}, token scopes:{}\",\n                        resourceScopes, introspectionResponse.getScope());\n                throw new WebApplicationException(\n                        \"Insufficient scopes!!! Required scope: \" + resourceScopes + \", token scopes: \"\n                                + introspectionResponse.getScope(),\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n\n            logger.info(\"Token scopes Valid Returning accessToken:{}\", accessToken);\n            return AUTHENTICATION_SCHEME + accessToken;\n        } catch (Exception ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"oAuth authorization error:{} \", ex.getMessage());\n            }\n            throw new WebApplicationException(\"oAuth authorization error \" + ex.getMessage(),\n                    Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n    }"
    },
    {
        "target_file_name": "AuthUtil.java",
        "target_method": "findMissingElements",
        "project_url": "https://github.com/JanssenProject/jans",
        "commit_id": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1^",
        "CWE_id": "CWE-284",
        "CVE_id": "CVE-2025-53003",
        "project_name": "jans",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "isEmpty"
        ],
        "target_code": "public List<String> findMissingElements(List<String> list1, List<String> list2) {\n        if (list1 == null || list1.isEmpty() || list2 == null || list2.isEmpty()) {\n            return Collections.emptyList();\n        }\n        return list1.stream().filter(e -> !list2.contains(e)).collect(Collectors.toList());\n    }"
    },
    {
        "target_file_name": "OpenIdAuthorizationService.java",
        "target_method": "validateScope",
        "project_url": "https://github.com/JanssenProject/jans",
        "commit_id": "92eea4d4637f1cae16ad2f07b2c16378ff3fc5f1^",
        "CWE_id": "CWE-284",
        "CVE_id": "CVE-2025-53003",
        "project_name": "jans",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private String validateScope(String accessToken, List<String> tokenScopes, ResourceInfo resourceInfo, String issuer)\n            throws WebApplicationException {\n        logger.info(\"Validate scope, accessToken:{}, tokenScopes:{}, resourceInfo: {}, issuer: {}\", accessToken,\n                tokenScopes, resourceInfo, issuer);\n        try {\n            // Get resource scope\n            Map<ProtectionScopeType, List<String>> resourceScopesByType = getRequestedScopes(resourceInfo);\n            List<String> resourceScopes = getAllScopeList(resourceScopesByType);\n            logger.debug(\"Validate scope, resourceScopesByType: {}, resourceScopes: {}\", resourceScopesByType,\n                    resourceScopes);\n\n            // find missing scopes\n            List<String> missingScopes = findMissingScopes(resourceScopesByType, tokenScopes);\n            logger.info(\"missingScopes:{}\", missingScopes);\n\n            // Check if resource requires auth server specific scope\n            List<String> authSpecificScope = getAuthSpecificScopeRequired(resourceInfo);\n            logger.info(\" resourceScopes:{}, authSpecificScope:{} \", resourceScopes, authSpecificScope);\n\n            // If No auth scope required OR if token contains the authSpecificScope\n            if ((authSpecificScope == null || authSpecificScope.isEmpty())) {\n                logger.info(\"Validating token scopes as no authSpecificScope required\");\n                if ((missingScopes != null && !missingScopes.isEmpty())) {\n                    logger.error(\"Insufficient scopes! Required scope:{} -  however token scopes:{}\", resourceScopes,\n                            tokenScopes);\n                    throw new WebApplicationException(\"Insufficient scopes! , Required scope: \" + resourceScopes\n                            + \", however token scopes: \" + tokenScopes,\n                            Response.status(Response.Status.UNAUTHORIZED).build());\n                }\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            // If only authSpecificScope missing then proceed with token creation else throw\n            // error\n            if (missingScopes != null && !missingScopes.isEmpty()\n                    && !isEqualCollection(missingScopes, authSpecificScope)) {\n                logger.error(\"Insufficient scopes!! Required scope:{}, , however token scopes:{} \", resourceScopes,\n                        tokenScopes);\n                throw new WebApplicationException(\"Insufficient scopes!! , Required scope: \" + resourceScopes\n                        + \", however token scopes: \" + tokenScopes,\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n            \n            //If no scope is missing\n            if (missingScopes == null || missingScopes.isEmpty()) {\n                logger.info(\" No missing scopes and hence returning original accessToken\");\n                return AUTHENTICATION_SCHEME + accessToken;\n            }\n\n            logger.info(\"Generating new token with authSpecificScope\");\n            // Generate token with required resourceScopes\n            resourceScopes.addAll(authSpecificScope);\n            accessToken = openIdService.requestAccessToken(authUtil.getClientId(), resourceScopes);\n            logger.debug(\"Introspecting new accessToken:{}\", accessToken);\n\n            // Introspect\n            IntrospectionResponse introspectionResponse = openIdService\n                    .getIntrospectionResponse(AUTHENTICATION_SCHEME + accessToken, accessToken, authUtil.getIssuer());\n\n            // Validate Token Scope\n            if (!validateScope(introspectionResponse.getScope(), resourceScopes)) {\n                logger.error(\"Insufficient scopes!!! for new token as well - Required scope:{}, token scopes:{}\",\n                        resourceScopes, introspectionResponse.getScope());\n                throw new WebApplicationException(\n                        \"Insufficient scopes!!! Required scope: \" + resourceScopes + \", token scopes: \"\n                                + introspectionResponse.getScope(),\n                        Response.status(Response.Status.UNAUTHORIZED).build());\n            }\n\n            logger.info(\"Token scopes Valid Returning accessToken:{}\", accessToken);\n            return AUTHENTICATION_SCHEME + accessToken;\n        } catch (Exception ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"oAuth authorization error:{} \", ex.getMessage());\n            }\n            throw new WebApplicationException(\"oAuth authorization error \" + ex.getMessage(),\n                    Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());\n        }\n    }"
    },
    {
        "target_file_name": "ConnectionFactoryImpl.java",
        "target_method": "doAuthentication",
        "project_url": "https://github.com/pgjdbc/pgjdbc",
        "commit_id": "9217ed16cb2918ab1b6b9258ae97e6ede244d8a0",
        "CWE_id": "CWE-287",
        "CVE_id": "CVE-2025-49146",
        "project_name": "pgjdbc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getAuthenticationMethodName",
            "of",
            "tr"
        ],
        "target_code": "private static void doAuthentication(PGStream pgStream, String host, String user, Properties info) throws IOException, SQLException {\n    // Now get the response from the backend, either an error message\n    // or an authentication request\n\n    /* SSPI negotiation state, if used */\n    ISSPIClient sspiClient = null;\n\n    /* SCRAM authentication state, if used */\n    ScramAuthenticator scramAuthenticator = null;\n    // TODO: figure out how to deal with new protocols\n    int protocol = 3 << 16;\n\n    boolean saslHandshakeCompleted = false;\n\n    try {\n      authloop: while (true) {\n        int beresp = pgStream.receiveChar();\n\n        switch (beresp) {\n          case PgMessageType.NEGOTIATE_PROTOCOL_RESPONSE:  // Negotiate Protocol Version\n            // read the length and ignore it.\n            pgStream.receiveInteger4();\n            protocol = pgStream.receiveInteger4();\n            int numOptionsNotRecognized = pgStream.receiveInteger4();\n            if (numOptionsNotRecognized > 0) {\n              // do not connect and throw an error\n              String errorMessage = \"Protocol error, received invalid options: \";\n              for (int i = 0; i < numOptionsNotRecognized; i++) {\n                errorMessage  += i > 0 ? \"\" : \",\" + pgStream.receiveString();\n              }\n              LOGGER.log(Level.FINEST, errorMessage);\n              throw new PSQLException(errorMessage, PSQLState.PROTOCOL_VIOLATION);\n            }\n            int major = protocol >> 16 & 0xff;\n            int minor = protocol & 0xff;\n            pgStream.setProtocolVersion( ProtocolVersion.fromMajorMinor(major, minor));\n            break;\n          case PgMessageType.ERROR_RESPONSE:\n            // An error occurred, so pass the error message to the\n            // user.\n            //\n            // The most common one to be thrown here is:\n            // \"User authentication failed\"\n            //\n            int elen = pgStream.receiveInteger4();\n\n            ServerErrorMessage errorMsg =\n                new ServerErrorMessage(pgStream.receiveErrorString(elen - 4));\n            LOGGER.log(Level.FINEST, \" <=BE ErrorMessage({0})\", errorMsg);\n            throw new PSQLException(errorMsg, PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n\n          case PgMessageType.AUTHENTICATION_RESPONSE:\n            // Authentication request.\n            // Get the message length\n            int msgLen = pgStream.receiveInteger4();\n\n            // Get the type of request\n            int areq = pgStream.receiveInteger4();\n\n            if (ChannelBindingOption.of(info) == ChannelBindingOption.REQUIRE) {\n              if (areq == AUTH_REQ_OK) {\n                if (!saslHandshakeCompleted) {\n                  throw new PSQLException(\n                      GT.tr(\"Channel binding is required, but server skipped authentication. \"\n                          + \"Channel binding is only supported with SCRAM authentication over encrypted connections.\"),\n                      PSQLState.CONNECTION_REJECTED);\n                }\n              } else if (areq != AUTH_REQ_SASL && areq != AUTH_REQ_SASL_CONTINUE && areq != AUTH_REQ_SASL_FINAL) {\n                throw new PSQLException(\n                      GT.tr(\"Channel binding is required, but server requested ''{0}'' authentication. \"\n                          + \"Channel binding is only supported with SCRAM authentication over encrypted connections.\",\n                          getAuthenticationMethodName(areq)),\n                      PSQLState.CONNECTION_REJECTED);\n              }\n            }\n\n            // Process the request.\n            switch (areq) {\n              case AUTH_REQ_MD5: {\n                byte[] md5Salt = pgStream.receive(4);\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" <=BE AuthenticationReqMD5(salt={0})\", Utils.toHexString(md5Salt));\n                }\n\n                byte[] digest = AuthenticationPluginManager.withEncodedPassword(\n                    AuthenticationRequestType.MD5_PASSWORD, info,\n                    encodedPassword -> MD5Digest.encode(user.getBytes(StandardCharsets.UTF_8),\n                        encodedPassword, md5Salt)\n                );\n\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" FE=> Password(md5digest={0})\", new String(digest, StandardCharsets.US_ASCII));\n                }\n\n                try {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + digest.length + 1);\n                  pgStream.send(digest);\n                } finally {\n                  Arrays.fill(digest, (byte) 0);\n                }\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_PASSWORD: {\n                LOGGER.log(Level.FINEST, \"<=BE AuthenticationReqPassword\");\n                LOGGER.log(Level.FINEST, \" FE=> Password(password=<not shown>)\");\n\n                AuthenticationPluginManager.withEncodedPassword(AuthenticationRequestType.CLEARTEXT_PASSWORD, info, encodedPassword -> {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + encodedPassword.length + 1);\n                  pgStream.send(encodedPassword);\n                  return void.class;\n                });\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_GSS:\n              case AUTH_REQ_SSPI:\n                /*\n                 * Use GSSAPI if requested on all platforms, via JSSE.\n                 *\n                 * For SSPI auth requests, if we're on Windows attempt native SSPI authentication if\n                 * available, and if not disabled by setting a kerberosServerName. On other\n                 * platforms, attempt JSSE GSSAPI negotiation with the SSPI server.\n                 *\n                 * Note that this is slightly different to libpq, which uses SSPI for GSSAPI where\n                 * supported. We prefer to use the existing Java JSSE Kerberos support rather than\n                 * going to native (via JNA) calls where possible, so that JSSE system properties\n                 * etc continue to work normally.\n                 *\n                 * Note that while SSPI is often Kerberos-based there's no guarantee it will be; it\n                 * may be NTLM or anything else. If the client responds to an SSPI request via\n                 * GSSAPI and the other end isn't using Kerberos for SSPI then authentication will\n                 * fail.\n                 */\n                final String gsslib = PGProperty.GSS_LIB.getOrDefault(info);\n                final boolean usespnego = PGProperty.USE_SPNEGO.getBoolean(info);\n\n                boolean useSSPI = false;\n\n                /*\n                 * Use SSPI if we're in auto mode on windows and have a request for SSPI auth, or if\n                 * it's forced. Otherwise use gssapi. If the user has specified a Kerberos server\n                 * name we'll always use JSSE GSSAPI.\n                 */\n                if (\"gssapi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE, \"Using JSSE GSSAPI, param gsslib=gssapi\");\n                } else if (areq == AUTH_REQ_GSS && !\"sspi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE,\n                      \"Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced\");\n                } else {\n                  /* Determine if SSPI is supported by the client */\n                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.getOrDefault(info),\n                      /* Use negotiation for SSPI, or if explicitly requested for GSS */\n                      areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego));\n\n                  useSSPI = sspiClient.isSSPISupported();\n                  LOGGER.log(Level.FINE, \"SSPI support detected: {0}\", useSSPI);\n\n                  if (!useSSPI) {\n                    /* No need to dispose() if no SSPI used */\n                    sspiClient = null;\n\n                    if (\"sspi\".equals(gsslib)) {\n                      throw new PSQLException(\n                          \"SSPI forced with gsslib=sspi, but SSPI not available; set loglevel=2 for details\",\n                          PSQLState.CONNECTION_UNABLE_TO_CONNECT);\n                    }\n                  }\n\n                  if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Using SSPI: {0}, gsslib={1} and SSPI support detected\", new Object[]{useSSPI, gsslib});\n                  }\n                }\n\n                if (useSSPI) {\n                  /* SSPI requested and detected as available */\n                  castNonNull(sspiClient).startSSPI();\n                } else {\n                  /* Use JGSS's GSSAPI for this request */\n                  AuthenticationPluginManager.withPassword(AuthenticationRequestType.GSS, info, password -> {\n                    MakeGSS.authenticate(false, pgStream, host, user, password,\n                        PGProperty.JAAS_APPLICATION_NAME.getOrDefault(info),\n                        PGProperty.KERBEROS_SERVER_NAME.getOrDefault(info), usespnego,\n                        PGProperty.JAAS_LOGIN.getBoolean(info),\n                        PGProperty.GSS_USE_DEFAULT_CREDS.getBoolean(info),\n                        PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n                    return void.class;\n                  });\n                }\n                break;\n\n              case AUTH_REQ_GSS_CONTINUE:\n                /*\n                 * Only called for SSPI, as GSS is handled by an inner loop in MakeGSS.\n                 */\n                castNonNull(sspiClient).continueSSPI(msgLen - 8);\n                break;\n\n              case AUTH_REQ_SASL:\n                scramAuthenticator = AuthenticationPluginManager.withPassword(AuthenticationRequestType.SASL, info, password -> {\n                  if (password == null) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but no password was provided.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  if (password.length == 0) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but the password is an empty string.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  return new ScramAuthenticator(password, pgStream, info);\n                });\n                scramAuthenticator.handleAuthenticationSASL();\n                break;\n\n              case AUTH_REQ_SASL_CONTINUE:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLContinue(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_SASL_FINAL:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLFinal(msgLen - 4 - 4);\n                saslHandshakeCompleted = true;\n                break;\n\n              case AUTH_REQ_OK:\n                /* Cleanup after successful authentication */\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationOk\");\n                break authloop; // We're done.\n\n              default:\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationReq (unsupported type {0})\", areq);\n                throw new PSQLException(GT.tr(\n                    \"The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.\",\n                    areq), PSQLState.CONNECTION_REJECTED);\n            }\n\n            break;\n\n          default:\n            throw new PSQLException(GT.tr(\"Protocol error.  Session setup failed.\"),\n                PSQLState.PROTOCOL_VIOLATION);\n        }\n      }\n    } finally {\n      /* Cleanup after successful or failed authentication attempts */\n      if (sspiClient != null) {\n        try {\n          sspiClient.dispose();\n        } catch (RuntimeException ex) {\n          LOGGER.log(Level.FINE, \"Unexpected error during SSPI context disposal\", ex);\n        }\n      }\n    }\n  }"
    },
    {
        "target_file_name": "ConnectionFactoryImpl.java",
        "target_method": "doAuthentication",
        "project_url": "https://github.com/pgjdbc/pgjdbc",
        "commit_id": "9217ed16cb2918ab1b6b9258ae97e6ede244d8a0^",
        "CWE_id": "CWE-287",
        "CVE_id": "CVE-2025-49146",
        "project_name": "pgjdbc",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private static void doAuthentication(PGStream pgStream, String host, String user, Properties info) throws IOException, SQLException {\n    // Now get the response from the backend, either an error message\n    // or an authentication request\n\n    /* SSPI negotiation state, if used */\n    ISSPIClient sspiClient = null;\n\n    /* SCRAM authentication state, if used */\n    ScramAuthenticator scramAuthenticator = null;\n    // TODO: figure out how to deal with new protocols\n    int protocol = 3 << 16;\n\n    try {\n      authloop: while (true) {\n        int beresp = pgStream.receiveChar();\n\n        switch (beresp) {\n          case PgMessageType.NEGOTIATE_PROTOCOL_RESPONSE:  // Negotiate Protocol Version\n            // read the length and ignore it.\n            pgStream.receiveInteger4();\n            protocol = pgStream.receiveInteger4();\n            int numOptionsNotRecognized = pgStream.receiveInteger4();\n            if (numOptionsNotRecognized > 0) {\n              // do not connect and throw an error\n              String errorMessage = \"Protocol error, received invalid options: \";\n              for (int i = 0; i < numOptionsNotRecognized; i++) {\n                errorMessage  += i > 0 ? \"\" : \",\" + pgStream.receiveString();\n              }\n              LOGGER.log(Level.FINEST, errorMessage);\n              throw new PSQLException(errorMessage, PSQLState.PROTOCOL_VIOLATION);\n            }\n            int major = protocol >> 16 & 0xff;\n            int minor = protocol & 0xff;\n            pgStream.setProtocolVersion( ProtocolVersion.fromMajorMinor(major, minor));\n            break;\n          case PgMessageType.ERROR_RESPONSE:\n            // An error occurred, so pass the error message to the\n            // user.\n            //\n            // The most common one to be thrown here is:\n            // \"User authentication failed\"\n            //\n            int elen = pgStream.receiveInteger4();\n\n            ServerErrorMessage errorMsg =\n                new ServerErrorMessage(pgStream.receiveErrorString(elen - 4));\n            LOGGER.log(Level.FINEST, \" <=BE ErrorMessage({0})\", errorMsg);\n            throw new PSQLException(errorMsg, PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n\n          case PgMessageType.AUTHENTICATION_RESPONSE:\n            // Authentication request.\n            // Get the message length\n            int msgLen = pgStream.receiveInteger4();\n\n            // Get the type of request\n            int areq = pgStream.receiveInteger4();\n\n            // Process the request.\n            switch (areq) {\n              case AUTH_REQ_MD5: {\n                byte[] md5Salt = pgStream.receive(4);\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" <=BE AuthenticationReqMD5(salt={0})\", Utils.toHexString(md5Salt));\n                }\n\n                byte[] digest = AuthenticationPluginManager.withEncodedPassword(\n                    AuthenticationRequestType.MD5_PASSWORD, info,\n                    encodedPassword -> MD5Digest.encode(user.getBytes(StandardCharsets.UTF_8),\n                        encodedPassword, md5Salt)\n                );\n\n                if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.log(Level.FINEST, \" FE=> Password(md5digest={0})\", new String(digest, StandardCharsets.US_ASCII));\n                }\n\n                try {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + digest.length + 1);\n                  pgStream.send(digest);\n                } finally {\n                  Arrays.fill(digest, (byte) 0);\n                }\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_PASSWORD: {\n                LOGGER.log(Level.FINEST, \"<=BE AuthenticationReqPassword\");\n                LOGGER.log(Level.FINEST, \" FE=> Password(password=<not shown>)\");\n\n                AuthenticationPluginManager.withEncodedPassword(AuthenticationRequestType.CLEARTEXT_PASSWORD, info, encodedPassword -> {\n                  pgStream.sendChar(PgMessageType.PASSWORD_REQUEST);\n                  pgStream.sendInteger4(4 + encodedPassword.length + 1);\n                  pgStream.send(encodedPassword);\n                  return void.class;\n                });\n                pgStream.sendChar(0);\n                pgStream.flush();\n\n                break;\n              }\n\n              case AUTH_REQ_GSS:\n              case AUTH_REQ_SSPI:\n                /*\n                 * Use GSSAPI if requested on all platforms, via JSSE.\n                 *\n                 * For SSPI auth requests, if we're on Windows attempt native SSPI authentication if\n                 * available, and if not disabled by setting a kerberosServerName. On other\n                 * platforms, attempt JSSE GSSAPI negotiation with the SSPI server.\n                 *\n                 * Note that this is slightly different to libpq, which uses SSPI for GSSAPI where\n                 * supported. We prefer to use the existing Java JSSE Kerberos support rather than\n                 * going to native (via JNA) calls where possible, so that JSSE system properties\n                 * etc continue to work normally.\n                 *\n                 * Note that while SSPI is often Kerberos-based there's no guarantee it will be; it\n                 * may be NTLM or anything else. If the client responds to an SSPI request via\n                 * GSSAPI and the other end isn't using Kerberos for SSPI then authentication will\n                 * fail.\n                 */\n                final String gsslib = PGProperty.GSS_LIB.getOrDefault(info);\n                final boolean usespnego = PGProperty.USE_SPNEGO.getBoolean(info);\n\n                boolean useSSPI = false;\n\n                /*\n                 * Use SSPI if we're in auto mode on windows and have a request for SSPI auth, or if\n                 * it's forced. Otherwise use gssapi. If the user has specified a Kerberos server\n                 * name we'll always use JSSE GSSAPI.\n                 */\n                if (\"gssapi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE, \"Using JSSE GSSAPI, param gsslib=gssapi\");\n                } else if (areq == AUTH_REQ_GSS && !\"sspi\".equals(gsslib)) {\n                  LOGGER.log(Level.FINE,\n                      \"Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced\");\n                } else {\n                  /* Determine if SSPI is supported by the client */\n                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.getOrDefault(info),\n                      /* Use negotiation for SSPI, or if explicitly requested for GSS */\n                      areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego));\n\n                  useSSPI = sspiClient.isSSPISupported();\n                  LOGGER.log(Level.FINE, \"SSPI support detected: {0}\", useSSPI);\n\n                  if (!useSSPI) {\n                    /* No need to dispose() if no SSPI used */\n                    sspiClient = null;\n\n                    if (\"sspi\".equals(gsslib)) {\n                      throw new PSQLException(\n                          \"SSPI forced with gsslib=sspi, but SSPI not available; set loglevel=2 for details\",\n                          PSQLState.CONNECTION_UNABLE_TO_CONNECT);\n                    }\n                  }\n\n                  if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE, \"Using SSPI: {0}, gsslib={1} and SSPI support detected\", new Object[]{useSSPI, gsslib});\n                  }\n                }\n\n                if (useSSPI) {\n                  /* SSPI requested and detected as available */\n                  castNonNull(sspiClient).startSSPI();\n                } else {\n                  /* Use JGSS's GSSAPI for this request */\n                  AuthenticationPluginManager.withPassword(AuthenticationRequestType.GSS, info, password -> {\n                    MakeGSS.authenticate(false, pgStream, host, user, password,\n                        PGProperty.JAAS_APPLICATION_NAME.getOrDefault(info),\n                        PGProperty.KERBEROS_SERVER_NAME.getOrDefault(info), usespnego,\n                        PGProperty.JAAS_LOGIN.getBoolean(info),\n                        PGProperty.GSS_USE_DEFAULT_CREDS.getBoolean(info),\n                        PGProperty.LOG_SERVER_ERROR_DETAIL.getBoolean(info));\n                    return void.class;\n                  });\n                }\n                break;\n\n              case AUTH_REQ_GSS_CONTINUE:\n                /*\n                 * Only called for SSPI, as GSS is handled by an inner loop in MakeGSS.\n                 */\n                castNonNull(sspiClient).continueSSPI(msgLen - 8);\n                break;\n\n              case AUTH_REQ_SASL:\n                scramAuthenticator = AuthenticationPluginManager.withPassword(AuthenticationRequestType.SASL, info, password -> {\n                  if (password == null) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but no password was provided.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  if (password.length == 0) {\n                    throw new PSQLException(\n                        GT.tr(\n                            \"The server requested SCRAM-based authentication, but the password is an empty string.\"),\n                        PSQLState.CONNECTION_REJECTED);\n                  }\n                  return new ScramAuthenticator(password, pgStream, info);\n                });\n                scramAuthenticator.handleAuthenticationSASL();\n                break;\n\n              case AUTH_REQ_SASL_CONTINUE:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLContinue(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_SASL_FINAL:\n                castNonNull(scramAuthenticator).handleAuthenticationSASLFinal(msgLen - 4 - 4);\n                break;\n\n              case AUTH_REQ_OK:\n                /* Cleanup after successful authentication */\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationOk\");\n                break authloop; // We're done.\n\n              default:\n                LOGGER.log(Level.FINEST, \" <=BE AuthenticationReq (unsupported type {0})\", areq);\n                throw new PSQLException(GT.tr(\n                    \"The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.\",\n                    areq), PSQLState.CONNECTION_REJECTED);\n            }\n\n            break;\n\n          default:\n            throw new PSQLException(GT.tr(\"Protocol error.  Session setup failed.\"),\n                PSQLState.PROTOCOL_VIOLATION);\n        }\n      }\n    } finally {\n      /* Cleanup after successful or failed authentication attempts */\n      if (sspiClient != null) {\n        try {\n          sspiClient.dispose();\n        } catch (RuntimeException ex) {\n          LOGGER.log(Level.FINE, \"Unexpected error during SSPI context disposal\", ex);\n        }\n      }\n    }\n  }"
    },
    {
        "target_file_name": "OIDCTest.java",
        "target_method": "init",
        "project_url": "https://github.com/xwiki-contrib/oidc",
        "commit_id": "d90d717172283aaa96bb5bb44e357f910ae64adb",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-49594",
        "project_name": "oidc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "asList"
        ],
        "target_code": "@BeforeClass\n    public static void init() throws Exception\n    {\n        // This will not be null if we are in the middle of allTests\n        if (context == null) {\n            PersistentTestContext persistentTestContext =\n                new PersistentTestContext(Arrays.asList(new XWikiExecutor(0)/* , new XWikiExecutor(1) */));\n            initializeSystem(persistentTestContext);\n\n            // Start XWiki\n            persistentTestContext.start();\n\n            // Cache the initial CSRF token since that token needs to be passed to all forms (this is done automatically\n            // in TestUtils), including the login form. Whenever a new user logs in we need to recache.\n            // Note that this requires a running XWiki instance.\n            getUtil().recacheSecretToken();\n        }\n    }"
    },
    {
        "target_file_name": "OIDCTest.java",
        "target_method": "init",
        "project_url": "https://github.com/xwiki-contrib/oidc",
        "commit_id": "d90d717172283aaa96bb5bb44e357f910ae64adb^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-49594",
        "project_name": "oidc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "asList"
        ],
        "target_code": "@BeforeClass\n    public static void init() throws Exception\n    {\n        // This will not be null if we are in the middle of allTests\n        if (context == null) {\n            PersistentTestContext persistentTestContext =\n                new PersistentTestContext(Arrays.asList(new XWikiExecutor(0)/*, new XWikiExecutor(1)*/));\n            initializeSystem(persistentTestContext);\n\n            // Start XWiki\n            persistentTestContext.start();\n\n            // Cache the initial CSRF token since that token needs to be passed to all forms (this is done automatically\n            // in TestUtils), including the login form. Whenever a new user logs in we need to recache.\n            // Note that this requires a running XWiki instance.\n            getUtil().recacheSecretToken();\n        }\n    }"
    },
    {
        "target_file_name": "OIDCTest.java",
        "target_method": "logout",
        "project_url": "https://github.com/xwiki-contrib/oidc",
        "commit_id": "d90d717172283aaa96bb5bb44e357f910ae64adb",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-49594",
        "project_name": "oidc",
        "is_vulnerable": false,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private void logout(int index)\n    {\n        getUtil().switchExecutor(index);\n        getUtil().gotoPage(getURL(index, \"/bin/logout/XWiki/XWikiLogout?xredirect=%2Fxwiki%2Fbin%2Fview%2FMain%2F\"));\n    }"
    },
    {
        "target_file_name": "OIDCTest.java",
        "target_method": "logout",
        "project_url": "https://github.com/xwiki-contrib/oidc",
        "commit_id": "d90d717172283aaa96bb5bb44e357f910ae64adb^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-49594",
        "project_name": "oidc",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private void logout(int index)\n    {\n        getUtil().switchExecutor(index);\n        getUtil().gotoPage(getURL(index, \"/bin/logout/XWiki/XWikiLogout?xredirect=%2Fxwiki%2Fbin%2Fview%2FMain%2F\"));\n    }"
    },
    {
        "target_file_name": "OIDCTest.java",
        "target_method": "authenticate",
        "project_url": "https://github.com/xwiki-contrib/oidc",
        "commit_id": "d90d717172283aaa96bb5bb44e357f910ae64adb",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-49594",
        "project_name": "oidc",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "assertFalse",
            "getURL",
            "getUtil",
            "gotToLogin",
            "gotoPage",
            "isAllowed"
        ],
        "target_code": "@Test\n    public void authenticate() throws Exception\n    {\n        cleanupClient();\n        cleanupProvider();\n\n        // Create a user on the provider\n        gotoHome(1);\n        getUtil().recacheSecretToken();\n        getUtil().createUser(\"provideruser\", \"providerpassword\", null);\n\n        // Go to token management of provideruser\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        // Make sure guest user is not allowed to access the user token management\n        assertFalse(OIDCApplicationsUserProfilePage.isAllowed());\n\n        // Login on the client\n        gotToLogin(0);\n\n        // We are asked for the provider to use, set it\n        OIDCClientProviderPage providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        LoginPage loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // A consent is asked, accept\n        OIDCProviderConsentPage consentPage = new OIDCProviderConsentPage();\n        consentPage.clickAccept();\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Log out of the client\n        logout(0);\n\n        // We are logged out of the provider and come back on the client\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure we are logged out of the client\n        assertNull(getCurrentUserReference());\n\n        // Make sure we are logged out of the provider too\n        gotoHome(1);\n        assertNull(getCurrentUserReference());\n\n        // Login again\n        gotToLogin(0);\n\n        // We are asked for the provider to use, set it\n        providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // No consent is needed this time\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Make sure the user is logged in the provider\n        gotoHome(1);\n        assertEquals(\"xwiki:XWiki.provideruser\", getCurrentUserReference());\n\n        // Create a token on the provider\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        OIDCApplicationsUserProfilePage applications = new OIDCApplicationsUserProfilePage(\"provideruser\");\n\n        applications.setApplicationName(\"My Application\");\n        applications = applications.clickCreate();\n\n        String token = applications.getToken();\n\n        URL url = new URL(getURL(1, \"/rest/\"));\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n        connection.connect();\n\n        assertEquals(\"xwiki:XWiki.provideruser\", connection.getHeaderField(\"XWiki-User\"));\n\n        // TODO: Add support on provider side to automatically catch standard logout and send a backchannel logout to\n        // all registered clients\n        // Log out of the provider\n        // logout(1);\n        //\n        // Make sure we are logged out of the provider\n        // assertNull(getCurrentUserReference());\n        //\n        // Make sure we are also logged out of the client\n        // gotoHome(0);\n        // assertNull(getCurrentUserReference());\n    }"
    },
    {
        "target_file_name": "OIDCTest.java",
        "target_method": "authenticate",
        "project_url": "https://github.com/xwiki-contrib/oidc",
        "commit_id": "d90d717172283aaa96bb5bb44e357f910ae64adb^",
        "CWE_id": "CWE-285",
        "CVE_id": "CVE-2025-49594",
        "project_name": "oidc",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "gotToClientLogin"
        ],
        "target_code": "@Test\n    public void authenticate() throws Exception\n    {\n        cleanupClient();\n        cleanupProvider();\n\n        // Create a user on the provider\n        gotoHome(1);\n        getUtil().recacheSecretToken();\n        getUtil().createUser(\"provideruser\", \"providerpassword\", null);\n\n        // Login on the client\n        gotToClientLogin();\n\n        // We are asked for the provider to use, set it\n        OIDCClientProviderPage providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        LoginPage loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // A consent is asked, accept\n        OIDCProviderConsentPage consentPage = new OIDCProviderConsentPage();\n        consentPage.clickAccept();\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Log out of the client\n        logout(0);\n\n        // We are logged out of the provider and come back on the client\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure we are logged out of the client\n        assertNull(getCurrentUserReference());\n\n        // Make sure we are logged out of the provider too\n        gotoHome(1);\n        assertNull(getCurrentUserReference());\n\n        // Login again\n        gotToClientLogin();\n\n        // We are asked for the provider to use, set it\n        providerPage = new OIDCClientProviderPage();\n        providerPage.setProvider(getURL(1, \"/oidc\"));\n\n        // Start authentication\n        providerPage.clickAuthenticate();\n\n        // It gets redirected to the provider login page, login\n        loginPage = new LoginPage();\n        loginPage.loginAs(\"provideruser\", \"providerpassword\");\n        // No consent is needed this time\n\n        // It gets redirected back to the client authenticated with the remote user\n        assertEquals(getHomeURL(0), getUtil().getDriver().getCurrentUrl());\n\n        // Make sure the we are authenticated and we get the expected id on client side\n        assertEquals(\"xwiki:XWiki.127001-provideruser\", getCurrentUserReference());\n\n        // Make sure the user is logged in the provider\n        gotoHome(1);\n        assertEquals(\"xwiki:XWiki.provideruser\", getCurrentUserReference());\n\n        // Create a token on the provider\n        getUtil().gotoPage(getURL(1, \"/bin/view/XWiki/provideruser?category=userapplications\"));\n        OIDCApplicationsUserProfilePage applications = new OIDCApplicationsUserProfilePage(\"provideruser\");\n\n        applications.setApplicationName(\"My Application\");\n        applications = applications.clickCreate();\n\n        String token = applications.getToken();\n\n        URL url = new URL(getURL(1, \"/rest/\"));\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"Authorization\", \"Bearer \" + token);\n        connection.connect();\n\n        assertEquals(\"xwiki:XWiki.provideruser\", connection.getHeaderField(\"XWiki-User\"));\n\n        // TODO: Add support on provider side to automatically catch standard logout and send a backchannel logout to\n        // all registered clients\n        // Log out of the provider\n        // logout(1);\n        //\n        // Make sure we are logged out of the provider\n        // assertNull(getCurrentUserReference());\n        //\n        // Make sure we are also logged out of the client\n        // gotoHome(0);\n        // assertNull(getCurrentUserReference());\n    }"
    },
    {
        "target_file_name": "ModificationsResourceImpl.java",
        "target_method": "getModifications",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "format",
            "getValidQueryOrder",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public History getModifications(String wikiName, Integer start, Integer number, String order, Long ts,\n            Boolean withPrettyNames) throws XWikiRestException\n    {\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            History history = new History();\n\n            String query = String.format(\"select doc.space, doc.name, doc.language, rcs.id, rcs.date, rcs.author,\"\n                + \" rcs.comment from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" rcs.date > :date order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\",\n                validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"date\", new Date(ts))\n                .setLimit(number).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[0];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[1];\n\n                DocumentReference documentReference =\n                    this.resolver.resolve(Utils.getPageId(wikiName, spaces, pageName));\n                if (this.authorizationManager.hasAccess(VIEW, documentReference)) {\n                    String language = (String) fields[2];\n                    if (language.equals(\"\")) {\n                        language = null;\n                    }\n                    XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[3];\n                    Timestamp timestamp = (Timestamp) fields[4];\n                    Date modified = new Date(timestamp.getTime());\n                    String modifier = (String) fields[5];\n                    String comment = (String) fields[6];\n\n                    HistorySummary historySummary =\n                        DomainObjectFactory.createHistorySummary(this.objectFactory, this.uriInfo.getBaseUri(),\n                            wikiName, spaces, pageName, language, nodeId.getVersion(), modifier, modified, comment,\n                            Utils.getXWikiApi(this.componentManager), withPrettyNames);\n                    history.getHistorySummaries().add(historySummary);\n                }\n            }\n\n            return history;\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n    }"
    },
    {
        "target_file_name": "PageHistoryResourceImpl.java",
        "target_method": "getPageHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "format",
            "getValidQueryOrder",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public History getPageHistory(String wikiName, String spaceName, String pageName, Integer start, Integer number,\n            String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            // Note that the query is made to work with Oracle which treats empty strings as null.\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and (doc.language = '' or doc.language is null)\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n\n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName).setLimit(number).setOffset(start).setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, null, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }"
    },
    {
        "target_file_name": "PageTranslationHistoryResourceImpl.java",
        "target_method": "getPageTranslationHistory",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "format",
            "getValidQueryOrder",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "@Override\n    public History getPageTranslationHistory(String wikiName, String spaceName, String pageName, String language,\n            Integer start, Integer number, String order, Boolean withPrettyNames) throws XWikiRestException\n    {\n        List<String> spaces = parseSpaceSegments(spaceName);\n\n        DocumentReference documentReference = new DocumentReference(wikiName, spaces, pageName);\n        try {\n            this.contextualAuthorizationManager.checkAccess(Right.VIEW, documentReference);\n        } catch (AccessDeniedException e) {\n            throw new WebApplicationException(Response.Status.UNAUTHORIZED);\n        }\n\n        String spaceId = Utils.getLocalSpaceId(spaces);\n\n        History history = new History();\n\n        try {\n            String validOrder = HqlQueryUtils.getValidQueryOrder(order, \"desc\");\n\n            String query = String.format(\"select doc.space, doc.name, rcs.id, rcs.date, rcs.author, rcs.comment\"\n                + \" from XWikiRCSNodeInfo as rcs, XWikiDocument as doc where rcs.id.docId = doc.id and\"\n                + \" doc.space = :space and doc.name = :name and doc.language = :language\"\n                + \" order by rcs.date %s, rcs.id.version1 %s, rcs.id.version2 %s\", validOrder, validOrder, validOrder);\n            \n            List<Object> queryResult = null;\n            queryResult = this.queryManager.createQuery(query, Query.XWQL).bindValue(\"space\", spaceId)\n                .bindValue(\"name\", pageName).setLimit(number).bindValue(\"language\", language).setOffset(start)\n                .setWiki(wikiName).execute();\n\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                XWikiRCSNodeId nodeId = (XWikiRCSNodeId) fields[2];\n                Timestamp timestamp = (Timestamp) fields[3];\n                Date modified = new Date(timestamp.getTime());\n                String modifier = (String) fields[4];\n                String comment = (String) fields[5];\n\n                HistorySummary historySummary = DomainObjectFactory.createHistorySummary(objectFactory,\n                        uriInfo.getBaseUri(), wikiName, spaces, pageName, language, nodeId.getVersion(), modifier,\n                        modified, comment, Utils.getXWikiApi(componentManager), withPrettyNames);\n\n                history.getHistorySummaries().add(historySummary);\n            }\n        } catch (QueryException e) {\n            throw new XWikiRestException(e);\n        }\n\n        return history;\n    }"
    },
    {
        "target_file_name": "BaseSearchResult.java",
        "target_method": "searchPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "format",
            "getValidQueryOrder",
            "setLimit",
            "setOffset"
        ],
        "target_code": "protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames, Boolean isLocaleAware) throws QueryException, IllegalArgumentException,\n            UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (searchScopes.contains(SearchScope.NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (isLocaleAware) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                    + \" from XWikiDocument as doc2\"\n                                    + \" where doc2.fullName = doc.fullName\"\n                                    + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                    + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause = String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(order, \"asc\"));\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.secureQueryManager.createQuery(queryString, Query.HQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                    .addFilter(Utils.getHiddenQueryFilter(this.componentManager)).setOffset(start)\n                    // Worst case scenario when making the locale aware query:\n                    // e.g.: Search matches a document translated in fr_CA and fr\n                    .setLimit(number * 2);\n\n            if (space != null) {\n                query.bindValue(\"space\", space);\n            }\n\n            if (searchScopes.contains(SearchScope.NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (isLocaleAware && searchScopes.contains(SearchScope.TITLE)) {\n                Locale userLocale = localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), wikiName, withPrettyNames, number, isLocaleAware);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "BaseSearchResult.java",
        "target_method": "searchSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "protected List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<SearchResult>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.secureQueryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(uriInfo.getBaseUri(), SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "BaseSearchResult.java",
        "target_method": "searchObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit"
        ],
        "target_code": "protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext xwikiContext = Utils.getXWikiContext(componentManager);\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaces, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && xwikiContext.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthorReference(), componentManager));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName, restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(uriInfo.getBaseUri(), ObjectResource.class, wikiName,\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "BaseSearchResult.java",
        "target_method": "searchPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "equals",
            "format",
            "setLimit",
            "setOffset"
        ],
        "target_code": "protected List<SearchResult> searchPages(List<SearchScope> searchScopes, String keywords, String wikiName,\n        String space, boolean hasProgrammingRights, int number, int start, String orderField, String order,\n        Boolean withPrettyNames, Boolean isLocaleAware) throws QueryException, IllegalArgumentException,\n            UriBuilderException, XWikiException\n    {\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (searchScopes.contains(SearchScope.NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < searchScopes.size(); i++) {\n                SearchScope scope = searchScopes.get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (isLocaleAware) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                    + \" from XWikiDocument as doc2\"\n                                    + \" where doc2.fullName = doc.fullName\"\n                                    + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                    + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                }\n\n                if (i != searchScopes.size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.queryManager.createQuery(queryString, Query.HQL)\n                    .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                    .addFilter(Utils.getHiddenQueryFilter(this.componentManager)).setOffset(start)\n                    // Worst case scenario when making the locale aware query:\n                    // e.g.: Search matches a document translated in fr_CA and fr\n                    .setLimit(number * 2);\n\n            if (space != null) {\n                query.bindValue(\"space\", space);\n            }\n\n            if (searchScopes.contains(SearchScope.NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (isLocaleAware && searchScopes.contains(SearchScope.TITLE)) {\n                Locale userLocale = localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), wikiName, withPrettyNames, number, isLocaleAware);\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "BaseSearchResult.java",
        "target_method": "searchSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "protected List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<SearchResult>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = queryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(uriInfo.getBaseUri(), SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "BaseSearchResult.java",
        "target_method": "searchObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "743ebf8696ffa55161ed2c5ecf26b09f69e6bcf1^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "bindValue",
            "createQuery",
            "execute",
            "setLimit"
        ],
        "target_code": "protected List<SearchResult> searchObjects(String keywords, String wikiName, String space,\n        boolean hasProgrammingRights, int number, int start, String orderField, String order, Boolean withPrettyNames)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext xwikiContext = Utils.getXWikiContext(componentManager);\n\n        XWiki xwikiApi = Utils.getXWikiApi(componentManager);\n\n        String database = Utils.getXWikiContext(componentManager).getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            Formatter f = new Formatter();\n\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (space != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id and lsp.id.id = obj.id and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(order) || \"desc\".equals(order)) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, order);\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\n                    \" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an exception */\n            if (space != null) {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", space).setLimit(number).execute();\n            } else {\n                queryResult =\n                    queryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase())).setLimit(number)\n                        .execute();\n            }\n\n            /* Build the result. */\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(wikiName, spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(wikiName, spaces, pageName);\n                String pageFullName = Utils.getPageFullName(wikiName, spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && xwikiContext.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(wikiName);\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (withPrettyNames) {\n                        searchResult.setAuthorName(Utils.getAuthorName(doc.getAuthorReference(), componentManager));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(uriInfo.getBaseUri(), PageResource.class, wikiName, restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(uriInfo.getBaseUri(), ObjectResource.class, wikiName,\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            Utils.getXWikiContext(componentManager).setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "DatabaseKeywordSearchSource.java",
        "target_method": "searchPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "isAlphanumeric",
            "setLimit",
            "setOffset"
        ],
        "target_code": "private List<SearchResult> searchPages(KeywordSearchOptions options, String keywords, URI baseURI)\n        throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = this.contextProvider.get().getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try (Formatter f = new Formatter()) {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            QueryManager finalQueryManager = this.queryManager;\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (options.searchScopes().contains(NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < options.searchScopes().size(); i++) {\n                KeywordSearchScope scope = options.searchScopes().get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (Boolean.TRUE.equals(options.isLocaleAware())) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                + \" from XWikiDocument as doc2\"\n                                + \" where doc2.fullName = doc.fullName\"\n                                + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                    default:\n                        // Ignore other scopes.\n                }\n\n                if (i != options.searchScopes().size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause =\n                    String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(options.order(), \"asc\"));\n\n                if (!StringUtils.isAlphanumeric(orderField)) {\n                    finalQueryManager = this.secureQueryManager;\n                }\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = finalQueryManager.createQuery(queryString, Query.HQL)\n                .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                .addFilter(this.hiddenDocumentFilterProvider.get()).setOffset(options.start())\n                // Worst case scenario when making the locale aware query:\n                // e.g.: Search matches a document translated in fr_CA and fr\n                .setLimit(options.number() * 2);\n\n            if (options.space() != null) {\n                query.bindValue(\"space\", options.space());\n            }\n\n            if (options.searchScopes().contains(NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (options.isLocaleAware() && options.searchScopes().contains(TITLE)) {\n                Locale userLocale = this.localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), options.wikiName(), options.withPrettyNames(),\n                options.number(), options.isLocaleAware(), baseURI);\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "DatabaseKeywordSearchSource.java",
        "target_method": "searchSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "private List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.queryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWikiContext context = this.contextProvider.get();\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(baseURI, SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(baseURI, PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "DatabaseKeywordSearchSource.java",
        "target_method": "searchObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "a45eca2af772abb7324e56d7fd2df1ac937bc445",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "createSearchResult",
            "createURI",
            "getAuthor",
            "getAuthorReference",
            "getDate",
            "getDisplayTitle",
            "getDocument",
            "getInstance",
            "getLinks",
            "getObjectId",
            "getPageFullName",
            "getPageId",
            "getPlainUserName",
            "getSpacesFromSpaceId",
            "getSpacesURLElements",
            "getUserReference",
            "getVersion",
            "getWiki",
            "hasAccessLevel",
            "setAuthor",
            "setAuthorName",
            "setClassName",
            "setHref",
            "setId",
            "setModified",
            "setObjectNumber",
            "setPageFullName",
            "setPageName",
            "setRel",
            "setSpace",
            "setTime",
            "setTitle",
            "setType",
            "setVersion",
            "setWiki",
            "toString",
            "wikiName",
            "withPrettyNames"
        ],
        "target_code": "private List<SearchResult> searchObjects(KeywordSearchOptions options, URI baseURI, List<Object> queryResult,\n        XWikiContext context) throws UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n\n        /* Build the result. */\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            Object[] fields = (Object[]) object;\n\n            String spaceId = (String) fields[1];\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            String pageName = (String) fields[2];\n            String className = (String) fields[3];\n            int objectNumber = (Integer) fields[4];\n\n            String id = Utils.getObjectId(options.wikiName(), spaces, pageName, className, objectNumber);\n\n            String pageId = Utils.getPageId(options.wikiName(), spaces, pageName);\n            String pageFullName = Utils.getPageFullName(options.wikiName(), spaces, pageName);\n\n            /*\n             * Check if the user has the right to see the found document. We also prevent guest users to access object\n             * data in order to avoid leaking important information such as emails to crawlers.\n             */\n            if (xwikiApi.hasAccessLevel(\"view\", pageId) && context.getUserReference() != null) {\n                Document doc = xwikiApi.getDocument(pageFullName);\n                String title = doc.getDisplayTitle();\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"object\");\n                searchResult.setId(id);\n                searchResult.setPageFullName(pageFullName);\n                searchResult.setTitle(title);\n                searchResult.setWiki(options.wikiName());\n                searchResult.setSpace(spaceId);\n                searchResult.setPageName(pageName);\n                searchResult.setVersion(doc.getVersion());\n                searchResult.setClassName(className);\n                searchResult.setObjectNumber(objectNumber);\n                searchResult.setAuthor(doc.getAuthor());\n                Calendar calendar = Calendar.getInstance();\n                calendar.setTime(doc.getDate());\n                searchResult.setModified(calendar);\n\n                if (options.withPrettyNames()) {\n                    searchResult.setAuthorName(context.getWiki().getPlainUserName(doc.getAuthorReference(), context));\n                }\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                String pageUri = Utils\n                    .createURI(baseURI, PageResource.class, options.wikiName(), restSpacesValue, pageName).toString();\n                Link pageLink = new Link();\n                pageLink.setHref(pageUri);\n                pageLink.setRel(Relations.PAGE);\n                searchResult.getLinks().add(pageLink);\n\n                String objectUri = Utils.createURI(baseURI, ObjectResource.class, options.wikiName(), restSpacesValue,\n                    pageName, className, objectNumber).toString();\n                Link objectLink = new Link();\n                objectLink.setHref(objectUri);\n                objectLink.setRel(Relations.OBJECT);\n                searchResult.getLinks().add(objectLink);\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "DatabaseKeywordSearchSource.java",
        "target_method": "searchPages",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "a45eca2af772abb7324e56d7fd2df1ac937bc445^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "setLimit",
            "setOffset"
        ],
        "target_code": "private List<SearchResult> searchPages(KeywordSearchOptions options, String keywords, URI baseURI)\n        throws QueryException, IllegalArgumentException,\n        UriBuilderException, XWikiException\n    {\n        String database = this.contextProvider.get().getWikiId();\n\n        /* This try is just needed for executing the finally clause. */\n        try (Formatter f = new Formatter()) {\n            if (keywords == null) {\n                return new ArrayList<>();\n            }\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn = \"\";\n            if (!StringUtils.isBlank(orderField)) {\n                addColumn =\n                    (orderField.equals(\"\") || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                        .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n            }\n\n            String addSpace = \"\";\n            if (options.searchScopes().contains(NAME)) {\n                // Join the space to get the last space name.\n                addSpace = \"left join XWikiSpace as space on doc.space = space.reference\";\n            }\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where doc.space = :space and ( \", addSpace);\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, doc.language\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc %s where ( \", addSpace);\n            }\n\n            /* Look for scopes related to pages */\n            int acceptedScopes = 0;\n            for (int i = 0; i < options.searchScopes().size(); i++) {\n                KeywordSearchScope scope = options.searchScopes().get(i);\n\n                switch (scope) {\n                    case CONTENT:\n                        f.format(\"upper(doc.content) like :keywords \");\n                        acceptedScopes++;\n                        break;\n                    case NAME:\n                        String matchTerminalPage = \"doc.name <> :defaultDocName and upper(doc.name) like :keywords\";\n                        String matchNestedPage = \"doc.name = :defaultDocName and upper(space.name) like :keywords\";\n                        f.format(\"((%s) or (%s)) \", matchTerminalPage, matchNestedPage);\n                        acceptedScopes++;\n                        break;\n                    case TITLE:\n                        f.format(\"(upper(doc.title) like :keywords\");\n                        if (Boolean.TRUE.equals(options.isLocaleAware())) {\n                            f.format(\" and (\");\n                            // In Oracle database, an empty language is stored as null.\n                            String emptyLanguageCondition = \"(doc.language = '' or doc.language is null)\";\n                            f.format(\"(doc.language = :locale or (%s and doc.defaultLanguage = :locale)) \",\n                                emptyLanguageCondition);\n                            f.format(\"or (doc.language = :language or (%s and doc.defaultLanguage = :language)) \",\n                                emptyLanguageCondition);\n                            f.format((\"or (%s and not exists(\"\n                                + \" from XWikiDocument as doc2\"\n                                + \" where doc2.fullName = doc.fullName\"\n                                + \" and (doc2.language = :locale or doc2.language = :language)))\"\n                                + \")\"), emptyLanguageCondition);\n                        }\n                        f.format(\") \");\n                        acceptedScopes++;\n                        break;\n                    default:\n                        // Ignore other scopes.\n                }\n\n                if (i != options.searchScopes().size() - 1) {\n                    f.format(\" or \");\n                }\n            }\n\n            /* If we don't find any scope related to pages then return empty results */\n            if (acceptedScopes == 0) {\n                return new ArrayList<>();\n            }\n\n            /* Build the order clause. */\n            String orderClause;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                orderClause =\n                    String.format(\"doc.%s %s\", orderField, HqlQueryUtils.getValidQueryOrder(options.order(), \"asc\"));\n            }\n\n            // Add ordering\n            f.format(\") order by %s\", orderClause);\n            String queryString = f.toString();\n\n            Query query = this.secureQueryManager.createQuery(queryString, Query.HQL)\n                .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                .addFilter(this.hiddenDocumentFilterProvider.get()).setOffset(options.start())\n                // Worst case scenario when making the locale aware query:\n                // e.g.: Search matches a document translated in fr_CA and fr\n                .setLimit(options.number() * 2);\n\n            if (options.space() != null) {\n                query.bindValue(\"space\", options.space());\n            }\n\n            if (options.searchScopes().contains(NAME)) {\n                query.bindValue(\"defaultDocName\",\n                    this.defaultEntityReferenceProvider.getDefaultReference(EntityType.DOCUMENT).getName());\n            }\n\n            // Search only pages translated in the user locale (e.g. fr_CA)\n            if (options.isLocaleAware() && options.searchScopes().contains(TITLE)) {\n                Locale userLocale = this.localizationContext.getCurrentLocale();\n                query.bindValue(\"locale\", userLocale.toString());\n                query.bindValue(\"language\", userLocale.getLanguage());\n            }\n\n            return getPagesSearchResults(query.execute(), options.wikiName(), options.withPrettyNames(),\n                options.number(), options.isLocaleAware(), baseURI);\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "DatabaseKeywordSearchSource.java",
        "target_method": "searchSpaces",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "a45eca2af772abb7324e56d7fd2df1ac937bc445^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "addFilter",
            "bindValue",
            "createQuery",
            "execute",
            "setLimit",
            "setOffset",
            "setWiki"
        ],
        "target_code": "private List<SearchResult> searchSpaces(String keywords, String wikiName, int number, int start, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        List<SearchResult> result = new ArrayList<>();\n\n        if (StringUtils.isEmpty(keywords)) {\n            return result;\n        }\n        String escapedKeywords = keywords.replaceAll(\"([%_!])\", \"!$1\");\n\n        String query = \"select space.reference from XWikiSpace as space\"\n            + \" where lower(space.name) like lower(:keywords) escape '!'\"\n            + \" or lower(space.reference) like lower(:prefix) escape '!'\"\n            + \" order by lower(space.reference), space.reference\";\n\n        List<Object> queryResult = this.secureQueryManager.createQuery(query, Query.HQL)\n            .bindValue(\"keywords\", String.format(\"%%%s%%\", escapedKeywords))\n            .bindValue(\"prefix\", String.format(\"%s%%\", escapedKeywords))\n            .setWiki(wikiName).setLimit(number).setOffset(start)\n            .addFilter(this.hiddenSpaceFilterProvider.get()).execute();\n\n        XWikiContext context = this.contextProvider.get();\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n        ObjectFactory objectFactory = new ObjectFactory();\n        for (Object object : queryResult) {\n            String spaceId = (String) object;\n            List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n            SpaceReference spaceReference = new SpaceReference(wikiName, spaces);\n\n            if (this.authorizationManager.hasAccess(Right.VIEW, spaceReference)) {\n                Document spaceDoc = xwikiApi.getDocument(spaceReference);\n\n                SearchResult searchResult = objectFactory.createSearchResult();\n                searchResult.setType(\"space\");\n                searchResult.setId(spaceId);\n                searchResult.setWiki(wikiName);\n                searchResult.setSpace(spaceId);\n                searchResult.setTitle(spaceDoc != null ? spaceDoc.getPlainTitle() : spaceReference.getName());\n\n                List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                // Add a link to the space information.\n                Link spaceLink = new Link();\n                spaceLink.setRel(Relations.SPACE);\n                spaceLink.setHref(\n                    Utils.createURI(baseURI, SpaceResource.class, wikiName, restSpacesValue).toString());\n                searchResult.getLinks().add(spaceLink);\n\n                // Add a link to the home page if it exists and it is viewable.\n                if (spaceDoc != null && !spaceDoc.isNew()) {\n                    Link pageLink = new Link();\n                    pageLink.setHref(Utils.createURI(baseURI, PageResource.class, wikiName,\n                        restSpacesValue, spaceDoc.getDocumentReference().getName()).toString());\n                    pageLink.setRel(Relations.HOME);\n                    searchResult.getLinks().add(pageLink);\n                }\n\n                result.add(searchResult);\n            }\n        }\n\n        return result;\n    }"
    },
    {
        "target_file_name": "DatabaseKeywordSearchSource.java",
        "target_method": "searchObjects",
        "project_url": "https://github.com/xwiki/xwiki-platform",
        "commit_id": "a45eca2af772abb7324e56d7fd2df1ac937bc445^",
        "CWE_id": "CWE-89",
        "CVE_id": "CVE-2025-52472",
        "project_name": "xwiki-platform",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "add",
            "bindValue",
            "createQuery",
            "createSearchResult",
            "createURI",
            "equals",
            "execute",
            "format",
            "get",
            "getAuthor",
            "getAuthorReference",
            "getDate",
            "getDisplayTitle",
            "getDocument",
            "getInstance",
            "getLinks",
            "getObjectId",
            "getPageFullName",
            "getPageId",
            "getPlainUserName",
            "getSpacesFromSpaceId",
            "getSpacesURLElements",
            "getUserReference",
            "getVersion",
            "getWiki",
            "getWikiId",
            "hasAccessLevel",
            "isBlank",
            "isEmpty",
            "number",
            "order",
            "orderField",
            "setAuthor",
            "setAuthorName",
            "setClassName",
            "setHref",
            "setId",
            "setLimit",
            "setModified",
            "setObjectNumber",
            "setPageFullName",
            "setPageName",
            "setRel",
            "setSpace",
            "setTime",
            "setTitle",
            "setType",
            "setVersion",
            "setWiki",
            "setWikiId",
            "space",
            "toString",
            "toUpperCase",
            "wikiName",
            "withPrettyNames"
        ],
        "target_code": "private List<SearchResult> searchObjects(String keywords, KeywordSearchOptions options,\n        boolean hasProgrammingRights, URI baseURI)\n        throws QueryException, IllegalArgumentException, UriBuilderException, XWikiException\n    {\n        XWikiContext context = this.contextProvider.get();\n\n        XWiki xwikiApi = new XWiki(context.getWiki(), context);\n\n        String database = context.getWikiId();\n\n        try (Formatter f = new Formatter()) {\n            List<SearchResult> result = new ArrayList<SearchResult>();\n\n            if (keywords == null) {\n                return result;\n            }\n\n            String orderField = options.orderField();\n            /*\n             * If the order field is already one of the field hard coded in the base query, then do not add it to the\n             * select clause.\n             */\n            String addColumn =\n                (orderField.isEmpty() || orderField.equals(\"fullName\") || orderField.equals(\"name\") || orderField\n                    .equals(\"space\")) ? \"\" : \", doc.\" + orderField;\n\n            if (options.space() != null) {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, \"\n                    + \"LargeStringProperty as lsp where doc.space = :space and obj.name=doc.fullName \"\n                    + \"and sp.id.id = obj.id and lsp.id.id = obj.id \"\n                    + \"and (upper(sp.value) like :keywords or upper(lsp.value) like :keywords) \");\n            } else {\n                f.format(\"select distinct doc.fullName, doc.space, doc.name, obj.className, obj.number\");\n                f.format(addColumn);\n                f.format(\" from XWikiDocument as doc, BaseObject as obj, StringProperty as sp, \"\n                    + \"LargeStringProperty as lsp where obj.name=doc.fullName and sp.id.id = obj.id \"\n                    + \"and lsp.id.id = obj.id and (upper(sp.value) like :keywords \"\n                    + \"or upper(lsp.value) like :keywords) \");\n            }\n\n            /* Build the order clause. */\n            String orderClause = null;\n            if (StringUtils.isBlank(orderField)) {\n                orderClause = \"doc.fullName asc\";\n            } else {\n                /* Check if the order parameter is a valid \"asc\" or \"desc\" string, otherwise use \"asc\" */\n                if (\"asc\".equals(options.order()) || \"desc\".equals(options.order())) {\n                    orderClause = String.format(\"doc.%s %s\", orderField, options.order());\n                } else {\n                    orderClause = String.format(\"doc.%s asc\", orderField);\n                }\n            }\n\n            /* Add some filters if the user doesn't have programming rights. */\n            if (hasProgrammingRights) {\n                f.format(\" order by %s\", orderClause);\n            } else {\n                f.format(\" and doc.space<>'XWiki' and doc.space<>'Admin' and doc.space<>'Panels' \"\n                        + \"and doc.name<>'WebPreferences' order by %s\",\n                    orderClause);\n            }\n\n            String query = f.toString();\n\n            List<Object> queryResult = null;\n\n            /* This is needed because if the :space placeholder is not in the query, setting it would cause an\n            exception */\n            if (options.space() != null) {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .bindValue(\"space\", options.space()).setLimit(options.number()).execute();\n            } else {\n                queryResult =\n                    this.secureQueryManager.createQuery(query, Query.XWQL)\n                        .bindValue(\"keywords\", String.format(\"%%%s%%\", keywords.toUpperCase()))\n                        .setLimit(options.number())\n                        .execute();\n            }\n\n            /* Build the result. */\n            ObjectFactory objectFactory = new ObjectFactory();\n            for (Object object : queryResult) {\n                Object[] fields = (Object[]) object;\n\n                String spaceId = (String) fields[1];\n                List<String> spaces = Utils.getSpacesFromSpaceId(spaceId);\n                String pageName = (String) fields[2];\n                String className = (String) fields[3];\n                int objectNumber = (Integer) fields[4];\n\n                String id = Utils.getObjectId(options.wikiName(), spaces, pageName, className, objectNumber);\n\n                String pageId = Utils.getPageId(options.wikiName(), spaces, pageName);\n                String pageFullName = Utils.getPageFullName(options.wikiName(), spaces, pageName);\n\n                /*\n                 * Check if the user has the right to see the found document. We also prevent guest users to access\n                 * object data in order to avoid leaking important information such as emails to crawlers.\n                 */\n                if (xwikiApi.hasAccessLevel(\"view\", pageId) && context.getUserReference() != null) {\n                    Document doc = xwikiApi.getDocument(pageFullName);\n                    String title = doc.getDisplayTitle();\n                    SearchResult searchResult = objectFactory.createSearchResult();\n                    searchResult.setType(\"object\");\n                    searchResult.setId(id);\n                    searchResult.setPageFullName(pageFullName);\n                    searchResult.setTitle(title);\n                    searchResult.setWiki(options.wikiName());\n                    searchResult.setSpace(spaceId);\n                    searchResult.setPageName(pageName);\n                    searchResult.setVersion(doc.getVersion());\n                    searchResult.setClassName(className);\n                    searchResult.setObjectNumber(objectNumber);\n                    searchResult.setAuthor(doc.getAuthor());\n                    Calendar calendar = Calendar.getInstance();\n                    calendar.setTime(doc.getDate());\n                    searchResult.setModified(calendar);\n\n                    if (options.withPrettyNames()) {\n                        searchResult.setAuthorName(\n                            context.getWiki().getPlainUserName(doc.getAuthorReference(), context));\n                    }\n\n                    List<String> restSpacesValue = Utils.getSpacesURLElements(spaces);\n\n                    String pageUri =\n                        Utils.createURI(baseURI, PageResource.class, options.wikiName(), restSpacesValue, pageName)\n                            .toString();\n                    Link pageLink = new Link();\n                    pageLink.setHref(pageUri);\n                    pageLink.setRel(Relations.PAGE);\n                    searchResult.getLinks().add(pageLink);\n\n                    String objectUri = Utils.createURI(baseURI, ObjectResource.class, options.wikiName(),\n                        restSpacesValue, pageName, className, objectNumber).toString();\n                    Link objectLink = new Link();\n                    objectLink.setHref(objectUri);\n                    objectLink.setRel(Relations.OBJECT);\n                    searchResult.getLinks().add(objectLink);\n\n                    result.add(searchResult);\n                }\n            }\n\n            return result;\n        } finally {\n            this.contextProvider.get().setWikiId(database);\n        }\n    }"
    },
    {
        "target_file_name": "ConversionUtil.java",
        "target_method": "getElementCount",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "72f79dec6d4292f892fbddd68a19c67935c7d81f",
        "CWE_id": "CWE-1333",
        "CVE_id": "CVE-2025-48058",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "matcherCount"
        ],
        "target_code": "public static long getElementCount(String xmlFile, String className) {\n        String regex = \"(<cim:\" + className + \" (rdf:ID=\\\"_|rdf:about=\\\"#_).*?\\\")>\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(xmlFile);\n        return matcherCount(matcher);\n    }"
    },
    {
        "target_file_name": "ConversionUtil.java",
        "target_method": "getElementCount",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "72f79dec6d4292f892fbddd68a19c67935c7d81f^",
        "CWE_id": "CWE-1333",
        "CVE_id": "CVE-2025-48058",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "count",
            "results"
        ],
        "target_code": "public static long getElementCount(String xmlFile, String className) {\n        String regex = \"(<cim:\" + className + \" (rdf:ID=\\\"_|rdf:about=\\\"#_).*?\\\")>\";\n        Pattern pattern = Pattern.compile(regex);\n        Matcher matcher = pattern.matcher(xmlFile);\n        return matcher.results().count();\n    }"
    },
    {
        "target_file_name": "ConversionUtil.java",
        "target_method": "xmlContains",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "getXMLInputFactory"
        ],
        "target_code": "public static boolean xmlContains(InputStream is, String clazz, String ns, String attr, String expectedValue) {\n        try {\n            XMLStreamReader reader = getXMLInputFactory().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(clazz)) {\n                    String actualValue = reader.getAttributeValue(ns, attr);\n                    if (expectedValue.equals(actualValue)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }"
    },
    {
        "target_file_name": "CgmesImport.java",
        "target_method": "separateByModelingAuthority",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getXMLInputFactory"
        ],
        "target_code": "private Set<ReadOnlyDataSource> separateByModelingAuthority() {\n            xmlInputFactory = getXMLInputFactory();\n            Map<String, List<String>> igmNames = new CgmesOnDataSource(dataSource).names().stream()\n                    // We consider IGMs only the modeling authorities that have an EQ file\n                    // The CGM SV should have the MA of the merging agent\n                    .filter(CgmesSubset.EQUIPMENT::isValidName)\n                    .map(name -> readModelingAuthority(name).map(ma -> Map.entry(ma, name)))\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toMap(Map.Entry::getKey, e -> new ArrayList<>(List.of(e.getValue()))));\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM EQ files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, v.get(0)));\n            }\n            // If we only have found one IGM there is no need to partition\n            if (igmNames.size() == 1) {\n                return Set.of(dataSource);\n            }\n            Set<String> shared = new HashSet<>();\n            new CgmesOnDataSource(dataSource).names().stream()\n                    // We read the modeling authorities present in the rest of instance files\n                    // and mark the instance name as linked to an IGM or as shared\n                    .filter(not(CgmesSubset.EQUIPMENT::isValidName))\n                    .filter(not(MultipleGridModelChecker::isBoundary))\n                    .forEach(name -> {\n                        Optional<String> ma = readModelingAuthority(name);\n                        if (ma.isPresent() && igmNames.containsKey(ma.get())) {\n                            igmNames.get(ma.get()).add(name);\n                        } else {\n                            shared.add(name);\n                        }\n                    });\n            // Build one data source for each IGM found\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, String.join(\",\", v)));\n                if (!shared.isEmpty()) {\n                    LOGGER.info(\"Shared files:\");\n                    shared.forEach(name -> LOGGER.info(\"  {}\", name));\n                }\n                LOGGER.info(\"Boundaries:\");\n                try {\n                    dataSource.listNames(\".*\").stream().filter(MultipleGridModelChecker::isBoundary).forEach(name -> LOGGER.info(\"  {}\", name));\n                } catch (IOException e) {\n                    throw new PowsyblException(e);\n                }\n            }\n            return igmNames.keySet().stream()\n                    .map(ma -> new FilteredReadOnlyDataSource(dataSource,\n                            name -> isBoundary(name) || igmNames.get(ma).contains(name) || shared.contains(name)))\n                    .collect(Collectors.toSet());\n        }"
    },
    {
        "target_file_name": "XMLImporter.java",
        "target_method": "exists",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "getXMLInputFactory"
        ],
        "target_code": "protected boolean exists(ReadOnlyDataSource dataSource, String ext) throws IOException {\n        try {\n            if (ext != null) {\n                try (InputStream is = dataSource.newInputStream(null, ext)) {\n                    // check the first root element is network and namespace is IIDM\n                    XMLStreamReader xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n                    try {\n                        while (xmlsr.hasNext()) {\n                            int eventType = xmlsr.next();\n                            if (eventType == XMLStreamConstants.START_ELEMENT) {\n                                String name = xmlsr.getLocalName();\n                                String ns = xmlsr.getNamespaceURI();\n                                return NetworkSerDe.NETWORK_ROOT_ELEMENT_NAME.equals(name)\n                                        && (Stream.of(IidmVersion.values()).anyMatch(v -> v.getNamespaceURI().equals(ns))\n                                        || Stream.of(IidmVersion.values()).filter(v -> v.compareTo(IidmVersion.V_1_7) >= 0).anyMatch(v -> v.getNamespaceURI(false).equals(ns)));\n                            }\n                        }\n                    } finally {\n                        cleanClose(xmlsr);\n                    }\n                }\n            }\n            return false;\n        } catch (XMLStreamException e) {\n            // not a valid xml file\n            return false;\n        }\n    }"
    },
    {
        "target_file_name": "XMLImporter.java",
        "target_method": "cleanClose",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "gcXmlInputFactory",
            "getXMLInputFactory"
        ],
        "target_code": "private void cleanClose(XMLStreamReader xmlStreamReader) {\n        try {\n            xmlStreamReader.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        } catch (XMLStreamException e) {\n            LOGGER.error(e.toString(), e);\n        }\n    }"
    },
    {
        "target_file_name": "XmlReader.java",
        "target_method": "close",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "gcXmlInputFactory",
            "getXMLInputFactory"
        ],
        "target_code": "@Override\n    public void close() {\n        try {\n            reader.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n    }"
    },
    {
        "target_file_name": "FullModel.java",
        "target_method": "parse",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "gcXmlInputFactory",
            "getXMLInputFactory"
        ],
        "target_code": "public static FullModel parse(Reader reader) {\n        Objects.requireNonNull(reader);\n        ParsingContext context = new ParsingContext();\n        try {\n            XMLStreamReader xmlReader = getXMLInputFactory().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(new String[] {\"/\", CgmesNames.RDF, CgmesNames.FULL_MODEL}, xmlReader, elementName1 -> {\n                    context.id = xmlReader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, CgmesNames.ABOUT);\n                    XmlUtil.readSubElements(xmlReader, subElementName -> readSubElement(subElementName, context, xmlReader));\n                });\n            } finally {\n                xmlReader.close();\n                XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n            }\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n        // the other attributes are checked in the constructor\n        if (context.version == null) {\n            throw new PowsyblException(\"Version is missing\");\n        }\n        return new FullModel(context.id, context.scenarioTime, context.created, context.description, context.version,\n                             context.profiles, context.dependentOn, context.supersedes, context.modelingAuthoritySet);\n    }"
    },
    {
        "target_file_name": "NamespaceReader.java",
        "target_method": "namespaces1",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "gcXmlInputFactory",
            "getXMLInputFactory"
        ],
        "target_code": "private static Set<String> namespaces1(InputStream is) throws XMLStreamException {\n        Set<String> found = new HashSet<>();\n        XMLStreamReader xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n        try {\n            boolean root = false;\n            while (xmlsr.hasNext() && !root) {\n                int eventType = xmlsr.next();\n                if (eventType == XMLStreamConstants.START_ELEMENT) {\n                    root = true;\n                    for (int k = 0; k < xmlsr.getNamespaceCount(); k++) {\n                        found.add(xmlsr.getNamespaceURI(k));\n                    }\n                }\n            }\n        } finally {\n            xmlsr.close();\n            XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n        }\n        return found;\n    }"
    },
    {
        "target_file_name": "NamespaceReader.java",
        "target_method": "base",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "gcXmlInputFactory",
            "getXMLInputFactory"
        ],
        "target_code": "public static String base(InputStream is) {\n        XMLStreamReader xmlsr;\n        try {\n            xmlsr = getXMLInputFactory().createXMLStreamReader(is);\n            try {\n                while (xmlsr.hasNext()) {\n                    int eventType = xmlsr.next();\n                    if (eventType == XMLStreamConstants.START_ELEMENT) {\n                        return xmlsr.getAttributeValue(null, \"base\");\n                    }\n                }\n            } finally {\n                xmlsr.close();\n                XmlUtil.gcXmlInputFactory(getXMLInputFactory());\n            }\n            return null;\n        } catch (XMLStreamException e) {\n            throw new CgmesModelException(\"base\", e);\n        }\n    }"
    },
    {
        "target_file_name": "PropertiesModuleConfigRepository.java",
        "target_method": "writeXml",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "getXMLOutputFactory"
        ],
        "target_code": "public static void writeXml(Path configDir, Path xmlFile) throws IOException, XMLStreamException {\n        XMLOutputFactory output = getXMLOutputFactory();\n        try (Writer writer = Files.newBufferedWriter(xmlFile, StandardCharsets.UTF_8)) {\n            XMLStreamWriter xmlWriter = output.createXMLStreamWriter(writer);\n            try {\n                xmlWriter.writeStartDocument(StandardCharsets.UTF_8.toString(), \"1.0\");\n                xmlWriter.writeStartElement(\"config\");\n                try (DirectoryStream<Path> ds = Files.newDirectoryStream(configDir, entry -> Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(\".properties\"))) {\n                    for (Path file : ds) {\n                        String fileName = file.getFileName().toString();\n                        String fileNameWithoutExtension = fileName.substring(0, fileName.length() - 11);\n                        xmlWriter.writeStartElement(fileNameWithoutExtension);\n                        Properties properties = new Properties();\n                        try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n                            properties.load(reader);\n                        }\n                        for (String name : properties.stringPropertyNames()) {\n                            String value = properties.getProperty(name);\n                            xmlWriter.writeStartElement(name);\n                            xmlWriter.writeCharacters(value);\n                            xmlWriter.writeEndElement();\n                        }\n                        xmlWriter.writeEndElement();\n                    }\n                }\n                xmlWriter.writeEndElement();\n                xmlWriter.writeEndDocument();\n            } finally {\n                xmlWriter.close();\n            }\n        }\n    }"
    },
    {
        "target_file_name": "ConversionUtil.java",
        "target_method": "xmlContains",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "newInstance"
        ],
        "target_code": "public static boolean xmlContains(InputStream is, String clazz, String ns, String attr, String expectedValue) {\n        try {\n            XMLStreamReader reader = XMLInputFactory.newInstance().createXMLStreamReader(is);\n            while (reader.hasNext()) {\n                if (reader.next() == XMLStreamConstants.START_ELEMENT && reader.getLocalName().equals(clazz)) {\n                    String actualValue = reader.getAttributeValue(ns, attr);\n                    if (expectedValue.equals(actualValue)) {\n                        reader.close();\n                        return true;\n                    }\n                }\n            }\n            reader.close();\n        } catch (XMLStreamException e) {\n            throw new RuntimeException(e);\n        }\n        return false;\n    }"
    },
    {
        "target_file_name": "CgmesImport.java",
        "target_method": "separateByModelingAuthority",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "newInstance"
        ],
        "target_code": "private Set<ReadOnlyDataSource> separateByModelingAuthority() {\n            xmlInputFactory = XMLInputFactory.newInstance();\n            Map<String, List<String>> igmNames = new CgmesOnDataSource(dataSource).names().stream()\n                    // We consider IGMs only the modeling authorities that have an EQ file\n                    // The CGM SV should have the MA of the merging agent\n                    .filter(CgmesSubset.EQUIPMENT::isValidName)\n                    .map(name -> readModelingAuthority(name).map(ma -> Map.entry(ma, name)))\n                    .flatMap(Optional::stream)\n                    .collect(Collectors.toMap(Map.Entry::getKey, e -> new ArrayList<>(List.of(e.getValue()))));\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM EQ files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, v.get(0)));\n            }\n            // If we only have found one IGM there is no need to partition\n            if (igmNames.size() == 1) {\n                return Set.of(dataSource);\n            }\n            Set<String> shared = new HashSet<>();\n            new CgmesOnDataSource(dataSource).names().stream()\n                    // We read the modeling authorities present in the rest of instance files\n                    // and mark the instance name as linked to an IGM or as shared\n                    .filter(not(CgmesSubset.EQUIPMENT::isValidName))\n                    .filter(not(MultipleGridModelChecker::isBoundary))\n                    .forEach(name -> {\n                        Optional<String> ma = readModelingAuthority(name);\n                        if (ma.isPresent() && igmNames.containsKey(ma.get())) {\n                            igmNames.get(ma.get()).add(name);\n                        } else {\n                            shared.add(name);\n                        }\n                    });\n            // Build one data source for each IGM found\n            if (!igmNames.isEmpty()) {\n                LOGGER.info(\"IGM files identified by Modeling Authority:\");\n                igmNames.forEach((k, v) -> LOGGER.info(\"  {} {}\", k, String.join(\",\", v)));\n                if (!shared.isEmpty()) {\n                    LOGGER.info(\"Shared files:\");\n                    shared.forEach(name -> LOGGER.info(\"  {}\", name));\n                }\n                LOGGER.info(\"Boundaries:\");\n                try {\n                    dataSource.listNames(\".*\").stream().filter(MultipleGridModelChecker::isBoundary).forEach(name -> LOGGER.info(\"  {}\", name));\n                } catch (IOException e) {\n                    throw new PowsyblException(e);\n                }\n            }\n            return igmNames.keySet().stream()\n                    .map(ma -> new FilteredReadOnlyDataSource(dataSource,\n                            name -> isBoundary(name) || igmNames.get(ma).contains(name) || shared.contains(name)))\n                    .collect(Collectors.toSet());\n        }"
    },
    {
        "target_file_name": "XMLImporter.java",
        "target_method": "exists",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "get"
        ],
        "target_code": "protected boolean exists(ReadOnlyDataSource dataSource, String ext) throws IOException {\n        try {\n            if (ext != null) {\n                try (InputStream is = dataSource.newInputStream(null, ext)) {\n                    // check the first root element is network and namespace is IIDM\n                    XMLStreamReader xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n                    try {\n                        while (xmlsr.hasNext()) {\n                            int eventType = xmlsr.next();\n                            if (eventType == XMLStreamConstants.START_ELEMENT) {\n                                String name = xmlsr.getLocalName();\n                                String ns = xmlsr.getNamespaceURI();\n                                return NetworkSerDe.NETWORK_ROOT_ELEMENT_NAME.equals(name)\n                                        && (Stream.of(IidmVersion.values()).anyMatch(v -> v.getNamespaceURI().equals(ns))\n                                        || Stream.of(IidmVersion.values()).filter(v -> v.compareTo(IidmVersion.V_1_7) >= 0).anyMatch(v -> v.getNamespaceURI(false).equals(ns)));\n                            }\n                        }\n                    } finally {\n                        cleanClose(xmlsr);\n                    }\n                }\n            }\n            return false;\n        } catch (XMLStreamException e) {\n            // not a valid xml file\n            return false;\n        }\n    }"
    },
    {
        "target_file_name": "XMLImporter.java",
        "target_method": "cleanClose",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "gcXmlInputFactory",
            "get"
        ],
        "target_code": "private void cleanClose(XMLStreamReader xmlStreamReader) {\n        try {\n            xmlStreamReader.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        } catch (XMLStreamException e) {\n            LOGGER.error(e.toString(), e);\n        }\n    }"
    },
    {
        "target_file_name": "XmlReader.java",
        "target_method": "close",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "gcXmlInputFactory",
            "get"
        ],
        "target_code": "@Override\n    public void close() {\n        try {\n            reader.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n    }"
    },
    {
        "target_file_name": "FullModel.java",
        "target_method": "parse",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "gcXmlInputFactory",
            "get"
        ],
        "target_code": "public static FullModel parse(Reader reader) {\n        Objects.requireNonNull(reader);\n        ParsingContext context = new ParsingContext();\n        try {\n            XMLStreamReader xmlReader = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(reader);\n            try {\n                XmlUtil.readUntilStartElement(new String[] {\"/\", CgmesNames.RDF, CgmesNames.FULL_MODEL}, xmlReader, elementName1 -> {\n                    context.id = xmlReader.getAttributeValue(CgmesNamespace.RDF_NAMESPACE, CgmesNames.ABOUT);\n                    XmlUtil.readSubElements(xmlReader, subElementName -> readSubElement(subElementName, context, xmlReader));\n                });\n            } finally {\n                xmlReader.close();\n                XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n            }\n        } catch (XMLStreamException e) {\n            throw new UncheckedXmlStreamException(e);\n        }\n        // the other attributes are checked in the constructor\n        if (context.version == null) {\n            throw new PowsyblException(\"Version is missing\");\n        }\n        return new FullModel(context.id, context.scenarioTime, context.created, context.description, context.version,\n                             context.profiles, context.dependentOn, context.supersedes, context.modelingAuthoritySet);\n    }"
    },
    {
        "target_file_name": "NamespaceReader.java",
        "target_method": "namespaces1",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "gcXmlInputFactory",
            "get"
        ],
        "target_code": "private static Set<String> namespaces1(InputStream is) throws XMLStreamException {\n        Set<String> found = new HashSet<>();\n        XMLStreamReader xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n        try {\n            boolean root = false;\n            while (xmlsr.hasNext() && !root) {\n                int eventType = xmlsr.next();\n                if (eventType == XMLStreamConstants.START_ELEMENT) {\n                    root = true;\n                    for (int k = 0; k < xmlsr.getNamespaceCount(); k++) {\n                        found.add(xmlsr.getNamespaceURI(k));\n                    }\n                }\n            }\n        } finally {\n            xmlsr.close();\n            XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n        }\n        return found;\n    }"
    },
    {
        "target_file_name": "NamespaceReader.java",
        "target_method": "base",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "createXMLStreamReader",
            "gcXmlInputFactory",
            "get"
        ],
        "target_code": "public static String base(InputStream is) {\n        XMLStreamReader xmlsr;\n        try {\n            xmlsr = XML_INPUT_FACTORY_SUPPLIER.get().createXMLStreamReader(is);\n            try {\n                while (xmlsr.hasNext()) {\n                    int eventType = xmlsr.next();\n                    if (eventType == XMLStreamConstants.START_ELEMENT) {\n                        return xmlsr.getAttributeValue(null, \"base\");\n                    }\n                }\n            } finally {\n                xmlsr.close();\n                XmlUtil.gcXmlInputFactory(XML_INPUT_FACTORY_SUPPLIER.get());\n            }\n            return null;\n        } catch (XMLStreamException e) {\n            throw new CgmesModelException(\"base\", e);\n        }\n    }"
    },
    {
        "target_file_name": "PropertiesModuleConfigRepository.java",
        "target_method": "writeXml",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "e6c7c4997ae8758b54a2f23ce1a499e25113acdc^",
        "CWE_id": "CWE-918",
        "CVE_id": "CVE-2025-47293",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": false,
        "target_api_name": [
            "newInstance"
        ],
        "target_code": "public static void writeXml(Path configDir, Path xmlFile) throws IOException, XMLStreamException {\n        XMLOutputFactory output = XMLOutputFactory.newInstance();\n        try (Writer writer = Files.newBufferedWriter(xmlFile, StandardCharsets.UTF_8)) {\n            XMLStreamWriter xmlWriter = output.createXMLStreamWriter(writer);\n            try {\n                xmlWriter.writeStartDocument(StandardCharsets.UTF_8.toString(), \"1.0\");\n                xmlWriter.writeStartElement(\"config\");\n                try (DirectoryStream<Path> ds = Files.newDirectoryStream(configDir, entry -> Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(\".properties\"))) {\n                    for (Path file : ds) {\n                        String fileName = file.getFileName().toString();\n                        String fileNameWithoutExtension = fileName.substring(0, fileName.length() - 11);\n                        xmlWriter.writeStartElement(fileNameWithoutExtension);\n                        Properties properties = new Properties();\n                        try (Reader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n                            properties.load(reader);\n                        }\n                        for (String name : properties.stringPropertyNames()) {\n                            String value = properties.getProperty(name);\n                            xmlWriter.writeStartElement(name);\n                            xmlWriter.writeCharacters(value);\n                            xmlWriter.writeEndElement();\n                        }\n                        xmlWriter.writeEndElement();\n                    }\n                }\n                xmlWriter.writeEndElement();\n                xmlWriter.writeEndDocument();\n            } finally {\n                xmlWriter.close();\n            }\n        }\n    }"
    },
    {
        "target_file_name": "SparseMatrix.java",
        "target_method": "read",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "8ed16ce41683c4aef5f6aa1dd5ae8642aa5ed2bd",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-47771",
        "project_name": "powsybl-core",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "allowFilter",
            "setObjectInputFilter"
        ],
        "target_code": "public static SparseMatrix read(InputStream inputStream) {\n        Objects.requireNonNull(inputStream);\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            // Check that the object to deserialize is really a SparseMatrix.\n            // This check is done prior to its complete deserialization to prevent security problems (RCE).\n            // - Check that all non-null encountered classes are among the accepted ones (the one composing a SparseMatrix).\n            ObjectInputFilter allowedClassesFilter = ObjectInputFilter.allowFilter(ALLOWED_CLASSES::contains, ObjectInputFilter.Status.REJECTED);\n            objectInputStream.setObjectInputFilter(allowedClassesFilter);\n            return (SparseMatrix) objectInputStream.readObject();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (ClassNotFoundException e) {\n            throw new UncheckedClassNotFoundException(e);\n        }\n    }"
    },
    {
        "target_file_name": "SparseMatrix.java",
        "target_method": "read",
        "project_url": "https://github.com/powsybl/powsybl-core",
        "commit_id": "8ed16ce41683c4aef5f6aa1dd5ae8642aa5ed2bd^",
        "CWE_id": "CWE-502",
        "CVE_id": "CVE-2025-47771",
        "project_name": "powsybl-core",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "public static SparseMatrix read(InputStream inputStream) {\n        Objects.requireNonNull(inputStream);\n        try (ObjectInputStream objectInputStream = new ObjectInputStream(inputStream)) {\n            return (SparseMatrix) objectInputStream.readObject();\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        } catch (ClassNotFoundException e) {\n            throw new UncheckedClassNotFoundException(e);\n        }\n    }"
    },
    {
        "target_file_name": "XunitXmlPlugin.java",
        "target_method": "parseAssemblies",
        "project_url": "https://github.com/allure-framework/allure2",
        "commit_id": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-52888",
        "project_name": "allure2",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setEntityResolver",
            "setValidating"
        ],
        "target_code": "private void parseAssemblies(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement assembliesElement = new XmlElement(document.getDocumentElement());\n            final String elementName = assembliesElement.getName();\n            if (!ASSEMBLIES_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid XUnit xml file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n\n            assembliesElement.get(ASSEMBLY_ELEMENT_NAME)\n                    .forEach(element -> parseAssembly(element, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }"
    },
    {
        "target_file_name": "TrxPlugin.java",
        "target_method": "parseTestRun",
        "project_url": "https://github.com/allure-framework/allure2",
        "commit_id": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-52888",
        "project_name": "allure2",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setEntityResolver",
            "setValidating"
        ],
        "target_code": "protected void parseTestRun(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement testRunElement = new XmlElement(document.getDocumentElement());\n            final String elementName = testRunElement.getName();\n            if (!TEST_RUN_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid TRX file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n            final Map<String, UnitTest> tests = new HashMap<>();\n            testRunElement.getFirst(TEST_DEFINITIONS_ELEMENT)\n                    .ifPresent(testDefinitions -> {\n                        testDefinitions.get(UNIT_TEST_ELEMENT).forEach(unitTestElement -> {\n                            final UnitTest unitTest = parseUnitTest(unitTestElement);\n                            tests.put(unitTest.getExecutionId(), unitTest);\n                        });\n                    });\n            testRunElement.getFirst(RESULTS_ELEMENT_NAME)\n                    .ifPresent(resultsElement -> parseResults(resultsElement, tests, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}\", parsedFile, e);\n        }\n    }"
    },
    {
        "target_file_name": "JunitXmlPlugin.java",
        "target_method": "parseRootElement",
        "project_url": "https://github.com/allure-framework/allure2",
        "commit_id": "cbcb33719851ff70adce85d38e15d20fc58d4eb7",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-52888",
        "project_name": "allure2",
        "is_vulnerable": false,
        "need_head_slicing": false,
        "target_api_name": [
            "setEntityResolver",
            "setValidating"
        ],
        "target_code": "private void parseRootElement(final Path resultsDirectory, final Path parsedFile,\n                                  final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            builder.setEntityResolver(new ClasspathEntityResolver());\n\n            final XmlElement rootElement = new XmlElement(builder.parse(parsedFile.toFile()).getDocumentElement());\n            final String elementName = rootElement.getName();\n\n            if (TEST_SUITE_ELEMENT_NAME.equals(elementName)) {\n                parseTestSuite(rootElement, parsedFile, context, visitor, resultsDirectory);\n                return;\n            }\n            if (TEST_SUITES_ELEMENT_NAME.equals(elementName)) {\n                rootElement.get(TEST_SUITE_ELEMENT_NAME)\n                        .forEach(element -> parseTestSuite(element, parsedFile, context, visitor, resultsDirectory));\n                return;\n            }\n            LOGGER.debug(\"File {} is not a valid JUnit xml. Unknown root element {}\", parsedFile, elementName);\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }"
    },
    {
        "target_file_name": "XunitXmlPlugin.java",
        "target_method": "parseAssemblies",
        "project_url": "https://github.com/allure-framework/allure2",
        "commit_id": "cbcb33719851ff70adce85d38e15d20fc58d4eb7^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-52888",
        "project_name": "allure2",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private void parseAssemblies(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement assembliesElement = new XmlElement(document.getDocumentElement());\n            final String elementName = assembliesElement.getName();\n            if (!ASSEMBLIES_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid XUnit xml file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n\n            assembliesElement.get(ASSEMBLY_ELEMENT_NAME)\n                    .forEach(element -> parseAssembly(element, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }"
    },
    {
        "target_file_name": "TrxPlugin.java",
        "target_method": "parseTestRun",
        "project_url": "https://github.com/allure-framework/allure2",
        "commit_id": "cbcb33719851ff70adce85d38e15d20fc58d4eb7^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-52888",
        "project_name": "allure2",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "protected void parseTestRun(final Path parsedFile, final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n            final Document document = builder.parse(parsedFile.toFile());\n            final XmlElement testRunElement = new XmlElement(document.getDocumentElement());\n            final String elementName = testRunElement.getName();\n            if (!TEST_RUN_ELEMENT_NAME.equals(elementName)) {\n                LOGGER.debug(\"{} is not a valid TRX file. Unknown root element {}\", parsedFile, elementName);\n                return;\n            }\n            final Map<String, UnitTest> tests = new HashMap<>();\n            testRunElement.getFirst(TEST_DEFINITIONS_ELEMENT)\n                    .ifPresent(testDefinitions -> {\n                        testDefinitions.get(UNIT_TEST_ELEMENT).forEach(unitTestElement -> {\n                            final UnitTest unitTest = parseUnitTest(unitTestElement);\n                            tests.put(unitTest.getExecutionId(), unitTest);\n                        });\n                    });\n            testRunElement.getFirst(RESULTS_ELEMENT_NAME)\n                    .ifPresent(resultsElement -> parseResults(resultsElement, tests, context, visitor));\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}\", parsedFile, e);\n        }\n    }"
    },
    {
        "target_file_name": "JunitXmlPlugin.java",
        "target_method": "parseRootElement",
        "project_url": "https://github.com/allure-framework/allure2",
        "commit_id": "cbcb33719851ff70adce85d38e15d20fc58d4eb7^",
        "CWE_id": "CWE-611",
        "CVE_id": "CVE-2025-52888",
        "project_name": "allure2",
        "is_vulnerable": true,
        "need_head_slicing": true,
        "target_api_name": [],
        "target_code": "private void parseRootElement(final Path resultsDirectory, final Path parsedFile,\n                                  final RandomUidContext context, final ResultsVisitor visitor) {\n        try {\n            LOGGER.debug(\"Parsing file {}\", parsedFile);\n            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            final DocumentBuilder builder = factory.newDocumentBuilder();\n\n            final XmlElement rootElement = new XmlElement(builder.parse(parsedFile.toFile()).getDocumentElement());\n            final String elementName = rootElement.getName();\n\n            if (TEST_SUITE_ELEMENT_NAME.equals(elementName)) {\n                parseTestSuite(rootElement, parsedFile, context, visitor, resultsDirectory);\n                return;\n            }\n            if (TEST_SUITES_ELEMENT_NAME.equals(elementName)) {\n                rootElement.get(TEST_SUITE_ELEMENT_NAME)\n                        .forEach(element -> parseTestSuite(element, parsedFile, context, visitor, resultsDirectory));\n                return;\n            }\n            LOGGER.debug(\"File {} is not a valid JUnit xml. Unknown root element {}\", parsedFile, elementName);\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            LOGGER.error(\"Could not parse file {}: {}\", parsedFile, e);\n        }\n    }"
    }
]